/*------------------------------------------------------------------------
 * aaBoost: A better boost
 *
 * Copyright (c) 2009-2016, Ashod Apakian <apakian at gmail dot com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of aaBoost nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *-----------------------------------------------------------------------*/

//aaDebugf("appVerif.exe shows virtualfree size is wrong:: fix me");
//aaDebugf("REMEMBER: I commented out  B aa_InputSystemHookedKeyEventProc   code to ignore injects");

/*
http://ithare.com/64-network-dos-and-donts-for-multi-player-game-developers-part-vi-tcp/
read about nodelay and solinger
*/

/*-----------------------------------------------------------------------*/
 //citsys01: removed spot_index_order
 //citsys02: ignoring orphaned upkeys
 //citsys03: if inputengine is_ok!=YES then return
 //citsys04: fixed surface leave event on initial call to inputengine, as prev->spot_index is 0, not -1

/*-----------------------------------------------------------------------*/

 //-fno-strict-aliasing -Wno-uninitialized

/*-----------------------------------------------------------------------*/

 #include "aa.h"
 #include <fcntl.h>

 #ifdef  _MSC_VER
 #pragma comment(lib,"gdi32.lib")
 #pragma comment(lib,"wsock32.lib")
 #pragma comment(lib,"advapi32.lib")
 #pragma comment(lib,"shell32.lib")
 #pragma comment(lib,"comdlg32.lib")
 #pragma comment(lib,"winmm.lib")
 #pragma comment(lib,"vfw32.lib")
 #pragma comment(lib,"kernel32.lib")
 #pragma comment(lib,"user32.lib")
 #endif

/*-----------------------------------------------------------------------*/
 V aaDummyFunction1                    (){} // this function is the first function offset, useful for aaFuncInfoGet
/*-----------------------------------------------------------------------*/

 #define aa_USE_CGICLIENT_THREADS      0

 #define aa_USE_GLOBAL_MUTEX           0
 CRITICAL_SECTION                      global_mutex;
 S jmp_buf aa_jmp_buf;

/*-----------------------------------------------------------------------*/

 H aa_last_line_executed               =__LINE__;

 #define aa_VERSION                    256

/*-----------------------------------------------------------------------*/

 #define aa_SHOW_PROFILE               0
 #define aa_SHOW_VERBOSE               0

/*-----------------------------------------------------------------------*/

 #define WAGO

 #define Boop
 #define aa_SHOW_DIAG_LINES            80000

 #define aaLogStructSize(obj)          aaLog(-555,"%-24s : %-5u bytes",#obj,sizeof(obj))

 #if aa_SHOW_PROFILE==1
 #define aa_DIAGNOSE                   YES
 H aa_diag_var;
 H aa_diag_hi;
 H aa_diag_lo;
 H aa_diag_cycle[aa_SHOW_DIAG_LINES];
 D aa_diag_hits[aa_SHOW_DIAG_LINES];
 H aa_diag_line[aa_SHOW_DIAG_LINES];
 C aa_diag_text[aa_SHOW_DIAG_LINES][55];
 #define aa_DIAG_IGNORECRASH(name)     aa_last_line_executed=__LINE__; if(aa.is_ready==YES&&aa.is_diag_paused==NO) { if(aa_diag_hits[__LINE__]==0) { strcpy(aa_diag_text[__LINE__],name); aa_diag_line[__LINE__]=__LINE__; } aa_diag_hits[__LINE__]++; aa_diag_cycle[__LINE__]=aa.core_system.cycle; aa_diag_lo++; if(aa_diag_lo==1000) { aa_diag_hi++; aa_diag_lo=0; } }
 #define aa_ZIAG(name)                 aa_DIAG_IGNORECRASH(name)
 #else
 #define aa_DIAGNOSE                   NO
  #ifdef __GNUC__
  #define aa_ZIAG(name)
  #define aa_DIAG_IGNORECRASH(name)
  #else
  #define aa_ZIAG(name)
  #define aa_DIAG_IGNORECRASH(name)
  #endif
 #endif


 #if aa_SHOW_VERBOSE==1
 #define log(...)                      aa_CoreSystemLog(__LINE__,__VA_ARGS__)
 #define prevent_warning(obj)          if(obj) {}
 #else
  #ifdef __GNUC__
  #define logg(...)
  #else
  //#define logg(x)                       /##/
  #endif
 #define prevent_warning(obj)          Boop
 #endif


/*-----------------------------------------------------------------------*/


 B WinFileTimeToSysTime                (FILETIME*filetime,_systime*systime);
 B WinSystemTimeToSysTime              (SYSTEMTIME*systemtime,_systime*systime);
 B WinSystemTimeFromSysTime            (SYSTEMTIME*systemtime,_systime*systime);
 B WinSystemTimeCopy                   (SYSTEMTIME*systemtime,SYSTEMTIME*ssystemtime);
 B WinErrorStringGet                   (VP string,H line);
 B WinSockAddrSet                      (struct sockaddr_in*addr,W family,H ip,W port);
 B WinPointCopy                        (POINT*point,POINT*spoint);
 B WinPointSet                         (POINT*point,N x,N y);
 B WinPointToCord                      (POINT*point,_cord*cord);
 B WinRectSet                          (RECT*rect,N x,N y,H w,H h);
 B WinRectToRect                       (RECT*rect,_rect*rect2);
 B WinRectCopy                         (RECT*rect,RECT*srect);
 B WinRectFromRect                     (RECT*rect,_rect*srect);
 B WinBmpInfoSet                       (BITMAPINFO*bmi,H w,H h,B bits,B negheight);
 B WinWaveHdrSet                       (WAVEHDR*hdr,LPSTR dat,H buflen,B bytesrec,H user,H flags);
 B WinWaveFormatExSet                  (WAVEFORMATEX*wfx,W tag,H sampssec,W channels,W bits,W cbsize);
 B WinWaveFormatExFromAudioMode        (WAVEFORMATEX*wfx,_audiomode*audiomode);
 B WinWaveFormatExToAudioMode          (WAVEFORMATEX*wfx,_audiomode*audiomode);
 B WinWaveFormatExToString             (WAVEFORMATEX*wfx,VP string);
 B WinWndClassExSet                    (WNDCLASSEX*wndclsex,W style,WNDPROC proc,VP classname);
 B WinCapParmsInit                     (VP caparms);


 structure
 {
 H cb;
 H majmin[2];
 H build;
 H platform;
 TCHAR txt[128];
 W spack[2];
 W smask;
 B type;
 B rsvd;
 }
 _mswinver;

/*-----------------------------------------------------------------------*/

 #ifdef _WIN64
 #define aa_MM_POINTER_TYPE            ULONGLONG
 #else
 #define aa_MM_POINTER_TYPE            DWORD
 #endif

 #define aa_MM_GET_HDR_DICT(m,i)       &(m)->headers->OptionalHeader.DataDirectory[i]


 T BOOL (WINAPI *DllEntryProc)         (HINSTANCE hinstDLL, H fdwReason, LPVOID lpReserved);

 Z ProtectionFlags[2][2][2]=           {{{PAGE_NOACCESS, PAGE_WRITECOPY},{PAGE_READONLY, PAGE_READWRITE},},
                                       {{PAGE_EXECUTE, PAGE_EXECUTE_WRITECOPY},{PAGE_EXECUTE_READ, PAGE_EXECUTE_READWRITE},},};

 #define aaGetHdrDictionary(mo,idx)    &(mo)->headers->OptionalHeader.DataDirectory[idx]


 structure
 {
 H magic;
 PIMAGE_NT_HEADERS headers;
 B *codeBase;
 HMODULE *modules;
 Z numModules;
 Z initialized;
 DllEntryProc EntryProc;
 BP cptr;
 _memoryunit img;
 }
 _aa_MemoryModule;


/*-----------------------------------------------------------------------*/


 structure
 {
 DWORD  cb;
 DWORD  PageFaultCount;
 SIZE_T PeakWorkingSetSize;
 SIZE_T WorkingSetSize;
 SIZE_T QuotaPeakPagedPoolUsage;
 SIZE_T QuotaPagedPoolUsage;
 SIZE_T QuotaPeakNonPagedPoolUsage;
 SIZE_T QuotaNonPagedPoolUsage;
 SIZE_T PagefileUsage;
 SIZE_T PeakPagefileUsage;
 SIZE_T PrivateUsage;
 }
 PROCESS_MEMORY_COUNTERS;

 structure
 {
 H dwSize;
 H cntUsage;
 H th32ProcessID;
 ULONG*th32DefaultHeapID;
 H th32ModuleID;
 H cntThreads;
 H th32ParentProcessID;
 LONG pcPriClassBase;
 H dwFlags;
 TCHAR szExeFile[MAX_PATH];
 }
 PROCENTRY32;


 structure
 {
 W Length;
 W MaximumLength;
 PWSTR Buffer;
 }
 UNICODE_STRING;

 structure
 {
 N ExitStatus;
 VP PebBaseAddress;
 HP AffinityMask;
 N BasePriority;
 HP UniqueProcessId;
 HP ParentProcessId;
 }
 PROCESS_BASIC_INFORMATION;


 structure
 {
 H dwSize;
 H th32ModuleID;
 H th32ProcessID;
 H GlblcntUsage;
 H ProccntUsage;
 BP modBaseAddr;
 H modBaseSize;
 HMODULE hModule;
 TCHAR szModule[256];
 TCHAR szExePath[MAX_PATH];
 }
 MODULEENTRY32;



 structure
 {
 DWORD dwSize;
 DWORD cntUsage;
 DWORD th32ThreadID;
 DWORD th32OwnerProcessID;
 LONG  tpBasePri;
 LONG  tpDeltaPri;
 DWORD dwFlags;
 }
 THREADENTRY32;


 structure
 {
 DWORD cb;
 TCHAR DeviceName[32];
 TCHAR DeviceString[128];
 DWORD StateFlags;
 TCHAR DeviceID[128];
 TCHAR DeviceKey[128];
 }
 aa_DISPLAY_DEVICE;



 structure
 {
 H cb_size;
 RECT r_moni;
 RECT w_work;
 H flags;
 TCHAR szDevice[CCHDEVICENAME];
 }
 aa_MONITOR_INFO;


 #define aa_DISDEV_ATTACHED_TO_DESKTOP 0x00000001
 #define aa_DISDEV_MULTI_DRIVER        0x00000002
 #define aa_DISDEV_PRIMARY_DEVICE      0x00000004
 #define aa_DISDEV_MIRRORING_DRIVER    0x00000008
 #define aa_DISDEV_VGA_COMPATIBLE      0x00000010
 #define aa_DISDEV_REMOVABLE           0x00000020
 #define aa_DISDEV_MODESPRUNED         0x08000000

 #define aa_DISDEV_ENUM_CURRENT_STNGS  -1
 #define aa_DISDEV_ENUM_REGISTRY_STNGS -2

 #define aa_DISDEV_DM_POSITION         0x20
 #define aa_DISDEV_CDS_SET_PRIMARY     0x10
 #define aa_DISDEV_CDS_NORESET         0x10000000

 T BOOL   (CALLBACK*MONENUMPROC)       (HANDLE,HDC,LPRECT,LPARAM);

 T BOOL   (WINAPI *getSystemTimes)     (FILETIME*,FILETIME*,FILETIME*);
 T BOOL   (WINAPI *getProcessTimes)    (HANDLE,FILETIME*,FILETIME*,FILETIME*,FILETIME*);
 T BOOL   (WINAPI *process32First)     (HANDLE,PROCENTRY32*);
 T BOOL   (WINAPI *process32Next)      (HANDLE,PROCENTRY32*);
 T BOOL   (WINAPI *thread32First)      (HANDLE,THREADENTRY32*);
 T BOOL   (WINAPI *thread32Next)       (HANDLE,THREADENTRY32*);
 T HANDLE (WINAPI *create32Snapshot)   (DWORD,DWORD);
 T BOOL   (WINAPI *module32First)      (HANDLE,MODULEENTRY32*);
 T BOOL   (WINAPI *module32Next)       (HANDLE,MODULEENTRY32*);
 T BOOL   (WINAPI *trycritical)        (LPCRITICAL_SECTION);
 T BOOL   (WINAPI *createprocwithlogin)(LPCWSTR,LPCWSTR,LPCWSTR,DWORD,LPCWSTR,LPWSTR,DWORD,LPVOID,LPCWSTR,LPSTARTUPINFOW,LPPROCESS_INFORMATION);
 T DWORD  (WINAPI *setlayeredwinattrs) (HWND,DWORD,BYTE,DWORD);
 T VOID   (WINAPI *disableGhosting)    (VOID);
 T BOOL   (WINAPI *printwindow)        (HWND,HDC,UINT);
 T BOOL   (WINAPI *enumdisplaydevs)    (LPCTSTR lpDevice,DWORD iDevNum,aa_DISPLAY_DEVICE*lpDisplayDevice,DWORD dwFlags);
 T BOOL   (WINAPI *enumDisplayMonitors)(HDC hDC,LPCRECT recclip,MONENUMPROC eproc,LPARAM data);
 T BOOL   (WINAPI *getMonitorInfoEx)   (HANDLE,aa_MONITOR_INFO*);
 T DWORD  (WINAPI *getModuleFileNameEx)(HANDLE,HMODULE,LPTSTR,DWORD);
 T DWORD  (WINAPI *getProcessFileName) (HANDLE,LPTSTR,DWORD);
 T BOOL   (WINAPI *getProcessMemoryInfo)(HANDLE,PROCESS_MEMORY_COUNTERS*,DWORD);
 T BOOL   (WINAPI *getOpenFileName)    (OPENFILENAME*);
 T DWORD  (NTAPI  *ntQueryInformationProcess) (HANDLE,DWORD,PVOID,DWORD,PDWORD);


 BOOL CALLBACK MonitorEproc            (HANDLE hmon,HDC hdc,LPRECT rcmon,LPARAM data)
 {
 NP hp,varptr;
 N i;

 varptr=(NP)data;
 i=varptr[0];
 if(i>=64) { return FALSE; }
 aaCast(hp,NP,&varptr[1+(i*6)]);
 hp[0]=(N)hmon;
 hp[1]=(N)hdc;
 hp[2]=(N)rcmon->left;
 hp[3]=(N)rcmon->top;
 hp[4]=(N)rcmon->right;
 hp[5]=(N)rcmon->bottom;
 i++;
 varptr[0]=i;
 return TRUE;
 }

/*-----------------------------------------------------------------------*/


 C ret_string_text[256][20];
 CP ret_string[256];
 HWND aa_hwnd_ignore[16]={0}; // first index is count of hwnds



 structure
 {
 H msg;
 B str[45];
 }
 _aa_winmsg;


 _aa_winmsg                            aa_winmsg[]={
 {0x0000,"NULL"},{0x0001,"CREATE"},{0x0002,"DESTROY"},{0x0003,"MOVE"},
 {0x0005,"SIZE"},{0x0006,"ACTIVATE"},{0x0007,"SETFOCUS"},{0x0008,"KILLFOCUS"},
 {0x000A,"ENABLE"},{0x000B,"SETREDRAW"},{0x000C,"SETTEXT"},{0x000D,"GETTEXT"},
 {0x000E,"GETTEXTLENGTH"},{0x000F,"PAINT"},{0x0010,"CLOSE"},{0x0011,"QUERYENDSESSION"},
 {0x0012,"QUIT"},{0x0013,"QUERYOPEN"},{0x0014,"ERASEBKGND"},{0x0015,"SYSCOLORCHANGE"},
 {0x0016,"ENDSESSION"},{0x0018,"SHOWWINDOW"},{0x001A,"WININICHANGE"},{WM_WININICHANGE,"SETTINGCHANGE"},
 {0x001B,"DEVMODECHANGE"},{0x001C,"ACTIVATEAPP"},{0x001D,"FONTCHANGE"},{0x001E,"TIMECHANGE"},
 {0x001F,"CANCELMODE"},{0x0020,"SETCURSOR"},{0x0021,"MOUSEACTIVATE"},{0x0022,"CHILDACTIVATE"},
 {0x0023,"QUEUESYNC"},{0x0024,"GETMINMAXINFO"},{0x0026,"PAINTICON"},{0x0027,"ICONERASEBKGND"},
 {0x0028,"NEXTDLGCTL"},{0x002A,"SPOOLERSTATUS"},{0x002B,"DRAWITEM"},{0x002C,"MEASUREITEM"},
 {0x002D,"DELETEITEM"},{0x002E,"VKEYTOITEM"},{0x002F,"CHARTOITEM"},{0x0030,"SETFONT"},
 {0x0031,"GETFONT"},{0x0032,"SETHOTKEY"},{0x0033,"GETHOTKEY"},{0x0037,"QUERYDRAGICON"},
 {0x0039,"COMPAREITEM"},{0x003D,"GETOBJECT"},{0x0041,"COMPACTING"},{0x0044,"COMMNOTIFY"},
 {0x0046,"WINDOWPOSCHANGING"},{0x0047,"WINDOWPOSCHANGED"},{0x0048,"POWER"},{0x004A,"COPYDATA"},
 {0x004B,"CANCELJOURNAL"},{0x004E,"NOTIFY"},{0x0050,"INPUTLANGCHANGEREQUEST"},{0x0051,"INPUTLANGCHANGE"},
 {0x0052,"TCARD"},{0x0053,"HELP"},{0x0054,"USERCHANGED"},{0x0055,"NOTIFYFORMAT"},
 {0x007B,"CONTEXTMENU"},{0x007C,"STYLECHANGING"},{0x007D,"STYLECHANGED"},{0x007E,"DISPLAYCHANGE"},
 {0x007F,"GETICON"},{0x0080,"SETICON"},{0x0081,"NCCREATE"},{0x0082,"NCDESTROY"},
 {0x0083,"NCCALCSIZE"},{0x0084,"NCHITTEST"},{0x0085,"NCPAINT"},{0x0086,"NCACTIVATE"},
 {0x0087,"GETDLGCODE"},{0x0088,"SYNCPAINT"},{0x00A0,"NCMOUSEMOVE"},{0x00A1,"NCLBUTTONDOWN"},
 {0x00A2,"NCLBUTTONUP"},{0x00A3,"NCLBUTTONDBLCLK"},{0x00A4,"NCRBUTTONDOWN"},{0x00A5,"NCRBUTTONUP"},
 {0x00A6,"NCRBUTTONDBLCLK"},{0x00A7,"NCMBUTTONDOWN"},{0x00A8,"NCMBUTTONUP"},{0x00A9,"NCMBUTTONDBLCLK"},
 //{0x0100,"KEYFIRST"},
 {0x0100,"KEYDOWN"},{0x0101,"KEYUP"},
 {0x0102,"CHAR"},{0x0103,"DEADCHAR"},
 {0x0104,"SYSKEYDOWN"},{0x0105,"SYSKEYUP"},
 {0x0106,"SYSCHAR"},{0x0107,"SYSDEADCHAR"},
 {0x0108,"KEYLAST"},
 {0x010D,"IME_STARTCOMPOSITION"},{0x010E,"IME_ENDCOMPOSITION"},
 {0x010F,"IME_COMPOSITION"},{0x010F,"IME_KEYLAST"},{0x0110,"INITDIALOG"},{0x0111,"COMMAND"},
 {0x0112,"SYSCOMMAND"},{0x0113,"TIMER"},{0x0114,"HSCROLL"},{0x0115,"VSCROLL"},
 {0x0116,"INITMENU"},{0x0117,"INITMENUPOPUP"},{0x011F,"MENUSELECT"},{0x0120,"MENUCHAR"},
 {0x0121,"ENTERIDLE"},{0x0122,"MENURBUTTONUP"},{0x0123,"MENUDRAG"},{0x0124,"MENUGETOBJECT"},
 {0x0125,"UNINITMENUPOPUP"},{0x0126,"MENUCOMMAND"},{0x0132,"CTLCOLORMSGBOX"},{0x0133,"CTLCOLOREDIT"},
 {0x0134,"CTLCOLORLISTBOX"},{0x0135,"CTLCOLORBTN"},{0x0136,"CTLCOLORDLG"},{0x0137,"CTLCOLORSCROLLBAR"},
 {0x0138,"CTLCOLORSTATIC"},{0x0200,"MOUSEFIRST"},{0x0200,"MOUSEMOVE"},{0x0201,"LBUTTONDOWN"},
 {0x0202,"LBUTTONUP"},{0x0203,"LBUTTONDBLCLK"},{0x0204,"RBUTTONDOWN"},{0x0205,"RBUTTONUP"},
 {0x0206,"RBUTTONDBLCLK"},{0x0207,"MBUTTONDOWN"},{0x0208,"MBUTTONUP"},{0x0209,"MBUTTONDBLCLK"},
 {0x020A,"MOUSEWHEEL"},{0x020A,"MOUSELAST"},{0x0209,"MOUSELAST"},{0x0210,"PARENTNOTIFY"},
 {0x0211,"ENTERMENULOOP"},{0x0212,"EXITMENULOOP"},{0x0213,"NEXTMENU"},{0x0214,"SIZING"},
 {0x0215,"CAPTURECHANGED"},{0x0216,"MOVING"},{0x0218,"POWERBROADCAST"},{0x0219,"DEVICECHANGE"},
 {0x0220,"MDICREATE"},{0x0221,"MDIDESTROY"},{0x0222,"MDIACTIVATE"},{0x0223,"MDIRESTORE"},
 {0x0224,"MDINEXT"},{0x0225,"MDIMAXIMIZE"},{0x0226,"MDITILE"},{0x0227,"MDICASCADE"},
 {0x0228,"MDIICONARRANGE"},{0x0229,"MDIGETACTIVE"},{0x0230,"MDISETMENU"},{0x0231,"ENTERSIZEMOVE"},
 {0x0232,"EXITSIZEMOVE"},{0x0233,"DROPFILES"},{0x0234,"MDIREFRESHMENU"},{0x0281,"IME_SETCONTEXT"},
 {0x0282,"IME_NOTIFY"},{0x0283,"IME_CONTROL"},{0x0284,"IME_COMPOSITIONFULL"},{0x0285,"IME_SELECT"},
 {0x0286,"IME_CHAR"},{0x0288,"IME_REQUEST"},{0x0290,"IME_KEYDOWN"},{0x0291,"IME_KEYUP"},
 {0x02A1,"MOUSEHOVER"},{0x02A3,"MOUSELEAVE"},{0x0300,"CUT"},{0x0301,"COPY"},
 {0x0302,"PASTE"},{0x0303,"CLEAR"},{0x0304,"UNDO"},{0x0305,"RENDERFORMAT"},
 {0x0306,"RENDERALLFORMATS"},{0x0307,"DESTROYCLIPBOARD"},{0x0308,"DRAWCLIPBOARD"},{0x0309,"PAINTCLIPBOARD"},
 {0x030A,"VSCROLLCLIPBOARD"},{0x030B,"SIZECLIPBOARD"},{0x030C,"ASKCBFORMATNAME"},{0x030D,"CHANGECBCHAIN"},
 {0x030E,"HSCROLLCLIPBOARD"},{0x030F,"QUERYNEWPALETTE"},{0x0310,"PALETTEISCHANGING"},{0x0311,"PALETTECHANGED"},
 {0x0312,"HOTKEY"},{0x0317,"PRINT"},{0x0318,"PRINTCLIENT"},{0x0358,"HANDHELDFIRST"},
 {0x035F,"HANDHELDLAST"},{0x0360,"AFXFIRST"},{0x037F,"AFXLAST"},{0x0380,"PENWINFIRST"},
 {0x038F,"PENWINLAST"},{0x8000,"APP"},{0x0400,"USER"}
 };



 #define aa_COREPREVMS_CpuLoadGet      0
 #define aa_COREPREVMS_NetYield        1


 structure
 {
 HINSTANCE this_instance;
 HINSTANCE prev_instance;
 H discovery_message_id;
 B aa_trace_file[513];
 B aa_crash_file[513];
 B built[50];
 B via_shortcut;
 B module_filename[_1K];
 B module_path[_1K];
 C command_line[_2K];
 N command_show;
 HMODULE kernel_module;
 HMODULE comdlg_module;
 HMODULE user_module;
 HMODULE advapi_module;
 HMODULE psapi_module;
 getSystemTimes GetSystemTimes;
 getProcessTimes GetProcessTimes;
 process32First Process32First;
 process32Next Process32Next;
 thread32First Thread32First;
 thread32Next Thread32Next;

 create32Snapshot Create32Snapshot;
 module32First Module32First;
 module32Next Module32Next;
 trycritical TryEnterCriticalSection;
 createprocwithlogin CreateProcWithLogin;
 setlayeredwinattrs SetLayeredWindowAttributes;
 disableGhosting DisableProcessWindowsGhosting;
 printwindow PrintWindow;
 enumdisplaydevs EnumDisplayDevices;
 enumDisplayMonitors EnumDisplayMonitors;
 ///queryFullProcName QueryFullProcName;
 getMonitorInfoEx GetMonitorInfoEx;
 getModuleFileNameEx GetModuleFileNameEx;
 getProcessMemoryInfo GetProcessMemoryInfo;
 getProcessFileName GetProcessFileName;
 getOpenFileName GetOpenFileName;
 Q perf_frequency;
 Q perf_frequency_ms;
 Q prev_msrunning[32];
// Q prev_microsecsrunning
 H launch_tik;
 H version;
 B in_debugger;
 B in_remote_debugger;
 HANDLE process_handle;
 H process_id;
 HANDLE thread_handle;
 H thread_id;
 C class_name[257];
 WNDCLASSEX class_data;
 HANDLE softice_handle;
 B wm_quit_received;
 H wm_quit_exitcode;
 B is_exitcode_set;
 H set_exitcode;
 HDC display_dc;
 Q last_yield_msrunning;
 Q subt_yield_msrunning;
 Q cycle;
 Q wm_msg_count_total;
 Q wm_msg_count_surfaced;
 Q wm_msg_count_unhandled;
 Q wm_msg_count_erasebg;
 Q wm_msg_count_paint;
 ///F last_yield_hz;
 ///H yield_sleep_cycle;
 ///H yield_sleep_step;
 HANDLE limiter_mutex_handle;
 Q limiter_last_counter;
 V(*LimiterMessageProc)(H,VP);
 V(*CopyDataProc)(HWND,HWND,H,H,VP);
 H master_log_entries;
 B master_log_state;
 B is_debugf_log_write;
 B debugf_log_write_style;
 H aamain_tik;
 H aamain_elapsed;
 Q aamain_perftik;
 Q aamain_perfelapsed;
 B is_morph_pending;
 PROCESS_INFORMATION morph_pi;
 B is_restart_on_crash;
 H crash_msrunning_required;
 H routine_proc_count;
 V (*RoutineProcYield[64])(VP);
 VP RoutineParmYield[64];
 V (*RoutineProcStop[64])(VP);
 VP RoutineParmStop[64];
 H note_killer_id;
 B(*SleepFunction)(Q ms);
 B is_console_attached;
 B is_console_ever_attached;
 B is_console_crlf_needed;
 }
 _aa_coresystem;


 B aa_CoreSystemHistory                (H line,VP fmt,...);
 B aa_CoreSystemLog                    (H style,VP fmt,...);
 B aa_CoreSystemLogStateSet            (B state);
 B aa_CoreSystemStart                  (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,Z cmdshow);
 B aa_CoreSystemSleepStandard          (Q microsecs);
 B aa_CoreSystemSleepPrecise           (Q microsecs);
 V aa_CoreSystemStop                   (V);
 B aa_CoreSystemWindowsMsgToString     (UINT msg,VP str);
 K aa_CoreSystemProc                   (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm);
 B aa_CoreSystemCpuLoadGet             (V);
 Q aa_CoreSystemTikPrecise             (V);
 B aa_CoreSystemTime                   (V);
 B aa_CoreSystemTimer                  (H index,B prefresh,B postfresh,Q ms);
 B aa_CoreSystemLoop                   (V);


/*-----------------------------------------------------------------------*/


 #define VAL_memd                      1684890989
 #define VAL_cyhz                      2053667171
 #define VAL_data                      1635017060
 #define VAL_miqu                      1970366829
 #define VAL_misk                      1802725741
 #define VAL_timr                      1919773044
 #define VAL_prof                      1718579824
 #define VAL_nrtt                      1953788526
 #define VAL_txen                      1852143732
 #define VAL_biqd                      1902602594
 #define VAL_task                      1802723700
 #define VAL_funt                      1953396070
 #define VAL_upar                      1918988405
 #define VAL_inif                      1718185577
 #define VAL_fprm                      1836216422
 #define VAL_http                      1886680168
 #define VAL_pars                      1936875888
 #define VAL_achn                      2092992221
 #define VAL_msql                      2336875888


 #define aa_MEMMODULE_MAGIC            VAL_memd
 #define aa_DATA_MAGIC                 VAL_data
 #define aa_MINIQUE_MAGIC              VAL_miqu
 #define aa_MINISTACK_MAGIC            VAL_misk
 #define aa_TIMER_MAGIC                VAL_timr
 #define aa_PROFILER_MAGIC             VAL_prof
 #define aa_RTT_MAGIC                  VAL_nrtt
 #define aa_BIQUAD_MAGIC               VAL_biqd
 #define aa_TASK_MAGIC                 VAL_task
 #define aa_FILEUNIT_MAGIC             VAL_funt
 #define aa_UPDATEAREA_MAGIC           VAL_upar
 #define aa_INI_MAGIC                  VAL_inif
 #define aa_HTTP_MAGIC                 VAL_http
 #define aa_PARSE_MAGIC                VAL_pars

/*-----------------------------------------------------------------------*/


 B aa_geo_country_code[251][3]=        { "--","AP","EU","AD","AE","AF","AG","AI","AL","AM","AN","AO","AQ","AR","AS","AT","AU","AW","AZ","BA","BB",
                                         "BD","BE","BF","BG","BH","BI","BJ","BM","BN","BO","BR","BS","BT","BV","BW","BY","BZ","CA","CC","CD",
                                         "CF","CG","CH","CI","CK","CL","CM","CN","CO","CR","CU","CV","CX","CY","CZ","DE","DJ","DK","DM","DO",
                                         "DZ","EC","EE","EG","EH","ER","ES","ET","FI","FJ","FK","FM","FO","FR","FX","GA","GB","GD","GE","GF",
                                         "GH","GI","GL","GM","GN","GP","GQ","GR","GS","GT","GU","GW","GY","HK","HM","HN","HR","HT","HU","ID",
                                         "IE","IL","IN","IO","IQ","IR","IS","IT","JM","JO",
                                         "JP","KE","KG","KH","KI","KM","KN","KP","KR","KW",
                                         "KY","KZ","LA","LB","LC","LI","LK","LR","LS","LT",
                                         "LU","LV","LY","MA","MC","MD","MG","MH","MK","ML",
                                         "MM","MN","MO","MP","MQ","MR","MS","MT","MU","MV",
                                         "MW","MX","MY","MZ","NA","NC","NE","NF","NG","NI",
                                         "NL","NO","NP","NR","NU","NZ","OM","PA","PE","PF",
                                         "PG","PH","PK","PL","PM","PN","PR","PS","PT","PW",
                                         "PY","QA","RE","RO","RU","RW","SA","SB","SC","SD",
                                         "SE","SG","SH","SI","SJ","SK","SL","SM","SN","SO",
                                         "SR","ST","SV","SY","SZ","TC","TD","TF","TG","TH",
                                         "TJ","TK","TM","TN","TO","TL","TR","TT","TV","TW",
                                         "TZ","UA","UG","UM","US","UY","UZ","VA","VC","VE",
                                         "VG","VI","VN","VU","WF","WS","YE","YT","RS","ZA",
                                         "ZM","ME","ZW","A1","A2","O1","AX","GG","IM","JE"};


 CP aa_geo_country_name[251]=          { "N/A","Asia/Pacific Region","Europe","Andorra","United Arab Emirates","Afghanistan","Antigua and Barbuda","Anguilla","Albania","Armenia","Netherlands Antilles",
                                         "Angola","Antarctica","Argentina","American Samoa","Austria","Australia","Aruba","Azerbaijan","Bosnia and Herzegovina","Barbados",
                                         "Bangladesh","Belgium","Burkina Faso","Bulgaria","Bahrain","Burundi","Benin","Bermuda","Brunei Darussalam","Bolivia",
                                         "Brazil","Bahamas","Bhutan","Bouvet Island","Botswana","Belarus","Belize","Canada","Cocos (Keeling) Islands","Congo, The Democratic Republic of the",
                                         "Central African Republic","Congo","Switzerland","Cote D'Ivoire","Cook Islands","Chile","Cameroon","China","Colombia","Costa Rica",
                                         "Cuba","Cape Verde","Christmas Island","Cyprus","Czech Republic","Germany","Djibouti","Denmark","Dominica","Dominican Republic",
                                         "Algeria","Ecuador","Estonia","Egypt","Western Sahara","Eritrea","Spain","Ethiopia","Finland","Fiji",
                                         "Falkland Islands (Malvinas)","Micronesia, Federated States of","Faroe Islands","France","France, Metropolitan","Gabon","United Kingdom","Grenada","Georgia","French Guiana",
                                         "Ghana","Gibraltar","Greenland","Gambia","Guinea","Guadeloupe","Equatorial Guinea","Greece","South Georgia and the South Sandwich Islands","Guatemala",
                                         "Guam","Guinea-Bissau","Guyana","Hong Kong","Heard Island and McDonald Islands","Honduras","Croatia","Haiti","Hungary","Indonesia",
                                         "Ireland","Israel","India","British Indian Ocean Territory","Iraq","Iran, Islamic Republic of","Iceland","Italy","Jamaica","Jordan",
                                         "Japan","Kenya","Kyrgyzstan","Cambodia","Kiribati","Comoros","Saint Kitts and Nevis","Korea, Democratic People's Republic of","Korea, Republic of","Kuwait",
                                         "Cayman Islands","Kazakhstan","Lao People's Democratic Republic","Lebanon","Saint Lucia","Liechtenstein","Sri Lanka","Liberia","Lesotho","Lithuania",
                                         "Luxembourg","Latvia","Libyan Arab Jamahiriya","Morocco","Monaco","Moldova, Republic of","Madagascar","Marshall Islands","Macedonia","Mali",
                                         "Myanmar","Mongolia","Macau","Northern Mariana Islands","Martinique","Mauritania","Montserrat","Malta","Mauritius","Maldives",
                                         "Malawi","Mexico","Malaysia","Mozambique","Namibia","New Caledonia","Niger","Norfolk Island","Nigeria","Nicaragua",
                                         "Netherlands","Norway","Nepal","Nauru","Niue","New Zealand","Oman","Panama","Peru","French Polynesia",
                                         "Papua New Guinea","Philippines","Pakistan","Poland","Saint Pierre and Miquelon","Pitcairn Islands","Puerto Rico","Palestinian Territory","Portugal","Palau",
                                         "Paraguay","Qatar","Reunion","Romania","Russian Federation","Rwanda","Saudi Arabia","Solomon Islands","Seychelles","Sudan",
                                         "Sweden","Singapore","Saint Helena","Slovenia","Svalbard and Jan Mayen","Slovakia","Sierra Leone","San Marino","Senegal","Somalia","Suriname",
                                         "Sao Tome and Principe","El Salvador","Syrian Arab Republic","Swaziland","Turks and Caicos Islands","Chad","French Southern Territories","Togo","Thailand",
                                         "Tajikistan","Tokelau","Turkmenistan","Tunisia","Tonga","Timor-Leste","Turkey","Trinidad and Tobago","Tuvalu","Taiwan",
                                         "Tanzania, United Republic of","Ukraine","Uganda","United States Minor Outlying Islands","United States","Uruguay","Uzbekistan","Holy See (Vatican City State)","Saint Vincent and the Grenadines","Venezuela",
                                         "Virgin Islands, British","Virgin Islands, U.S.","Vietnam","Vanuatu","Wallis and Futuna","Samoa","Yemen","Mayotte","Serbia","South Africa",
                                         "Zambia","Montenegro","Zimbabwe","Anonymous Proxy","Satellite Provider","Other","Aland Islands","Guernsey","Isle of Man","Jersey"};

 B aa_geo_continent[251][3]=           { "--","AS","EU","EU","AS","AS","SA","SA","EU","AS","SA",
                                         "AF","AN","SA","OC","EU","OC","SA","AS","EU","SA",
                                         "AS","EU","AF","EU","AS","AF","AF","SA","AS","SA",
                                         "SA","SA","AS","AF","AF","EU","SA","NA","AS","AF",
                                         "AF","AF","EU","AF","OC","SA","AF","AS","SA","SA",
                                         "SA","AF","AS","AS","EU","EU","AF","EU","SA","SA",
                                         "AF","SA","EU","AF","AF","AF","EU","AF","EU","OC",
                                         "SA","OC","EU","EU","EU","AF","EU","SA","AS","SA",
                                         "AF","EU","SA","AF","AF","SA","AF","EU","SA","SA",
                                         "OC","AF","SA","AS","AF","SA","EU","SA","EU","AS",
                                         "EU","AS","AS","AS","AS","AS","EU","EU","SA","AS",
                                         "AS","AF","AS","AS","OC","AF","SA","AS","AS","AS",
                                         "SA","AS","AS","AS","SA","EU","AS","AF","AF","EU",
                                         "EU","EU","AF","AF","EU","EU","AF","OC","EU","AF",
                                         "AS","AS","AS","OC","SA","AF","SA","EU","AF","AS",
                                         "AF","NA","AS","AF","AF","OC","AF","OC","AF","SA",
                                         "EU","EU","AS","OC","OC","OC","AS","SA","SA","OC",
                                         "OC","AS","AS","EU","SA","OC","SA","AS","EU","OC",
                                         "SA","AS","AF","EU","AS","AF","AS","OC","AF","AF",
                                         "EU","AS","AF","EU","EU","EU","AF","EU","AF","AF",
                                         "SA","AF","SA","AS","AF","SA","AF","AF","AF","AS",
                                         "AS","OC","AS","AF","OC","AS","AS","SA","OC","AS",
                                         "AF","EU","AF","OC","NA","SA","AS","EU","SA","SA",
                                         "SA","SA","AS","OC","OC","OC","AS","AF","EU","AF",
                                         "AF","EU","AF","--","--","--","EU","EU","EU","EU"};


/*-----------------------------------------------------------------------*/

 CP aa_common_name[2][26]=             {
                                       {"Alistar","Bob","Craig","David","Eddy","Fred","Greg","Harry",
                                        "Ian","John","Ken","Larry","Mike","Norman","Oscar","Pete",
                                        "quincy","Ron","Steve","Tom","Urving","Victor","William","Xeo","Yuri","Zach"},
                                       {"Angel","Betty","Carol","Dianne","Eliza","Fiona","Grace","Helen",
                                        "Irene","Janene","Kathy","Lisa","Mindy","Nancy","Olivia","Penny","Qeisha",
                                        "Rachael","Sarah","Tanya","Ursela","Vera","Wendy","Xeisha","Yvonne","Zoey"}
                                       };

/*-----------------------------------------------------------------------*/

 B aa_starchar[4]=                     {'|','/','-','\\'};

 CP aa_timemonth[12]=                  {"Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"};
 CP aa_timemonthex[12]=                {"January","Febuary","March","April","May","June","July","August","September","October","November","December"};
 CP aa_timeday[7]=                     {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
 CP aa_timedayex[7]=                   {"Sunday","Monday","Tueday","Wednesday","Thursday","Friday","Saturday"};


 structure
 {
 H last_tik;
 D cpu_mhz;
 B is_timezone_ready;
 N timezone_bias;
 B is_dls;
 B is_std;
 N timezone_bias_total;
 B timezone_string[_1K];
 }
 _aa_timersystem;


 B aa_TimerSystemStart                 (V);
 B aa_TimerSystemCpuSpeedGet           (V);
 B aa_TimerSystemTimezoneGet           (V);
 V aa_TimerSystemStop                  (V);


/*-----------------------------------------------------------------------*/


 #define qsMAXSTACK                    (sizeof(size_t)*CHAR_BIT)
 #define qsEXCHANGE(a,b,size)          {Z s; ZP ai,bi; CP ac,bc; \
                                        ai=(ZP)a; bi=(ZP)b; for(s=sizeof(Z); s<=size; s+=sizeof(Z)) { Z t=*ai; *ai++=*bi; *bi++=t; } \
                                        ac=(CP)ai; bc=(CP)bi; for(s=s-sizeof(Z)+1; s<=size;s++) { C t=*ac; *ac++=*bc; *bc++=t; } }

/*-----------------------------------------------------------------------*/

 #define aa_MEMORY_OPCODE_SAFETY       32

 #define aa_MEMORYCRC_POLYNOMIAL       0x04C11DB7
 #define aa_MEMORYCRC_POLYNOMIALb      0x1EDC6F41
 #define aa_MEMORYCRC_POLYNOMIAL64     0xC96C5795D7870F42;

 #define aa_MEMORYTEMP_User             0
 #define aa_MEMORYTEMP_UdpPktRet       10
 #define aa_MEMORYTEMP_DynAppendf      11
 #define aa_MEMORYTEMP_Debugf          12
 #define aa_MEMORYTEMP_StrExplode      13
 #define aa_MEMORYTEMP_Log             14
 #define aa_MEMORYTEMP_SurfaceScroll   15
 #define aa_MEMORYTEMP_IcmpProc        16
 #define aa_MEMORYTEMP_SniffProc       17
 #define aa_MEMORYTEMP_StrReverse      18
 #define aa_MEMORYTEMP_StrMultSpaces   19
 #define aa_MEMORYTEMP_StrEncode       20
 #define aa_MEMORYTEMP_StrDecode       21
 #define aa_MEMORYTEMP_StringDecodeA   22
 #define aa_MEMORYTEMP_StringDecodeB   23
 #define aa_MEMORYTEMP_StrAppendf      24
 #define aa_MEMORYTEMP_StrCopyf        25
 #define aa_MEMORYTEMP_StrNCopyf       26
 #define aa_MEMORYTEMP_StrAppendCopyf  27
 #define aa_MEMORYTEMP_CgiWritef       28
 #define aa_MEMORYTEMP_CgiRead         29
 #define aa_MEMORYTEMP_CallWritef      30
 #define aa_MEMORYTEMP_CallMirror      31
 #define aa_MEMORYTEMP_FileWritef      32
 #define aa_MEMORYTEMP_StrHash         33
 #define aa_MEMORYTEMP_ClipWritef      34
 #define aa_MEMORYTEMP_IcmpWritef      35
 #define aa_MEMORYTEMP_SniffPktRet     36
 #define aa_MEMORYTEMP_Base64          37
 #define aa_MEMORYTEMP_JsonDumpA       38
 #define aa_MEMORYTEMP_JsonDumpB       39
 #define aa_MEMORYTEMP_ProcessList     40
 #define aa_MEMORYTEMP_ProcessTcp      41
 #define aa_MEMORYTEMP_OrderSort       42
 #define aa_MEMORYTEMP_OrderBlob       43
 #define aa_MEMORYTEMP_StrCopyfLen     44
 #define aa_MEMORYTEMP_QueFind         45
 #define aa_MEMORYTEMP_SurfaceConvolve 46
 #define aa_MEMORYTEMP_aaf             47


 #define aa_MEM_NOTALIND(eex,eey)      (((N)eex&(sizeof(N)-1))|((N)eey&(sizeof(N)-1)))
 #define aa_MEM_BIGBLOCKSIZE           (sizeof(N)<<2)
 #define aa_MEM_LITTLEBLOCKSIZE        (sizeof(N))
 #define aa_MEM_TOO_SMALL(LEN)         ((LEN)<(N)aa_MEM_BIGBLOCKSIZE)



 structure
 {
 H magic;
 B is_protected;
 B is_user;
 B is_locked;
 B mini_type;
 H mini_index;
 H realloc_count;
 H bytes;
 C name[32];
 BP actual_ptr;
 H actual_len;
 }
 _aa_memoryheader;



 structure
 {
 _memorystatus status;
 _memorytable table;
 H table_pf;
 PROCESS_MEMORY_COUNTERS pmc;
 Q crc64_table[256];
 H crc_table[256];
 H run_bytes;
 BP temp_mem[256];
 H temp_bytes[256];
 H temp_hits[256];
 H temp_allocs[256];
 H temp_reallocs[256];
 BP cdecl_ram;
 H alloc_calls;
 H realloc_calls;
 H release_calls;
 }
 _aa_memorysystem;


 B aa_MemorySystemStart                (V);
 V aa_MemorySystemStop                 (V);
 V aa_MemorySystemDump                 (V);
 B aa_MemoryAllocate                   (PP mem,H bytes,VP name,B lock);
 B aa_MemoryReAllocate                 (PP mem,H bytes);
 B aa_MemoryProtect                    (VP mem,B state);
 B aa_MemoryRelease                    (VP mem);
 B aa_MemoryTemp                       (PP mem,H bytes,B level);

 H tot_v_alloc=0;
 H tot_v_free=0;
 H tot_v_protect=0;

/*-----------------------------------------------------------------------*/

 // apx 300meg of pages possible (300x256x4096)

 #define USE_PAGE_CRITICAL_SECTION     YES-1

 #define aa_PAGE_BASE_HANDLE           92932
 #define aa_PAGE_MAX_BOOKS             512  // was 2048
 #define aa_PAGE_PER_BOOK              256 // must be 256 ( i think, otherwise, crashes may occwr )
 #define aa_PAGE_BYTES                 _16K // was 4k


 structure
 {
 BP mem;
 B in_use[aa_PAGE_PER_BOOK];
 B protection[aa_PAGE_PER_BOOK];
 C name[aa_PAGE_PER_BOOK][13];
 H usage;
 }
 _aa_pagebook;


 structure
 {
 H bytes_per_page;
 H bytes_per_book;
 H bytes_accessable;
 H pages_per_system;
 H books_per_system;
 _aa_pagebook*book;
 H pages_commited;
 H pages_allocated;
 CRITICAL_SECTION mutex;
 }
 _aa_pagesystem;


 B aa_PageSystemStart                  (V);
 V aa_PageSystemStop                   (V);
 B aa_PageAllocate                     (HP handle,PP mem,VP name);
 B aa_PageRelease                      (H handle);
 B aa_PageProtect                      (H handle,B state);
 B aa_PageStatus                       (H handle,PP mem,BP isprotected,BP isuser);
 B aa_PageArrayIo                      (HP harray,H hcount,H offset,H bytes,VP data,B writemode);
 B aa_PageArrayFill                    (HP harray,H hcount,H offset,H bytes,B val);


/*-----------------------------------------------------------------------*/

 #define aa_OBJ_MAX_PER_ID             1000000
 #define aa_OBJ_BASE_HANDLE            3292932

 structure
 {
 B in_use;
 B is_protected;
 Q sesh; // use lo, hi=reserverd
 }
 _aa_objectinstanceheader;


 structure
 {
 H instance_limit;
 H instance_count;
 H instance_slots;
 H instance_bytes;
 H instance_initial;
 B name[33];
 BP instance_mem;
 B(*Destructor)(H handle);
 H sesh_counter;
 }
 _aa_object;


 structure
 {
 _aa_object object[256];
 B id_head;
 Q object_check_count[256];
 H sesh_counter;
 H total_count;
 }
 _aa_objectsystem;



 B aa_ObjectSystemStart                (V);
 V aa_ObjectSystemStop                 (V);
 B aa_ObjectDefine                     (B id,H bytes,H limit,H initial,B(*Destructor)(H),VP name);
 B aa_ObjectUndefine                   (B id);
 B aa_ObjectCreate                     (B id,HP handle,PP mem);
 B aa_ObjectCheck                      (B id,H handle,PP mem,BP isprotected);
 B aa_ObjectProtect                    (B id,H handle,B state);
 B aa_ObjectDestroy                    (B id,H handle);
 B aa_ObjectIdNew                      (BP id);
 B aa_ObjectNext                       (B id,HP handle,PP mem,HP iterationcounter);
 B aa_ObjectFromHandle                 (BP id,H handle);
 B aa_ObjectHandleToIndex              (B id,H handle,HP index);
 B aa_ObjectIndexToHandle              (B id,H index,HP handle);

/*-----------------------------------------------------------------------*/


 structure
 {
 B is_manual_reset;
 B is_signaled;
 HANDLE handle;
 }
 _aa_event;


 B aa_EventDefine                      (_aa_event*event,B manualreset,B startsignaled,VP fmt,...);
 B aa_EventUndefine                    (_aa_event*event);
 B aa_EventSignal                      (_aa_event*event);
 B aa_EventIsSignaled                  (_aa_event*event);
 B aa_EventReset                       (_aa_event*event);

/*-----------------------------------------------------------/----------------------------------*/

 #define PROT_NONE                     0
 #define PROT_READ                     1
 #define PROT_WRITE                    2
 #define PROT_EXEC                     4

 #define MAP_FILE                      0
 #define MAP_SHARED                    1
 #define MAP_PRIVATE                   2
 #define MAP_TYPE                      0xf
 #define MAP_FIXED                     0x10
 #define MAP_ANONYMOUS                 0x20
 #define MAP_ANON                      MAP_ANONYMOUS

 #define MAP_FAILED                    ((VP)-1)

 #define MS_ASYNC                      1
 #define MS_SYNC                       2
 #define MS_INVALIDATE                 4

 #ifndef FILE_MAP_EXECUTE
 #define FILE_MAP_EXECUTE              0x0020
 #endif

 Z aa__map_mman_error                  (Y err,Z deferr);
 Y aa__map_mmap_prot_page              (Z prot);
 Y aa__map_mmap_prot_file              (Z prot);

 VP aa_mmap                            (VP addr,size_t len,Z prot,Z flags,Z fildes,off_t off);
 Z aa_munmap                           (VP addr,size_t len);
 Z aa_mprotect                         (VP addr,size_t len,Z prot);
 Z aa_msync                            (VP addr,size_t len,Z flags);
 Z aa_mlock                            (VP addr,size_t len);
 Z aa_munlock                          (VP addr,size_t len);

/*-----------------------------------------------------------/----------------------------------*/

// #include <fcntl.h>
#if 0
 int open                              (char*filename,int flags,int mode);
 int close                             (int fildes);
 off_t lseek                           (int fildes,off_t offset,int whence);
 int read                              (int handle,void*buffer,int nbyte);
 int write                             (int handle,void*buffer,int nbyte);
#endif
/*-----------------------------------------------------------/----------------------------------*/

 #define VE(serialmem,phyAddr)         ((VP)phyAddr-serialmem->base)/sizeof(C)
 #define PE(serialmem,virAddr)         ((virAddr==0)?((VP)0):((VP)(serialmem->base+virAddr*sizeof(C))))

 structure
 {
 Y ref;
 Z status;
 Y next;
 }
 _serialnode;



 B aa_SerialMemDefrag                  (_serialmem*serialmem);


/*-----------------------------------------------------------/----------------------------------*/

 B aa_SerialMemDefrag                  (_serialmem*serialmem)
 {
 _serialnode*temp;
 _serialnode*current;
 _serialnode*previous;

 if(serialmem==NULL) { return RET_BADPARM; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return RET_NOTINITIALIZED; }
 current=(_serialnode*)serialmem->base;
 previous=current;
 while(PE(serialmem,current->next)!=NULL)
  {
  current=(_serialnode*)(PE(serialmem,current->next));
  if(PE(serialmem,current->next)!=NULL)
   {
   if(current->status==0&&((_serialnode*)(PE(serialmem,current->next)))->status==0)
    {
    if(PE(serialmem,((_serialnode*)(PE(serialmem,current->next)))->next)!=NULL)
     {
     temp=(_serialnode*)PE(serialmem,((_serialnode*)(PE(serialmem,current->next)))->next);
     current->next=VE(serialmem,temp);
     current=previous;
     }
    else
     {
     current->next=0;
     break;
     }
    }
   else
    {
    previous=current;
    }
   }
  }
 return RET_YES;
 }


/*-----------------------------------------------------------/----------------------------------*/

 #define aa_MathTwister_MM             397
 #define aa_MathTwister_MATRIX_A       0x9908b0dfUL
 #define aa_MathTwister_UPPER_MASK     0x80000000UL
 #define aa_MathTwister_LOWER_MASK     0x7fffffffUL


 #define VAL_II                        18761
 #define VAL_MM                        19789

 D aa_muly_table[10]=                  {0.50,0.75,1.25,1.50,1.75,1.95,2.00,2.10,2.25,2.50};


 inline N aaDoubleToLong               (D d)
 {
 #define aa_DLD_MAGIC                  (((65536.0*65536.0*16.0)+32768.0)*65536.0)
 D dt=d+aa_DLD_MAGIC;
 return(*(NP)&dt)-0x80000000;
 }



 inline V aaDoubleToDwords             (D d,HP lopart,HP hipart)
 {
 H xh,xl;
 D dh,dl;

 dh=d/_4Bd;
 xh=(H)dh;
 dl=(D)xh*_4Bd;
 dl=d-dl;
 xl=(H)dl;
 if(lopart) { *lopart=xl; }
 if(hipart) { *hipart=xh; }
 }



 inline V aaDoubleToLongs              (D d,NP lopart,NP hipart)
 {
 N xh,xl;
 D dh,dl;

 dh=d/_4Bd;
 xh=(N)dh;
 dl=(D)xh*_4Bd;
 dl=d-dl;
 xl=(N)dl;
 if(lopart) { *lopart=xl; }
 if(hipart) { *hipart=xh; }
 }




 B aa_math_scan_zigzag[64]=
 {
 0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,
 35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63
 };


 B aa_math_scan_zigzag_jpeg[64]=
 {
 0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,
 10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63
 };


 H aa_math_system_smallprime[1972]=
 {
 3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,
 127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,
 251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,
 389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,
 541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,
 677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,
 839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,
 1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,
 1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,
 1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,
 1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,
 1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,
 1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,
 1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,
 1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,
 2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,
 2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,
 2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,
 2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,
 2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,
 2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,
 2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,
 3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,
 3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,
 3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,
 3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,
 3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,
 3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,
 3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,
 4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,
 4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,
 4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,
 4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,
 4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,
 4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999,5003,5009,5011,
 5021,5023,5039,5051,5059,5077,5081,5087,5099,5101,5107,5113,5119,5147,5153,5167,5171,5179,
 5189,5197,5209,5227,5231,5233,5237,5261,5273,5279,5281,5297,5303,5309,5323,5333,5347,5351,
 5381,5387,5393,5399,5407,5413,5417,5419,5431,5437,5441,5443,5449,5471,5477,5479,5483,5501,
 5503,5507,5519,5521,5527,5531,5557,5563,5569,5573,5581,5591,5623,5639,5641,5647,5651,5653,
 5657,5659,5669,5683,5689,5693,5701,5711,5717,5737,5741,5743,5749,5779,5783,5791,5801,5807,
 5813,5821,5827,5839,5843,5849,5851,5857,5861,5867,5869,5879,5881,5897,5903,5923,5927,5939,
 5953,5981,5987,6007,6011,6029,6037,6043,6047,6053,6067,6073,6079,6089,6091,6101,6113,6121,
 6131,6133,6143,6151,6163,6173,6197,6199,6203,6211,6217,6221,6229,6247,6257,6263,6269,6271,
 6277,6287,6299,6301,6311,6317,6323,6329,6337,6343,6353,6359,6361,6367,6373,6379,6389,6397,
 6421,6427,6449,6451,6469,6473,6481,6491,6521,6529,6547,6551,6553,6563,6569,6571,6577,6581,
 6599,6607,6619,6637,6653,6659,6661,6673,6679,6689,6691,6701,6703,6709,6719,6733,6737,6761,
 6763,6779,6781,6791,6793,6803,6823,6827,6829,6833,6841,6857,6863,6869,6871,6883,6899,6907,
 6911,6917,6947,6949,6959,6961,6967,6971,6977,6983,6991,6997,7001,7013,7019,7027,7039,7043,
 7057,7069,7079,7103,7109,7121,7127,7129,7151,7159,7177,7187,7193,7207,7211,7213,7219,7229,
 7237,7243,7247,7253,7283,7297,7307,7309,7321,7331,7333,7349,7351,7369,7393,7411,7417,7433,
 7451,7457,7459,7477,7481,7487,7489,7499,7507,7517,7523,7529,7537,7541,7547,7549,7559,7561,
 7573,7577,7583,7589,7591,7603,7607,7621,7639,7643,7649,7669,7673,7681,7687,7691,7699,7703,
 7717,7723,7727,7741,7753,7757,7759,7789,7793,7817,7823,7829,7841,7853,7867,7873,7877,7879,
 7883,7901,7907,7919,7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,
 8081,8087,8089,8093,8101,8111,8117,8123,8147,8161,8167,8171,8179,8191,8209,8219,8221,8231,
 8233,8237,8243,8263,8269,8273,8287,8291,8293,8297,8311,8317,8329,8353,8363,8369,8377,8387,
 8389,8419,8423,8429,8431,8443,8447,8461,8467,8501,8513,8521,8527,8537,8539,8543,8563,8573,
 8581,8597,8599,8609,8623,8627,8629,8641,8647,8663,8669,8677,8681,8689,8693,8699,8707,8713,
 8719,8731,8737,8741,8747,8753,8761,8779,8783,8803,8807,8819,8821,8831,8837,8839,8849,8861,
 8863,8867,8887,8893,8923,8929,8933,8941,8951,8963,8969,8971,8999,9001,9007,9011,9013,9029,
 9041,9043,9049,9059,9067,9091,9103,9109,9127,9133,9137,9151,9157,9161,9173,9181,9187,9199,
 9203,9209,9221,9227,9239,9241,9257,9277,9281,9283,9293,9311,9319,9323,9337,9341,9343,9349,
 9371,9377,9391,9397,9403,9413,9419,9421,9431,9433,9437,9439,9461,9463,9467,9473,9479,9491,
 9497,9511,9521,9533,9539,9547,9551,9587,9601,9613,9619,9623,9629,9631,9643,9649,9661,9677,
 9679,9689,9697,9719,9721,9733,9739,9743,9749,9767,9769,9781,9787,9791,9803,9811,9817,9829,
 9833,9839,9851,9857,9859,9871,9883,9887,9901,9907,9923,9929,9931,9941,9949,9967,9973,10007,
 10009,10037,10039,10061,10067,10069,10079,10091,10093,10099,10103,10111,10133,10139,10141,
 10151,10159,10163,10169,10177,10181,10193,10211,10223,10243,10247,10253,10259,10267,10271,
 10273,10289,10301,10303,10313,10321,10331,10333,10337,10343,10357,10369,10391,10399,10427,
 10429,10433,10453,10457,10459,10463,10477,10487,10499,10501,10513,10529,10531,10559,10567,
 10589,10597,10601,10607,10613,10627,10631,10639,10651,10657,10663,10667,10687,10691,10709,
 10711,10723,10729,10733,10739,10753,10771,10781,10789,10799,10831,10837,10847,10853,10859,
 10861,10867,10883,10889,10891,10903,10909,10937,10939,10949,10957,10973,10979,10987,10993,
 11003,11027,11047,11057,11059,11069,11071,11083,11087,11093,11113,11117,11119,11131,11149,
 11159,11161,11171,11173,11177,11197,11213,11239,11243,11251,11257,11261,11273,11279,11287,
 11299,11311,11317,11321,11329,11351,11353,11369,11383,11393,11399,11411,11423,11437,11443,
 11447,11467,11471,11483,11489,11491,11497,11503,11519,11527,11549,11551,11579,11587,11593,
 11597,11617,11621,11633,11657,11677,11681,11689,11699,11701,11717,11719,11731,11743,11777,
 11779,11783,11789,11801,11807,11813,11821,11827,11831,11833,11839,11863,11867,11887,11897,
 11903,11909,11923,11927,11933,11939,11941,11953,11959,11969,11971,11981,11987,12007,12011,
 12037,12041,12043,12049,12071,12073,12097,12101,12107,12109,12113,12119,12143,12149,12157,
 12161,12163,12197,12203,12211,12227,12239,12241,12251,12253,12263,12269,12277,12281,12289,
 12301,12323,12329,12343,12347,12373,12377,12379,12391,12401,12409,12413,12421,12433,12437,
 12451,12457,12473,12479,12487,12491,12497,12503,12511,12517,12527,12539,12541,12547,12553,
 12569,12577,12583,12589,12601,12611,12613,12619,12637,12641,12647,12653,12659,12671,12689,
 12697,12703,12713,12721,12739,12743,12757,12763,12781,12791,12799,12809,12821,12823,12829,
 12841,12853,12889,12893,12899,12907,12911,12917,12919,12923,12941,12953,12959,12967,12973,
 12979,12983,13001,13003,13007,13009,13033,13037,13043,13049,13063,13093,13099,13103,13109,
 13121,13127,13147,13151,13159,13163,13171,13177,13183,13187,13217,13219,13229,13241,13249,
 13259,13267,13291,13297,13309,13313,13327,13331,13337,13339,13367,13381,13397,13399,13411,
 13417,13421,13441,13451,13457,13463,13469,13477,13487,13499,13513,13523,13537,13553,13567,
 13577,13591,13597,13613,13619,13627,13633,13649,13669,13679,13681,13687,13691,13693,13697,
 13709,13711,13721,13723,13729,13751,13757,13759,13763,13781,13789,13799,13807,13829,13831,
 13841,13859,13873,13877,13879,13883,13901,13903,13907,13913,13921,13931,13933,13963,13967,
 13997,13999,14009,14011,14029,14033,14051,14057,14071,14081,14083,14087,14107,14143,14149,
 14153,14159,14173,14177,14197,14207,14221,14243,14249,14251,14281,14293,14303,14321,14323,
 14327,14341,14347,14369,14387,14389,14401,14407,14411,14419,14423,14431,14437,14447,14449,
 14461,14479,14489,14503,14519,14533,14537,14543,14549,14551,14557,14561,14563,14591,14593,
 14621,14627,14629,14633,14639,14653,14657,14669,14683,14699,14713,14717,14723,14731,14737,
 14741,14747,14753,14759,14767,14771,14779,14783,14797,14813,14821,14827,14831,14843,14851,
 14867,14869,14879,14887,14891,14897,14923,14929,14939,14947,14951,14957,14969,14983,15013,
 15017,15031,15053,15061,15073,15077,15083,15091,15101,15107,15121,15131,15137,15139,15149,
 15161,15173,15187,15193,15199,15217,15227,15233,15241,15259,15263,15269,15271,15277,15287,
 15289,15299,15307,15313,15319,15329,15331,15349,15359,15361,15373,15377,15383,15391,15401,
 15413,15427,15439,15443,15451,15461,15467,15473,15493,15497,15511,15527,15541,15551,15559,
 15569,15581,15583,15601,15607,15619,15629,15641,15643,15647,15649,15661,15667,15671,15679,
 15683,15727,15731,15733,15737,15739,15749,15761,15767,15773,15787,15791,15797,15803,15809,
 15817,15823,15859,15877,15881,15887,15889,15901,15907,15913,15919,15923,15937,15959,15971,
 15973,15991,16001,16007,16033,16057,16061,16063,16067,16069,16073,16087,16091,16097,16103,
 16111,16127,16139,16141,16183,16187,16189,16193,16217,16223,16229,16231,16249,16253,16267,
 16273,16301,16319,16333,16339,16349,16361,16363,16369,16381,16411,16417,16421,16427,16433,
 16447,16451,16453,16477,16481,16487,16493,16519,16529,16547,16553,16561,16567,16573,16603,
 16607,16619,16631,16633,16649,16651,16657,16661,16673,16691,16693,16699,16703,16729,16741,
 16747,16759,16763,16787,16811,16823,16829,16831,16843,16871,16879,16883,16889,16901,16903,
 16921,16927,16931,16937,16943,16963,16979,16981,16987,16993,17011,17021,17027,17029,17033,
 17041,17047,17053,17077,17093,17099,17107,17117,
 };



 structure
 {
 _twister twister;
 D four_billion;
 D ten_million;
 D one_million;
 I dct_iclip[1024];
 IP dct_iclip_ptr;
 }
 _aa_mathsystem;


 B aa_MathSystemStart                  (V);
 V aa_MathSystemStop                   (V);
 B aa_MathRandomGet                    (VP buf,H bytes);


/*----------------------------------------------------------*/



 structure
 {
 H magic;
 B state;
 Q id;
 H page_index;
 H block_index;
 }
 _aa_poolblockstub;


 structure
 {
 H blocks_allocated;
 H blocks_inuse;
 H block_pf;
 BP block_memory;
 BP block_state;
 }
 _aa_poolpage;


 structure
 {
 H self_handle;
 _poolstatus status;
 Q id_counter;
 H pages_topup_amount;
 H pages_topup_threshold;
 H pages_full;
 H page_pf;
 H pages_allocated;
 _aa_poolpage*page;
 }
 _aa_poolobject;


 structure
 {
 B object_id;
 }
 _aa_poolsystem;


 B aa_PoolSystemStart                  (V);
 V aa_PoolSystemStop                   (V);
 B aa_PoolSystemAddPages               (PP ptr,H qty);


/*---------------------------------------------------------*/

 structure
 {
 H self_handle;
 CRITICAL_SECTION mutex;
 HANDLE handle;
 _aa_event event;
 H id;
 _threadstatus status;
 }
 _aa_threadobject;


 structure
 {
 B object_id;
 }
 _aa_threadsystem;


 B aa_ThreadSystemStart                (V);
 V aa_ThreadSystemStop                 (V);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 STARTUPINFO si;
 STARTUPINFOW siw;
 SECURITY_ATTRIBUTES sa;
 SECURITY_DESCRIPTOR sd;
 PROCESS_INFORMATION pi;
 _processstatus status;
 PUSER_INFO_1 user_info;
 H ms_root;
 //_threadunit crash_thread;
 _timer crash_tm;
 H crash_tm_counter;
 }
 _aa_processobject;


 structure
 {
 B object_id;
 }
 _aa_processsystem;


 B aa_ProcessSystemStart               (V);
 V aa_ProcessSystemStop                (V);
 B aa_ProcessSystemCreate              (HP handle,VP processfilename,VP commandline,B clmode,B inherit,B startpaused,B detach,B newroot,W showcmd,B isconsole,VP desktop);
 BOOL CALLBACK aa_ProcessSystemEnum    (HWND hwnd,LPARAM lParam);
 H aa_ProcessCrashTester               (VP parm);

/*-----------------------------------------------------------------------*/

 T VOID (WINAPI *PFIBER_START_ROUTINE) (LPVOID lpFiberParameter);
 T PFIBER_START_ROUTINE                LPFIBER_START_ROUTINE;


 structure
 {
 H self_handle;
 H data;
 VP fib;
 VP parent_fib;
 _fiberstatus status;
 V(*Proc)(VP);
 }
 _aa_fiberobject;


 structure
 {
 B object_id;
 VP WINAPI (*CreateFiber)(H stacksize,LPFIBER_START_ROUTINE lpStartAddress,VP parm);
 VP WINAPI (*ConvertThreadToFiber)(VP parm);
 V  WINAPI (*SwitchToFiber)(VP fib);
 V  WINAPI (*DeleteFiber)(VP fib);
 }
 _aa_fibersystem;

 B aa_FiberSystemStart                 (V);
 V aa_FiberSystemStop                  (V);
 B aa_FiberSystemModuleInit            (V);


/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 _winenumstatus status;
 H slots;
 BP mem;
 H thread_handle;
 _threadstatus thread_status;
 H sleep_cycle;
 }
 _aa_winenumobject;



 structure
 {
 B object_id;
 }
 _aa_winenumsystem;


 B aa_WinEnumSystemStart               (V);
 V aa_WinEnumSystemStop                (V);
 BOOL CALLBACK aa_WinEnumProc          (HWND hwnd,LPARAM lparm);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 _dynbufstatus status;
 H write_bit_pos;
 H read_bit_pos;
 }
 _aa_dynbufobject;


 structure
 {
 B object_id;
 }
 _aa_dynbufsystem;


 B aa_DynbufSystemStart                (V);
 V aa_DynbufSystemStop                 (V);
 B aa_DynbufSystemExtend               (PP ptr,H by);

/*-----------------------------------------------------------------------*/


 structure
 {
 H self_handle;
 _arraystatus status;
 H pages_allocated;
 H slots_allocated;
 H actual_bytes_allocated;
 HP pge_slot;
 }
 _aa_arrayobject;


 structure
 {
 B object_id;
 }
 _aa_arraysystem;


 B aa_ArraySystemStart                 (V);
 V aa_ArraySystemStop                  (V);
 B aa_ArraySystemExtendPageSlots       (PP mem,H by);

/*-----------------------------------------------------------------------*/


 structure
 {
 H mode;
 H off;
 H chars;
 }
 _crlfdecoder;


/*-----------------------------------------------------------------------*/


 structure
 {
 H self_handle;
 H head,tail;
 _questatus status;
 H pages_allocated;
 H slots_allocated;
 HP pge_slot;
 B crlf_state;
 H line_peek_offset;
 H line_chars;
 }
 _aa_queobject;


 structure
 {
 B object_id;
 }
 _aa_quesystem;


 B aa_QueSystemStart                   (V);
 V aa_QueSystemStop                    (V);
 B aa_QueSystemExtendPageSlots         (PP mem,H by);

/*-----------------------------------------------------------------------*/

 #define aa_HUFF_HEAP_SIZE              ((sizeof(D)*257)+(((sizeof(VP)*4)+sizeof(D)+sizeof(H))*(257*3))+((sizeof(H)+sizeof(H))*257))


 struct _aahuff_node
 {
 struct _aahuff_node*lr[2];
 struct _aahuff_node*qprev;
 struct _aahuff_node*qnext;
 D prob;
 H c;
 };



 structure
 {
 H code;
 H bits;
 }
 _aahuff_enctable;


 V aa_huffmanWriteTreeAndMakeTable     (BP out,HP outbitctr,H outlen,_aahuff_enctable*et,H code,Y bits,struct _aahuff_node *t);
 B aa_huffmanReadTree                  (BP in,HP inbitctr,H inlen,BP *heapptr,BP heapend,struct _aahuff_node**hnptr);
 H aa_huffmanCompress                  (BP in,H inlen,BP out,H outlen,VP huffheap);
 H aa_huffmanDecompress                (BP in,H inlen,BP out,H outlen,VP huffheap,H hs);


/*-----------------------------------------------------------------------*/


 #define aa_LZ4_compressBound(isize)   (isize+(isize/255)+16)

 // MEMORY_USAGE :
 // Memory usage formula : N->2^N Bytes (examples : 10 -> 1KB; 12 -> 4KB ; 16 -> 64KB; 20 -> 1MB; etc.)
 // Increasing memory usage improves compression ratio
 // Reduced memory usage can improve speed, due to cache effect
 // Default value is 14, for 16KB, which nicely fits into Intel x86

 #define aa_LZ4_MEMORY_USAGE           14
 #define aa_LZ4_NOTCOMPRESSIBLE_DETLEV 6
 #define aa_LZ4_ARCH64                 0

 #define expect(expr,value)            (expr)
 #define likely(expr)                  expect((expr)!=0,1)
 #define unlikely(expr)                expect((expr)!=0,0)

 structure { u16 v; }                  aa_LZ4_U16_S;
 structure { u32 v; }                  aa_LZ4_U32_S;

 #define aa_LZ4_A32(x)                 (((aa_LZ4_U32_S *)(x))->v)
 #define aa_LZ4_A16(x)                 (((aa_LZ4_U16_S *)(x))->v)

 #define aa_LZ4_MINMATCH               4
 #define aa_LZ4_HASH_LOG               (aa_LZ4_MEMORY_USAGE-2)
 #define aa_LZ4_HASHTABLESIZE          (1<<aa_LZ4_HASH_LOG)
 #define aa_LZ4_HASH_MASK              (aa_LZ4_HASHTABLESIZE-1)

 #define aa_LZ4_SKIPSTRENGTH           (aa_LZ4_NOTCOMPRESSIBLE_DETLEV>2?aa_LZ4_NOTCOMPRESSIBLE_DETLEV:2)
 #define aa_LZ4_STACKLIMIT             13
 #define aa_LZ4_HEAPMODE               (aa_LZ4_HASH_LOG>aa_LZ4_STACKLIMIT)
 #define aa_LZ4_COPYLENGTH             8
 #define aa_LZ4_LASTLITERALS           5
 #define aa_LZ4_MFLIMIT                (aa_LZ4_COPYLENGTH+aa_LZ4_MINMATCH)
 #define aa_LZ4_MINLENGTH              (aa_LZ4_MFLIMIT+1)

 #define aa_LZ4_MAXD_LOG               16
 #define aa_LZ4_MAX_DISTANCE           ((1<<aa_LZ4_MAXD_LOG)-1)

 #define aa_LZ4_ML_BITS                4
 #define aa_LZ4_ML_MASK                ((1U<<aa_LZ4_ML_BITS)-1)
 #define aa_LZ4_RUN_BITS               (8-aa_LZ4_ML_BITS)
 #define aa_LZ4_RUN_MASK               ((1U<<aa_LZ4_RUN_BITS)-1)

 #define aa_LZ4_STEPSIZE               4
 #define aa_LZ4_UARCH                  u32
 #define aa_LZ4_AARCH                  aa_LZ4_A32
 #define aa_LZ4_COPYSTEP(s,d)	aa_LZ4_A32(d)=aa_LZ4_A32(s); d+=4; s+=4;
 #define aa_LZ4_COPYPACKET(s,d)	aa_LZ4_COPYSTEP(s,d); aa_LZ4_COPYSTEP(s,d);
 #define aa_LZ4_SECURECOPY	aa_LZ4_WILDCOPY
 #define aa_LZ4_INITBASE(base)         const int base=0

 #define aa_LZ4_READ_LE_16(d,s,p)      { d=(s)-aa_LZ4_A16(p); }
 #define aa_LZ4_WRITE_LE_16(p,v)       { aa_LZ4_A16(p)=v; p+=2; }

 #define aa_LZ4_HASH_FUNCTION(i)	(((i)*2654435761U)>>((aa_LZ4_MINMATCH*8)-aa_LZ4_HASH_LOG))
 #define aa_LZ4_HASH_VALUE(p)	aa_LZ4_HASH_FUNCTION(aa_LZ4_A32(p))
 #define aa_LZ4_WILDCOPY(s,d,e)	do { aa_LZ4_COPYPACKET(s,d) } while (d<e);
 #define aa_LZ4_BLINDCOPY(s,d,l)	{ BP e=(d)+l; aa_LZ4_WILDCOPY(s,d,e); d=e; }

 #define aa_LZ4_64KLIMIT               ((1<<16)+(aa_LZ4_MFLIMIT-1))
 #define aa_LZ4_HASHLOG64K             (aa_LZ4_HASH_LOG+1)
 #define aa_LZ4_HASH64KTABLESIZE       (1U<<aa_LZ4_HASHLOG64K)
 #define aa_LZ4_HASH64K_FUNCTION(i)	(((i)*2654435761U)>>((aa_LZ4_MINMATCH*8)-aa_LZ4_HASHLOG64K))
 #define aa_LZ4_HASH64K_VALUE(p)	aa_LZ4_HASH64K_FUNCTION(aa_LZ4_A32(p))


 Z aa_LZ4_compressCtx                  (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize);
 Z aa_LZ4_compress64kCtx               (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize);
 Z aa_LZ4_uncompressEx                 (VP source,VP dest,Z osize);


/*-----------------------------------------------------------------------*/

 Z aa_LZ4_compressCtx                  (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize)
 {
 BP HashTable[aa_LZ4_HASHTABLESIZE]={0};
 BP ip=(BP) source;
 aa_LZ4_INITBASE(base);
 BP anchor=ip;
 BP iend=ip+isize;
 BP mflimit=iend-aa_LZ4_MFLIMIT;
 BP op=(BP)dest;
 BP oend=op+maxOutputSize;
 BP forwardIp,ref,token;
 BP src,dst;
 Z step,findMatchAttempts,lastRun,len,length,skipStrength=aa_LZ4_SKIPSTRENGTH;
 u32 forwardH,h;

 src=(BP)source;
 dst=(BP)dest;
 if(isize<aa_LZ4_MINLENGTH) goto _last_literals;
 (V)ctx;
 HashTable[aa_LZ4_HASH_VALUE(ip)]=ip-base;
 ip++; forwardH=aa_LZ4_HASH_VALUE(ip);
 for(;;)
  {
  findMatchAttempts=(1U<<skipStrength)+3;
  forwardIp=ip;
  do
   {
   h=forwardH;
   step=findMatchAttempts++>>skipStrength;
   ip=forwardIp;
   forwardIp=ip+step;
   if unlikely(forwardIp>mflimit) { goto _last_literals; }
   forwardH=aa_LZ4_HASH_VALUE(forwardIp);
   ref=base+HashTable[h];
   HashTable[h]=ip-base;
   }
  while((ref<ip-aa_LZ4_MAX_DISTANCE)||(aa_LZ4_A32(ref)!=aa_LZ4_A32(ip)));
  while((ip>anchor)&&(ref>(BP)src)&&unlikely(ip[-1]==ref[-1])) { ip--; ref--; }
  length=ip-anchor;
  token=op++;
  if unlikely(op+length+(2+1+aa_LZ4_LASTLITERALS)+(length>>8)>=oend) return 0;
  if(length>=(Z)aa_LZ4_RUN_MASK)
   {
   *token=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   len=length-aa_LZ4_RUN_MASK;
   for(;len>254;len-=255) *op++=255;
   *op++=(B)len;
   }
  else *token=(length<<aa_LZ4_ML_BITS);
  aa_LZ4_BLINDCOPY(anchor,op,length);
_next_match:
 aa_LZ4_WRITE_LE_16(op,ip-ref);
 ip+=aa_LZ4_MINMATCH;ref+=aa_LZ4_MINMATCH;
 anchor=ip;
 while likely(ip<(iend-aa_LZ4_LASTLITERALS)-(aa_LZ4_STEPSIZE-1))
  {
  aa_LZ4_UARCH diff=aa_LZ4_AARCH(ref)^aa_LZ4_AARCH(ip);
  if(!diff) { ip+=aa_LZ4_STEPSIZE; ref+=aa_LZ4_STEPSIZE; continue; }
  ip+=(__builtin_ctz(diff)>>3);
  goto _endCount;
  }
 if(aa_LZ4_ARCH64)
  {
  if((ip<((iend-aa_LZ4_LASTLITERALS)-3))&&(aa_LZ4_A32(ref)==aa_LZ4_A32(ip))) { ip+=4; ref+=4; }
  }
 if((ip<((iend-aa_LZ4_LASTLITERALS)-1))&&(aa_LZ4_A16(ref)==aa_LZ4_A16(ip))) { ip+=2; ref+=2; }
 if((ip<(iend-aa_LZ4_LASTLITERALS))&&(*ref==*ip)) ip++;
 _endCount:
 len=(ip-anchor);
 if(len>=(Z)aa_LZ4_ML_MASK)
  {
  *token+=aa_LZ4_ML_MASK;
  len-=aa_LZ4_ML_MASK;
  for(;len>509; len-=510) { *op++=255; *op++=255; }
  if(len>254) { len-=255; *op++=255; }
  *op++=(B)len;
  }
 else *token+=len;
 if(ip>mflimit) { anchor=ip;  break; }
 HashTable[aa_LZ4_HASH_VALUE(ip-2)]=ip-2-base;
 ref=base+HashTable[aa_LZ4_HASH_VALUE(ip)];
 HashTable[aa_LZ4_HASH_VALUE(ip)]=ip-base;
 if((ref>ip-(aa_LZ4_MAX_DISTANCE+1))&&(aa_LZ4_A32(ref)==aa_LZ4_A32(ip))) { token=op++; *token=0;goto _next_match; }
 anchor=ip++;
 forwardH=aa_LZ4_HASH_VALUE(ip);
 }
 _last_literals:
  {
  lastRun=iend-anchor;
  if(((BP)op-dst)+lastRun+1+((lastRun-15)/255)>=maxOutputSize) return 0;
  if(lastRun>=(Z)aa_LZ4_RUN_MASK)
   {
   *op++=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   lastRun-=aa_LZ4_RUN_MASK;
   for(;lastRun>254;lastRun-=255) *op++=255;
   *op++=(B)lastRun;
   }
  else *op++=(lastRun<<aa_LZ4_ML_BITS);
  aaMemoryCopy(op,iend-anchor,anchor);
  //memcpy(op,anchor,iend-anchor);
  op+=iend-anchor;
  }
 return (Z)(((BP)op)-dst);
 }









 Z aa_LZ4_compress64kCtx               (PP ctx,VP source,VP dest,Z isize,Z maxOutputSize)
 {
 u16 HashTable[aa_LZ4_HASH64KTABLESIZE]={0};
 BP ip=(BP) source;
 BP anchor=ip;
 BP base=ip;
 BP iend=ip+isize;
 BP mflimit=iend-aa_LZ4_MFLIMIT;
 BP op=(BP)dest;
 BP oend=op+maxOutputSize;
 Z lastRun,step,len,length,findMatchAttempts,skipStrength=aa_LZ4_SKIPSTRENGTH;
 BP ref,token,forwardIp;
 BP src,dst;
 u32 forwardH,h;

 src=(BP)source;
 dst=(BP)dest;
 if(isize<aa_LZ4_MINLENGTH) goto _last_literals;
 (V)ctx;
 ip++; forwardH=aa_LZ4_HASH64K_VALUE(ip);
 for(;;)
  {
  findMatchAttempts=(1U<<skipStrength)+3;
  forwardIp=ip;
  do
   {
   h=forwardH;
   step=findMatchAttempts++>>skipStrength;
   ip=forwardIp;
   forwardIp=ip+step;
   if(forwardIp>mflimit) { goto _last_literals; }
   forwardH=aa_LZ4_HASH64K_VALUE(forwardIp);
   ref=base+HashTable[h];
   HashTable[h]=ip-base;
   }
  while(aa_LZ4_A32(ref)!=aa_LZ4_A32(ip));
  while((ip>anchor)&&(ref>(BP)src)&&(ip[-1]==ref[-1])) { ip--; ref--; }
  length=ip-anchor;
  token=op++;
  if unlikely(op+length+(2+1+aa_LZ4_LASTLITERALS)+(length>>8)>=oend) return 0;
  if(length>=(Z)aa_LZ4_RUN_MASK)
   {
   *token=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   len=length-aa_LZ4_RUN_MASK;
   for(; len>254; len-=255) *op++=255; *op++=(B)len;
   }
  else *token=(length<<aa_LZ4_ML_BITS);
  aa_LZ4_BLINDCOPY(anchor,op,length);
 _next_match:
  aa_LZ4_WRITE_LE_16(op,ip-ref);
  ip+=aa_LZ4_MINMATCH; ref+=aa_LZ4_MINMATCH;
  anchor=ip;
  while(ip<(iend-aa_LZ4_LASTLITERALS)-(aa_LZ4_STEPSIZE-1))
   {
   aa_LZ4_UARCH diff=aa_LZ4_AARCH(ref)^aa_LZ4_AARCH(ip);
   if(!diff) { ip+=aa_LZ4_STEPSIZE; ref+=aa_LZ4_STEPSIZE; continue; }
   ip+=(__builtin_ctz(diff)>>3);
   goto _endCount;
   }
  if(aa_LZ4_ARCH64)
   {
   if((ip<((iend-aa_LZ4_LASTLITERALS)-3))&&(aa_LZ4_A32(ref)==aa_LZ4_A32(ip))) { ip+=4; ref+=4; }
   }
  if((ip<((iend-aa_LZ4_LASTLITERALS)-1))&&(aa_LZ4_A16(ref)==aa_LZ4_A16(ip))) { ip+=2; ref+=2; }
  if((ip<(iend-aa_LZ4_LASTLITERALS))&&(*ref==*ip)) ip++;
 _endCount:
 len=(ip-anchor);
 if(len>=(Z)aa_LZ4_ML_MASK)
  {
  *token+=aa_LZ4_ML_MASK;
  len-=aa_LZ4_ML_MASK;
  for(; len>509; len-=510) { *op++=255; *op++=255; }
  if(len>254) { len-=255; *op++=255; }
  *op++=(B)len;
  }
 else *token+=len;
 if(ip>mflimit) { anchor=ip;  break; }
 HashTable[aa_LZ4_HASH64K_VALUE(ip-2)]=ip-2-base;
 ref=base+HashTable[aa_LZ4_HASH64K_VALUE(ip)];
 HashTable[aa_LZ4_HASH64K_VALUE(ip)]=ip-base;
 if(aa_LZ4_A32(ref)==aa_LZ4_A32(ip)) { token=op++; *token=0;goto _next_match; }
 anchor=ip++;
 forwardH=aa_LZ4_HASH64K_VALUE(ip);
 }
 _last_literals:
  {
  lastRun=iend-anchor;
  if(((BP)op-dst)+lastRun+1+((lastRun)>>8)>=maxOutputSize) return 0;
  if(lastRun>=(Z)aa_LZ4_RUN_MASK)
   {
   *op++=(aa_LZ4_RUN_MASK<<aa_LZ4_ML_BITS);
   lastRun-=aa_LZ4_RUN_MASK;
   for(; lastRun>254; lastRun-=255) *op++=255;
   *op++=(B)lastRun;
   }
  else *op++=(lastRun<<aa_LZ4_ML_BITS);
  aaMemoryCopy(op,iend-anchor,anchor);
  ///memcpy(op,anchor,iend-anchor);
  op+=iend-anchor;
  }
 return (Z)(((BP)op)-dst);
 }






 Z aa_LZ4_uncompressEx                 (VP source,VP dest,Z osize)
 {
 BP ip=(BP)source;
 BP op=(BP)dest;
 BP oend=op+osize;
 BP ref,cpy;
 B token;
 Z len,length,dec2;
 BP src,dst;
 size_t dec[]={0,3,2,3,0,0,0,0};

 src=(BP)source;
 dst=(BP)dest;
 while(1)
  {
  token=*ip++;
  if((length=(token>>aa_LZ4_ML_BITS))==aa_LZ4_RUN_MASK)  { for(;(len=*ip++)==255;length+=255){} length+=len; }
  cpy=op+length;
  if unlikely(cpy>oend-aa_LZ4_COPYLENGTH)
   {
   if(cpy>oend) goto _output_error;
   aaMemoryCopy(op,length,ip);
   //memcpy(op,ip,length);
   ip+=length;
   break;
   }
  aa_LZ4_WILDCOPY(ip,op,cpy); ip-=(op-cpy); op=cpy;
  aa_LZ4_READ_LE_16(ref,cpy,ip); ip+=2;
  if(ref<(BP)dst) goto _output_error;
  if((length=(token&aa_LZ4_ML_MASK))==aa_LZ4_ML_MASK) { for(;*ip==255;length+=255) {ip++;} length+=*ip++; }
  if unlikely(op-ref<aa_LZ4_STEPSIZE)
   {
   dec2=0;
   *op++=*ref++;  *op++=*ref++; *op++=*ref++; *op++=*ref++;
   ref-=dec[op-ref];
   aa_LZ4_A32(op)=aa_LZ4_A32(ref); op+=aa_LZ4_STEPSIZE-4;
   ref-=dec2;
   }
  else
   {
   aa_LZ4_COPYSTEP(ref,op);
   }
  cpy=op+length-(aa_LZ4_STEPSIZE-4);
  if(cpy>oend-aa_LZ4_COPYLENGTH)
   {
   if(cpy>oend) goto _output_error;
   aa_LZ4_SECURECOPY(ref,op,(oend-aa_LZ4_COPYLENGTH));
   while(op<cpy) *op++=*ref++;
   op=cpy;
   if(op==oend) break;
   continue;
   }
  aa_LZ4_SECURECOPY(ref,op,cpy);
  op=cpy;
  }
 return (Z)(((BP)ip)-src);
_output_error:
 return (Z)(-(((BP)ip)-src));
 }


/*-----------------------------------------------------------------------*/



 #define aa_MAX_GENERAL_QUES           8

 structure
 {
 H que_handle;
 H tik;
 H waiting;
 H counter;
 }
 _aa_generalevent_object;


 structure
 {
 _aa_generalevent_object object[aa_MAX_GENERAL_QUES];
 }
 _aa_generaleventsystem;


 B aa_GeneralEventSystemStart          (V);
 V aa_GeneralEventSystemStop           (V);

/*-----------------------------------------------------------------------*/

 B aa_Base64Char[64]=                  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

 C aa_chartype[128]=                   {
                                       // NUL SOH STX ETX EOT ENQ ACK BEL  BS  HT  LF  VT  FF  CR  SO  SI
                                           0 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 32, 32, 32, 32, 32, 1 , 1 ,
                                       // DLE DC1 DC2 DC3 DC4 NAK SYN ETB CAN  EM SUB ESC  FS  GS  RS  US
                                           1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
                                       // SP   !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
                                           32, 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 7 , 1 , 1 , 1 , 1 , 1 ,
                                       //  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
                                           9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 9 , 1 , 1 , 1 , 1 , 1 , 1 ,
                                       //  @   A   B   C   D   E   F   G   H   I   J   K   N   M   N   O
                                           1 , 1 , 1 , 1 , 19, 26, 77, 26, 51, 96, 1 , 1 , 48, 1 , 44, 66,
                                       //  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
                                           1 , 1 , 1 , 1 , 1 , 80, 1 , 1 , 30, 1 , 1 , 95, 1 , 95, 1 , 1 ,
                                       //  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
                                           1 , 1 , 1 , 98, 19, 26, 26, 26, 51, 96, 1 , 1 , 22, 1 , 11,66 ,
                                       //  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~  DEL
                                           59, 1 , 1 , 4 , 1 , 80, 1 , 1 , 30, 1 , 1 , 1 , 1 , 1 , 1 , 1 ,
                                       };




/*-----------------------------------------------------------------------*/

 #define aa_NET_RECENT_FREQ            1.0
 #define aa_NET_CLIENT_CALL_MAXEXTRA   _512K
 #define aa_NET_CGI_CLIENT_MAXBUF      _8K
 #define aa_NET_SOMAXCONN              1024
 #define aa_NET_MAX_TCP_CALLS          _64K
 #define aa_NET_MAX_TCP_PORTS          _2K


 S CP aa_mime_type[64][2]=
 {
 { "c",    "text/x-csrc" },
 { "c++",  "text/x-c++src" },
 { "cpp",  "text/x-c++src" },
 { "h",    "text/x-chdr" },
 { "hpp",  "text/x-chdr" },
 { "html", "text/html" },
 { "htm",  "text/html" },
 { "js",   "application/javascript" },
 { "shtml","text/html" },
 { "css",  "text/css" },
 { "txt",  "text/plain" },
 { "pl",   "text/plain" },
 { "php",  "text/html" },
 { "mdb",  "application/msaccess" },
 { "xls",  "application/msexcel" },
 { "doc",  "application/msword" },
 { "bin",  "application/octet-stream" },
 { "exe",  "application/octet-stream" },
 { "ogg",  "application/ogg" },
 { "pdf",  "application/pdf" },
 { "rtf",  "application/rtf" },
 { "tgz",  "application/x-compressed" },
 { "gz",   "application/x-compressed" },
 { "z",    "application/x-compress" },
 { "swf",  "application/x-shockwave-flash" },
 { "tar",  "application/x-tar" },
 { "rar",  "application/x-rar-compressed" },
 { "zip",  "application/x-zip-compressed" },
 { "xml",  "application/xml" },
 { "ra",   "audio/x-pn-realaudio" },
 { "ram",  "audio/x-pn-realaudio" },
 { "wav",  "audio/x-wav" },
 { "bmp",  "image/bmp"},
 { "tif",  "image/tiff"},
 { "tiff", "image/tiff"},
 { "gif",  "image/gif" },
 { "jpeg", "image/jpeg" },
 { "jpe",  "image/jpeg" },
 { "jpg",  "image/jpeg" },
 { "png",  "image/png" },
 { "ico",  "image/x-icon" },
 { "wav",  "audio/x-wav"},
 { "mid",  "audio/mid"},
 { "aif",  "audio/x-aif"},
 { "aiff", "audio/x-aiff"},
 { "avi",  "video/avi" },
 { "mp3",  "video/mpeg" },
 { "mpeg", "video/mpeg" },
 { "mpg",  "video/mpeg" },
 { "flv",  "video/x-flv" },
 { "avi",  "video/x-msvideo" },
 { "qt",   "video/quicktime" },
 { "mov",  "video/quicktime" },
 { "",     "" }
 };


/*-----------------------------------------------------------------------*/


 #ifndef SO_EXCLUSIVEADDRUSE
 #define SO_EXCLUSIVEADDRUSE           ((Z)(~SO_REUSEADDR))
 #endif


 #define T_A                           1
 #define T_NS                          2
 #define T_CNAME                       5
 #define T_SOA                         6
 #define T_WKS                         11
 #define T_PTR                         12
 #define T_MX                          15
 #define T_TXT                         16
 #define T_ALL                         255


 structure
 {
 u16 id;
 u8 rd     :1;
 u8 tc     :1;
 u8 aa     :1;
 u8 opcode :4;
 u8 qr     :1;
 u8 rcode  :4;
 u8 cd     :1;
 u8 ad     :1;
 u8 z      :1;
 u8 ra     :1;
 u16 q_count;
 u16 ans_count;
 u16 auth_count;
 u16 add_count;
 }
 _DNS_HEADER;


 structure
 {
 u16 qtype;
 u16 qclass;
 }
 _DNS_QUESTION;


 structure
 {
 u16 type;
 u16 _class;
 u32 ttl;
 u16 data_len;
 }
 _DNS_R_DATA;



 structure
 {
 B name[_1K];
 _DNS_R_DATA*resource;
 H rdata_off;
 B rdata[_1K];
 Z pref;
 }
 _DNS_RES_RECORD;



 structure
 {
 B mname[_1K];
 B rname[_1K];
 H serial;
 H refresh;
 H retry;
 H expire;
 H minimum;
 }
 _DNS_SOA;




 structure
 {
 H self_handle;
 H stage;
 HANDLE resolver_handle;
 B host_ent[MAXGETHOSTSTRUCT];
 _dnsstatus status;
 _udpunit udp;
 _udppkt o_pkt;
 _udppkt i_pkt;
 H ms_tik;
 W id_match;
 _timer tm;
 H timeout;
 B buf[65536];
 B dnsName[_1K];
 H dnsName_sl;
 H outlen;
 _DNS_RES_RECORD answers[20],auth[20],addit[20];
 }
 _aa_netdnsobject;



 structure
 {
 H self_handle;
 _sniffstatus status;
 H rcve_que;
 SOCKET sock;
 H ms_root;
 H inactive_ms_root;
 H calc_timer_cycle;
 }
 _aa_netsniffobject;





 structure
 {
 H self_handle;
 _icmpstatus status;
 H rcve_que;
 H xmit_que;
 SOCKET sock;
 H ms_root;
 H inactive_ms_root;
 ///////
 H calc_timer_cycle;
 }
 _aa_neticmpobject;



 structure
 {
 H self_handle;
 _udpstatus status;
 H rcve_que;
 H xmit_que;
 SOCKET sock;
 H ms_root;
 H cycle;
 H inactive_ms_root;
 H rcve_pkts_total_recent;
 H xmit_pkts_total_recent;
 H rcve_bytes_total_recent;
 H xmit_bytes_total_recent;
 H rcve_pkts_total_previous;
 H xmit_pkts_total_previous;
 H rcve_bytes_total_previous;
 H xmit_bytes_total_previous;
 _profiler recent_profiler;
 _profiler xmit_profiler;
 _profiler xmit_profiler_direct;
 H last_total_pkts_sent;
 H calc_timer_cycle;
 H sub_tik;
 B user_data[256];
 }
 _aa_netudpobject;



 structure
 {
 H self_handle;
 H stage;
 _stunclientstatus status;
 H root_ms;
 H attempt;
 _netrtt rtt;
 H test_num;
 B tid[16];
 H udp_handle;
 B is_udp_created;
 }
 _aa_netstunclientobject;





 structure
 {
 H self_handle;
 B socket_used;
 SOCKET sock;
 _tcpportstatus status;
 H next_call_counter;
 H manage_iterator;
 }
 _aa_nettcpportobject;






 structure
 {
 H self_handle;
 B socket_used;
 B is_shutdown;
 B is_dns;
 H dns_handle;
 SOCKET sock;
 SOCKET port_sock;
 H xmit_que;
 H rcve_que;
 H ms_root;
 H inactive_rcve_ms_root;
 H inactive_xmit_ms_root;
 H local_closed_ms_root;
 H remote_closed_ms_root;
 B user_data[256];
 _tcpcallstatus status;
 B crlf_state;
 H line_peek_offset;
 H line_chars;
 B is_rcve_backoff;
 B is_xmit_backoff;
 B is_xmit_slowdown;
 B system_data[256];
 }
 _aa_nettcpcallobject;



 structure
 {
 Y syn:1;
 Y ack:1;
 Y eak:1;
 Y rst:1;
 Y nul:1;
 Y chk:1;
 Y tcs:1;
 Y zer:1;
 Y hlen:8;
 B seq_num;
 B ack_num;
 W crc;
 }
 _aa_netrudpheader;



 structure
 {
 Y csrc_count:4;
 Y extension:1;
 Y padding:1;
 Y version:2;
 Y type:7;
 Y marker:1;
 W seq;
 H timestamp;
 H ssrc;
 }
 _aa_netrtpheader;




 structure
 {
 B vihl;
 B tos;
 I totlen;
 I id;
 I flagoff;
 B ttl;
 B protocol;
 W checksum;
 struct in_addr src_ip;
 struct in_addr dst_ip;
 }
 _aa_netipheader;



 structure
 {
 B type;
 B code;
 W crc;
 W id;
 W seq;
 }
 _aa_neticmpheader;



 structure
 {
 B is_open;
 HINSTANCE module_handle;
 H (WINAPI*GetTcpTable) (MIB_TCPTABLE*pTcpTable,PDWORD dwsize,BOOL order);
 H (WINAPI*GetUdpTable) (MIB_UDPTABLE*pTcpTable,PDWORD dwsize,BOOL order);
 _netportlist list;
 H u_len;
 H t_len;
 BP mem;
 }
 _aa_netportlist;



 structure
 {
 H self_handle;
 _cgiclientstatus status;
 PROCESS_INFORMATION pi;
 STARTUPINFO si;
 B is_running;
 _threadunit thread;
 H obj_handle;
 HANDLE out_read;
 HANDLE in_write;
 HANDLE std_input;
 HANDLE err_handle;
 H tid;
 _queunit c2s_que;
 _queunit s2c_que;
 H ms_root;
 H inactive_rcve_ms_root;
 H inactive_xmit_ms_root;
 H inactive_line_ms_root;
 H tmp_cy;
 }
 _aa_netcgiclientobject;



 structure
 {
 H self_handle;
 _serverstatus status;
 }
 _aa_netserverobject;


 structure
 {
 H self_handle;
 H phaze;
 H ms_root;
 _wockstatus status;
 Q msr;//cyc;
 B sec_key[257];
 B out_key[257];
 _queunit xmit_que;
 _queunit rcve_que;
 B is_fin;
 B is_mask;
 B opcode;
 H mask;
 H size_bytes;
 H pkt_bytes;
 H mask_offset;
 H data_offset;
 H data_bytes;
 H pkt_done;
 H xmit_done;
 H xmit_bytes;
 }
 _aa_netwockobject;




 structure
 {
 WSADATA ws_data;
 H sniff_message_id;
 H icmp_message_id;
 H dns_message_id;
 H tcp_message_id;
 C class_name[257];
 WNDCLASSEX class_data;
 HWND window;
 B dns_object_id;
 B sniff_object_id;
 B icmp_object_id;
 B udp_object_id;
 B stunclient_object_id;
 B tcpport_object_id;
 B tcpcall_object_id;
 B client_object_id;
 B cgiclient_object_id;
 B server_object_id;
 B wock_object_id;
 H next_public_ip_counter;
 H next_tcpcall_counter;
 H next_clientcall_counter;
 H yield_tcpcall_counter;
 H yield_udp_counter;
 //H yield_tcpport_counter;
 B local_email_checked;
 B local_email_count;
 B local_email[4][65];
 _netstatus net_status;
 _udppkt tmp_udp_pkt;
 B tmpbuf[70000];
 _aa_netportlist port_list;
 H sub_yield_tik[3];
 }
 _aa_netsystem;



 B aa_NetSystemStart                   (V);
 V aa_NetSystemStop                    (V);
 B aa_NetSystemLocalEmailCheck         (V);
 B aa_NetSystemResolveIpPortPair       (SOCKET sock,HP locip,WP locport,HP remip,WP remport);
 B aa_NetSystemFindDnsByResolverHandle (HP handle,PP mem,HANDLE resolverhandle);
 B aa_NetSystemFindSniffBySock         (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFindIcmpBySock          (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFindPortBySock          (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFSystemFindCallBySock   (HP handle,PP mem,SOCKET sock,B mustbeincall,B mustbeoutcall);
 B aa_NetSystemFindCallByPortSock      (HP handle,PP mem,SOCKET sock);
 B aa_NetSystemFindUdpByAddress        (HP handle,PP mem,H ip,W port);
 B aa_NetSystemLocalHostGet            (HP localip,H count);
 B aa_NetSystemTcpCallCreate           (HP handle,H ip,W port,H sip,W sport);
 B aa_NetSystemNextTcpCall             (HP handle,PP ptr,W matchport,HP iterationcounter);
 B aa_NetSystemProcessTcp              (PP mem);
 B aa_NetSystemCalculateUdpTimers      (PP mem);
 B aa_NetSystemProcessUdp              (PP mem);
 B aa_NetSystemProcessSniff            (PP mem);
 B aa_NetSystemProcessIcmp             (PP mem,B doread,B dowrite);
 K aa_NetSystemProc                    (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm);
 B aa_NetSystemYield                   (V);
 B aa_NetCgiClientUpdate               (H handle);
 H aa_NetCgiClientThread               (VP parm);
 B aa_NetCgiClientPseudoThread         (H handle);
 V aa_NetDnsYield                      (PP mem);
 V aa_NetDnsFromFormat                 (VP outhost);
 V aa_NetDnsToFormat                   (VP outdns);
 V aa_NetDnsReadName                   (BP reader,BP buffer,ZP count,BP name);


/*-----------------------------------------------------------------------*/


 B aa_fontdos[2048]=
 {
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3c,0x42,0xa5,0x81,0xa5,0x99,0x42,0x3c,0x3c,0x7e,0xdb,0xff,0xdb,0xe7,0x7e,0x3c,0x6c,0xfe,0xfe,0xfe,0x7c,0x38,0x10,0x00,
 0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x38,0x38,0xd6,0xfe,0xd6,0x10,0x38,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x10,0x38,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,
 0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0xf0,0xc0,0xa0,0x9e,0x1b,0x1b,0x0e,0x00,
 0x3c,0x66,0x66,0x3c,0x18,0x7e,0x18,0x00,0x10,0x30,0x70,0x50,0x10,0x18,0x1c,0x0c,0xfc,0x84,0xfc,0x84,0xc4,0xe6,0x67,0x03,0x10,0xd6,0x38,0xee,0x38,0xd6,0x10,0x00,
 0x01,0x07,0x1f,0x7f,0x1f,0x07,0x01,0x00,0x80,0xe0,0xf8,0xfe,0xf8,0xe0,0x80,0x00,0x10,0x38,0x7c,0x10,0x7c,0x38,0x10,0x00,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x00,
 0xfe,0xdb,0xdb,0xde,0xd8,0xd8,0xd8,0x00,0x7c,0xc6,0x1c,0x64,0x4c,0x70,0xc6,0x7c,0x00,0x00,0x00,0x00,0x7e,0x7e,0x7e,0x00,0x18,0x3c,0x7e,0x18,0x7e,0x3c,0x18,0x7e,
 0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x20,0x60,0xfe,0x60,0x20,0x00,0x00,0x00,0x08,0x0c,0xfe,0x0c,0x08,0x00,0x00,
 0x00,0x00,0x06,0x06,0x06,0xfe,0x00,0x00,0x00,0x24,0x66,0xff,0x66,0x24,0x00,0x00,0x00,0x00,0x10,0x38,0x7c,0xfe,0x00,0x00,0x00,0x00,0xfe,0x7c,0x38,0x10,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x18,0x00,0x18,0x00,0x6c,0x6c,0x6c,0x00,0x00,0x00,0x00,0x00,0x6c,0x6c,0xfe,0x6c,0xfe,0x6c,0x6c,0x00,
 0x10,0x7c,0x16,0x7c,0xd0,0x7c,0x10,0x00,0x86,0xc6,0x60,0x30,0x18,0xcc,0xc6,0x00,0x38,0x6c,0x38,0x9c,0x76,0x66,0xdc,0x00,0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,
 0x30,0x18,0x0c,0x0c,0x0c,0x18,0x30,0x00,0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00,0x00,0x24,0x18,0x7e,0x18,0x24,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x0c,0x00,0x00,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x80,0xc0,0x60,0x30,0x18,0x0c,0x06,0x00,
 0x7c,0xc6,0xd6,0xd6,0xd6,0xc6,0x7c,0x00,0x30,0x38,0x3c,0x30,0x30,0x30,0xfc,0x00,0x3c,0x66,0x60,0x30,0x18,0x0c,0x7e,0x00,0x3c,0x66,0x60,0x38,0x60,0x66,0x3c,0x00,
 0x60,0x70,0x78,0x6c,0xfe,0x60,0x60,0x00,0xfe,0x06,0x7e,0xc0,0xc0,0xc6,0x7c,0x00,0x78,0x0c,0x06,0x7e,0xc6,0xc6,0x7c,0x00,0xfe,0xc6,0x60,0x30,0x18,0x18,0x18,0x00,
 0x7c,0xc6,0xc6,0x7c,0xc6,0xc6,0x7c,0x00,0x7c,0xc6,0xc6,0xfc,0xc0,0x60,0x3c,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x0c,
 0x60,0x30,0x18,0x0c,0x18,0x30,0x60,0x00,0x00,0x00,0x7e,0x00,0x00,0x7e,0x00,0x00,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x00,0x3c,0x66,0x30,0x18,0x18,0x00,0x18,0x00,
 0x7c,0xc6,0xf6,0xf6,0xf6,0x06,0xfc,0x00,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0x00,0x7e,0xc6,0xc6,0x7e,0xc6,0xc6,0x7e,0x00,0x7c,0xc6,0x06,0x06,0x06,0xc6,0x7c,0x00,
 0x3e,0x66,0xc6,0xc6,0xc6,0x66,0x3e,0x00,0x7e,0x06,0x06,0x3e,0x06,0x06,0x7e,0x00,0x7e,0x06,0x06,0x3e,0x06,0x06,0x06,0x00,0x7c,0xc6,0x06,0xf6,0xc6,0xc6,0xfc,0x00,
 0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x7e,0x18,0x18,0x18,0x18,0x18,0x7e,0x00,0xf0,0x60,0x60,0x60,0x60,0x66,0x3c,0x00,0xc6,0x66,0x36,0x1e,0x36,0x66,0xc6,0x00,
 0x06,0x06,0x06,0x06,0x06,0x06,0xfe,0x00,0xc6,0xee,0xfe,0xd6,0xd6,0xc6,0xc6,0x00,0xc6,0xce,0xde,0xf6,0xe6,0xc6,0xc6,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,
 0x7e,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x00,0x7c,0xc6,0xc6,0xc6,0xb6,0x66,0xdc,0x00,0x7e,0xc6,0xc6,0x7e,0x36,0x66,0xc6,0x00,0x7c,0xc6,0x06,0x7c,0xc0,0xc6,0x7c,0x00,
 0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0xc6,0xc6,0xc6,0x6c,0x6c,0x38,0x38,0x00,0xc6,0xc6,0xd6,0xd6,0xfe,0xee,0xc6,0x00,
 0xc6,0xc6,0x6c,0x38,0x6c,0xc6,0xc6,0x00,0xc3,0xc3,0x66,0x3c,0x18,0x18,0x18,0x00,0xfe,0xc0,0x60,0x38,0x0c,0x06,0xfe,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00,
 0x03,0x06,0x0c,0x18,0x30,0x60,0xc0,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x3c,0x00,0x18,0x3c,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,
 0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x06,0x06,0x76,0xce,0xc6,0xce,0x76,0x00,0x00,0x00,0x7c,0xc6,0x06,0xc6,0x7c,0x00,
 0xc0,0xc0,0xdc,0xe6,0xc6,0xe6,0xdc,0x00,0x00,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x70,0xd8,0x18,0x7c,0x18,0x18,0x18,0x00,0x00,0x00,0xdc,0xe6,0xe6,0xdc,0xc0,0x7c,
 0x06,0x06,0x76,0xce,0xc6,0xc6,0xc6,0x00,0x18,0x00,0x1c,0x18,0x18,0x18,0x3c,0x00,0x60,0x00,0x70,0x60,0x60,0x60,0x66,0x3c,0x0c,0x0c,0xcc,0x6c,0x3c,0x6c,0xcc,0x00,
 0x1c,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x6e,0xd6,0xd6,0xd6,0xd6,0x00,0x00,0x00,0x76,0xce,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,
 0x00,0x00,0x76,0xce,0xce,0x76,0x06,0x06,0x00,0x00,0xdc,0xe6,0xe6,0xdc,0xc0,0xc0,0x00,0x00,0xf6,0x0e,0x06,0x06,0x06,0x00,0x00,0x00,0xfc,0x06,0x7c,0xc0,0x7e,0x00,
 0x18,0x18,0x7c,0x18,0x18,0xd8,0x70,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xe6,0xdc,0x00,0x00,0x00,0xc6,0xc6,0x6c,0x6c,0x38,0x00,0x00,0x00,0xc6,0xd6,0xd6,0xee,0x44,0x00,
 0x00,0x00,0xc6,0x6c,0x38,0x6c,0xc6,0x00,0x00,0x00,0xc6,0xc6,0xe6,0xdc,0xc0,0x7c,0x00,0x00,0xfc,0x60,0x30,0x18,0xfc,0x00,0x70,0x18,0x18,0x0e,0x18,0x18,0x70,0x00,
 0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00,0x0e,0x18,0x18,0x70,0x18,0x18,0x0e,0x00,0xdc,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0x00,0x00,
 0x78,0xcc,0x06,0x06,0xcc,0x38,0x60,0x38,0x6c,0x00,0xc6,0xc6,0xc6,0xe6,0xdc,0x00,0xf0,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x7c,0x82,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,
 0x6c,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x1e,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x38,0x28,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0x00,0x00,0x7c,0x06,0x06,0x7c,0x30,0x18,
 0x7c,0x82,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x6c,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x1e,0x00,0x7c,0xc6,0xfe,0x06,0xfc,0x00,0x6c,0x00,0x38,0x30,0x30,0x30,0x78,0x00,
 0x7c,0xc6,0x38,0x30,0x30,0x30,0x78,0x00,0x1c,0x00,0x38,0x30,0x30,0x30,0x78,0x00,0xc6,0x38,0x6c,0xc6,0xfe,0xc6,0xc6,0x00,0x38,0x6c,0x38,0x6c,0xc6,0xfe,0xc6,0x00,
 0xf0,0x00,0xfc,0x0c,0x7c,0x0c,0xfc,0x00,0x00,0x00,0x76,0xd8,0xfe,0x1b,0xfe,0x00,0xf8,0x3c,0x36,0xfe,0x36,0x36,0xf6,0x00,0x7c,0x82,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,
 0x6c,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,0x1e,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,0x7c,0x82,0x00,0xc6,0xc6,0xe6,0xdc,0x00,0x1e,0x00,0xc6,0xc6,0xc6,0xe6,0xdc,0x00,
 0x6c,0x00,0xc6,0xc6,0xe6,0xdc,0xc0,0x7c,0xc6,0x7c,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x6c,0x00,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x30,0x30,0xfc,0x06,0x06,0xfc,0x30,0x30,
 0x38,0x6c,0x0c,0x1e,0x0c,0xce,0x7e,0x00,0x66,0x66,0x3c,0x18,0x7e,0x18,0x7e,0x18,0x3e,0x66,0x66,0x1e,0x66,0xf6,0x66,0xe6,0x70,0xd8,0x18,0x7c,0x18,0x18,0x1b,0x0e,
 0xf0,0x00,0x7c,0xc0,0xfc,0xc6,0xfc,0x00,0xf0,0x00,0x38,0x30,0x30,0x30,0x78,0x00,0xf0,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0x00,0xf0,0x00,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,
 0xdc,0x76,0x00,0x76,0xce,0xc6,0xc6,0x00,0xdc,0x76,0xce,0xde,0xf6,0xe6,0xc6,0x00,0x3c,0x36,0x36,0x6c,0x00,0x7e,0x00,0x00,0x3c,0x66,0x66,0x3c,0x00,0x7e,0x00,0x00,
 0x18,0x00,0x18/0x18,0x0c,0x66,0x3c,0x00,0x00,0x00,0x00,0x7e,0x06,0x06,0x00,0x00,0x00,0x00,0x00,0x7e,0x60,0x60,0x00,0x00,0xc3,0x63,0x33,0x1b,0x6c,0xc6,0x63,0xf0,
 0xc3,0x63,0x33,0xdb,0xec,0xf6,0xfb,0xc0,0x18,0x00,0x18,0x18,0x3c,0x3c,0x18,0x00,0x00,0xd8,0x6c,0x36,0x6c,0xd8,0x00,0x00,0x00,0x36,0x6c,0xd8,0x6c,0x36,0x00,0x00,
 0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xbb,0xee,0xbb,0xee,0xbb,0xee,0xbb,0xee,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
 0x10,0x10,0x10,0x1f,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x10,0x1f,0x10,0x10,0x10,0x28,0x28,0x28,0x2f,0x28,0x28,0x28,0x28,0x00,0x00,0x00,0x3f,0x28,0x28,0x28,0x28,
 0x00,0x00,0x1f,0x10,0x1f,0x10,0x10,0x10,0x28,0x28,0x2f,0x20,0x2f,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x00,0x00,0x3f,0x20,0x2f,0x28,0x28,0x28,
 0x28,0x28,0x2f,0x20,0x3f,0x00,0x00,0x00,0x28,0x28,0x28,0x3f,0x00,0x00,0x00,0x00,0x10,0x10,0x1f,0x10,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x10,0x10,0x10,0x10,
 0x10,0x10,0x10,0xf0,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,0x10,0x10,0x10,0x10,
 0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,0x10,0xf0,0x10,0x10,0x10,0x28,0x28,0x28,0xe8,0x28,0x28,0x28,0x28,
 0x28,0x28,0xe8,0x08,0xf8,0x00,0x00,0x00,0x00,0x00,0xf8,0x08,0xe8,0x28,0x28,0x28,0x28,0x28,0xef,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xef,0x28,0x28,0x28,
 0x28,0x28,0xe8,0x08,0xe8,0x28,0x28,0x28,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x28,0x28,0xef,0x00,0xef,0x28,0x28,0x28,0x10,0x10,0xff,0x00,0xff,0x00,0x00,0x00,
 0x28,0x28,0x28,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x10,0x10,0x10,0x00,0x00,0x00,0xff,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xf8,0x00,0x00,0x00,0x00,
 0x10,0x10,0xf0,0x10,0xf0,0x00,0x00,0x00,0x00,0x00,0xf0,0x10,0xf0,0x10,0x10,0x10,0x00,0x00,0x00,0xf8,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xff,0x28,0x28,0x28,0x28,
 0x10,0x10,0xff,0x10,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x10,0x10,0x10,0x10,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
 0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
 0x00,0x00,0xdc,0x56,0x26,0x56,0xdc,0x00,0x78,0xcc,0x6c,0xcc,0xcc,0xcc,0x6c,0x0c,0xfe,0xc6,0x06,0x06,0x06,0x06,0x06,0x00,0x00,0xfc,0xfe,0x48,0x48,0x4c,0xc6,0x00,
 0xfe,0x8c,0x18,0x30,0x18,0x8c,0xfe,0x00,0x00,0x00,0xfc,0x26,0x66,0x66,0x3c,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xdc,0x6c,0x06,0x00,0x00,0xfc,0x36,0x30,0x30,0x30,0x00,
 0x38,0x10,0x7c,0xc6,0x7c,0x10,0x38,0x00,0x38,0x6c,0xc6,0xfe,0xc6,0x6c,0x38,0x00,0x38,0x6c,0xc6,0xc6,0x6c,0x6c,0xee,0x00,0x70,0x18,0x30,0x78,0xcc,0xcc,0x78,0x00,
 0x00,0x6e,0xdd,0x99,0xbb,0x76,0x00,0x00,0x60,0x20,0x7c,0xd6,0xd6,0x7c,0x08,0x0c,0xf0,0x18,0x0c,0xfc,0x0c,0x18,0xf0,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,
 0x00,0x7e,0x00,0x7e,0x00,0x7e,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x7e,0x00,0x0e,0x38,0xe0,0x38,0x0e,0x00,0xfe,0x00,0xe0,0x38,0x0e,0x38,0xe0,0x00,0xfe,0x00,
 0x70,0xd8,0xd8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1b,0x1b,0x0e,0x18,0x18,0x00,0x7e,0x00,0x18,0x18,0x00,0x00,0xdc,0x76,0x00,0xdc,0x76,0x00,0x00,
 0x3c,0x66,0x66,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0xf0,0x30,0x30,0x30,0x36,0x3c,0x38,0x30,
 0x36,0x6e,0x66,0x66,0x66,0x00,0x00,0x00,0x3c,0x66,0x38,0x0c,0x7e,0x00,0x00,0x00,0x00,0x00,0x3c,0x3c,0x3c,0x3c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 };




 structure
 {
 W maj_ver,min_ver;
 W num_tables;
 W search_range;
 W entry_selector;
 W range_shift;
 }
 _aa_ttfoffsettable;


 structure
 {
 C tag[4];
 H crc,off,len;
 }
 _aa_ttftabledirectory;


 structure
 {
 W selector;
 W count;
 W offset;
 }
 _aa_ttfnametableheader;


 structure
 {
 W platform_id,encoding_id,lang_id,name_id;
 W str_len,str_off;
 }
 _aa_ttfnamerecord;



 structure
 {
 H self_handle;
 _fontstatus status;
 I char_lead[256];
 I char_width[256];
 I char_gap[256];
 BP img;
 }
 _aa_fontobject;


 structure
 {
 B object_id;
 H font_4x8;
 H font_4x16;
 H font_8x8;
 H font_8x16;
 H font_8x32;
 H font_16x16;
 H font_16x32;
 }
 _aa_fontsystem;



 H font_4x8=0;
 H font_4x16=0;
 H font_8x8=0;
 H font_8x16=0;
 H font_8x32=0;
 H font_16x16=0;
 H font_16x32=0;


 K aa_FontCallBack                     (ENUMLOGFONT FAR*lpelf,NEWTEXTMETRIC FAR*lpntm,Z FontType,LPARAM lParam);
 B aa_FontSystemStart                  (V);
 V aa_FontSystemStop                   (V);

/*-----------------------------------------------------------------------*/

 #define DISPLAY_DEVICE_ACTIVE         0x00000001
 #define DISPLAY_DEVICE_ATTACHED       0x00000002
 #define DIGCF_PRESENT	             0x00000002
 #define DICS_FLAG_GLOBAL              1
 #define DIREG_DEV                     0x00000001
 #define NAME_SIZE                     200


 structure
 {
 DWORD cbSize;
 GUID  ClassGuid;
 DWORD DevInst;
 ULONG_PTR Reserved;
 }
 SP_DEVINFO_DATA;


 structure
 {
 DWORD cbSize;
 GUID  InterfaceClassGuid;
 DWORD Flags;
 ULONG_PTR Reserved;
 }
 SP_DEVICE_INTERFACE_DATA;


 DLL_IMPORT BOOL WINAPI                SetupDiEnumDeviceInfo(VP,DWORD,SP_DEVINFO_DATA*);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsA(GUID*,PCSTR,HWND,DWORD);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsW(GUID*,PCWSTR,HWND,DWORD);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsExA(GUID*,PCSTR,HWND,DWORD,VP,PCSTR,PVOID);
 DLL_IMPORT VP   WINAPI                SetupDiGetClassDevsExW(GUID*,PCWSTR,HWND,DWORD,VP,PCWSTR,PVOID);
 DLL_IMPORT HKEY WINAPI                SetupDiOpenDeviceInterfaceRegKey(VP,SP_DEVICE_INTERFACE_DATA*,DWORD,REGSAM);
 DLL_IMPORT HKEY WINAPI                SetupDiOpenDevRegKey(VP,SP_DEVINFO_DATA*,DWORD,DWORD,DWORD,REGSAM);
 DLL_IMPORT BOOL WINAPI                SetupDiDestroyDeviceInfoList(VP);

 GUID GUID_CLASS_MONITOR               ={0x4d36e96e,0xe325,0x11ce,{0xbf,0xc1,0x08,0x00,0x2b,0xe1,0x03,0x18}};



 #define CTLCODE(dtype,func,meth,acs)  (((dtype)<<16)|((acs)<<14)|((func)<<2)|(meth))
 #define IOVIDSET_DISPLAY_BRIGHT       CTLCODE(0x00000023,0x127,0,0)
 #define IOVIDQRY_DISPLAY_BRIGHT       CTLCODE(0x00000023,0x126,0,0)
 #define IOVIDQRY_SUPPORTED_BRIGHT     CTLCODE(0x00000023,0x125,0,0)

 T BOOL   (WINAPI *getDeviceGammaRamp) (HDC hDC,LPVOID lpRamp);
 T BOOL   (WINAPI *setDeviceGammaRamp) (HDC hDC,LPVOID lpRamp);


 structure
 {
 B is_revert;
// _displayinfo launch_display_info;
 HANDLE gdi32_module;
 getDeviceGammaRamp GetDeviceGammaRamp;
 setDeviceGammaRamp SetDeviceGammaRamp;
 }
 _aa_displaysystem;

 B aa_DisplaySystemStart               (V);
 V aa_DisplaySystemStop                (V);
 B aa_DisplaySystemLoadModules         (V);

 B aa_DisplayGetMonitorSizeFromEDID    (HKEY hDevRegKey,WP WidthMm,WP HeightMm);
 B aa_DisplayGetSizeForDevID           (CP TargetDevID,WP WidthMm,WP HeightMm);

/*-----------------------------------------------------------------------*/

 E { PNG_BADFORMAT,PNG_RGB8,PNG_RGB16,PNG_RGBA8,PNG_RGBA16,PNG_LUMINANCE1,PNG_LUMINANCE2,PNG_LUMINANCE4,
     PNG_LUMINANCE8,PNG_LUMINANCE_ALPHA1,PNG_LUMINANCE_ALPHA2,PNG_LUMINANCE_ALPHA4,PNG_LUMINANCE_ALPHA8 };
 E { PNG_ERROR=-1,PNG_DECODED=0,PNG_HEADER=1,PNG_NEW=2};
 E { PNG_LUM=0,PNG_RGB=2,PNG_LUMA=4,PNG_RGBA=6};

 #define PNG_MAKE_BYTE(b)              ((b)&0xFF)
 #define PNG_MAKE_DWORD(a,b,c,d)       ((PNG_MAKE_BYTE(a)<<24)|(PNG_MAKE_BYTE(b)<<16)|(PNG_MAKE_BYTE(c)<<8)|PNG_MAKE_BYTE(d))
 #define PNG_MAKE_DWORD_PTR(p)         PNG_MAKE_DWORD((p)[0],(p)[1],(p)[2],(p)[3])
 #define PNG_CHUNK_IHDR                PNG_MAKE_DWORD('I','H','D','R')
 #define PNG_CHUNK_IDAT                PNG_MAKE_DWORD('I','D','A','T')
 #define PNG_CHUNK_IEND                PNG_MAKE_DWORD('I','E','N','D')
 #define PNG_FIRST_LENGTH_CODE_INDEX   257
 #define PNG_LAST_LENGTH_CODE_INDEX    285
 #define PNG_NUM_DEFLATE_CODE_SYMBOLS  288
 #define PNG_NUM_DISTANCE_SYMBOLS      32
 #define PNG_NUM_CODE_LENGTH_CODES     19
 #define PNG_MAX_SYMBOLS               288
 #define PNG_DEFLATE_CODE_BITLEN       15
 #define PNG_DISTANCE_BITLEN           15
 #define PNG_CODE_LENGTH_BITLEN        7
 #define PNG_MAX_BIT_LENGTH            15
 #define PNG_DEFLATE_CODE_BUFFER_SIZE  (PNG_NUM_DEFLATE_CODE_SYMBOLS*2)
 #define PNG_DISTANCE_BUFFER_SIZE      (PNG_NUM_DISTANCE_SYMBOLS*2)
 #define PNG_CODE_LENGTH_BUFFER_SIZE   (PNG_NUM_DISTANCE_SYMBOLS*2)
 #define PNG_SET_ERROR(upng,code)      do { (upng)->error=(code); (upng)->error_line=__LINE__; } while (0)

 #define PNG_HEADER_OFFSET_IHDR        0x0C
 #define PNG_HEADER_SIZE_IHDR          0x11
 #define PNG_HEADER_OFFSET_WIDTH       0x10
 #define PNG_HEADER_OFFSET_HEIGHT      0x14
 #define PNG_HEADER_OFFSET_FORMAT      0x19
 #define PNG_HEADER_OFFSET_IHDR_CRC    0x1D
 #define PNG_HEADER_OFFSET_IDAT_SIZE   0x21
 #define PNG_HEADER_OFFSET_IDAT_DATA   0x29


 structure { BP buffer;H size;C owning; } upng_source;

 structure
 {
 H width,height;
 B color_type;
 H components;
 H bpp;
 H color_depth;
 B format;
 BP buffer;
 H size;
 B error;
 H error_line;
 B state;
 upng_source source;
 }
 upng_t;

 structure pnghufftree
 {
 HP tree2d;
 H maxbitlen;
 H numcodes;
 }
 pnghufftree;

 B aa_png_header[43]="\x89PNG\r\n\x1A\n\0\0\0\rIHDR\0\0\0\0\0\0\0\0\x08\0\0\0\0\0\0\0\0\0\0\0\0IDAT\x78\x01";
 B aa_png_trailer[12]="\0\0\0\0IEND\xAE\x42\x60\x82";

 H PNG_LENGTH_BASE[29]={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258};
 H PNG_LENGTH_EXTRA[29]={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
 H PNG_DISTANCE_BASE[30]={1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577};
 H PNG_DISTANCE_EXTRA[30]={0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
 H PNG_CLCL[PNG_NUM_CODE_LENGTH_CODES]={ 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };
 H PNG_FIXED_DEFLATE_CODE_TREE[PNG_NUM_DEFLATE_CODE_SYMBOLS*2]={
 289,370,290,307,546,291,561,292,293,300,294,297,295,296,0,1,2,3,298,299,4,5,6,7,301,304,302,303,8,9,10,11,305,306,12,
 13,14,15,308,339,309,324,310,317,311,314,312,313,16,17,18,19,315,316,20,21,22,23,318,321,319,320,24,25,26,27,322,323,
 28,29,30,31,325,332,326,329,327,328,32,33,34,35,330,331,36,37,38,39,333,336,334,335,40,41,42,43,337,338,44,45,46,47,
 340,355,341,348,342,345,343,344,48,49,50,51,346,347,52,53,54,55,349,352,350,351,56,57,58,59,353,354,60,61,62,63,356,
 363,357,360,358,359,64,65,66,67,361,362,68,69,70,71,364,367,365,366,72,73,74,75,368,369,76,77,78,79,371,434,372,
 403,373,388,374,381,375,378,376,377,80,81,82,83,379,380,84,85,86,87,382,385,383,384,88,89,90,91,386,387,92,93,94,95,
 389,396,390,393,391,392,96,97,98,99,394,395,100,101,102,103,397,400,398,399,104,105,106,107,401,402,108,109,110,111,404,
 419,405,412,406,409,407,408,112,113,114,115,410,411,116,117,118,119,413,416,414,415,120,121,122,123,417,418,124,125,126,
 127,420,427,421,424,422,423,128,129,130,131,425,426,132,133,134,135,428,431,429,430,136,137,138,139,432,433,140,141,142,
 143,435,483,436,452,568,437,438,445,439,442,440,441,144,145,146,147,443,444,148,149,150,151,446,449,447,448,152,153,154,
 155,450,451,156,157,158,159,453,468,454,461,455,458,456,457,160,161,162,163,459,460,164,165,166,167,462,465,463,464,168,
 169,170,171,466,467,172,173,174,175,469,476,470,473,471,472,176,177,178,179,474,475,180,181,182,183,477,480,478,479,184,
 185,186,187,481,482,188,189,190,191,484,515,485,500,486,493,487,490,488,489,192,193,194,195,491,492,196,197,198,199,494,
 497,495,496,200,201,202,203,498,499,204,205,206,207,501,508,502,505,503,504,208,209,210,211,506,507,212,213,214,215,509,
 512,510,511,216,217,218,219,513,514,220,221,222,223,516,531,517,524,518,521,519,520,224,225,226,227,522,523,228,229,230,
 231,525,528,526,527,232,233,234,235,529,530,236,237,238,239,532,539,533,536,534,535,240,241,242,243,537,538,244,245,246,
 247,540,543,541,542,248,249,250,251,544,545,252,253,254,255,547,554,548,551,549,550,256,257,258,259,552,553,260,261,262,
 263,555,558,556,557,264,265,266,267,559,560,268,269,270,271,562,565,563,564,272,273,274,275,566,567,276,277,278,279,569,
 572,570,571,280,281,282,283,573,574,284,285,286,287,0,0};
 H PNG_FIXED_DISTANCE_TREE[PNG_NUM_DISTANCE_SYMBOLS*2]={33,48,34,41,35,38,36,37,0,1,2,3,39,40,4,5,6,7,42,45,43,
 44,8,9,10,11,46,47,12,13,14,15,49,56,50,53,51,52,16,17,18,19,54,55,20,21,22,23,57,60,58,59,24,25,26,27,61,62,28,29,30,31,0,0};

 B aa_PngFromImage                     (VP imgdata,N width,N height,N stride,VP outbuf,N maxout,HP outbytes);


/*-----------------------------------------------------------------------*/


 structure
 {
 BP data;
 Z width,height;
 Z x_pos,y_pos;
 }
 _jpegchunk;


 structure
 {
 B data[512];
 Y bit_size;
 }
 _jpegbuf;


 structure
 {
 W length;
 B data[338];
 W img_w_off;
 W img_h_off;
 }
 _jpeghdr;


 structure
 {
 H magic;
 W img_w,img_h;
 W x_pos,y_pos;
 I prev_y1dc,prev_y2dc;
 I prev_crdc,prev_cbdc;
 B eoi;
 Z blocks_n;
 _jpeghdr header;
 C quant[64];
 _jpegchunk chunk;
 _jpegbuf buffy;
 _memoryunit yuv;
 _memoryunit out;
 H out_len;
 }
 _jpegctx;



 B aa_JpegChunkNext                    (_jpegchunk*chunk);
 V aa_JpegChunkCopyY1                  (_jpegchunk*chunk,IP destination);
 V aa_JpegChunkCopyY2                  (_jpegchunk*chunk,IP destination);
 V aa_JpegChunkCopyCr                  (_jpegchunk*chunk,IP destination);
 V aa_JpegChunkCopyCb                  (_jpegchunk*chunk,IP destination);

 V aa_JpegAdd                          (_jpegbuf*buffer,Y bits,B bits_n);
 V aa_JpegAddAC                        (_jpegbuf*buffer,WP table,B run,I value);
 V aa_JpegAddDC                        (_jpegbuf*buffer,WP table,I value);

 V aa_JpegEncode                       (_jpegctx*jpegctx,IP last_dc,WP dc_table,WP ac_table,IP block);
 V aa_JpegQuantize                     (_jpegctx*jpegctx,IP block);
 Z aa_JpegWrite                        (_jpegctx*jpegctx,BP buffer,Z buffer_size);

 B aa_JpegNew                          (_jpegctx*jpegctx);
 B aa_JpegDelete                       (_jpegctx*jpegctx);
 B aa_JpegCompress                     (_jpegctx*jpegctx,H w,H h,VP img);



/*-----------------------------------------------------------------------*/

 #define WM_SURFACE_SYSTRAY_MSG        (WM_USER+41)
 #define aa_WARP_SHIFTS                15
 #define aa_WARP_THRESH                (1<<aa_WARP_SHIFTS)

 #define RGB_Y_OUT                     1.164
 #define B_U_OUT                       2.018
 #define Y_ADD_OUT                     16
 #define G_U_OUT                       0.391
 #define G_V_OUT                       0.813
 #define U_ADD_OUT                     128
 #define R_V_OUT                       1.596
 #define V_ADD_OUT                     128
 #define SCALEBITS_OUT                 13
 #define FIX_OUT(x)                    ((W)((x)*(1L<<SCALEBITS_OUT)+0.5))



 structure
 {
 H self_handle;
 _surfacestatus status;
 B(*PixelGet)(VP surfobj,N x,N y,_rgba*p1);
 B(*PixelPut)(VP surfobj,N x,N y,_rgba*p1);
 B(*PixelSet)(VP surfobj,N x,N y,_rgba*p1);
 _timer caret_timer;
 H spot_id_counter;
 }
 _aa_surfaceobject;




 structure
 {
 B object_id;
 H caret_speed;
 B yuva_tables_init;
 N RGB_Y_tab[256];
 N B_U_tab[256];
 N G_U_tab[256];
 N G_V_tab[256];
 N R_V_tab[256];
 }
 _aa_surfacesystem;


 structure
 {
 W type;
 H size;
 W rsvd1,rsvd2;
 H off_bits;
 }
 _aa_surfacebmpfilehdr;


 structure
 {
 H width,height;
 W bits;
 H compression;
 }
 _aa_surfacebmpinfohdr;


 structure
 {
 H width,height;
 W planes,bits;
 H compression,imgsize;
 H xpixpermeter,ypixpermeter;
 H clrused,clrimportant;
 }
 _aa_surfacewinbmpinfohdr;



 structure
 {
 W width,height;
 W planes,bits;
 }
 _aa_surfaceos2bmpinfohdr;



 structure
 {
 W byte_order;
 W id_42;
 H offset;
 }
 _aa_surfacetiffhdr;



 structure
 {
 W rsvd,type;
 W count;
 }
 _aa_surfaceiconhdr;




 structure
 {
 B wid,hit;
 B colors,rsvd;
 W planes,bps;
 H size,offset;
 }
 _aa_surfaceiconentry;



 structure
 {
 B id_length;
 B pal_type;
 B img_type;
 W first_color;
 W pal_colors;
 B pal_entry_size;
 W left;
 W top;
 W width;
 W height;
 B bpp;
 B flags;
 }
 _aa_surfacetgahdr;


 structure
 {
 N index,code,length;
 }
 _aa_surfacejpeghuffnode;




 structure
 {
 B is_failed;
 B is_sos;
 B is_sof0;
 B is_dht;
 B is_soi;
 B is_dqt;
 B is_dri;
 B is_app0;
 BP data_start;
 BP data;
 N width,height;
 N component_count;
 _aa_surfacejpeghuffnode huffman_node[1024];
 I dequant[128];
 N samples_y;
 N huffman_y,huffman_cbcr;
 N quant_y,ac_y,dc_y;
 N quant_cbcr,ac_cbcr,dc_cbcr;
 N bits,byte;
 }
 _aa_surfacejpegdecoder;






 structure
 {
 Y b:5;
 Y g:5;
 Y r:5;
 Y a:1;
 }
 _aa_pen16;


 structure
 {
 B b;
 B g;
 B r;
 }
 _aa_pen24;



 B aa_SurfaceSystemStart               (V);
 V aa_SurfaceSystemStop                (V);
 B aa_SurfaceSystemFindSurfaceByHwnd   (HP handle,PP mem,HWND hwnd);

 V aa_SurfaceSystemYuvTablesInit       (V);

 B aa_SurfaceDecodeJpegBlock           (_aa_surfacejpegdecoder*dec,NP dat,N dc,N ac,N qt,NP old_dc);
 B aa_SurfaceDecodeTgaRle              (NP duppixcount,NP blockcount,HP off,VP mem,B bits,_rgba*p1);

 B aa_SurfaceSortSpots                 (PP mem);


/*-----------------------------------------------------------------------*/



 B aa_cursorhand[(32*4)+(32*4)]=
 {
 0xF9,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,
 0xF0,0xFF,0xFF,0xFF,0xF0,0x3F,0xFF,0xFF,0xF0,0x07,0xFF,0xFF,0xF0,0x01,0xFF,0xFF,
 0xF0,0x00,0xFF,0xFF,0x10,0x00,0x7F,0xFF,0x00,0x00,0x7F,0xFF,0x00,0x00,0x7F,0xFF,
 0x80,0x00,0x7F,0xFF,0xC0,0x00,0x7F,0xFF,0xC0,0x00,0x7F,0xFF,0xE0,0x00,0x7F,0xFF,
 0xE0,0x00,0xFF,0xFF,0xF0,0x00,0xFF,0xFF,0xF0,0x00,0xFF,0xFF,0xF8,0x01,0xFF,0xFF,
 0xF8,0x01,0xFF,0xFF,0xF8,0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
 0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,

 0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x06,0x00,0x00,0x00,
 0x06,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x06,0xC0,0x00,0x00,0x06,0xD8,0x00,0x00,
 0x06,0xDA,0x00,0x00,0x06,0xDB,0x00,0x00,0x67,0xFB,0x00,0x00,0x77,0xFF,0x00,0x00,
 0x37,0xFF,0x00,0x00,0x17,0xFF,0x00,0x00,0x1F,0xFF,0x00,0x00,0x0F,0xFF,0x00,0x00,
 0x0F,0xFE,0x00,0x00,0x07,0xFE,0x00,0x00,0x07,0xFE,0x00,0x00,0x03,0xFC,0x00,0x00,
 0x03,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 };


 structure
 {
 HCURSOR hand_cursor_handle;
 HCURSOR current_cursor_handle;
 B cursor_id;
 }
 _aa_cursorsystem;


 B aa_CursorSystemStart                (V);
 V aa_CursorSystemStop                 (V);

/*-----------------------------------------------------------------------*/

 #define WM_APP_BAR_MSG                (WM_USER+77)

 structure
 {
 B state;
 B orientation;
 H edge;
 H depth;
 _rect rect;
 H surface_handle;
 }
 _aa_appbarsystem;



 B aa_AppBarSystemStart                (V);
 V aa_AppBarSystemStop                 (V);



/*-----------------------------------------------------------------------*/

 H aa_GifCodeMasks[13]=                {0,1,3,7,15,31,63,127,255,0x01ff,0x03ff,0x07ff,0x0fff};
 I aa_GifInterlacedOffset[4]=          {0,4,2,1};
 I aa_GifInterlacedJumps[4]=           {8,8,4,2};



 structure
 {
 H self_handle;
 H file_bytes;
 BP file_mem;
 H file_offset_root;
 H file_offset;
 H next_offset;
 H next_framenum;
 W version;
 W total_colors;
 B bg_color_used;
 B bg_color_index;
 W global_color_bits;
 W global_color_count;
 _rgba global_color_pen[256];
 W local_color_bits;
 W local_color_count;
 B disposal_method;
 _rgba local_color_pen[256];
 _cord frame_cord;
 _size frame_size;
 B frame_interlaced;
 B frame_use_local_color;
 B frame_transparent_index_set;
 B frame_transparent_index;
 B allow_next;
 BP img;
 H bpp;
 H clear_code;
 H eof_code;
 H RunningCode;
 H RunningBits;
 H MaxCode1;
 H last_code;
 H CrntCode;
 H stack_ptr;
 H CrntShiftState;
 H CrntShiftDWord;
 H PixelCount;
 B Buf[256];
 B Stack[4095];
 B Suffix[4095+1];
 H Prefix[4095+1];
 _gifstatus status;
 H tik;
 }
 _aa_gifobject;


 structure
 {
 B object_id;
 }
 _aa_gifsystem;


 B aa_GifSystemStart                   (V);
 V aa_GifSystemStop                    (V);
 B aa_GifSystemReadBytes               (PP mem,H bytes,VP buf);
 N aa_GifSystemBitSize                 (N value);
 B aa_GifSystemReadFrameInfo           (PP mem);
 B aa_GifSystemReadExtension           (PP mem,NP extension_code,BP*extension);
 B aa_GifSystemReadExtensionNext       (PP mem,BP*extension);
 B aa_GifSystemReadLine                (PP mem,BP line,N linelen);
 B aa_GifSystemGetCodeNext             (PP mem,BP*codeblock);
 B aa_GifSystemDecompressLine          (PP mem,BP line,N linelen);
 B aa_GifSystemGetPrefixChar           (HP prefix,N Code,N clear_code);
 B aa_GifSystemDecompressInput         (PP mem,NP Code);

/*-----------------------------------------------------------------------*/

 ///#pragma pack(1)
 _rgba col_null,col_black,col_white,col_gray[32];
 _rgba col_red[32],col_green[32],col_blue[32];
 _rgba col_purple[32],col_yellow[32],col_cyan[32];
 _rgba col_orange[32],col_sky[32];
 _rgba col_pastelred[32],col_pastelgreen[32],col_pastelblue[32];
 _rgba col_pastelpurple[32],col_pastelyellow[32],col_pastelcyan[32];
 _rgba col_pastelorange[32],col_pastelsky[32];
 _rgba*col_map[576];
 ///#pragma pack()


 B aa_halftone4x4_1[16]=               { 0,25,6,31,38,12,44,19,9,35,3,28,47,22,41,15 };
 B aa_halftone4x4_2[16]=               { 41,3,9,28,35,15,22,47,6,25,38,0,19,44,31,12 };
 B aa_halftone16x16[256]=
 {
 0,44,9,41,3,46,12,43,1,44,10,41,3,46,12,43,34,16,25,19,37,18,28,21,35,16,26,19,37,18,28,21,
 38,6,47,3,40,9,50,6,38,7,47,4,40,9,49,6,22,28,13,31,25,31,15,34,22,29,13,32,24,31,15,34,
 2,46,12,43,1,45,10,42,2,45,11,42,1,45,11,42,37,18,27,21,35,17,26,20,36,17,27,20,36,17,26,20,
 40,8,49,5,38,7,48,4,39,8,48,5,39,7,48,4,24,30,15,33,23,29,13,32,23,30,14,33,23,29,14,32,
 2,46,12,43,0,44,10,41,3,47,12,44,0,44,10,41,37,18,27,21,35,16,25,19,37,19,28,22,35,16,25,19,
 40,9,49,5,38,7,47,4,40,9,50,6,38,6,47,3,24,30,15,34,22,29,13,32,25,31,15,34,22,28,13,31,
 1,45,11,42,2,46,11,42,1,45,10,41,2,46,11,43,36,17,26,20,36,17,27,21,35,16,26,20,36,18,27,21,
 39,8,48,4,39,8,49,5,38,7,48,4,39,8,49,5,23,29,14,33,24,30,14,33,23,29,13,32,24,30,14,33,
 };


 B aa_halftone8x8[64] =
 {
 0,38,9,47,2,40,11,50,25,12,35,22,27,15,37,24,6,44,3,41,8,47,5,43,31,19,28,15,34,21,31,18,1,39,11,49,
 0,39,10,48,27,14,36,23,26,13,35,23,7,46,4,43,7,45,3,42,33,20,30,17,32,19,29,16,
 };


 B aa_halftonexlat[216] =
 {
 0,29,30,31,32,249,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,250,250,57,58,59,251,
 60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,250,90,91,92,93,94,95,96,97,98,
 99,100,101,102,103,104,105,106,107,108,109,110,111,227,112,113,114,115,116,117,118,119,151,120,121,122,123,124,228,125,126,229,133,162,
 135,131,132,137,166,134,140,130,136,143,138,139,174,141,142,177,129,144,145,146,147,148,149,150,157,152,153,154,155,156,192,158,159,160,161,196,
 163,164,165,127,199,167,168,169,170,171,172,173,207,175,176,210,178,179,180,181,182,183,184,185,186,187,188,189,190,191,224,193,194,
 195,252,252,197,198,128,253,252,200,201,202,203,204,205,206,230,208,209,231,211,212,213,214,215,216,217,218,219,220,221,222,254,223,232,225,226,255,
 };




 structure
 {
 _rgba shadow;
 _rgba half_pal[216];
 }
 _aa_colorsystem;


 B aa_ColorSystemStart                 (V);
 V aa_ColorSystemStop                  (V);



/*-----------------------------------------------------------------------*/

 #define aa_INPUT_IHKE_QUEUE_SIZE      256


 structure
 {
 Q microsecs;
 Q sequence;
 B msg;
 B is_ext;
 B is_sys;
 B is_caps;
 B is_numl;
 B is_scrl;
 B is_shift;
 B is_ctrl;
 B is_alt;
 B is_win;
 B is_injected;
 B skey_code;
 B vkey_code;
 B akey_code;
 B xf;
 }
 _aa_inputhookedkeyevent;



 structure
 {
 HKL keyboard_layout;
 H keyboard_scan_code[256];
 H keyboard_speed;
 H keyboard_delay;
 H tray_cycle;
 HWND tray_hwnd;
 H vsx,vsy;
 HWND capture_hwnd;
 HANDLE mutex_handle;

 _memorymodule memod;
 BP vkcode;
 //HHOOK hHook;
 HHOOK hKeyHook;
 HHOOK hMouseHook;


 V(*dllSetProcAdr)(B(*proc)(VP name,VP etc,BP type,PP ptr));
 B(*dllInitPlugin)(V);
 LRESULT CALLBACK(*dllHookProc)(int,WPARAM,LPARAM);
 //_vm vmvm;

 N wheel;
 //Q speedy;

 Q sequence;
 Q ihke_sequence;
 Q ihke_events_waiting;
 Q ihke_events_total;
 _queunit ihke_que;
 //_queunit input_stream_que;
 _aa_inputhookedkeyevent ihke_que_array[aa_INPUT_IHKE_QUEUE_SIZE];
 H ihke_que_head;
 H ihke_que_tail;

 Q engine_sequence;

 B vkey_used_count;
 B vkey_down_count;
 B vkey_held_count;
 B vkey_up_count;
 C vkey_state[256];

 B vs_key_rep[63356];

 W is_dragging:1;
 W is_caps:1;
 W is_scrl:1;
 W is_numl:1;
 W is_shift:1;
 W is_ctrl:1;
 W is_alt:1;
 W is_win:1;
 W is_left:1;
 W is_mid:1;
 W is_right:1;
 W rsvd:5;
 }
 _aa_inputsystem;




 B aa_InputSystemStart                 (V);
 V aa_InputSystemStop                  (V);

 B aa_InputKeyLoggerStart              (V);

 B aa_InputSystemHookedKeyEngineStart  (V);
 B aa_InputSystemHookedKeyEngineStop   (V);

 //B aa_InputSystemThisGetProcAddress    (VP name,VP etc,BP type,PP ptr);

 B aa_InputSystemCountVkeys            (V);
 B aa_InputSystemVkeyStateSet          (Z vkey,B cmd,B ismore);


 //B CALLBACK aa_InputSystemHookedKeyEventProc    (WPARAM wParam,LPARAM lParam);
 B aa_InputSystemHookedKeyProcess      (_aa_inputhookedkeyevent*aaihke);



 B aa_InputSystemKeyEventProc          (HWND wnd,H msg,WPARAM wparm,LPARAM lparm,B extflag);



 B aa_InputStateGet                    (_inputstate*inputstate,B dokeys,B domouse);


/*-----------------------------------------------------------------------*/





 structure
 {
 H self_handle;
 _audiostatus status;
 WAVEFORMATEX wfx;
 HWAVEIN handle;
 H que_handle;
 _questatus que_status;
 B is_openreceived;
 H last_sample_position;
 _timer inactive_timer;
 WAVEHDR wave_hdr[128];
 BP wave_buf;
 H cycle;
 H ctrl_master_volume;
 H ctrl_master_mute;
 MIXERLINE ctrl_master_line;
 D pre_mix_left[5000];
 D pre_mix_rigt[5000];
 }
 _aa_audioobject;



/*[5:20:30 AM] Dmitry Zapashchikov says: G[dB] = 20 * log10( MAX / abs( S ))*/

 structure
 {
 B object_id;
 D ch_block[_32K];
 }
 _aa_audiosystem;



 B aa_AudioSystemStart                 (V);
 V aa_AudioSystemStop                  (V);
 B aa_AudioSystemModeVerify            (_audiomode*audiomode);
 K aa_AudioSystemOutProc               (HWAVEOUT h,UINT msg,H data,H p1,H p2);
 K aa_AudioSystemInProc                (HWAVEOUT h,UINT msg,H data,H p1,H p2);
 B aa_AudioSystemUpdateSamplePosition  (PP mem);
 B aa_AudioSystemProcessQues           (PP mem);

 D aa_AudioSystemAtan2                 (D x,D y);
 V aa_AudioSystemFFT                   (FP fftbuffer,N framesize,N sign);

 B aa_AudioSystemGetVolume             (PP mem,H ctrlid,NP vol);
 B aa_AudioSystemSetVolume             (PP mem,H ctrlid,NP vol);
 B aa_AudioSystemGetMute               (PP mem,H ctrlid,NP mute);
 B aa_AudioSystemSetMute               (PP mem,H ctrlid,NP mute);
 B aa_AudioSystemGetLineControls       (PP mem,MIXERLINE*mxline,H source,H dest,HP volctrl,HP mutectrl);
 B aa_AudioSystemChannelMixer          (PP mem);





/*-----------------------------------------------------------------------*/

 #define aa_VIDCAP_ALLOW_YUY2          (YES)

 #define USE_VIDCAP_CRITICAL_SECTION   (YES-1)

 #define aa_VIDCAP_THREAD_SLEEP        1
 #define aa_VIDCAP_THREAD_STATUS_CYCLE 10

 #define WM_USER_VIDCAP_SOURCE         (WM_USER+12)
 #define aa_CONTROLCALLBACK_PREROLL    1
 #define aa_CONTROLCALLBACK_CAPTURING  2
 #define aa_IDS_CAP_BEGIN              300
 #define aa_IDS_CAP_END                301
 #define aa_AVSTREAMMASTER_AUDIO       0
 #define aa_AVSTREAMMASTER_NONE        1

 #define VAL_IYUV                      1448433993
 #define VAL_I420                      808596553
 #define VAL_YUY2                      844715353
 #define VAL_limt                      1953327468
 #define VAL_aamh                      1751998817
 #define VAL_YUYV                      1448695129
 #define VAL_V422                      842150998
 #define VAL_UYVY                      1498831189
 #define VAL_YV12                      842094169

 structure
 {
 UINT        uiImageWidth;               // Width of the image
 UINT        uiImageHeight;              // Height of the image
 BOOL        fLiveWindow;                // Now Previewing video?
 BOOL        fOverlayWindow;             // Now Overlaying video?
 BOOL        fScale;                  // Scale image to client?
 POINT       ptScroll;                   // Scroll position
 BOOL        fUsingDefaultPalette;       // Using default driver palette?
 BOOL        fAudioHardware;             // Audio hardware present?
 BOOL        fCapFileExists;             // Does capture file exist?
 DWORD       dwCurrentVideoFrame;        // # of video frames cap'td
 DWORD       dwCurrentVideoFramesDropped;// # of video frames dropped
 DWORD       dwCurrentWaveSamples;       // # of wave samples cap'td
 DWORD       dwCurrentTimeElapsedMS;     // Elapsed capture duration
 HPALETTE    hPalCurrent;                // Current palette in use
 BOOL        fCapturingNow;              // Capture in progress?
 DWORD       dwReturn;                   // Error value after any operation
 UINT        wNumVideoAllocated;         // Actual number of video buffers
 UINT        wNumAudioAllocated;         // Actual number of audio buffers
 }
 aa_CAPSTATUS;



 structure
 {
 DWORD       dwRequestMicroSecPerFrame;  // Requested capture rate
 BOOL        fMakeUserHitOKToCapture;    // Show "Hit OK to cap" dlg?
 UINT        wPercentDropForError;       // Give error msg if > (10%)
 BOOL        fYield;                     // Capture via background task?
 DWORD       dwIndexSize;                // Max index size in frames (32K)
 UINT        wChunkGranularity;          // Junk chunk granularity (2K)
 BOOL        fUsingDOSMemory;            // Use DOS buffers?
 UINT        wNumVideoRequested;         // # video buffers, If 0, autocalc
 BOOL        fCaptureAudio;              // Capture audio?
 UINT        wNumAudioRequested;         // # audio buffers, If 0, autocalc
 UINT        vKeyAbort;                  // Virtual key causing abort
 BOOL        fAbortLeftMouse;            // Abort on left mouse?
 BOOL        fAbortRightMouse;           // Abort on right mouse?
 BOOL        fLimitEnabled;              // Use wTimeLimit?
 UINT        wTimeLimit;                 // Seconds to capture
 BOOL        fMCIControl;                // Use MCI video source?
 BOOL        fStepMCIDevice;             // Step MCI device?
 DWORD       dwMCIStartTime;             // Time to start in MS
 DWORD       dwMCIStopTime;              // Time to stop in MS
 BOOL        fStepCaptureAt2x;           // Perform spatial averaging 2x
 UINT        wStepCaptureAverageFrames;  // Temporal average n Frames
 DWORD       dwAudioBufferSize;          // Size of audio bufs (0 = default)
 BOOL        fDisableWriteCache;         // Attempt to disable write cache
 UINT        AVStreamMaster;             // Which stream controls length?
 }
 aa_CAPTUREPARMS;


 structure
 {
 LPBYTE      lpData;                 // pointer to locked data buffer
 DWORD       dwBufferLength;         // Length of data buffer
 DWORD       dwBytesUsed;            // Bytes actually used
 DWORD       dwTimeCaptured;         // Milliseconds from start of stream
 DWORD       dwUser;                 // for client's use
 DWORD       dwFlags;                // assorted flags (see defines)
 DWORD*      dwReserved[4];          // reserved for driver
 }
 aa_VIDEOHDR;

 structure
 {
 UINT        wDeviceIndex;               // Driver index in system.ini
 BOOL        fHasOverlay;                // Can device overlay?
 BOOL        fHasDlgVideoSource;         // Has Video source dlg?
 BOOL        fHasDlgVideoFormat;         // Has Format dlg?
 BOOL        fHasDlgVideoDisplay;        // Has External out dlg?
 BOOL        fCaptureInitialized;        // Driver ready to capture?
 BOOL        fDriverSuppliesPalettes;    // Can driver make palettes?
 // following always NULL on Win32.
 HANDLE      hVideoIn;                   // Driver In channel
 HANDLE      hVideoOut;                  // Driver Out channel
 HANDLE      hVideoExtIn;                // Driver Ext In channel
 HANDLE      hVideoExtOut;               // Driver Ext Out channel
 }
 aa_CAPDRIVERCAPS;



 structure
 {
 H self_handle;
 _vidcapstatus status;
 B has_format;
 B has_display;
 B is_frame_waiting;
 B is_abort_complete;
 B is_connect_failed;
 B is_sourcebox_message_received;
 B is_sourcebox_closed;
 H error_count;
 N error_code;
 H device_id;
 H frames_bad;
 _size requested_capture_size;
 B requested_capture_bits;
 H using_bmp_compression;
 H thread_id;
 H thread_handle;
 H thread_lparm;
 _aa_event connect_event;
 HWND hwnd;
 H window_to_active_after_connect;
 H window_to_active_after_sourcebox_close;
 H frame_buf_bytes;
 B auto_detect_stage;
 B auto_detect_bit_mode;
 _size auto_detect_size;
 BP frame_buf;
 }
 _aa_vidcapobject;




 structure
 {
 B object_id;
 }
 _aa_vidcapsystem;


 B aa_VidCapSystemStart                (V);
 V aa_VidCapSystemStop                 (V);
 H aa_VidCapThread                     (VP parm);
 B aa_VidCapSetCallbacks               (PP mem,B state);
 B aa_VidCapFindByCaptureHwnd          (HP handle,PP mem,HWND wnd);
 K aa_VidCapErrorProc                  (HWND wnd,N errorid,LPSTR errortxt);
 K aa_VidCapControlProc                (HWND wnd,N state);
 K aa_VidCapStatusProc                 (HWND wnd,N id,LPCSTR str);
 K aa_VidCapPreviewProc                (HWND wnd,aa_VIDEOHDR* lpvhdr);
 K aa_VidCapVideoProc                  (HWND wnd,aa_VIDEOHDR* lpvhdr);
 B aa_VidCapProcessFrame               (HWND wnd,aa_VIDEOHDR* lpvhdr);
 B aa_VidCapAbort                      (PP mem);


/*-----------------------------------------------------------------------*/




 structure
 {
 Q length;
 Q offset;
 B block[_4K];
 B wbits[_4K/8];
 W wbits_on;
 W ttl;
 }
 _aa_filestreamcache;


 structure
 {
 H self_handle;
 HANDLE handle;
 _filestreamstatus status;
 B is_stdio;
 B crlf_state;
 Q line_peek_offset;
 H line_chars;
 B gfs_required;
 H cycle;
 _aa_filestreamcache*cache;
 H cache_slots;
 H cache_count;
 }
 _aa_filestreamobject;


 structure
 {
 B object_id;
 }
 _aa_filestreamsystem;


 B aa_FileStreamSystemStart            (V);
 V aa_FileStreamSystemStop             (V);

 //B aa_FileStreamCacheSlotFind          (PP mem,Q offset,Q bytes,HP slot);
 //B aa_FileStreamCacheManage            (PP mem);
 B aa_FileStreamCacheManage            (PP mem);
 B aa_FileStreamCacheRead              (PP mem,H bytes,VP data);
 B aa_FileStreamCacheWrite             (PP mem,H bytes,VP data);


/*-----------------------------------------------------------------------*/


 structure
 {
 B is_open;
 B is_close;
 B is_failure;
 B is_cancelled;
 B filter[257];
 B initial_dir[257];
 B initial_file[129];
 BP selection;
 B max_files;
 HANDLE handle;
 B caption[65];
 HWND parent_hwnd;
 OPENFILENAME of;
 }
 _aa_fileboxsystem;


 H WINAPI aa_FileBoxProc               (LPVOID pa);

 B aa_FileBoxSystemStart               (V);
 V aa_FileBoxSystemStop                (V);

/*-----------------------------------------------------------------------*/


 structure
 {
 B is_open;
 B is_close;
 B is_cancelled;
 B is_failure;
 B initial_dir[513];
 B caption[65];
 HANDLE handle;
 H surface_handle;
 HWND parent_hwnd;
 HWND dialog_hwnd;
 BROWSEINFO bi;
 LPITEMIDLIST pidl;
 TCHAR szDir[MAX_PATH];
 B r_path[MAX_PATH];
 }
 _aa_folderboxsystem;

 Z CALLBACK aa_FolderBoxCallback       (HWND hwnd,UINT uMsg,LPARAM lp,LPARAM pData);
 H WINAPI aa_FolderBoxProc             (LPVOID pa);

 B aa_FolderBoxSystemStart             (V);
 V aa_FolderBoxSystemStop              (V);

/*-----------------------------------------------------------------------*/

 B aa_SysIsWinServer                   (V);
 B aa_SysIsWinXpSp2OrGreater           (V);


/*-----------------------------------------------------------------------*/


 typedef union
 {
 FILETIME dword;
 Q quad;
 }
 myFILETIME;

 // #define aa_Li2Double(x)               ((D)((x).hi)*4.294967296E9+(D)((x).lo))


 structure
 {
 B is_started;
 myFILETIME prev_idle_time;
 myFILETIME prev_kernel_time;
 myFILETIME prev_user_time;
 G prev_ki_time;
 G process_prev_idle_time;
 G process_prev_kernel_time;
 G process_prev_user_time;
 }
 _aa_cpumonitorsystem;



 B aa_CpuMonitorSystemStart            (V);
 V aa_CpuMonitorSystemStop             (V);


/*-----------------------------------------------------------------------*/


 structure
 {
 H self_handle;
 HANDLE handle;
 _dirstatus status;
 H slots;
 BP mem;
 WIN32_FIND_DATA wfd;
 }
 _aa_dirobject;


 structure
 {
 B object_id;
 }
 _aa_dirsystem;


 B aa_DirSystemStart                   (V);
 V aa_DirSystemStop                    (V);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 H stage;
 _dirwalkerstatus status;
 H root_sl;
 H ti;
 _ministack dms;
 B in_proc;
 }
 _aa_dirwalkerobject;


 structure
 {
 B object_id;
 }
 _aa_dirwalkersystem;

 B aa_DirWalkerSystemStart             (V);
 V aa_DirWalkerSystemStop              (V);


/*-----------------------------------------------------------------------*/

 #define aaRipemdBytesToDword          (((H) *((p)+3) << 24)|((H) *((p)+2) << 16) | ((H) *((p)+1) <<  8) | ((H) *(p)))
 #define aaRipemdROL(x,n)              (((x) << (n)) | ((x) >> (32-(n))))
 #define aaRipemdF(x,y,z)              ((x) ^ (y) ^ (z))
 #define aaRipemdG(x,y,z)              (((x) & (y)) | (~(x) & (z)))
 #define aaRipemdH(x,y,z)              (((x) | ~(y)) ^ (z))
 #define aaRipemdI(x,y,z)              (((x) & (z)) | ((y) & ~(z)))
 #define aaRipemdJ(x,y,z)              ((x) ^ ((y) | ~(z)))
 #define aaRipemdFF(a,b,c,d,e,x,s)     { (a)+=aaRipemdF((b),(c),(d))+(x)+0x00000000UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdGG(a,b,c,d,e,x,s)     { (a)+=aaRipemdG((b),(c),(d))+(x)+0x5a827999UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdHH(a,b,c,d,e,x,s)     { (a)+=aaRipemdH((b),(c),(d))+(x)+0x6ed9eba1UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdII(a,b,c,d,e,x,s)     { (a)+=aaRipemdI((b),(c),(d))+(x)+0x8f1bbcdcUL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdJJ(a,b,c,d,e,x,s)     { (a)+=aaRipemdJ((b),(c),(d))+(x)+0xa953fd4eUL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdFFF(a,b,c,d,e,x,s)    { (a)+=aaRipemdF((b),(c),(d))+(x)+0x00000000UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdGGG(a,b,c,d,e,x,s)    { (a)+=aaRipemdG((b),(c),(d))+(x)+0x7a6d76e9UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdHHH(a,b,c,d,e,x,s)    { (a)+=aaRipemdH((b),(c),(d))+(x)+0x6d703ef3UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdIII(a,b,c,d,e,x,s)    { (a)+=aaRipemdI((b),(c),(d))+(x)+0x5c4dd124UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }
 #define aaRipemdJJJ(a,b,c,d,e,x,s)    { (a)+=aaRipemdJ((b),(c),(d))+(x)+0x50a28be6UL; (a)=aaRipemdROL((a),(s))+(e); (c)=aaRipemdROL((c), 10); }

// #define aaMD5FF(b,c,d)                ((b & c) | (~b & d)) // optimised
 #define aaMD5FF(b,c,d)                (d ^ (b & (c ^ d)))
 #define aaMD5FG(b,c,d)                aaMD5FF (d, b, c)
 #define aaMD5FH(b,c,d)                (b ^ c ^ d)
 #define aaMD5FI(b,c,d)                (c ^ (b | ~d))
 #define aaMD5OP1(a,b,c,d,s,T)         do { a+=aaMD5FF(b,c,d)+(*cwp++)+T;    a=aaNumRoll(a,s); a+=b; }   while (0)
 #define aaMD5OP2(f,a,b,c,d,k,s,T)     do { a+=f(b,c,d)+digp->correct_words[k]+T;  a=aaNumRoll(a,s); a+=b; }   while (0)

 #define aaSHA1Rol(val,bits)           (((val)<<(bits))|((val)>>(32-(bits))))
 #define aaSHA1Blk0(i)                 (zblock->l[i]=(aaSHA1Rol(zblock->l[i],24)&0xFF00FF00)|(aaSHA1Rol(zblock->l[i],8)&0x00FF00FF))
 #define aaSHA1Blk(i)                  (zblock->l[i&15]=aaSHA1Rol(zblock->l[(i+13)&15]^zblock->l[(i+8)&15]^zblock->l[(i+2)&15]^zblock->l[i&15],1))
 #define aaSHA1R0(v,w,x,y,z,i)         z+=((w&(x^y))^y)+aaSHA1Blk0(i)+0x5A827999+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R1(v,w,x,y,z,i)         z+=((w&(x^y))^y)+aaSHA1Blk(i)+0x5A827999+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R2(v,w,x,y,z,i)         z+=(w^x^y)+aaSHA1Blk(i)+0x6ED9EBA1+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R3(v,w,x,y,z,i)         z+=(((w|x)&y)|(w&x))+aaSHA1Blk(i)+0x8F1BBCDC+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);
 #define aaSHA1R4(v,w,x,y,z,i)         z+=(w^x^y)+aaSHA1Blk(i)+0xCA62C1D6+aaSHA1Rol(v,5);w=aaSHA1Rol(w,30);


 H aa_DigestSha2K256[256]=              {0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
                                        0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
                                        0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
                                        0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
                                        0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
                                        0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
                                        0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
                                        0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2};



 structure
 {
 H self_handle;
 _digeststatus status;
 B requires_reset;
 H counter;
 H count;
 B block[64];
 H len[2];
 H correct_words[16];
 }
 _aa_digestobject;


 structure
 {
 B object_id;
 }
 _aa_digestsystem;


 B aa_DigestSystemStart                (V);
 V aa_DigestSystemStop                 (V);
 V aa_DigestSystemCompress             (PP mem,HP block);
 V aa_DigestSystemMd5                  (_aa_digestobject*digp,BP inbuf,H inlen);
 V aa_DigestSystemSha256Transform      (_aa_digestobject*digp);

 H aa_DigestSha2rotateRight            (H n,H x);
 H aa_DigestSha2choice                 (H x,H y,H z);
 H aa_DigestSha2majority               (H x,H y,H z);
 H aa_DigestSha2Sigma0                 (H x);
 H aa_DigestSha2Sigma1                 (H x);
 H aa_DigestSha2sigma0                 (H x);
 H aa_DigestSha2sigma1                 (H x);
 H aa_DigestSha2expand                 (HP WX,H j);
 H aa_DigestSha2safeAdd                (H x,H y);



/*-----------------------------------------------------------------------*/

//https://github.com/chettrick/aes256
//https://github.com/kokke/tiny-AES128-C

 structure
 {
 H esk[32];
 H dsk[32];
 }
 _aa_crypto_des_context;



 structure
 {
 H esk[96];
 H dsk[96];
 }
 _aa_crypto_des3_context;



 H aa_crypto_des_SB1[64] =
 {
 0x01010400,0x00000000,0x00010000,0x01010404,0x01010004,0x00010404,0x00000004,0x00010000,0x00000400,0x01010400,0x01010404,0x00000400,0x01000404,0x01010004,
 0x01000000,0x00000004,0x00000404,0x01000400,0x01000400,0x00010400,0x00010400,0x01010000,0x01010000,0x01000404,0x00010004,0x01000004,0x01000004,0x00010004,
 0x00000000,0x00000404,0x00010404,0x01000000,0x00010000,0x01010404,0x00000004,0x01010000,0x01010400,0x01000000,0x01000000,0x00000400,0x01010004,0x00010000,
 0x00010400,0x01000004,0x00000400,0x00000004,0x01000404,0x00010404,0x01010404,0x00010004,0x01010000,0x01000404,0x01000004,0x00000404,0x00010404,0x01010400,
 0x00000404,0x01000400,0x01000400,0x00000000,0x00010004,0x00010400,0x00000000,0x01010004
 };

 H aa_crypto_des_SB2[64] =
 {
 0x80108020,0x80008000,0x00008000,0x00108020,0x00100000,0x00000020,0x80100020,0x80008020,0x80000020,0x80108020,0x80108000,0x80000000,0x80008000,0x00100000,
 0x00000020,0x80100020,0x00108000,0x00100020,0x80008020,0x00000000,0x80000000,0x00008000,0x00108020,0x80100000,0x00100020,0x80000020,0x00000000,0x00108000,
 0x00008020,0x80108000,0x80100000,0x00008020,0x00000000,0x00108020,0x80100020,0x00100000,0x80008020,0x80100000,0x80108000,0x00008000,0x80100000,0x80008000,
 0x00000020,0x80108020,0x00108020,0x00000020,0x00008000,0x80000000,0x00008020,0x80108000,0x00100000,0x80000020,0x00100020,0x80008020,0x80000020,0x00100020,
 0x00108000,0x00000000,0x80008000,0x00008020,0x80000000,0x80100020,0x80108020,0x00108000
 };

 H aa_crypto_des_SB3[64] =
 {
 0x00000208,0x08020200,0x00000000,0x08020008,0x08000200,0x00000000,0x00020208,0x08000200,0x00020008,0x08000008,0x08000008,0x00020000,0x08020208,0x00020008,
 0x08020000,0x00000208,0x08000000,0x00000008,0x08020200,0x00000200,0x00020200,0x08020000,0x08020008,0x00020208,0x08000208,0x00020200,0x00020000,0x08000208,
 0x00000008,0x08020208,0x00000200,0x08000000,0x08020200,0x08000000,0x00020008,0x00000208,0x00020000,0x08020200,0x08000200,0x00000000,0x00000200,0x00020008,
 0x08020208,0x08000200,0x08000008,0x00000200,0x00000000,0x08020008,0x08000208,0x00020000,0x08000000,0x08020208,0x00000008,0x00020208,0x00020200,0x08000008,
 0x08020000,0x08000208,0x00000208,0x08020000,0x00020208,0x00000008,0x08020008,0x00020200
 };

 H aa_crypto_des_SB4[64] =
 {
 0x00802001,0x00002081,0x00002081,0x00000080,0x00802080,0x00800081,0x00800001,0x00002001,0x00000000,0x00802000,0x00802000,0x00802081,0x00000081,0x00000000,
 0x00800080,0x00800001,0x00000001,0x00002000,0x00800000,0x00802001,0x00000080,0x00800000,0x00002001,0x00002080,0x00800081,0x00000001,0x00002080,0x00800080,
 0x00002000,0x00802080,0x00802081,0x00000081,0x00800080,0x00800001,0x00802000,0x00802081,0x00000081,0x00000000,0x00000000,0x00802000,0x00002080,0x00800080,
 0x00800081,0x00000001,0x00802001,0x00002081,0x00002081,0x00000080,0x00802081,0x00000081,0x00000001,0x00002000,0x00800001,0x00002001,0x00802080,0x00800081,
 0x00002001,0x00002080,0x00800000,0x00802001,0x00000080,0x00800000,0x00002000,0x00802080
 };



 H aa_crypto_des_SB5[64] =
 {
 0x00000100,0x02080100,0x02080000,0x42000100,0x00080000,0x00000100,0x40000000,0x02080000,0x40080100,0x00080000,0x02000100,0x40080100,0x42000100,0x42080000,
 0x00080100,0x40000000,0x02000000,0x40080000,0x40080000,0x00000000,0x40000100,0x42080100,0x42080100,0x02000100,0x42080000,0x40000100,0x00000000,0x42000000,
 0x02080100,0x02000000,0x42000000,0x00080100,0x00080000,0x42000100,0x00000100,0x02000000,0x40000000,0x02080000,0x42000100,0x40080100,0x02000100,0x40000000,
 0x42080000,0x02080100,0x40080100,0x00000100,0x02000000,0x42080000,0x42080100,0x00080100,0x42000000,0x42080100,0x02080000,0x00000000,0x40080000,0x42000000,
 0x00080100,0x02000100,0x40000100,0x00080000,0x00000000,0x40080000,0x02080100,0x40000100
 };



 H aa_crypto_des_SB6[64] =
 {
 0x20000010,0x20400000,0x00004000,0x20404010,0x20400000,0x00000010,0x20404010,0x00400000,0x20004000,0x00404010,0x00400000,0x20000010,0x00400010,0x20004000,
 0x20000000,0x00004010,0x00000000,0x00400010,0x20004010,0x00004000,0x00404000,0x20004010,0x00000010,0x20400010,0x20400010,0x00000000,0x00404010,0x20404000,
 0x00004010,0x00404000,0x20404000,0x20000000,0x20004000,0x00000010,0x20400010,0x00404000,0x20404010,0x00400000,0x00004010,0x20000010,0x00400000,0x20004000,
 0x20000000,0x00004010,0x20000010,0x20404010,0x00404000,0x20400000,0x00404010,0x20404000,0x00000000,0x20400010,0x00000010,0x00004000,0x20400000,0x00404010,
 0x00004000,0x00400010,0x20004010,0x00000000,0x20404000,0x20000000,0x00400010,0x20004010
 };



 H aa_crypto_des_SB7[64] =
 {
 0x00200000,0x04200002,0x04000802,0x00000000,0x00000800,0x04000802,0x00200802,0x04200800,0x04200802,0x00200000,0x00000000,0x04000002,0x00000002,0x04000000,
 0x04200002,0x00000802,0x04000800,0x00200802,0x00200002,0x04000800,0x04000002,0x04200000,0x04200800,0x00200002,0x04200000,0x00000800,0x00000802,0x04200802,
 0x00200800,0x00000002,0x04000000,0x00200800,0x04000000,0x00200800,0x00200000,0x04000802,0x04000802,0x04200002,0x04200002,0x00000002,0x00200002,0x04000000,
 0x04000800,0x00200000,0x04200800,0x00000802,0x00200802,0x04200800,0x00000802,0x04000002,0x04200802,0x04200000,0x00200800,0x00000000,0x00000002,0x04200802,
 0x00000000,0x00200802,0x04200000,0x00000800,0x04000002,0x04000800,0x00000800,0x00200002
 };




 H aa_crypto_des_SB8[64] =
 {
 0x10001040,0x00001000,0x00040000,0x10041040,0x10000000,0x10001040,0x00000040,0x10000000,0x00040040,0x10040000,0x10041040,0x00041000,0x10041000,0x00041040,
 0x00001000,0x00000040,0x10040000,0x10000040,0x10001000,0x00001040,0x00041000,0x00040040,0x10040040,0x10041000,0x00001040,0x00000000,0x00000000,0x10040040,
 0x10000040,0x10001000,0x00041040,0x00040000,0x00041040,0x00040000,0x10041000,0x00001000,0x00000040,0x10040040,0x00001000,0x00041040,0x10001000,0x00000040,
 0x10000040,0x10040000,0x10040040,0x10000000,0x00040000,0x10001040,0x00000000,0x10041040,0x00040040,0x10000040,0x10040000,0x10001000,0x10001040,0x00000000,
 0x10041040,0x00041000,0x00041000,0x00001040,0x00001040,0x00040040,0x10000000,0x10041000
 };



 H aa_crypto_des_LHs[16] =
 {
 0x00000000,0x00000001,0x00000100,0x00000101,0x00010000,0x00010001,0x00010100,0x00010101,0x01000000,0x01000001,0x01000100,0x01000101,0x01010000,0x01010001,0x01010100,0x01010101
 };



 H aa_crypto_des_RHs[16] =
 {
 0x00000000,0x01000000,0x00010000,0x01010000,0x00000100,0x01000100,0x00010100,0x01010100,0x00000001,0x01000001,0x00010001,0x01010001,0x00000101,0x01000101,0x00010101,0x01010101,
 };



 #define aaDES_IP(XX,YY)                                  \
 {                                                        \
 TT=((XX>>4)^YY)&0x0F0F0F0F; YY^=TT; XX^=(TT<<4);         \
 TT=((XX>>16)^YY)&0x0000FFFF; YY^=TT; XX^=(TT<<16);       \
 TT=((YY>>2)^XX)&0x33333333; XX^=TT; YY^=(TT<<2);         \
 TT=((YY>>8)^XX)&0x00FF00FF; XX^=TT; YY^=(TT<<8);         \
 YY=((YY<<1)|(YY>>31))&0xFFFFFFFF;                        \
 TT=(XX^YY)&0xAAAAAAAA; YY^=TT; XX^=TT;                   \
 XX=((XX<<1)|(XX>>31))&0xFFFFFFFF;                        \
 }



 #define aaDES_FP(XX,YY)                                  \
 {                                                        \
 XX=((XX<<31)|(XX>>1))&0xFFFFFFFF;                        \
 TT=(XX^YY)&0xAAAAAAAA; XX^=TT; YY^=TT;                   \
 YY=((YY<<31)|(YY>>1))&0xFFFFFFFF;                        \
 TT=((YY>>8)^XX)&0x00FF00FF; XX^=TT; YY^=(TT<<8);         \
 TT=((YY>>2)^XX)&0x33333333; XX^=TT; YY^=(TT<<2);         \
 TT=((XX>>16)^YY)&0x0000FFFF; YY^=TT; XX^=(TT<<16);       \
 TT=((XX>>4)^YY)&0x0F0F0F0F; YY^=TT; XX^=(TT<<4);         \
 }




 #define aaDES_ROUND(XX,YY)                               \
 {                                                        \
 TT=*SK++^XX;                                             \
 YY^=aa_crypto_des_SB8[(TT)&0x3F]^                        \
     aa_crypto_des_SB6[(TT>>8)&0x3F]^                     \
     aa_crypto_des_SB4[(TT>>16)&0x3F]^                    \
     aa_crypto_des_SB2[(TT>>24)&0x3F];                    \
 TT=*SK++^((XX<<28)|(XX>>4));                             \
 YY^=aa_crypto_des_SB7[(TT)&0x3F]^                        \
     aa_crypto_des_SB5[(TT>>8)&0x3F]^                     \
     aa_crypto_des_SB3[(TT>>16)&0x3F]^                    \
     aa_crypto_des_SB1[(TT>>24)&0x3F];                    \
 }


 structure
 {
 H self_handle;
 B type;
 B state[258];
 _aa_crypto_des_context des_context;
 _aa_crypto_des3_context des3_context;
 }
 _aa_cryptoobject;


 structure
 {
 B object_id;
 }
 _aa_cryptosystem;

 B aa_CryptoSystemStart                (V);
 V aa_CryptoSystemStop                 (V);
 V aa_CryptoSystemProcess              (H SK[32],B key[8]);

/*-----------------------------------------------------------------------*/

 structure
 {
 H self_handle;
 _jsonstatus status;
 Z depth;
 B in_array;
 B last_enc_type;
 H dec_stage;
 H lines_allocated;
 H bytes_allocated;
 H bytes_left;
 _parser pa,pb;
 }
 _aa_jsonobject;



 structure
 {
 B object_id;
 }
 _aa_jsonsystem;



 B aa_JsonSystemStart                  (V);
 B aa_JsonSystemStop                   (V);
 B aa_JsonSystemExtendMemory           (PP mem,H by);
 B aa_JsonSystemDecoderType            (PP mem,B type,H off,H bytes,VP data);
 B aa_jsonSystemDecode                 (PP mem);


/*-----------------------------------------------------------------------*/


 structure
 {
 H next_iteration[128];
 }
 _aa_classsystem;

 B aa_ClassSystemStart                 (V);
 V aa_ClassSystemStop                  (V);


/*-----------------------------------------------------------------------*/


 #define aa_SETTINGS_ROOT              "aa\\Settings"

 structure
 {
 B rets;
 HKEY enum_key;
 }
 _aa_settingssystem;


 B aa_SettingsSystemStart              (V);
 V aa_SettingsSystemStop               (V);

/*-----------------------------------------------------------------------*/

 structure
 {
 B tmp;
 }
 _aa_clipboardsystem;


 B aa_ClipBoardSystemStart             (V);
 V aa_ClipBoardSystemStop              (V);

/*-----------------------------------------------------------------------*/

 //#define aa_IPCUSER_BYTES              _8K

 structure
 {
 H self_handle;
 H total_bytes;
 H user_bytes;
 H lock_deny_count;
 B rsvd[1016];
 }
 _ipcramhdr;


 structure
 {
 H self_handle;
 HANDLE object_handle;
 HANDLE mutex_handle;
 BP page_memory;
 _ipcstatus status;
 }
 _aa_ipcobject;


 structure
 {
 B object_id;
 }
 _aa_ipcsystem;


 B aa_IpcSystemStart                   (V);
 V aa_IpcSystemStop                    (V);

/*-----------------------------------------------------------------------*/



/*-----------------------------------------------------------------------*/



 structure
 {
 H self_handle;
 _desktopstatus status;
 H thread_id;
 HDESK desk_handle;
 HDESK original_handle;
 }
 _aa_desktopobject;


 structure
 {
 B object_id;
 }
 _aa_desktopsystem;


 B aa_DesktopSystemStart               (V);
 V aa_DesktopSystemStop                (V);

/*-----------------------------------------------------------------------*/



 structure
 {
 _aa_coresystem core_system;
 _aa_timersystem timer_system;
 _aa_memorysystem memory_system;
 _aa_pagesystem page_system;
 _aa_objectsystem object_system;
 _aa_threadsystem thread_system;
 _aa_poolsystem pool_system;
 _aa_processsystem process_system;
 _aa_fibersystem fiber_system;
 _aa_winenumsystem winenum_system;
 _aa_mathsystem math_system;
 _aa_dynbufsystem dynbuf_system;
 _aa_arraysystem array_system;
 _aa_quesystem que_system;
 _aa_generaleventsystem generalevent_system;
 _aa_netsystem net_system;
 _aa_fontsystem font_system;
 _aa_displaysystem display_system;
 _aa_surfacesystem surface_system;
 _aa_colorsystem color_system;
 _aa_gifsystem gif_system;
 _aa_cursorsystem cursor_system;
 _aa_appbarsystem appbar_system;
 _aa_inputsystem input_system;
 _aa_audiosystem audio_system;
 _aa_vidcapsystem vidcap_system;
 _aa_filestreamsystem filestream_system;
 _aa_fileboxsystem filebox_system;
 _aa_folderboxsystem folderbox_system;
 _aa_dirsystem dir_system;
 _aa_dirwalkersystem dirwalker_system;
 _aa_cpumonitorsystem cpumonitor_system;
 _aa_digestsystem digest_system;
 _aa_cryptosystem crypto_system;
 _aa_jsonsystem json_system;
 _aa_classsystem class_system;
 _aa_settingssystem settings_system;
 _aa_clipboardsystem clipboard_system;
 _aa_ipcsystem ipc_system;
 _aa_desktopsystem desktop_system;
 B is_diag_paused;
 B is_ready;
 }
 _aa;

 _aa                                   aa;


 B is_aa_quit_posted=NO;
 B is_aa_started=NO;
 B is_aa_started_by_winmain=NO;

 B aa_is_quit_called=NO;
 B aa_is_quit_received=NO;
 B aa_is_esc=NO;
 H aa_prevstage=0;
 H aa_nextstage=0;
 H aa_stage=0;
 B aa_i_am=0;
 H aa_craperr=0;
 B aa_is_64bit=NO;
 B aa_bigendian=NO;
 B aa_littleendian=NO;
 Q aa_cycle=0;
 B aa_firsttik_set=NO;
 H aa_firsttik=0;
 H aa_launchtik=0;
 H aa_discovery_id=0;
 D aa_askhz=0.0;
 D aa_curhz=0.0;
 D aa_curcpuload=0.0;
 D aa_curprocessload=0.0;
 D aa_avgcpuload=0.0;
 D aa_avgprocessload=0.0;
 Q aa_msrunning=0;
 Q aa_microsecsrunning=0;
 D aa_secsrunning=0;
 B aa_hide_diag=NO;
 B aa_hide_leak=NO;
 H aa_oof_count=0;
 Q aa_stats[50]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
 BP aa_cdecl;


 B aa_last_line_info[128]={0};

 C aa_last_executed[257]={0};


/*-----------------------------------------------------------------------*/

 _size aa_size_32x32  ={.w=32,.h=32 };
 _size aa_size_320x240={.w=320,.h=240 };
 _size aa_size_640x480={.w=640,.h=480 };
 _size aa_size_800x600={.w=800,.h=600 };
 _size aa_size_1024x768={.w=1024,.h=768 };

/*-----------------------------------------------------------------------*/



 N WINAPI aa_ExceptionHandler          (struct _EXCEPTION_POINTERS*exceptioninfo)
 {
 S B first_call=YES;
 B txt[_32K];
 H f,c,exa,ok,i,mx;
 //H adr,bytes,p;
 //B isaa,isvar;
 B fn[129];
 //VP proc;
 VP iproc[32];
 C path[_1K];
 C name[_1K];
 _aa_memoryheader*memhdr;

 GetCurrentDirectory(MAX_PATH,(CP)path);
 aaStringCopy(name,path);
 aaStringAppend(name,"\\aa_crash.txt");

 if(aa.core_system.is_restart_on_crash==YES)
  {
  if(aa_msrunning<aa.core_system.crash_msrunning_required)
   {
   if(first_call==YES) { aaJournal(name,"oops1"); first_call=NO;  }
   else                {  aaJournal(name,"oops2"); return(EXCEPTION_EXECUTE_HANDLER); }
   }
  else
   {
   if(first_call==YES) {  aaJournal(name,"oops3"); first_call=NO;  }
   else                {  aaJournal(name,"oops4"); return(EXCEPTION_EXECUTE_HANDLER); }
   }
  }
 else
  {
  if(first_call==YES) {  aaJournal(name,"oops5"); first_call=NO;  }
  else                {  aaJournal(name,"oops6"); return(EXCEPTION_EXECUTE_HANDLER); }
  }
 aaStringNull(txt);
 aaStringAppendf(txt,"\r\n");
 aaStringAppendf(txt,"------------------------------------------------------\r\n");
 aaStringAppendf(txt,"**aaBoost has crashed**\r\n");
 aaStringAppendf(txt,"process_id=%i\r\n",aa.core_system.process_id);
 aaStringAppendf(txt,"------------------------------------------------------\r\n");
 switch(exceptioninfo->ExceptionRecord->ExceptionCode)
  {
  case EXCEPTION_ACCESS_VIOLATION:               aaStringAppendf(txt,"REASON: access violation\r\n"); break;
  case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:          aaStringAppendf(txt,"REASON: array bounds\r\n"); break;
  case EXCEPTION_BREAKPOINT:                     aaStringAppendf(txt,"REASON: breakpoint\r\n"); break;
  case EXCEPTION_DATATYPE_MISALIGNMENT:          aaStringAppendf(txt,"REASON: data misalignment\r\n"); break;
  case EXCEPTION_FLT_DENORMAL_OPERAND:           aaStringAppendf(txt,"REASON: denormal operand\r\n"); break;
  case EXCEPTION_FLT_DIVIDE_BY_ZERO:             aaStringAppendf(txt,"REASON: divide by zero\r\n"); break;
  case EXCEPTION_FLT_INEXACT_RESULT:             aaStringAppendf(txt,"REASON: inexact resultr\r\n"); break;
  case EXCEPTION_FLT_INVALID_OPERATION:          aaStringAppendf(txt,"REASON: invalid operation\r\n"); break;
  case EXCEPTION_FLT_OVERFLOW:                   aaStringAppendf(txt,"REASON: overflow\r\n"); break;
  case EXCEPTION_FLT_STACK_CHECK:                aaStringAppendf(txt,"REASON: stack check\r\n"); break;
  case EXCEPTION_FLT_UNDERFLOW:                  aaStringAppendf(txt,"REASON: underflow\r\n"); break;
  case EXCEPTION_ILLEGAL_INSTRUCTION:            aaStringAppendf(txt,"REASON: illegal instruction\r\n"); break;
  case EXCEPTION_IN_PAGE_ERROR:                  aaStringAppendf(txt,"REASON: in page\r\n"); break;
  case EXCEPTION_INT_DIVIDE_BY_ZERO:             aaStringAppendf(txt,"REASON: INT divide zero\r\n"); break;
  case EXCEPTION_INT_OVERFLOW:                   aaStringAppendf(txt,"REASON: INT overflow\r\n"); break;
  case EXCEPTION_INVALID_DISPOSITION:            aaStringAppendf(txt,"REASON: invalid disposition\r\n"); break;
  case EXCEPTION_NONCONTINUABLE_EXCEPTION:       aaStringAppendf(txt,"REASON: noncommutable exception\r\n"); break;
  case EXCEPTION_PRIV_INSTRUCTION:               aaStringAppendf(txt,"REASON: priv instruction\r\n"); break;
  case EXCEPTION_SINGLE_STEP:                    aaStringAppendf(txt,"REASON: single step\r\n"); break;
  case EXCEPTION_STACK_OVERFLOW:                 aaStringAppendf(txt,"REASON: stack overflow\r\n"); break;
  default:                                       aaStringAppendf(txt,"REASON: Unknown %08lx\r\n",exceptioninfo->ExceptionRecord->ExceptionCode); break;
  }
 aaStringAppendf(txt,"FLAGS: %lu\r\n",exceptioninfo->ExceptionRecord->ExceptionFlags);
 exa=(H)exceptioninfo->ExceptionRecord->ExceptionAddress;
 aaStringAppendf(txt,"ADDRESS OF CRASH: %p\r\nlast_line_executed=%u\r\n",exa,aa_last_line_executed);
 if(aa_last_line_info[0]) { aaStringAppendf(txt,"last_info=%s\r\n",aa_last_line_info); }
 if(aa_last_executed[0]) { aaStringAppendf(txt,"last_executed=%s\r\n",aa_last_executed); }
 aaMemoryZero(iproc,sizeof(iproc));
 while(1)
  {
  c=0;
  iproc[c]=__builtin_return_address(0);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  iproc[c]=__builtin_return_address(1);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  iproc[c]=__builtin_return_address(2);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  iproc[c]=__builtin_return_address(3);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  iproc[c]=__builtin_return_address(4);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  iproc[c]=__builtin_return_address(5);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  iproc[c]=__builtin_return_address(6);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  iproc[c]=__builtin_return_address(7);  if(iproc[c]==NULL||iproc[c]==0) break; c++;
  break;
  }
 if(aa.core_system.is_restart_on_crash==NO)
  {
  aaNote(0,"r\r\n%s",txt);
  }
 else
  {
  aaHistory(__LINE__,"%s %s",__FILE__,txt);
  }

  if(aa_hide_leak==NO)
   {
   mx=aaElementCount(aa.memory_system.table.block);
   for(i=0;i<mx;i++)
    {
    if(aa.memory_system.table.block[i]!=NULL)
     {
     memhdr=(_aa_memoryheader*)aa.memory_system.table.block[i];
     aaLog(-555," Block[%-4i]=%p bytes=%-8u prot=%-3s locked=%-3s user=%-3s realloc=%-8u (%s)",
     i,memhdr,memhdr->bytes,
     aaBoolString(memhdr->is_protected),
     aaBoolString(memhdr->is_locked),
     aaBoolString(memhdr->is_user),
     memhdr->realloc_count,
     memhdr->name);
     }
    }
   }


 ok=NO;
 aaStringNull(fn);



 if(aa.core_system.is_restart_on_crash==NO)
  {
  if(ok)
   {
   ///aaStringAppendf(txt,"Function index %i  [%s]  (offset: %lu bytes)  \n",p,fn,aaNumAbs((N)exa-(N)adr));
   }
  for(f=0;f<32;f++)
   {
   if(iproc[f]==0) break;
   if(f==0) { aaStringAppendf(txt,"__builtin_return_address\r\n"); }
   aaStringAppendf(txt,"[%i]=%p",f,iproc[f]);
   aaStringAppendf(txt,"\r\n");
   }
  aaJournal(name,"%s",txt);
  aaNote(0,"z %s",txt);
  }
 aaLog(-1,"\n\n\n\n\n%s",txt);
 if(aa.core_system.is_restart_on_crash==YES&&aa_msrunning>=aa.core_system.crash_msrunning_required)
  {
  aaHistory(__LINE__,"%s",__FILE__);
  aaMorph(aa.core_system.module_filename,aa.core_system.command_line);
  aaQuit();
  aaStop();
  return(EXCEPTION_EXECUTE_HANDLER);
  }
 return(EXCEPTION_EXECUTE_HANDLER);
 }


/*-----------------------------------------------------------------------*/


 structure                             {Q dummyq; H dummyh; B dummyb; } _packdummy;


 B aaStart                             (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,Z cmdshow)
 {
 B ret;
 H val;
 BP bp;

 ///OutputDebugString("func-aaStart");
 #if aa_USE_GLOBAL_MUTEX == 1
 InitializeCriticalSection(&global_mutex);
 #endif
 if(sizeof(_packdummy)!=13) { aaNote(0,"-fpack-struct not enabled"); return 0; }
 if(is_aa_started==YES) { oof; return RET_INUSE; }
 ///if(setjmp(aa_jmp_buf)!=0)   { return RET_FAILED; } //oof; return(aaStop());   }
 val=0x01020304;
 bp=(BP)&val;
 if(*bp==1) { aa_bigendian=YES; aa_littleendian=NO; }
 else       { aa_bigendian=NO; aa_littleendian=YES; }
 is_aa_started=YES;
 while(1)
  {
  if(GetFileAttributes("C:\\i_am_ashod.tag")!=F32) { aa_i_am='A'; break; }
  break;
  }

 #if aa_DIAGNOSE == YES
  {
  H go;
  HP hp;
  aaCast(hp,HP,aa_diag_hits);
  for(go=0;go<(sizeof(aa_diag_hits)/4);go++) hp[go]=0;
  aaCast(hp,HP,aa_diag_cycle);
  for(go=0;go<(sizeof(aa_diag_cycle)/4);go++) hp[go]=0;
 // for(go=0;go<aa_SHOW_CRASHTRACE_LEN;go++) { aa_diag_last_line[go]=0;}
  aa_diag_hi=aa_diag_lo=0;
  }
 #endif
 if((ret=aa_CoreSystemStart(thisinst,previnst,cmdline,cmdshow))!=YES) { return ret; }
 ///OutputDebugString("aaStart returned from aa_coresystemstart");
 aa_TimerSystemStart();
 aa_MemorySystemStart();
 aa_TimerSystemCpuSpeedGet();
 aa_PageSystemStart();
 aa_ObjectSystemStart();
 aa_ThreadSystemStart();
 aa_PoolSystemStart();
 aa_ProcessSystemStart();
 aa_FiberSystemStart();
 aa_WinEnumSystemStart();
 aa_MathSystemStart();
 aa_DynbufSystemStart();
 aa_ArraySystemStart();
 aa_QueSystemStart();
 aa_GeneralEventSystemStart();
 if((ret=aa_NetSystemStart())!=YES) { return ret; }
 aa_FontSystemStart();
 aa_DisplaySystemStart();
 aa_SurfaceSystemStart();
 aa_CursorSystemStart();
 aa_AppBarSystemStart();
 aa_ColorSystemStart();
 aa_GifSystemStart();
 aa_InputSystemStart();
 aa_AudioSystemStart();
 aa_VidCapSystemStart();
 aa_FileStreamSystemStart();
 aa_FileBoxSystemStart();
 aa_FolderBoxSystemStart();
 aa_DirSystemStart();
 aa_DirWalkerSystemStart();
 aa_CpuMonitorSystemStart();
 aa_DigestSystemStart();
 aa_CryptoSystemStart();
 aa_JsonSystemStart();
 aa_ClassSystemStart();
 aa_SettingsSystemStart();
 aa_ClipBoardSystemStart();
 aa_IpcSystemStart();
 aa_DesktopSystemStart();
 ///OutputDebugString("line 4264");
 aa_CoreSystemLogStateSet(1);
 aaTimerTikElapsed(aa.core_system.aamain_tik,&aa.core_system.aamain_elapsed);
 aa.is_ready=YES;
 //if(setjmp(aa_jmp_buf)!=0)   { return RET_FAILED; } //oof; return(aaStop());   }
 return RET_YES;
 }





 Z aaStop                              (V)
 {
 H go,i,mx;

 //////////////////////////////////////////////////////////////////////////////////////////////
 if(is_aa_started_by_winmain==YES&&is_aa_quit_posted==NO) {   PostQuitMessage(1); }
 /////////////////////
 //aaLog(-1,"line=%i",__LINE__);
 aa_last_line_executed=__LINE__;
 for(go=0;go<1000;go++)
  {
  if(aa.core_system.wm_quit_received==YES) {  break; }
  aa_CoreSystemLoop();
  aaSleep(2);
  }
 /////////////////////
 //aaLog(-1,"line=%i",__LINE__);
 //aaLog(-1,"Bytes allocated = %i ,  blocks allocated = %i",aa.memory_system.status.bytes_allocated,aa.memory_system.status.blocks_allocated);
 //aaLog(-1,"pages allocated = %i ,  pages commited = %i\r\n",aa.page_system.pages_allocated,aa.page_system.pages_commited);
//aaLog(-1,"line=%i",__LINE__);
 mx=aaElementCount(aa.core_system.RoutineProcStop);
 for(i=0;i<mx;i++)
  {
  if(aa.core_system.RoutineProcStop[mx-i-1]!=NULL)
   {
   aa.core_system.RoutineProcStop[mx-i-1](aa.core_system.RoutineParmStop[mx-i-1]);
   }
  aa.core_system.RoutineProcStop[mx-i-1]=NULL;
  aa.core_system.RoutineProcYield[mx-i-1]=NULL;
  aa.core_system.RoutineParmStop[mx-i-1]=NULL;
  aa.core_system.RoutineParmYield[mx-i-1]=NULL;
  }
 aa_DesktopSystemStop();
 aa_IpcSystemStop();
 aa_ClipBoardSystemStop();
 aa_SettingsSystemStop();
 aa_ClassSystemStop();
 aa_JsonSystemStop();
 aa_CryptoSystemStop();
 aa_DigestSystemStop();
 aa_CpuMonitorSystemStop();
 aa_DirWalkerSystemStop();
 aa_DirSystemStop();
 aa_FolderBoxSystemStop();
 aa_FileBoxSystemStop();
 aa_FileStreamSystemStop();
 aa_VidCapSystemStop();
 aa_AudioSystemStop();
 aa_InputSystemStop();
 aa_GifSystemStop();
 aa_ColorSystemStop();
 aa_AppBarSystemStop();
 aa_CursorSystemStop();
 aa_SurfaceSystemStop();
 aa_DisplaySystemStop();
 aa_FontSystemStop();
 aa_NetSystemStop();
 aa_GeneralEventSystemStop();
 aa_QueSystemStop();
 aa_ArraySystemStop();
 aa_DynbufSystemStop();
 aa_MathSystemStop();
 aa_WinEnumSystemStop();
 aa_FiberSystemStop();
 aa_ProcessSystemStop();
 aa_PoolSystemStop();
 aa_ThreadSystemStop();
 aa_ObjectSystemStop();
 aa_PageSystemStop();
 aa_MemorySystemStop();
 aa_TimerSystemStop();
 aa_CoreSystemStop();
 aa_last_line_executed=__LINE__;

 while(1)
 {
 if(aa_hide_diag==YES) { break; }
 #if aa_DIAGNOSE == YES
  {
  H sx,i,tik,el,cc,tmpcnt,tmpline;
  C tmpname[64];
  C txt[_1K];
  D d1,d2,gt,pc;
  H yz=0;
  N j,dif,flp;
  tik=GetTickCount();
  if(tik>=aa.core_system.launch_tik)   {  el=tik-aa.core_system.launch_tik;            }
  else                                   {  el=(F32-aa.core_system.launch_tik)+(tik+1);  }
  gt=aa_diag_hi*1000.0;
  gt=gt+aa_diag_lo;
  pc=100.0/gt;
  cc=0;
  for(i=0;i<aa_SHOW_DIAG_LINES;i++)  {  if(aa_diag_text[i][0]!=NULL_CHAR)  { aa_diag_hits[cc]=aa_diag_hits[i];  aa_diag_line[cc]=aa_diag_line[i];   strcpy(aa_diag_text[cc],aa_diag_text[i]);   cc++;  }  }
  //aaLog(-555,"cc=%i",cc);
  for(i=1;i<cc;i++)
   {
   tmpname[0]=0;
   tmpcnt=aa_diag_hits[i];
   tmpline=aa_diag_line[i];
   strcpy(tmpname,aa_diag_text[i]);
   j=i-1;
   while(j>=0)
    {
    if(tmpcnt<aa_diag_hits[j]) { break; }
    aa_diag_hits[j+1]=aa_diag_hits[j];
    strcpy(aa_diag_text[j+1],aa_diag_text[j]);
    aa_diag_line[j+1]=aa_diag_line[j];
    j--;
    }
   aa_diag_hits[j+1]=tmpcnt;
   aa_diag_line[j+1]=tmpline;
   strcpy(aa_diag_text[j+1],tmpname);
   }
  d1=(D)el;
  d1=d1/1000.0;
  d1=gt/(d1+0.0001);
  aaLog(-555,"");
  aaLog(-555,"==================================================================================");
  aaLog(-555,"Diagnosis: %.0f calls made by %i functions, in %i ms, apx %.0f calls/sec",gt,cc,el,d1);
  aaLog(-555,"==================================================================================");
  aaLog(-555,"");
  if(el<=1000)
   {
   gt=1000.0/el;
   //gt=1.0/gt;
   if(gt!=0&&aa.memory_system.status.fill_calls!=0)
    {
    aaLog(-555,"MEMORY FILL: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",
               (Q)(aa.memory_system.status.bytes_filled/gt)/1024,(Q)aa.memory_system.status.bytes_filled/1024,(Q)aa.memory_system.status.fill_calls,(Q)(aa.memory_system.status.bytes_filled/aa.memory_system.status.fill_calls)/1024);
    }
   if(gt!=0&&aa.memory_system.status.copy_calls!=0)
    {
    aaLog(-555,"MEMORY COPY: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",(Q)
                (aa.memory_system.status.bytes_copied/gt)/1024,(Q)aa.memory_system.status.bytes_copied/1024,(Q)aa.memory_system.status.copy_calls,(Q)(aa.memory_system.status.bytes_copied/aa.memory_system.status.copy_calls)/1024);
    }
   }
  else
   {
   gt=el/1000.0;
   if(gt!=0&&aa.memory_system.status.fill_calls!=0)
    {
    aaLog(-555,"MEMORY FILL: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",
               (Q)(aa.memory_system.status.bytes_filled/gt)/1024,(Q)aa.memory_system.status.bytes_filled/1024,(Q)aa.memory_system.status.fill_calls,(Q)(aa.memory_system.status.bytes_filled/aa.memory_system.status.fill_calls)/1024);
    }
   if(gt!=0&&aa.memory_system.status.copy_calls!=0)
    {
    aaLog(-555,"MEMORY COPY: %9I64u k/s %9I64u KiloBytes  %I64u calls  %I64u KB/call",(Q)
                (aa.memory_system.status.bytes_copied/gt)/1024,(Q)aa.memory_system.status.bytes_copied/1024,(Q)aa.memory_system.status.copy_calls,(Q)(aa.memory_system.status.bytes_copied/aa.memory_system.status.copy_calls)/1024);
    }
   }
  aaLog(-555,"");
  aaLog(-555,"GLOBALALLOC: CALLS=%u %I64u KiloBytes",aa.memory_system.status.globalalloc_calls,(Q)aa.memory_system.status.globalalloc_bytes/1024);
  aaLog(-555,"");
  aaLog(-555,"MEMORY PEAK: ALLOC=%.2f Megs  USER ALLOC=%.2f Megs",(aa.memory_system.status.peak_bytes_allocated)/1048576.0,  (aa.memory_system.status.peak_user_bytes_allocated)/1048576.0);
  aaLog(-555,"");
  for(sx=0;sx<256;sx++)
   {
   if(aa.memory_system.temp_bytes[sx]!=0)
    {
    aaLog(-555,"MEMORY TEMP: [%3i] = %u bytes ( %u allocs , %u reallocs ) ",sx,aa.memory_system.temp_bytes[sx],aa.memory_system.temp_allocs[sx],aa.memory_system.temp_reallocs[sx]);
    }
   }
  aaLog(-555,"");
  for(sx=0;sx<cc;sx++)
   {
   if(aaStringICompare(aa_diag_text[sx],"aaYield",0)==YES)
    {
    d1=(D)aa_diag_hits[sx]/gt;
    yz=(H)d1;
    aaLog(-555,"OS MEMALOCS: %lu",aa.memory_system.alloc_calls);
    aaLog(-555,"OS MEMRALCS: %lu",aa.memory_system.realloc_calls);
    aaLog(-555,"OS MEMRELES: %lu",aa.memory_system.release_calls);
    aaLog(-555,"");
    aaLog(-555,"      YIELD: %.1fhz",yz/1.0);
    aaLog(-555,"     CYCLES: %I64u",aa.core_system.cycle);
    aaLog(-555,"    RUNTIME: %.2f secs",el/1000.0);
    aaLog(-555,"");
    aaLog(-555,"   WM_TOTAL: %I64u",aa.core_system.wm_msg_count_total);
    aaLog(-555,"WM_SURFACED: %I64u",aa.core_system.wm_msg_count_surfaced);
    aaLog(-555,"WM_ERASEBKG: %I64u",aa.core_system.wm_msg_count_erasebg);
    aaLog(-555,"   WM_PAINT: %I64u",aa.core_system.wm_msg_count_paint);
    aaLog(-555,"WM_UNHANDLD: %I64u",aa.core_system.wm_msg_count_unhandled);
    aaLog(-555,"------------------------------------------------------------------------------------------------------------------------------");
    break;
    }
   }
  if(gt==0) { gt=1; }
  flp=0;
  if(yz==0) { yz=1; }
  for(sx=0;sx<cc;sx++)
   {
   d1=(D)aa_diag_hits[sx]*pc;
   d2=(D)aa_diag_hits[sx]/gt;
   dif=(N)d2-(N)yz;
   txt[1]=0;
   if(dif>=-1&&dif<=1) { txt[0]='*';   } else { txt[0]=32; }
   if(dif==0)    {    if(flp==0) {  aaLog(-555," "); flp=1; }    }
   else          {    if(flp==1) {  aaLog(-555," "); flp=2; }    }
   if(d2<1.0)    {    if(flp==2) {  aaLog(-555," "); flp=3; }    }
   aaLog(-555," %-5i %37s  %8.2f Hz  %8.3f Yz  %11.0f calls  %6.3f %%  %s",aa_diag_line[sx],aa_diag_text[sx],d2,d2/(D)yz,aa_diag_hits[sx],d1,txt);
   }
  aaLog(-555,"");
  aaLog(-555,"Object Check Hits");
  aaLog(-555,"-----------------");
  for(sx=0;sx<256;sx++)
   {
   if(aa.object_system.object_check_count[sx]!=0)
    {
    aaLog(-555,"Object %-15s=%I64u",aa.object_system.object[sx].name,aa.object_system.object_check_count[sx]);
    }
   }
  aaLog(-555,"");
  aaLogStructSize(_arraystatus);
  aaLogStructSize(_threadstatus);
  aaLogStructSize(_classstatus);
  aaLogStructSize(_fiberstatus);
  aaLogStructSize(_jsonstatus);
  aaLogStructSize(_dynbufstatus);
  aaLogStructSize(_questatus);
  aaLogStructSize(_gifstatus);
  aaLogStructSize(_ipcstatus);
  aaLogStructSize(_winenumstatus);
  aaLogStructSize(_sniffstatus);
  aaLogStructSize(_poolstatus);
  aaLogStructSize(_digeststatus);
  aaLogStructSize(_stunclientstatus);
  aaLogStructSize(_icmpstatus);
  aaLogStructSize(_tcpportstatus);
  aaLogStructSize(_fontstatus);
  aaLogStructSize(_cgiclientstatus);
  aaLogStructSize(_serverstatus);
  aaLogStructSize(_udpstatus);
  aaLogStructSize(_audiostatus);
  aaLogStructSize(_desktopstatus);
  aaLogStructSize(_dirstatus);
  aaLogStructSize(_tcpcallstatus);
  aaLogStructSize(_filestreamstatus);
  aaLogStructSize(_inputstate);
  aaLogStructSize(_surfacestatus);
  aaLogStructSize(_vidcapstatus);
  aaLogStructSize(_folderboxstatus);
  aaLogStructSize(_netstatus);
  aaLogStructSize(_memorystatus);
  aaLogStructSize(_memorystatus);
  aaLogStructSize(_processstatus);
  aaLogStructSize(_inputengine);
  aaLogStructSize(_mysqlbeautifier);
  aaLogStructSize(_wockstatus);
  aaLogStructSize(_mysql);
  aaLogStructSize(_dnsstatus);
  aaLogStructSize(_fileboxstatus);
  aaLog(-555,"==================================================================================");
  aaLog(-555,"");
  }
 #endif
 break;
 }

 if(aa.core_system.is_morph_pending)
  {
  aaLog(-555,"morph is pending, about to resume");
  aaLimiterSet(0,0);
  aaSleep(10); // this used to be Sleep(100) ..
  aaLog(-555,"resu=%i",ResumeThread(aa.core_system.morph_pi.hThread));
  }
 logg("Calling ExitProcess(%i)",aa.core_system.wm_quit_exitcode);
 logg("");
 logg("~-");
 #if aa_DIAGNOSE == YES
 if(aa_hide_diag!=YES)
  {
  aaLog(-555,"\n\naaBoost stopped: after %ims",GetTickCount()-aa.core_system.launch_tik);
  }
 #endif

 #ifdef __BORLANDC__
 if(aa.core_system.in_debugger==YES)  { aaFocusToBorland(); }
 #endif
 //aaLog(-777,"ended %lu",GetTickCount());
//aaFocusToCodeBlocks();
 timeEndPeriod(1);
 #if aa_USE_GLOBAL_MUTEX == 1
 DeleteCriticalSection(&global_mutex);
 #endif
 return aa.core_system.wm_quit_exitcode;
 }







 B aaExitCodeSet                       (H code)
 {
 aa.core_system.is_exitcode_set=YES;
 aa.core_system.set_exitcode=code;
 return RET_YES;
 }


 //structure                             {Q dummyq; H dummyh; B dummyb; } _packdummy;


 #ifdef IS_A_DLL


 BOOL WINAPI DllMain                   (HINSTANCE thisinst,DWORD fdwReason,LPVOID lpReserved )
 {
 H ec;
 UNUSE(lpReserved);

 if(aa_firsttik_set==NO) { aa_firsttik=GetTickCount(); aa_firsttik_set=YES; }
 switch( fdwReason )
  {
  case DLL_PROCESS_ATTACH:
  if(sizeof(_packdummy)!=13) { MessageBox(NULL,(char*)"pattach","-fpack-struct not enabled",MB_OK); return 0; }
  if(aaStart(thisinst,0,0,SW_SHOWDEFAULT)!=YES) {  return 0; }
  is_aa_started_by_winmain=YES;
  if(setjmp(aa_jmp_buf)!=0)   {  return(aaStop());   }
  break;
  case DLL_THREAD_ATTACH:
  MessageBox(NULL,(char*)"tattach"," ",MB_OK);
  break;
  case DLL_THREAD_DETACH:
  MessageBox(NULL,(char*)"tdettach"," ",MB_OK);
  break;
  case DLL_PROCESS_DETACH:
  ec=aaStop();
  if(aa.core_system.is_exitcode_set)  {  return aa.core_system.set_exitcode;  }
  break;
  }
 return TRUE;
 }



#else



 Z WINAPI WinMain                      (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,Z cmdshow)
 {
 H ec;

 ///OutputDebugString("WinMain");
 if(sizeof(_packdummy)!=13) { aaNote(0,"-fpack-struct not enabled"); return 0; }
 if(aa_firsttik_set==NO) { aa_firsttik=GetTickCount(); aa_firsttik_set=YES; }
 if(aaStart(thisinst,previnst,cmdline,cmdshow)!=YES) {  return 0; }
 is_aa_started_by_winmain=YES;
 if(setjmp(aa_jmp_buf)!=0)   {  return(aaStop());   }
 if(!aa_is_quit_called) { aaMain(); }
 ec=aaStop();
 if(aa.core_system.is_exitcode_set)  {  return aa.core_system.set_exitcode;  }
 return ec;
 }




#endif



 B WinFileTimeToSysTime                (FILETIME*filetime,_systime*systime)
 {
 SYSTEMTIME st;
 FILETIME ft;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filetime==NULL) { return RET_BADPARM; }
 if(systime==NULL) { return RET_BADPARM; }
 #if 1
 if(FileTimeToLocalFileTime(filetime,&ft)==0) { return RET_FAILED; }
// if(FileTimeToSystemTime(filetime,&st)==0) { return RET_FAILED; }
 if(FileTimeToSystemTime(&ft,&st)==0) { return RET_FAILED; }
 #else
 if(FileTimeToLocalFileTime(filetime,&st)==0) { return RET_FAILED; }
// if(FileTimeToSystemTime(&ft,&st)==0) { return RET_FAILED; }
 #endif
 systime->dow=st.wDayOfWeek;
 systime->year=st.wYear;
 systime->month=st.wMonth;
 systime->date=st.wDay;
 systime->hour=st.wHour;
 systime->minute=st.wMinute;
 systime->second=st.wSecond;
 systime->ms=st.wMilliseconds;
 systime->gmt_dif=0;
 return RET_YES;
 }






 B WinSystemTimeToSysTime              (SYSTEMTIME*systemtime,_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systemtime==NULL) { return RET_BADPARM; }
 if(systime==NULL) { return RET_BADPARM; }
 systime->dow=systemtime->wDayOfWeek;
 systime->year=systemtime->wYear;
 systime->month=systemtime->wMonth;
 systime->date=systemtime->wDay;
 systime->hour=systemtime->wHour;
 systime->minute=systemtime->wMinute;
 systime->second=systemtime->wSecond;
 systime->ms=systemtime->wMilliseconds;
 systime->gmt_dif=0;
 return RET_YES;
 }





 B WinSystemTimeFromSysTime            (SYSTEMTIME*systemtime,_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systemtime==NULL) { return RET_BADPARM; }
 if(systime==NULL) { return RET_BADPARM; }
 systemtime->wDayOfWeek=(W)systime->dow;
 systemtime->wYear=(W)systime->year;
 systemtime->wMonth=(W)systime->month;
 systemtime->wDay=(W)systime->date;
 systemtime->wHour=(W)systime->hour;
 systemtime->wMinute=(W)systime->minute;
 systemtime->wSecond=(W)systime->second;
 systemtime->wMilliseconds=(W)systime->ms;
 return RET_YES;
 }





 B WinSystemTimeCopy                   (SYSTEMTIME*systemtime,SYSTEMTIME*ssystemtime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systemtime==NULL) { return RET_BADPARM; }
 if(ssystemtime==NULL) { return RET_BADPARM; }
 systemtime->wDayOfWeek=ssystemtime->wDayOfWeek;
 systemtime->wYear=ssystemtime->wYear;
 systemtime->wMonth=ssystemtime->wMonth;
 systemtime->wDay=ssystemtime->wDay;
 systemtime->wHour=ssystemtime->wHour;
 systemtime->wMinute=ssystemtime->wMinute;
 systemtime->wSecond=ssystemtime->wSecond;
 systemtime->wMilliseconds=ssystemtime->wMilliseconds;
 return RET_YES;
 }




 B WinErrorStringGet                   (VP string,H line)
 {
 B txt[_1K];
 DWORD ea,eb;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ea=GetLastError();
 if(string!=NULL) { aaStringNull(string); }
 aaStringNull(txt);
 eb=FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL,ea,MAKELANGID(LANG_NEUTRAL,SUBLANG_DEFAULT),(LPTSTR)txt,_1K,NULL);
 if(eb==0) { return RET_FAILED; }
 aaStringAppendf(txt,"\nerrorcode=%u (0x%08x)\nline=%i",ea,ea,line);
 if(string!=NULL)  { aaStringCopyf(string,"%s",txt);  }
 else              { aaNote(0,"%s",txt);  }
 return RET_YES;
 }






 B WinSockAddrSet                      (struct sockaddr_in*addr,W family,H ip,W port)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(addr==NULL) { return RET_BADPARM; }
 aaMemoryFill(addr,sizeof(struct sockaddr_in),0);
 addr->sin_family=family;
 *(HP)&addr->sin_addr=ip;
 addr->sin_port=port;
 return RET_YES;
 }



 B WinPointCopy                        (POINT*point,POINT*spoint)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(point==NULL)   { return RET_BADPARM; }
 if(spoint==NULL)   { return RET_BADPARM; }
 point->x=spoint->x;
 point->y=spoint->y;
 return RET_YES;
 }


 B WinPointSet                         (POINT*point,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(point==NULL)   { return RET_BADPARM; }
 point->x=x;
 point->y=y;
 return RET_YES;
 }



 B WinPointToCord                      (POINT*point,_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(point==NULL) { return RET_BADPARM; }
 return(aaCordSet(cord,point->x,point->y));
 }



 B WinRectSet                          (RECT*rect,N x,N y,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL)  { return RET_BADPARM; }
 rect->left=x;
 rect->top=y;
 rect->right=rect->left+w;
 rect->bottom=rect->top+h;
 return RET_YES;
 }




 B WinRectToRect                       (RECT*rect,_rect*rect2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 return(aaRectSet(rect2,rect->left,rect->top,(rect->right-rect->left),(rect->bottom-rect->top)));
 }



 B WinRectCopy                         (RECT*rect,RECT*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(srect==NULL) { return RET_BADPARM; }
 rect->left=srect->left;
 rect->right=srect->right;
 rect->top=srect->top;
 rect->bottom=srect->bottom;
 return RET_YES;
 }


 B WinRectFromRect                     (RECT*rect,_rect*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(srect==NULL) { return RET_BADPARM; }
 rect->left=srect->x;
 rect->top=srect->y;
 rect->right=rect->left+srect->w;
 rect->bottom=rect->top+srect->h;
 return RET_YES;
 }




 B WinBmpInfoSet                       (BITMAPINFO*bmi,H w,H h,B bits,B negheight)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bmi==NULL) { return RET_BADPARM; }
 if(w==0) { return RET_BADPARM; }
 if(h==0) { return RET_BADPARM; }
 #if aa_VIDCAP_ALLOW_YUY2==YES
 if(bits!=11&&bits!=12&&bits!=13&&bits!=15&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #else
 if(bits!=11&&bits!=12&&bits!=15&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #endif
 aaMemoryFill(bmi,sizeof(BITMAPINFOHEADER),0);
 bmi->bmiHeader.biSize=sizeof(BITMAPINFOHEADER);
 bmi->bmiHeader.biWidth=w;
 if(negheight==YES) { bmi->bmiHeader.biHeight=aaNumNeg((N)h); }
 else                 { bmi->bmiHeader.biHeight=h; }
 bmi->bmiHeader.biPlanes=1;
 bmi->bmiHeader.biBitCount=bits;                   // IYUV ??
 if(bits==11) { bmi->bmiHeader.biBitCount=12; bmi->bmiHeader.biCompression=VAL_IYUV; bmi->bmiHeader.biSizeImage=(w*h)+((w*h)/2);    }
 else
 if(bits==12) { bmi->bmiHeader.biBitCount=12; bmi->bmiHeader.biCompression=VAL_I420; bmi->bmiHeader.biSizeImage=(w*h)+((w*h)/2);    }
 else
 if(bits==13) { bmi->bmiHeader.biBitCount=16; bmi->bmiHeader.biCompression=VAL_YUY2; bmi->bmiHeader.biSizeImage=(w*h*2)+((((w/2)*h))*2);   }
 else           { bmi->bmiHeader.biCompression=BI_RGB; bmi->bmiHeader.biSizeImage=(w*h)*(bits/7);  }
 return RET_YES;
 }




 B WinWaveHdrSet                       (WAVEHDR*hdr,LPSTR dat,H buflen,B bytesrec,H user,H flags)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hdr==NULL) { return RET_BADPARM; }
 if(dat==NULL) { return RET_BADPARM; }
 hdr->lpData=dat;
 hdr->dwBufferLength=buflen;
 hdr->dwBytesRecorded=bytesrec;
 hdr->dwUser=user;
 hdr->dwFlags=flags;
 hdr->dwLoops=0;
 hdr->lpNext=0;
 hdr->reserved=0;
 return RET_YES;
 }


 B WinWaveFormatExSet                  (WAVEFORMATEX*wfx,W tag,H sampssec,W channels,W bits,W cbsize)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) {  return RET_BADPARM; }
 if(tag==0) {   return RET_BADPARM; }
 if(channels==0) {  return RET_BADPARM; }
 if(sampssec==0) {  return RET_BADPARM; }
 aaMemoryFill(wfx,sizeof(WAVEFORMATEX),0);
 if(bits==0) { bits=16; }
 wfx->wFormatTag=tag;
 wfx->nChannels=channels;
 wfx->nSamplesPerSec=sampssec;
 wfx->wBitsPerSample=bits;
 wfx->nBlockAlign=(W)((wfx->wBitsPerSample*wfx->nChannels)>>3);
 wfx->nAvgBytesPerSec=(wfx->nSamplesPerSec*wfx->nBlockAlign);
 wfx->cbSize=cbsize;
 return RET_YES;
 }





 B WinWaveFormatExFromAudioMode        (WAVEFORMATEX*wfx,_audiomode*audiomode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) { return RET_BADPARM; }
 if(audiomode==NULL) { return RET_BADPARM; }
 aaMemoryFill(wfx,sizeof(WAVEFORMATEX),0);
 if(audiomode->channels<1||audiomode->channels>2) { return RET_BADPARM; }
 wfx->nChannels=audiomode->channels;
 wfx->nSamplesPerSec=audiomode->frequency;
 wfx->wBitsPerSample=audiomode->bits;
 wfx->wFormatTag=WAVE_FORMAT_PCM;
 wfx->nBlockAlign=(WORD)((wfx->nChannels*wfx->wBitsPerSample)>>3);
 wfx->nAvgBytesPerSec=wfx->nSamplesPerSec*wfx->nBlockAlign;
 wfx->cbSize=0;
 return RET_YES;
 }





 B WinWaveFormatExToAudioMode          (WAVEFORMATEX*wfx,_audiomode*audiomode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) { return RET_BADPARM; }
 if(audiomode==NULL) { return RET_BADPARM; }
 return RET_YES;
 }




 B WinWaveFormatExToString             (WAVEFORMATEX*wfx,VP string)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wfx==NULL) { return RET_BADPARM; }
 if(string==NULL) { return RET_BADPARM; }
 aaStringCopyf(string,"tag=0x%04x samsec=%i bits=%i ch=%i align=%i avgbps=%i cbsize=%i",
 wfx->wFormatTag,wfx->nSamplesPerSec,wfx->wBitsPerSample,wfx->nChannels,wfx->nBlockAlign,wfx->nAvgBytesPerSec,wfx->cbSize);
 return RET_YES;
 }






 B WinWndClassExSet                    (WNDCLASSEX*wndclsex,W style,WNDPROC proc,VP classname)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wndclsex==NULL) { return RET_BADPARM; }
 if(proc==NULL) { return RET_BADPARM; }
 if(classname==NULL) { return RET_BADPARM; }
 aaMemoryFill(wndclsex,sizeof(WNDCLASSEX),0);
 wndclsex->cbSize=sizeof(WNDCLASSEX);
 wndclsex->style=style;
 wndclsex->lpfnWndProc=proc;
 wndclsex->hInstance=aa.core_system.this_instance;
 wndclsex->hCursor=NULL;
 wndclsex->hIcon=NULL;
 wndclsex->lpszClassName=(LPCTSTR)classname;// (LPCTSTR)aa.core_system.class_name;
 wndclsex->hbrBackground=NULL;
 return RET_YES;
 }








 B WinCapParmsInit                     (VP caparms)
 {
 aa_CAPTUREPARMS*cpp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(caparms==NULL) { return RET_BADPARM; }
 aaCast(cpp,aa_CAPTUREPARMS*,caparms);
// log(WinCapParmsInit Micropersec=%i",(N)((1000.0/aa_VIDCAP_PreviewRate)*1000));
 aaMemoryFill(cpp,sizeof(aa_CAPTUREPARMS),0);
 cpp->dwRequestMicroSecPerFrame=30000; // (N)((1000.0/aa_VIDCAP_PreviewRate)*1000);
 cpp->fMakeUserHitOKToCapture=FALSE;
 cpp->wPercentDropForError=50;
 cpp->fYield=TRUE;
 cpp->dwIndexSize=0;
 cpp->wChunkGranularity=0;
 cpp->fUsingDOSMemory=FALSE;
 cpp->wNumVideoRequested=0;
 cpp->fCaptureAudio=NO;
 cpp->wNumAudioRequested=0;
 cpp->vKeyAbort=FALSE;
 cpp->fAbortLeftMouse=FALSE;
 cpp->fAbortRightMouse=FALSE;
 cpp->fLimitEnabled=FALSE;
 cpp->wTimeLimit=FALSE;
 cpp->fMCIControl=FALSE;
 cpp->fStepMCIDevice=FALSE;
 cpp->dwMCIStartTime=0;
 cpp->dwMCIStopTime=0;
 cpp->fStepCaptureAt2x=FALSE+1;
 cpp->wStepCaptureAverageFrames=5;
 cpp->dwAudioBufferSize=0;
 cpp->fDisableWriteCache=0;
 cpp->AVStreamMaster=aa_AVSTREAMMASTER_NONE;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aa_CoreSystemHistory                (H line,VP fmt,...)
 {
 static B first=YES;
 static C file_name[512];
 va_list argptr;
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 C str[_8K],txt[_8K];
 BOOL b;
 LARGE_INTEGER zi;
 B path[_1K];
// SYSTEMTIME st;

 aaFmt(fmt,argptr,str);
 if(first==YES)
  {
  GetCurrentDirectory(MAX_PATH,(CP)path);
  aaStringCopy(file_name,path);
  aaStringAppend(file_name,"\\aa_history.txt");
  ////GetWindowsDirectory(file_name,300);
  //aaStringAppend(file_name,"\\aa_history.txt");
  }
 aaStringNull(txt);
// GetLocalTime(&st);
 aaTimeToString(NULL,&txt[_4K],NULL,0);
// aaStringCopyf(txt,&txt[_4K]);
 first=NO;
  if(line==F32)    { aaStringAppendf(txt,"%s\r\n",str);                  }
  else           { aaStringAppendf(txt,"%-8lu | %s| %s\r\n",line,&txt[_4K],str); }
/// aaStringAppendf(txt,"| %s\r\n",str);
 aaStringLen(txt,&sl);
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)file_name,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,txt,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile(file_name); first=YES;  }
 return RET_YES;
 }




 B aa_CoreSystemLog                    (H style,VP fmt,...)
 {
 static H first_tik=0;
 static H last_tik=0;
 static C file_name[512];
 va_list argptr;
 H tik,ms_el,ms_dif;
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 B str[_64K],txt[_16K+_4K];
 B path[_1K];
 BOOL b;
/// C stz[_2K];
 SYSTEMTIME st;
 LARGE_INTEGER zi;

 ///OutputDebugString("aa_coresystemlog");
 aaFmt(fmt,argptr,str);
 if(aa.core_system.master_log_state==NO) { return RET_YES; }
 aaStringLen(str,&sl);
 while(1)
  {
  if(sl<1) { break; }
  if(aaCharIsVisible(str[sl-1])==YES) { break; }
  if(str[sl-1]==NULL_CHAR) { break; }
  str[sl-1]=NULL_CHAR;
  sl--;
  }
 str[sl]=NULL_CHAR;

 GetLocalTime(&st);
 if(aa.core_system.master_log_entries==0)
  {
  first_tik=GetTickCount();
  last_tik=first_tik;
  GetCurrentDirectory(MAX_PATH,(CP)path);
  aaStringCopy(file_name,path);
  //GetWindowsDirectory(file_name,300);
  aaStringAppend(file_name,"\\");
  aaStringAppend(file_name,aa.core_system.aa_trace_file);
  //DeleteFile(file_name);
  }
 //-//==//==// return YES;
 aaStringNull(txt);


 tik=GetTickCount();
 if(tik>=first_tik)   {  ms_el=tik-first_tik;            }
 else                 {  ms_el=(F32-first_tik)+(tik+1);  }
 if(tik>=last_tik)    {  ms_dif=tik-last_tik;            }
 else                 {  ms_dif=(F32-last_tik)+(tik+1);  }
 last_tik=tik;
 aaStringNull(txt);
 aaStringNull(&txt[_4K]);

 aaStringAppendf(txt,"%-6u ",aa.core_system.process_id);
 aaStringAppendf(txt,"%7lu ",ms_el);
 if(ms_dif>50) { aaStringAppendf(txt,"+%-5lu:",ms_dif); }
 else          { aaStringAppend(txt,"      :"); }

 //if(style!=-777&&style!=-1&&style!=-2) { style=-777; }
/// str[sl]=0x0d; str[sl+1]=0x0a; str[sl+2]=NULL_CHAR; sl+=2;

 if(style!=(H)-777&&style!=(H)-666&&style!=(H)-555) { style=(H)-777; }

 if(style==(H)-777)
  {
  aaStringAppendf(txt,"%2i:%02i:%02i %6.2fm/%-3i %3i/%-3i  %s\r\n",st.wHour,st.wMinute,st.wSecond,(F)aa.memory_system.status.bytes_allocated/1048576.0,aa.memory_system.status.blocks_allocated,aa.page_system.pages_allocated,aa.page_system.pages_commited,str);
  }
 else
 if(style==(H)-666)
  {
  aaStringAppendf(txt,"%s\r\n",str);
  }
 else
 if(style==(H)-555)
  {
  aaStringCopyf(txt,"%s\r\n",str);
  }


 ///OutputDebugString("aa_coresystemlog end section");
 aaStringLen(txt,&sl);
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)file_name,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,txt,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile(file_name); aa.core_system.master_log_entries=0;}
 else                 { aa.core_system.master_log_entries++; }
 return RET_YES;
 }






 B aa_CoreSystemLogStateSet            (B state)
 {
 aa.core_system.master_log_state=state;
 return RET_YES;
 }



 B aa_CoreSystemSleepStandard          (Q microsecs)
 {
 DWORD r;

 r=SleepEx(microsecs/1000,FALSE);
 if(r!=0)  { return RET_NO; }
 return RET_YES;
 }





 B aa_CoreSystemSleepPrecise           (Q microsecs)
 {
 B ret;
 struct timeval tv;
 fd_set dummy;
 static SOCKET s={0};


 if(s==0)
  {
  s=socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
  if(s==(SOCKET)SOCKET_ERROR) { oof; }
  }
 FD_ZERO(&dummy);
 FD_SET(s,&dummy);
 tv.tv_sec=microsecs/1000000;
 tv.tv_usec=microsecs%1000000;
 if(select(0,0,0,&dummy,&tv)!=0) { ret=RET_NO; }
 else                            { ret=RET_YES; }
 return ret;
 }








 B aa_CoreSystemStart                  (HINSTANCE thisinst,HINSTANCE previnst,LPSTR cmdline,int cmdshow)
 {
 HDC dc;
 DEVMODE dm;
 N i;
 H t;
 T BOOL (*_idp) (VOID);
 T BOOL (*_ridp) (HANDLE,BOOL*);
 BOOL bl;
 _idp idp;
 _ridp ridp;
 T BOOL (*_iswow)(HANDLE,BOOL *);
 _iswow iswow;
 BOOL i64;
 STARTUPINFO si;
 B path[_1K];
 B file[_1K];
 LARGE_INTEGER dtik;

 ///OutputDebugString("func=aa_CoreSystemStart");

//a_trace_file[513]

 t=GetTickCount();
 aaMemoryFill(&aa,sizeof(_aa),0);

 aaStringCopy(aa.core_system.aa_trace_file,"aa_trace.txt");

 GdiSetBatchLimit(1);
 GetCurrentDirectory(MAX_PATH,(CP)path);
 //GetWindowsDirectory((CP)path,500);
 //aStringCopyf(file,"%s\\aa_trace.txt",path);
 aaStringCopy(file,path);
 aaStringAppend(file,"\\");
 aaStringAppend(file,aa.core_system.aa_trace_file);

 #if aaTraceResetAlways==YES
 aaAaFilesDeleteOnSize(0,0,0,0);
 #endif

 #if aaTraceDebugf==YES
 aaDebugfLogWriteSet(YES);
 #endif
// aaAaFilesBackupOnSize(_256K,_256K,_256K,_256K);
// aaAaFilesDeleteOnSize(_256K,_256K,_256K,_256K);
 //aaAaFilesDeleteOnSize(0,0,0,0);
 //aaFileDelete(file);
 //if(aaFileExists(file)!=RET_YES){ aaFileSaveFromMemory(file,0,0);  }


 aa.core_system.SleepFunction=aa_CoreSystemSleepStandard;
 SetUnhandledExceptionFilter(aa_ExceptionHandler);

 aaMemoryFill(&dm,sizeof(dm),0);
 aa.core_system.launch_tik=t;
 aa.core_system.aamain_tik=aa.core_system.launch_tik;

 timeBeginPeriod(1);
 if(QueryPerformanceFrequency((LARGE_INTEGER*)&dtik)==0) oof;
 aa.core_system.perf_frequency=dtik.QuadPart;
 aa.core_system.perf_frequency_ms=aa.core_system.perf_frequency/1000;

 QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
 aa.core_system.aamain_perftik=dtik.QuadPart;
 aa.core_system.version=aa_VERSION;
 aa_launchtik=aa.core_system.launch_tik;

 if((aa.core_system.advapi_module=LoadLibrary("advapi32.dll"))==NULL) { oow; }
 if((aa.core_system.comdlg_module=LoadLibrary("comdlg32.dll"))==NULL) { oow; }
 if((aa.core_system.kernel_module=LoadLibrary("kernel32.dll"))==NULL) { oow; }
 if((aa.core_system.user_module=LoadLibrary("user32.dll"))==NULL) { oow; }
 if((aa.core_system.psapi_module=LoadLibrary("psapi.dll"))==NULL) { oow; }

 if((idp=(_idp)GetProcAddress(aa.core_system.kernel_module,"IsDebuggerPresent"))!=NULL)  { aa.core_system.in_debugger=(B)(idp()==YES);  }
 if((ridp=(_ridp)GetProcAddress(aa.core_system.kernel_module,"CheckRemoteDebuggerPresent"))!=NULL)
  {
  if(ridp(GetCurrentProcess(),&bl)!=0) { if(bl) aa.core_system.in_remote_debugger=YES; }
  }
 if((iswow=(_iswow)GetProcAddress(aa.core_system.kernel_module,"IsWow64Process"))!=NULL)
  {
  if(iswow(GetCurrentProcess(),&i64)) { if(i64)   {    aa_is_64bit=YES;    } }
  }
 if((aa.core_system.GetSystemTimes=(getSystemTimes)GetProcAddress(aa.core_system.kernel_module,"GetSystemTimes"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetProcessTimes=(getProcessTimes)GetProcAddress(aa.core_system.kernel_module,"GetProcessTimes"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Process32First=(process32First)GetProcAddress(aa.core_system.kernel_module,"Process32First"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Process32Next=(process32Next)GetProcAddress(aa.core_system.kernel_module,"Process32Next"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Thread32First=(thread32First)GetProcAddress(aa.core_system.kernel_module,"Thread32First"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Thread32Next=(thread32Next)GetProcAddress(aa.core_system.kernel_module,"Thread32Next"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Create32Snapshot=(create32Snapshot)GetProcAddress(aa.core_system.kernel_module,"CreateToolhelp32Snapshot"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Module32First=(module32First)GetProcAddress(aa.core_system.kernel_module,"Module32First"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.Module32Next=(module32Next)GetProcAddress(aa.core_system.kernel_module,"Module32Next"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.TryEnterCriticalSection=(trycritical)GetProcAddress(aa.core_system.kernel_module,"TryEnterCriticalSection"))==NULL) { oof; return RET_FAILED; }
 //if((aa.core_system.QueryFullProcName=(queryFullProcName)GetProcAddress(aa.core_system.kernel_module,"QueryFullProcessImageName"))==NULL) { oow; return RET_FAILED; }
 if((aa.core_system.CreateProcWithLogin=(createprocwithlogin)GetProcAddress(aa.core_system.advapi_module,"CreateProcessWithLogonW"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.SetLayeredWindowAttributes=(setlayeredwinattrs)GetProcAddress(aa.core_system.user_module,"SetLayeredWindowAttributes"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.DisableProcessWindowsGhosting=(disableGhosting)GetProcAddress(aa.core_system.user_module,"DisableProcessWindowsGhosting"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.PrintWindow=(printwindow)GetProcAddress(aa.core_system.user_module,"PrintWindow"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.EnumDisplayDevices=(enumdisplaydevs)GetProcAddress(aa.core_system.user_module,"EnumDisplayDevicesA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.EnumDisplayMonitors=(enumDisplayMonitors)GetProcAddress(aa.core_system.user_module,"EnumDisplayMonitors"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetMonitorInfoEx=(getMonitorInfoEx)GetProcAddress(aa.core_system.user_module,"GetMonitorInfoA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetModuleFileNameEx=(getModuleFileNameEx)GetProcAddress(aa.core_system.psapi_module,"GetModuleFileNameExA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetProcessFileName=(getProcessFileName)GetProcAddress(aa.core_system.psapi_module,"GetProcessImageFileNameA"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetProcessMemoryInfo=(getProcessMemoryInfo)GetProcAddress(aa.core_system.psapi_module,"GetProcessMemoryInfo"))==NULL) { oof; return RET_FAILED; }
 if((aa.core_system.GetOpenFileName=(getOpenFileName)GetProcAddress(aa.core_system.comdlg_module,"GetOpenFileNameA"))==NULL) { oof; return RET_FAILED; }

 aa_CoreSystemLogStateSet(YES);
 aaTimeOfLastCompile(aa.core_system.built);
 logg("aaBoost v%i Built: %s %s %s",aa.core_system.version,aa.core_system.built,aa.core_system.in_debugger?"*DEBUGGER RUNNING*":" ",aa.core_system.built,aa.core_system.in_remote_debugger?"*REMOTE DEBUGGER RUNNING*":" ",aaBoolStrings(aaIsProfiling(),"*PROFILING ENABLED* ",""));
 //aaLog(-1,"By Ashod Apakian, (c) 1997-2007");

 for(i=0;i<256;i++)
  {
  aaCast(ret_string[i],CP,ret_string_text[i]);
  aaStringCopy(ret_string[i],"RET_");
  switch(i)
   {
   case RET_NO: aaStringCopy(&ret_string[i][4],"NO"); break;
   case RET_YES: aaStringCopy(&ret_string[i][4],"YES"); break;
   case RET_BADPARM: aaStringCopy(&ret_string[i][4],"BADPARM"); break;
   case RET_FAILED: aaStringCopy(&ret_string[i][4],"FAILED"); break;
   case RET_BOUNDS: aaStringCopy(&ret_string[i][4],"BOUNDS"); break;
   case RET_FORBIDDEN: aaStringCopy(&ret_string[i][4],"FORBIDDEN"); break;
   case RET_NOMEMORY: aaStringCopy(&ret_string[i][4],"NOMEMORY"); break;
   case RET_BADHANDLE: aaStringCopy(&ret_string[i][4],"BADHANDLE"); break;
   case RET_NOTFOUND: aaStringCopy(&ret_string[i][4],"NOTFOUND"); break;
   case RET_NOTREADY: aaStringCopy(&ret_string[i][4],"NOTREADY"); break;
   case RET_EXISTS: aaStringCopy(&ret_string[i][4],"EXISTS"); break;
   case RET_ALREADYOPEN: aaStringCopy(&ret_string[i][4],"ALREADYOEN"); break;
   case RET_NOTOPEN: aaStringCopy(&ret_string[i][4],"NOTOPEN"); break;
   case RET_INUSE: aaStringCopy(&ret_string[i][4],"INUSE"); break;
   case RET_NOTSTARTED: aaStringCopy(&ret_string[i][4],"NOTSTARTED"); break;
   case RET_CORRUPTED: aaStringCopy(&ret_string[i][4],"CORRUPTED"); break;
   case RET_NOTSUPPORTED: aaStringCopy(&ret_string[i][4],"NOTSUPPORTED"); break;
   case RET_DENIED: aaStringCopy(&ret_string[i][4],"DENIED"); break;
   case RET_TIMEOUT: aaStringCopy(&ret_string[i][4],"TIMEOUT"); break;
   case RET_FATAL: aaStringCopy(&ret_string[i][4],"FATAL"); break;
   case RET_BADSTATE: aaStringCopy(&ret_string[i][4],"BADSTATE"); break;
   case RET_FINISHED: aaStringCopy(&ret_string[i][4],"FINISHED"); break;
   case RET_NOTINITIALIZED: aaStringCopy(&ret_string[i][4],"NOTINITIALIZED"); break;
   case RET_PARTIAL: aaStringCopy(&ret_string[i][4],"PARTIAL"); break;
   case RET_ALREADYSTARTED: aaStringCopy(&ret_string[i][4],"ALREADYSTARTED"); break;
   case RET_ATTENTION: aaStringCopy(&ret_string[i][4],"ATTENTION"); break;
   case RET_BADFORMAT: aaStringCopy(&ret_string[i][4],"BADFORMAT"); break;
   case RET_CANCELLED: aaStringCopy(&ret_string[i][4],"CANCELLED"); break;
   case RET_WORKING:   aaStringCopy(&ret_string[i][4],"WORKING"); break;
   case RET_COLLISION:   aaStringCopy(&ret_string[i][4],"COLLISION"); break;
   case RET_POSSIBLE:    aaStringCopy(&ret_string[i][4],"POSSIBLE"); break;
   case RET_IGNORE:      aaStringCopy(&ret_string[i][4],"IGNORE"); break;
   case RET_INCOMPLETE:      aaStringCopy(&ret_string[i][4],"INCOMPLETE"); break;
   case RET_OTHER:           aaStringCopy(&ret_string[i][4],"OTHER"); break;
   case RET_UNKNOWN: aaStringCopy(&ret_string[i][4],"UNKNOWN"); break;
   default:
   ret_string[i][4]=((i/100)%10)+'0';
   ret_string[i][5]=((i/10)%10)+'0';
   ret_string[i][6]=((i%10)+'0');
   ret_string[i][7]=NULL_CHAR;
   break;
   }
  }
 dm.dmSize=sizeof(DEVMODE);
 dm.dmFields=DM_BITSPERPEL;
 dm.dmBitsPerPel=32;
 aaMemoryFill(&si,sizeof(si),0);
 si.cb=sizeof(si);
 GetStartupInfo(&si);
 if((dc=CreateDC("DISPLAY",NULL,NULL,&dm))==NULL) return RET_FAILED;
 aa.core_system.display_dc=dc;
 aa.core_system.this_instance=thisinst;
 aa.core_system.prev_instance=previnst;
 aa.core_system.discovery_message_id=RegisterWindowMessage("aaBoostDiscovery");
 aa_discovery_id=aa.core_system.discovery_message_id;
 aaStringCopy(aa.core_system.command_line,cmdline);
 GetModuleFileName(NULL,(CP)aa.core_system.module_filename,sizeof(aa.core_system.module_filename));
 aaStringCopy(aa.core_system.module_path,aa.core_system.module_filename);
 aaStringFindChar(aa.core_system.module_path,0,&t,BSLASH_CHAR,YES,0,NO);
 if(t!=F32) { aa.core_system.module_path[t+1]=NULL_CHAR; }
 if(si.dwFlags&0x800) aa.core_system.via_shortcut=YES;
 aa.core_system.command_show=cmdshow;
 aa.core_system.process_handle=GetCurrentProcess();
 aa.core_system.process_id=GetCurrentProcessId();
 aa.core_system.thread_handle=GetCurrentThread();
 aa.core_system.thread_id=GetCurrentThreadId();

 sprintf(aa.core_system.class_name,"aa.core_system.class.Name.%lu",GetTickCount());
 //aaStringCopyf(aa.core_system.class_name,"aa.core_system.class.Name.%lu",GetTickCount());

 //WinWndClassExSet(&aa.core_system.class_data,CS_OWNDC,aa_CoreSystemProc,aa.core_system.class_name);
 //|CS_GLOBALCLASS|CS_OWNDC
 WinWndClassExSet(&aa.core_system.class_data,CS_GLOBALCLASS|CS_OWNDC|CS_HREDRAW|CS_VREDRAW,aa_CoreSystemProc,aa.core_system.class_name);
 //WinWndClassExSet(&aa.core_system.class_data,CS_GLOBALCLASS|CS_HREDRAW|CS_VREDRAW,aa_CoreSystemProc,aa.core_system.class_name);
 if(RegisterClassEx(&aa.core_system.class_data)==0) { oow; return RET_FAILED; }
// SetThreadPriority(aa.core_system.thread_handle,THREAD_PRIORITY_NORMAL);
 aa_CoreSystemTime();
 ///OutputDebugString("func=aa_CoreSystemStart finished");
 return RET_YES;
 }




 BOOL myprintwindow (HWND wnd,HDC dc,UINT val)
 {
 return(aa.core_system.PrintWindow(wnd,dc,val));
 }



 V aa_CoreSystemStop                   (V)
 {
 logg("aa_CoreSystemStop()");
 logg("");
// aa_CoreSystemLoop();
 if(aa.core_system.is_console_attached) { aaConsoleDetach(); }
 if(aa.core_system.kernel_module!=NULL) { FreeLibrary(aa.core_system.kernel_module); aa.core_system.kernel_module=NULL; }
 if(aa.core_system.comdlg_module!=NULL) { FreeLibrary(aa.core_system.comdlg_module); aa.core_system.comdlg_module=NULL; }
 if(aa.core_system.user_module!=NULL)   { FreeLibrary(aa.core_system.user_module); aa.core_system.user_module=NULL; }
 if(aa.core_system.advapi_module!=NULL) { FreeLibrary(aa.core_system.advapi_module); aa.core_system.advapi_module=NULL; }
 DeleteDC(aa.core_system.display_dc);
 UnregisterClass((LPCTSTR)aa.core_system.class_name,aa.core_system.this_instance);
// aaLimiterSet(NO);
#if 0
 {
 H tik,el;
 tik=GetTickCount();
 if(tik>=aa.core_system.launch_tik)   {  el=tik-aa.core_system.launch_tik;            }
 else                                   {  el=(F32-aa.core_system.launch_tik)+(tik+1);  }
 if(el!=el ) { oof; } // shut warning up, #if log 0
 aaLog(-1,"total running time = %ld ms",el);///1000.0);
 }
#endif
 }


 B aa_CoreSystemWindowsMsgToString     (UINT msg,VP str)
 {
 H i;

 if(str) { aaStringNull(str); }
 for(i=0;i<aaElementCount(aa_winmsg);i++)
  {
  if(msg!=aa_winmsg[i].msg) { continue; }
  aaStringCopyf(str,"%s",aa_winmsg[i].str);
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 K aa_CoreSystemProc                   (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm)
 {
 H surface_handle;
 _aa_surfaceobject*surp;
 PAINTSTRUCT ps;
 _rect blit_rect;
 _cord c1,c2;
 N h_dif,v_dif;
 POINT pnt;
 POINTS pnts;
 COPYDATASTRUCT*cdsp;
 BP bp;
 B txt[_16K];
 N ret_value;
 APPBARDATA data;
// N delta;
 N re;
 B id;
 B ret;
 S N isin=0;

#if 1
 if(isin==0) {isin=1;  }
 else
  {
  if(msg==WM_PAINT)
   {
   PAINTSTRUCT pps;
   if(BeginPaint(wnd,&pps)==NULL)   {  oow;  }
   EndPaint(wnd,&pps);
   return 0;
   }
  return 0;
  }
 #endif

 #if 0
 if(msg==WM_ACTIVATE||msg==WM_ACTIVATEAPP)
  {
  isin=0;
  return 0;
  }
 #endif


 //logg("%s:%i hwnd=%x msg=%i",__func__,__LINE__,wnd,msg);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret_value=-1;
 aa.core_system.wm_msg_count_total++;
 aa_stats[0]=aa.core_system.wm_msg_count_total;




 ret=aa_SurfaceSystemFindSurfaceByHwnd(&surface_handle,(VP)&surp,wnd);

 if(ret!=YES)
  {
  isin=0;
  return DefWindowProc(wnd,msg,wparm,lparm);
  }
 //aaLog(-777,"%s:%i hwnd=%x msg=%i, %s ,surface=%x",__func__,__LINE__,wnd,msg,ret_string[ret],surface_handle);

 if(ret==RET_YES)
  {
  aa.core_system.wm_msg_count_surfaced++;
  aa_stats[1]=aa.core_system.wm_msg_count_surfaced;
  switch(msg)
   {
   case WM_APP_BAR_MSG:
   switch(wparm)
    {
    case ABN_FULLSCREENAPP:  break;

    case ABN_POSCHANGED:
    data.cbSize=sizeof(data);
    data.hWnd=surp->status.hwnd;
    data.uEdge=aa.appbar_system.edge;
    SetRect(&data.rc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
    if(SHAppBarMessage(ABM_QUERYPOS,&data)==FALSE) { oof; oow; }
    switch (data.uEdge)
     {
     default: oof; break;
     case ABE_LEFT:   data.rc.right=data.rc.left+aa.appbar_system.depth;   break;
     case ABE_TOP:    data.rc.bottom=data.rc.top+aa.appbar_system.depth;   break;
     case ABE_RIGHT:  data.rc.left=data.rc.right-aa.appbar_system.depth;   break;
     case ABE_BOTTOM: data.rc.top=data.rc.bottom-aa.appbar_system.depth;    break;
     }
    // Leave all the members as they were when
    SHAppBarMessage(ABM_SETPOS,&data);
    aaRectSet(&aa.appbar_system.rect,data.rc.left,data.rc.top,data.rc.right-data.rc.left,data.rc.bottom-data.rc.top);
    break;

    case ABN_STATECHANGE:    break;
    case ABN_WINDOWARRANGE:  break;
    default: oof; break;
    }
   ret_value=0;// was 1 nov 22 2006
   break;

   case WM_TIMER:
///   BUGGY;
   ret_value=0;
   break;

   case WM_DROPFILES:
   ret_value=0;
    {
    UINT dcount,dod;
    HDROP drop;
    drop=(HANDLE)wparm;
    DragQueryPoint(drop,&pnt);
    dcount=DragQueryFile(drop,F32,0,0);
//    BUG,
//    aaDebugf("Drop point %i %i, count=%i",pnt.x,pnt.y,dcount);
    for(dod=0;dod<dcount;dod++)
     {
     if(DragQueryFile(drop,dod,(CP)txt,_4K)!=0)
      {
      if(surp->status.is_drop_accept)
       {
       if(surp->status.drop_list.magic==0)
        {
        aaListNew(&surp->status.drop_list);
        }
       aaListAppendf(&surp->status.drop_list,0,0,"%s",txt);
       surp->status.drop_count++;
       }
//     aaDebugf("dropindex %i = %s",dod,txt);
      }
     }
    DragFinish(drop);
    }
   break;


   case WM_CLOSE:
//   MessageBox(NULL,(char*)"tdettach","dwd ",MB_OK);
   //aaLog(-1,"got wm_close d %i,%i",surp->status.size.w,surp->status.size.h);
   //ret_value=1; // if skype ElseProc screws up this ret_value might be a clue
   surp->status.is_closed=YES;
   ret_value=0;// was 1  nov 22 , 2006
   break;


   case WM_QUIT:
   if(aa.core_system.wm_quit_received==NO)
    {
    aa.core_system.wm_quit_exitcode=wparm;
    aa.core_system.wm_quit_received=YES;
    aa_is_quit_received=YES;
    }
   ret_value=-1; // was 1 nov 22 2006
   break;


   case WM_SETFOCUS:
   case WM_KILLFOCUS:
   if(msg==WM_SETFOCUS)
    {
    surp->status.is_focus=YES;
    }
   else
   if(msg==WM_KILLFOCUS)
    {
    surp->status.is_focus=NO;
    }
   ret_value=1; // was 1 nov 22 2006
   break;



   case WM_MOUSEMOVE:
   ///aa_DIAG("** WM_MOUSEMOVE **");
   if(GetCursor()!=aa.cursor_system.current_cursor_handle)    {         SetCursor(aa.cursor_system.current_cursor_handle); }
   ret_value=0;// was 1 nov 22 2006
   break;

   /*

   case WM_NCMOUSEMOVE:
   ret_value=0;
   break;
     */

   case WM_DEADCHAR:
   case WM_SYSDEADCHAR:
   case WM_CHAR:
   case WM_SYSCHAR:
   case WM_KEYDOWN:
   case WM_SYSKEYDOWN:
   case WM_KEYUP:
   case WM_SYSKEYUP:
   if(msg==WM_KEYUP||msg==WM_KEYDOWN||msg==WM_SYSKEYUP||msg==WM_SYSKEYDOWN)//||msg==WM_CHAR||msg==WM_SYSCHAR)
    {
    if(aa.input_system.hKeyHook==0)
     {
     aa_InputSystemKeyEventProc(wnd,msg,wparm,lparm,0);
     }
    }

   if(msg==WM_KEYDOWN&&wparm==VK_ESCAPE)
    {
    if(aa_is_esc==NO)
     {
     aa_is_esc=YES;
     }
    }

   ret_value=0;// was 1 nov 22 2006
   break;




  case WM_COMMAND: //if(msg==WM_COMMAND&&HIWORD(wparm)==BN_CLICKED)
  if(HIWORD(wparm)!=BN_CLICKED) { ret_value=-1; break; }
  ///if(aa.bugger_system.is_open!=YES) { ret_value=-1; break; }
  ret_value=0;// was -1: jul 2015
  break;



  #if 0
  case WM_MOUSEWHEEL: // which parm holds x/y pos and time of event ??
               // this is important so we know where in our window the mouse wheel occured ( i.e on the scroll part or
               // some other dialog component
  delta=(I)HIWORD(wparm);
  if(delta<0)
   {
   delta=aaNumAbs(delta);
   delta=delta/100;
   delta=1;
   //aaDebugf("a delta=%i ,, wheel=%i + %i=%i",delta,aa.input_system.wheel,delta,aa.input_system.wheel+delta);
   surp->status.wheel-=delta;//delta;
   aa.input_system.wheel-=delta;//delta;
   //aa.input_system.wheel+=delta;
   }
  else
  if(delta>0)
   {
   delta=aaNumAbs(delta);
   delta=delta/100;
   delta=1;
   //aaDebugf("b delta=%i ,, wheel=%i + %i=%i",delta,aa.input_system.wheel,delta,aa.input_system.wheel+delta);
   surp->status.wheel+=delta;
   aa.input_system.wheel+=delta;
   //aa.input_system.wheel-=delta;
   }

  //if(delta!=0) {                aaDebugf("wparm=%i",delta); }

  //if(wparm==7340032) { surp->status.wheel++; aa.input_system.wheel++;  }
  //else
  //if((signed)wparm==-7340032) {surp->status.wheel--; aa.input_system.wheel--; ;  }
//                 aaDebugf("Awgeelk %i",aa.input_system.wheel);
  ret_value=0;
  break;
  #endif





   case WM_SURFACE_SYSTRAY_MSG:
   switch(lparm)
    {
    case WM_LBUTTONUP:
    case WM_RBUTTONUP:
    surp->status.is_systray_clicked=YES;
    surp->status.is_systray_right_clicked=(B)(lparm==WM_RBUTTONDBLCLK||lparm==WM_RBUTTONUP);
    GetCursorPos(&pnt);
    aaCordSet(&surp->status.systray_click_cord,pnt.x,pnt.y);
    break;

    case WM_MOUSEMOVE:
    break;

    default:

    break;
    }
   ret_value=0;// was 1 nov 22 2006
   break;


   case WM_NCHITTEST:
   if(surp->status.is_shown==YES&&surp->status.is_moveable==2)
    {
    pnts=MAKEPOINTS(lparm);
    c1.x=pnts.x;
    c1.y=pnts.y;
    aaSurfaceVisualCordToCord(surface_handle,&c1,&c2);
    if(c2.y>=0&&c2.y<=20)
     {
     isin=0;
     return HTCAPTION;
     }
    }
   ret_value=-1;
   break;

   //case WM_MOVING:
   //ret_value=1;
   //break;

   case WM_SETREDRAW:
   ret_value=0;
   break;

   case WM_ERASEBKGND:
   aa.core_system.wm_msg_count_erasebg++;
   aa_stats[2]=aa.core_system.wm_msg_count_erasebg;
   ret_value=-1;
   ret_value=0;//  see http://www.catch22.net/tuts/flicker )
   break;

   case WM_ENTERMENULOOP:
   case WM_EXITMENULOOP:
   ret_value=0;
   break;

   case WM_PAINT:
   #ifdef aa_VERSION
   aa_ZIAG("WM_PAINT");
   #endif
   aa.core_system.wm_msg_count_paint++;
   aa_stats[3]=aa.core_system.wm_msg_count_paint;
   if(BeginPaint(surp->status.hwnd,&ps)==NULL)   {  oof; oow; Boop;   break;   }
   //aaDebugf("erase=%u %u (rect=%i,%i,%i,%i)",ps.fErase,surface_handle,ps.rcPaint.left,ps.rcPaint.top,ps.rcPaint.right-ps.rcPaint.left,ps.rcPaint.bottom-ps.rcPaint.top);
   if(surp->status.is_shown==YES&&surp->status.is_ignore_wmpaint==NO)
    {
    ///aaDebugf("iser=%i erase 0x%08x %i,%i,%i,%i",ps.fErase,surface_handle,ps.rcPaint.left,ps.rcPaint.top,ps.rcPaint.right-ps.rcPaint.left,ps.rcPaint.bottom-ps.rcPaint.top);
    //if(ps.fErase ) aaDebugf("iser=%i erase 0x%08x %i,%i,%i,%i",ps.fErase,surface_handle,ps.rcPaint.left,ps.rcPaint.top,ps.rcPaint.right-ps.rcPaint.left,ps.rcPaint.bottom-ps.rcPaint.top);
     //if(!ps.fErase )
     {
      h_dif=(ps.rcPaint.right-ps.rcPaint.left);
     h_dif=aaNumClamp(h_dif,0,F24);
     v_dif=(ps.rcPaint.bottom-ps.rcPaint.top);
     v_dif=aaNumClamp(v_dif,0,F24);
     aaRectSet(&blit_rect,ps.rcPaint.left,ps.rcPaint.top,h_dif,v_dif);
     aaSurfaceBlit(surface_handle,&blit_rect,0,&blit_rect,NO);
     //aaDebugf("blit %u   %i,%i,%i,%u ispar=%i",surface_handle,aaRectParts(blit_rect),surp->status.is_parent);
     //aaSurfaceUpdateAreaAdd(surface_handle,&blit_rect,1);
     /// ????
     //InvalidateRect(surp->status.hwnd,&ps.rcPaint,0);
     }
    }
   EndPaint(surp->status.hwnd,&ps);
   ret_value=0;// was 1 , dec 2011
   break;



//   case WM_ACTIVATE:   BUG,"activate %s",surp->status.title);   break;



   case WM_SETCURSOR:
   ret_value=TRUE;
   break;


   case WM_MOVE:
   ret_value=0;
   break;

   case WM_STYLECHANGING:
   ret_value=0;
   break;

   case WM_STYLECHANGED:
   ret_value=0;
   break;


   case WM_GETDLGCODE:
   ret_value=-1;
   break;



   case WM_NCCALCSIZE:
   if(wparm==FALSE) { ret_value=0; break; }
   if(wparm==TRUE) { ret_value=0; break; }
   ret_value=1;
   break;


   case WM_NCPAINT:
   ret_value=0; // was 1 jul 2015
   break;


   //case WM_GETICON:
   //ret_value=(N)surp->status.icon;
   //break;



   case WM_WINDOWPOSCHANGING:
   ret_value=0;// was 1 jul 2015
   break;

   case WM_WINDOWPOSCHANGED:
   ret_value=0;// was 1 jul 2015
   break;





   case WM_COPYDATA:
   #ifdef aa_VERSION
   aa_ZIAG("WM_COPYDATA");
   #endif
   aaCast(cdsp,COPYDATASTRUCT*,lparm);
   aaCast(bp,BP,cdsp->lpData);
   if(aa.core_system.LimiterMessageProc!=NULL&&aa.core_system.limiter_mutex_handle!=0)
    {
    if(*(HP)&bp[0]==VAL_limt)
     {
     if(cdsp->dwData==19721972&&cdsp->cbData>=32&&cdsp->cbData<=_16K)
      {
      //if(*(HP)&bp[12]!=aa.core_system.limiter_last_counter.hi||*(HP)&bp[16]!=aa.core_system.limiter_last_counter.lo )
      if(*(QP)&bp[12]!=aa.core_system.limiter_last_counter)//.hi||*(HP)&bp[16]!=aa.core_system.limiter_last_counter.lo )
       {
       aa.core_system.limiter_last_counter=*(QP)&bp[12];
       //aa.core_system.limiter_last_counter.hi=*(HP)&bp[12];
      // aa.core_system.limiter_last_counter.lo=*(HP)&bp[16];
       aaMemoryCopy(txt,cdsp->cbData-32,&bp[32]);
       aa.core_system.LimiterMessageProc(cdsp->cbData-32,txt);
       isin=0;
       return 1;
       }
      }
     }
    }

   if(aa.core_system.CopyDataProc!=NULL)
    {
    aa.core_system.CopyDataProc((HWND)wparm,wnd,cdsp->dwData,cdsp->cbData,bp);
    isin=0;
    return 1;
    }

//  break;    // WM_COPYDATA fall-thru to ElseProc, so normal WM_COPYDATA messages are handled in ElseProc


   default:
   if(msg!=WM_COPYDATA)
    {
    aa.core_system.wm_msg_count_unhandled++;
    aa_stats[4]=aa.core_system.wm_msg_count_unhandled;
    }

   if(surp->status.ElseProc!=NULL)
    {
    oof;
    //if(msg==MM_MCINOTIFY) BUG,"eenotify hwnd=%u ",wnd);
    re=surp->status.ElseProc(wnd,msg,wparm,lparm,&id);
    if(id==NO)
     {
     isin=0;
     return(re);
     }
    }
   ret_value=-1;
   break;
   }
  }

 if(ret_value!=-1)
  {
  isin=0;
  return(ret_value);
  }
 isin=0;
 return DefWindowProc(wnd,msg,wparm,lparm);
 }







 B aa_CoreSystemCpuLoadGet             (V)
 {
 myFILETIME i_time,k_time,u_time;
 myFILETIME ii_time,cc_time,ee_time,kk_time,uu_time;
 G i_now,k_now,u_now;
 G rtk,rtu,rti;
 G xtk,xtu;
 G ztk,ztu,zti;
 D cpu,sys;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(cpuload)   { *cpuload=aa_curcpuload; }
 //if(procload)  { *procload=aa_curprocessload; }
 if(aa.core_system.GetSystemTimes(&i_time.dword,&k_time.dword,&u_time.dword)==0) {  oow; }
 zti=i_time.quad;
 ztk=k_time.quad;
 ztu=u_time.quad;
 i_now=zti-aa.cpumonitor_system.prev_idle_time.quad;
 k_now=ztk-aa.cpumonitor_system.prev_kernel_time.quad;
 u_now=ztu-aa.cpumonitor_system.prev_user_time.quad;
 sys=(k_now+u_now);
 if(sys!=0)  {  cpu=(((sys-(D)i_now)*100.0)/sys);  aa_curcpuload=(D)cpu;  }
 aa.cpumonitor_system.prev_user_time.quad=ztu;
 aa.cpumonitor_system.prev_idle_time.quad=zti;
 aa.cpumonitor_system.prev_kernel_time.quad=ztk;
 ii_time.quad=0;//
 if(aa.core_system.GetProcessTimes(aa.core_system.process_handle,&cc_time.dword,&ee_time.dword,&kk_time.dword,&uu_time.dword)==0) { oow; }
 rti=ii_time.quad;
 rtk=kk_time.quad;
 rtu=uu_time.quad;
 xtk=rtk-aa.cpumonitor_system.process_prev_kernel_time;
 xtu=rtu-aa.cpumonitor_system.process_prev_user_time;
 cpu=(D)(ztu+ztk)-(D)aa.cpumonitor_system.prev_ki_time;
 if(cpu!=0)  {  aa_curprocessload=(D)((xtu+xtk)*100.0)/(D)cpu;  }
//
 aa_curcpuload=aaNumClamp(aa_curcpuload,0,100);
 aa_curprocessload=aaNumClamp(aa_curprocessload,0,100);

 if(aa_curprocessload>aa_curcpuload) {  aa_curprocessload=aa_curcpuload;  }
 aa_avgcpuload-=(aa_avgcpuload/10.0);
 aa_avgcpuload+=(aa_curcpuload/10.0);
 aa_avgprocessload-=(aa_avgprocessload/10.0);
 aa_avgprocessload+=(aa_curprocessload/10.0);
 aa_avgcpuload=aaNumClamp(aa_avgcpuload,0,100);
 aa_avgprocessload=aaNumClamp(aa_avgprocessload,0,100);
 aa.cpumonitor_system.process_prev_user_time=rtu;
 aa.cpumonitor_system.process_prev_idle_time=rti;
 aa.cpumonitor_system.process_prev_kernel_time=rtk;
 aa.cpumonitor_system.prev_ki_time=ztu+ztk;
// if(procload)  { *procload=aa_curprocessload; }
 //if(cpuload)  { *cpuload=aa_curcpuload; }
 return RET_YES;
 }





 Q aa_CoreSystemTikPrecise             (V)
 {
 Q ms;
 D dd,ee;

 LARGE_INTEGER dtik;
 QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
 ms=dtik.QuadPart;
 dd=(D)ms;
 dd=(dd*1000.0);
 ee=(D)aa.core_system.perf_frequency;
 ee=ee/1000.0;
 dd=dd/ee;
 ms=(Q)dd;
 return(ms);
 }





 B aa_CoreSystemTime                   (V)
 {
 LARGE_INTEGER dtik;
 H tik;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif


 aaTimerTikGet(&tik);
 aaTimerTikElapsedUsingTik(aa.core_system.aamain_tik,tik,&aa.core_system.aamain_elapsed);

 if(aa.core_system.perf_frequency_ms!=0)
  {
  QueryPerformanceCounter((LARGE_INTEGER*)&dtik);
  aa.core_system.aamain_perfelapsed=dtik.QuadPart-aa.core_system.aamain_perftik;
  aa_msrunning=aa.core_system.aamain_perfelapsed/aa.core_system.perf_frequency_ms;
  aa_microsecsrunning=((aa.core_system.aamain_perfelapsed*1000)/aa.core_system.perf_frequency_ms);
  }
 else
  {
  aa_msrunning=aa.core_system.aamain_elapsed;
  aa_microsecsrunning=aa_msrunning*1000;
  }
 aa_secsrunning=(D)aa_msrunning/1000.0;
 return RET_YES;
 }






 B aa_CoreSystemTimer                  (H index,B prefresh,B postfresh,Q ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(index>=aaElementCount(aa.core_system.prev_msrunning)) { return RET_NO; }
 if(prefresh) { aa_CoreSystemTime(); }
 if((aa_msrunning-aa.core_system.prev_msrunning[index])<ms) { return RET_NO; }
 if(postfresh) { aa_CoreSystemTime(); }
 aa.core_system.prev_msrunning[index]=aa_msrunning;
 return RET_YES;
 }




 B aa_CoreSystemLoop                   (V)
 {
 MSG msg;
 BOOL bl;
 H go=0;
 //N delta;

 do
 {
 if(PeekMessage(&msg,NULL,0,0,PM_NOREMOVE))
  {
  //if(aa_CoreSystemWindowsMsgToString(msg.message,txt)==YES)   {   aaDebugf("%s",txt);   }
  //else   {   aaDebugf("unnown %x",msg.message);   }

  /* apr 2016 - using hooks instead
  if(msg.message==WM_MOUSEWHEEL)
   {
   delta=(I)HIWORD(msg.wParam);
   if(delta<0) { delta=aaNumAbs(delta); delta=delta/100; delta=1; aa.input_system.wheel-=delta;   }
   else
   if(delta>0) { delta=aaNumAbs(delta); delta=delta/100; delta=1; aa.input_system.wheel+=delta;    }
   }
  */

//  if(msg.message==0x020a) BUGGY;
  { H ii,igl=(H)aa_hwnd_ignore[0]; for(ii=0;ii<igl;ii++) {  if(aa_hwnd_ignore[1+ii]==msg.hwnd) { break; }   } if(ii!=igl) {  break; }  }
  bl=GetMessage(&msg,NULL,0,0);
  if(bl==0)
  //if(msg.message==WM_QUIT)
   {
   aa_is_quit_received=YES;
   aa.core_system.wm_quit_received=YES;
   aa.core_system.wm_quit_exitcode=msg.wParam;
   }
  else
  if(bl==-1)
   {
   oof;
   return RET_FAILED;
   }
  TranslateMessage(&msg);
  DispatchMessage(&msg);
  if(aa.core_system.wm_quit_received==YES) {  return RET_NO; } // i added this line, 2007 - ashod, qekyfavu
  }
 else
  {
  if(aa.core_system.wm_quit_received==YES) {   return RET_NO; }
  break;
  }
 //go++;
 if((go++)>5) {  break; }
 //break;
 }
 while(1);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 V aaAbort                             (VP fmt,...)
 {
 va_list argptr;
 B str[_8K];
 B buf[_8K];

 aaFmt(fmt,argptr,str);
 aaStringCopyf(buf,"aaAbort\n");
 aaStringAppendf(buf,"--------------------------------------------------------------------\n");
 aaStringAppendf(buf,"aa_stage=%i\n",aa_stage);
 aaStringAppendf(buf,"aa_prevstage=%i\n",aa_prevstage);
 aaStringAppendf(buf,"aa_nextstage=%i\n",aa_nextstage);
 aaStringAppendf(buf,"aa_cycle=%I64u\n",aa_cycle);
 aaStringAppendf(buf,"aa_msrunning=%I64u\n",aa_msrunning);
 aaStringAppendf(buf,"--------------------------------------------------------------------\n");
 aaStringAppendf(buf,"%s\n",str);
 aaStringAppendf(buf,"--------------------------------------------------------------------");
 aaNote(0,"%s",buf);
 longjmp(aa_jmp_buf,1);
 }


/*-----------------------------------------------------------------------*/


 B aaQuit                              (V)
 {
 #ifdef aa_VERSION
 //aa_ZIAG(__FUNCTION__);
 #endif

 aa_is_quit_called=YES;
 if(aa.core_system.wm_quit_received==NO)
  {
  if(is_aa_started_by_winmain==YES)
   {
   is_aa_quit_posted=YES;
   PostQuitMessage(0);
   }
  }
 return RET_YES;
 }


 Q aaMsRunning                         (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_CoreSystemTime();
 return aa_msrunning;
 }




 Q aaMicrosecsRunning                  (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_CoreSystemTime();
 return aa_microsecsrunning;
 }


/*-----------------------------------------------------------------------*/

 B aaTrace                             (VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_64K];
 B prev_log_state;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 str[0]=0;
 aaFmt(fmt,argptr,str);
 prev_log_state=aa.core_system.master_log_state;
 aa_CoreSystemLogStateSet(YES);
 ret=aa_CoreSystemLog(123,"%s",str);
 aa_CoreSystemLogStateSet(prev_log_state);
 return ret;
 }



 B aaTraceFileSet                      (VP fmt,...)
 {
 B prev_file[_1K];
 aaVargsf(fmt);

 aaStringCopyf(prev_file,"%s",aa.core_system.aa_trace_file);
 if(str64k.len==0)
  {
  aaStringCopyf(aa.core_system.aa_trace_file,"aa_trace.txt");
  }
 else
  {
  aaStringCopyf(aa.core_system.aa_trace_file,"%s",str64k.buf);
  }
 if(aaStringICompare(prev_file,aa.core_system.aa_trace_file,0)!=YES)
  {
  aa.core_system.master_log_entries=0;
  }
 return RET_YES;
 }





 B aaCallStackGet                      (H maxitems,HP addresses)
 {
 VP sp;
 structure { VP *addr; } _caller;
 _caller*caller;
 H i=0;
 __asm__("movl %%ebp,%0" : "=r"(sp));
 for(i=0;i<maxitems;i++) { addresses[i]=0; }
 i=0;
 caller=(VP)sp;
 while(caller)
  {
  addresses[i++]=*(HP)&(caller[1]);
  //addresses[i]=0;
  if(i>=maxitems) { break; }
  caller=(_caller*)caller->addr;
  }
 return RET_YES;
 }




 B aaCpuIdGet                          (Z cpuinfo[4],Z infotype)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 __asm__ __volatile__ (
 "cpuid"
 : "=a" (cpuinfo [0]), "=b" (cpuinfo [1]), "=c" (cpuinfo [2]), "=d" (cpuinfo [3])
 : "a" (infotype));
 return RET_YES;
 }



//=====================================

 FILE *_fdopen                         (Z fd,CP mode);
 //Z _open_osfhandle                     (ZP osfhandle,Z flags);
 Z _close                              (Z fd);
 //intptr_t _get_osfhandle               (Z fd);


 B aaConsoleAttach                     (V)
 {
 Z fdo,fde;
 HANDLE conshout,consherr;
 FILE*fpo,*fpe;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.core_system.is_console_attached==YES) { return RET_YES; }
 if(AttachConsole(ATTACH_PARENT_PROCESS))
  {
  conshout=GetStdHandle(STD_OUTPUT_HANDLE);
  fdo=_open_osfhandle((intptr_t)conshout,16384);
  fpo=_fdopen(fdo,"w");
  *stdout=*fpo;
  setvbuf(stdout,NULL,_IONBF,0);
  consherr=GetStdHandle(STD_ERROR_HANDLE);
  fde=_open_osfhandle((intptr_t)consherr,16384);
  fpe=_fdopen(fde,"w");
  *stderr=*fpe;
  setvbuf(stderr,NULL,_IONBF,0);
  aa.core_system.is_console_attached=YES;
  aa.core_system.is_console_crlf_needed=NO;
  aa.core_system.is_console_ever_attached=YES;
  return RET_YES;
  }
 aa.core_system.is_console_ever_attached=OTHER;
 return RET_FAILED;
 }





 B aaConsoleDetach                     (V)
 {
 INPUT ip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.core_system.is_console_attached!=YES) { return RET_NOTOPEN; }
 if(aa.core_system.is_console_crlf_needed)
  {
  if(GetConsoleWindow()!=GetForegroundWindow()) { return RET_NOTREADY; }
  aaMemoryFill(&ip,sizeof(ip),0);
  ip.type=INPUT_KEYBOARD;
  ip.ki.wVk=CR_CHAR;
  SendInput(1,&ip,sizeof(INPUT));
  ip.ki.dwFlags=KEYEVENTF_KEYUP;
  SendInput(1,&ip,sizeof(INPUT));
  }
 if(FreeConsole()==0) { return RET_FAILED; }
 aa.core_system.is_console_attached=NO;
 aa.core_system.is_console_crlf_needed=NO;
 return RET_YES;
 }




 B aaConsolePrintf                     (VP fmt,...)
 {
 va_list argptr;
 B str[_16K];
 //Z hConHandle;
 //FILE *fp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if(aa.core_system.is_console_attached!=YES) { return RET_NOTOPEN; }

 printf("%s",str);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/





 B aaLog                               (H line,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_64K];
 B prev_log_state;

 ///OutputDebugString("func=aaLog");
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 str[0]=0;
 aaFmt(fmt,argptr,str);
 ///if((N)line==-666) { return RET_YES; }
 prev_log_state=aa.core_system.master_log_state;
 aa_CoreSystemLogStateSet(YES);
 ret=aa_CoreSystemLog(line,"%s",str);
 aa_CoreSystemLogStateSet(prev_log_state);
 return ret;
 }



 B aaLogEx                             (VP filename,H line,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_64K];
 B prev_log_state;

 ///OutputDebugString("func=aaLog");
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(filename);
 str[0]=0;
 aaFmt(fmt,argptr,str);
 ///if((N)line==-666) { return RET_YES; }
 prev_log_state=aa.core_system.master_log_state;
 aa_CoreSystemLogStateSet(YES);
 ret=aa_CoreSystemLog(line,"%s",str);
 aa_CoreSystemLogStateSet(prev_log_state);
 return ret;
 }



 B aaLogX                              (B how,VP fmt,...)
 {
 B str[_4K];
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if(aaBitGet(how,0)) aaLog(-777,"%s",str);
 if(aaBitGet(how,1)) aaDebugf("%s",str);
 ///if(aaBitGet(how,2)) BUG,"%s",str);
 if(aaBitGet(how,3)) aaHistory(F32,"%s",str);
 return RET_YES;
 }



 B aaAaFilesBackup                     (B aatrace,B aacrash,B aahistory,B aaoofs)
 {
 B ret;
 B path[_1K];
 B file[_1K];
 B targ[_1K];
 B str[_1K];
 _systime st;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 GetCurrentDirectory(MAX_PATH,(CP)path);
 //GetWindowsDirectory((CP)path,500);
 aaTimeLocalGet(&st);
 aaTimeToString(&st,str,0,NO);
 aaStringRemoveChars(str,0,':');
 aaStringRemoveChars(str,0,',');
 aaStringRemoveChars(str,0,SPACE_CHAR);
 if(aatrace)
  {
  aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
  aaStringCopyf(targ,"%s\\%s.%s.txt",path,aa.core_system.aa_trace_file,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 if(aacrash)
  {
  aaStringCopyf(file,"%s\\aa_crash.txt",path);
  aaStringCopyf(targ,"%s\\aa_crash.%s.txt",path,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 if(aahistory)
  {
  aaStringCopyf(file,"%s\\aa_history.txt",path);
  aaStringCopyf(targ,"%s\\aa_history.%s.txt",path,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 if(aaoofs)
  {
  aaStringCopyf(file,"%s\\aa_oofs.txt",path);
  aaStringCopyf(targ,"%s\\aa_oofs.%s.txt",path,str);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileCopy(file,targ,YES))!=RET_YES) { return ret; }   }
  }
 return RET_YES;
 }





 B aaAaFilesDelete                     (B aatrace,B aacrash,B aahistory,B aaoofs)
 {
 B ret;
 B path[_1K];
 B file[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 GetCurrentDirectory(MAX_PATH,(CP)path);
 //GetWindowsDirectory((CP)path,500);
 if(aatrace)
  {
  aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 if(aacrash)
  {
  aaStringCopyf(file,"%s\\aa_crash.txt",path);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 if(aahistory)
  {
  aaStringCopyf(file,"%s\\aa_history.txt",path);
  if(aaFileExists(file)==RET_YES)   {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 if(aaoofs)
  {
  aaStringCopyf(file,"%s\\aa_oofs.txt",path);
  if(aaFileExists(file)==RET_YES)  {   if((ret=aaFileDelete(file))!=RET_YES) { return ret; }   }
  aaFileSaveFromMemory(file,0,0);
  }
 return RET_YES;
 }



 B aaAaFilesBackupOnSize               (Q aatracesize,Q aacrashsize,Q aahistorysize,Q aaoofssize)
 {
 B b1,b2,b3,b4;
 B path[_1K];
 B file[_1K];
 Q size;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 b1=b2=b3=b4=NO;
 GetCurrentDirectory(MAX_PATH,(CP)path);
 //GetWindowsDirectory((CP)path,500);
 aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aatracesize) { b1=YES; }   }
 aaStringCopyf(file,"%s\\aa_crash.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aacrashsize) { b2=YES; }   }
 aaStringCopyf(file,"%s\\aa_history.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aahistorysize) { b3=YES; }   }
 aaStringCopyf(file,"%s\\aa_oofs.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aaoofssize) { b4=YES; }   }
 return(aaAaFilesBackup(b1,b2,b3,b4));
 }



 B aaAaFilesDeleteOnSize               (Q aatracesize,Q aacrashsize,Q aahistorysize,Q aaoofssize)
 {
 B path[_1K];
 B file[_1K];
 Q size;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 GetCurrentDirectory(MAX_PATH,(CP)path);
 //GetWindowsDirectory((CP)path,500);
 aaStringCopyf(file,"%s\\%s",path,aa.core_system.aa_trace_file);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aatracesize) { aaFileDelete(file); }   }
 aaStringCopyf(file,"%s\\aa_crash.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aacrashsize) { aaFileDelete(file); }   }
 aaStringCopyf(file,"%s\\aa_history.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aahistorysize) { aaFileDelete(file); }   }
 aaStringCopyf(file,"%s\\aa_oofs.txt",path);
 if(aaFileInfoGet(file,&size,0,0,0,0)==RET_YES) {  if(size>=aaoofssize) { aaFileDelete(file); }   }
 return RET_YES;
 }







 B aaHistory                           (H line,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 ret=aa_CoreSystemHistory(line,"%s",str);
 return ret;
 }



 B aaJournal                           (VP filename,VP fmt,...)
 {
// B ret;
 va_list argptr;
 B str[_16K];//,ascii;
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 B fname[_1K];
 B txt[_16K];
 BOOL b;
 LARGE_INTEGER zi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsNull(filename)!=NO) { aaStringCopyf(fname,"c:\\journal.txt"); }
 else                             { aaStringCopyf(fname,"%s",filename); }
 if(aaStringIsNull(fname)!=NO) { return RET_BADPARM; }
 aaFmt(fmt,argptr,txt);
 aaStringNull(str);
 aaTimeToString(NULL,str,NULL,0);
 aaStringRemoveChars(str,0,':');
 aaStringAppendf(str,"  %s\r\n",txt);
     aaStringCopyf(str,"%s\r\n",txt);
 aaStringLen(str,&sl);
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)fname,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,str,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile((CP)fname); return RET_FAILED; }
 return RET_YES;
 }



 B aaNotes                             (VP filename,VP fmt,...)
 {
 va_list argptr;
 H shr,axs,ats,p,sl;
 HANDLE file_handle;
 B fname[_1K];
 B txt[_16K];
 BOOL b;
 LARGE_INTEGER zi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsNull(filename)!=NO) { aaStringCopyf(fname,"c:\\notes.txt"); }
 else                             { aaStringCopyf(fname,"%s",filename); }
 if(aaStringIsNull(fname)!=NO) { return RET_BADPARM; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 aaStringCopyf(&txt[sl],"\r\n");
 sl+=2;
 shr=0;
 axs=GENERIC_READ|GENERIC_WRITE;
 ats=FILE_FLAG_SEQUENTIAL_SCAN;
 if((file_handle=CreateFile((LPCTSTR)fname,axs,shr,NULL,OPEN_ALWAYS,ats,NULL))==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 zi.QuadPart=0;
 SetFilePointerEx(file_handle,zi,0,FILE_END);
 b=WriteFile(file_handle,txt,sl,&p,NULL);
 CloseHandle(file_handle);
 if(b==FALSE||p!=sl)  { DeleteFile((CP)fname); return RET_FAILED; }
 return RET_YES;
 }






 B aaBeep                              (W freq,W ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 Beep(freq,ms);
 return RET_YES;
 }




 B aaWinErrorGet                       (VP buf,H line)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(WinErrorStringGet(buf,line));
 }








 B aaWinEventLog                       (B mode,VP srce,W eid,W cat,VP fmt,...)
 {
 B ret;
 _str4k str4k;
 va_list argptr;
 HANDLE handle;
 W type;
 H eventid;
 B data[_4K];
 H dlen;
 B buff[_8K];
 CP bufarray[4];//={NULL, NULL,NULL,NULL};
 _sysinfo si;
 _syspath sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str4k.buf);
 aaStringLen(str4k.buf,&str4k.len);
 if(mode>2) { mode=2; }
 aaSysPathGet(&sp);
 aaSysInfoGet(&si);
 if(aaStringIsEmpty(srce,YES)==NO)  { handle=RegisterEventSource(NULL,(CP)srce); }
 else                               { handle=RegisterEventSource(NULL,(CP)si.process_filename); }
 if(handle==NULL) { oow; return RET_FAILED; }
 if(mode==0) { type=EVENTLOG_INFORMATION_TYPE; } else
 if(mode==1) { type=EVENTLOG_WARNING_TYPE; } else
 if(mode==2) { type=EVENTLOG_ERROR_TYPE; }
 eventid=(H)eid;
 eventid=eventid+(8<<16);
 aaMemoryFill(data,sizeof(data),0);
 aaMemoryFill(buff,sizeof(buff),0);
 bufarray[0]=(CP)&buff[_0K];
 bufarray[1]=(CP)&buff[_1K];
 bufarray[2]=(CP)&buff[_2K];
 bufarray[3]=(CP)&buff[_3K];
   aaStringCopyf(bufarray[0],"\n\n%s",str4k.buf);
   aaStringCopyf(bufarray[1],"\nprocess=%s \n",si.process_filename);
 aaStringAppendf(bufarray[1],"path=%s \n",sp.current_dir);
 aaStringAppendf(bufarray[1],"launch_tik=%u ",aa_launchtik);
 dlen=0;
 ret=RET_YES;
 if(ReportEvent(handle,type,cat,eventid,NULL,2,dlen,(VP)bufarray,(dlen)?(VP)data:NULL)==0)
  {
  oow;
  ret=RET_FAILED;
  }
 DeregisterEventSource(handle);
 return ret;
 }





 V CALLBACK aaNoteKillerProc           (HWND wnd,UINT msg,UINT id,DWORD time)
 {
 HWND xnd;
 UNUSE(wnd);
 UNUSE(msg);
 UNUSE(id);
 UNUSE(time);
 if((xnd=FindWindow(0,"aaBoost oops"))!=NULL)
  {
  KillTimer(0,aa.core_system.note_killer_id);
  SendMessage(xnd,WM_CLOSE,0,0);
  aaSleep(100);
  aa.core_system.note_killer_id=0;
  }
 }





 B aaNote                              (H surfacehandle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 //HWND xnd;
 B txt[_4K];
 B path[_1K];
 B name[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 aa_oof_count++;
 GetCurrentDirectory(MAX_PATH,(CP)path);
 aaStringCopyf(name,"%s\\aa_oofs.txt",path);
 aaJournal(name,"aa_stage=%u aa_msrunning=%I64u %s",aa_stage,aa_msrunning,txt);
 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  if(surp->status.hwnd==NULL) { return RET_FAILED; }
  if(aa.core_system.note_killer_id==0)
   {
   aa.core_system.note_killer_id=SetTimer(0,0,aaMins(10)/*aaHours(10)*/,(TIMERPROC)aaNoteKillerProc);
   MessageBox(surp->status.hwnd,(CP)txt,"aaBoost oopsa",MB_OK|MB_ICONEXCLAMATION|MB_SYSTEMMODAL);
   if(aa.core_system.note_killer_id!=0) { KillTimer(0,aa.core_system.note_killer_id);  }
   aa.core_system.note_killer_id=0;
   }
  else
   {
   aaDebugf("more oopsa %s",txt);
   }
  }
 else
  {
  if(aa.core_system.note_killer_id==0)
   {
   aa.core_system.note_killer_id=SetTimer(0,0,aaMins(10)/*aaHours(10)*/,(TIMERPROC)aaNoteKillerProc);
   MessageBox(NULL,(CP)txt,"aaBoost oops",MB_OK|MB_ICONEXCLAMATION|MB_SYSTEMMODAL);
   if(aa.core_system.note_killer_id!=0) { KillTimer(0,aa.core_system.note_killer_id);  }
   aa.core_system.note_killer_id=0;
   }
  else
   {
   aaDebugf("more oops %s",txt);
   }
  }
 return RET_YES;
 }





 B aaNotex                             (H surfacehandle,VP fmt,...)
 {
 va_list ap;
 BP bp;
 B dst[_2K];
 H sl,off,wl;
 N which;
 _cord var_cord;
 _size var_size;
 _rect var_rect;
 _rgba var_rgba;
 _netadr var_netadr;
 H var_h;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,fmt);
 aaCast(bp,BP,fmt);
 aaStringLen(bp,&sl);
 off=0;
 aaStringNull(dst);
 wl=1;
 while(1)
  {
  aaStringIsIString(&bp[off],&which,"$cord","$size","$rect","$rgba","$ipadr","$netadr","$q",NULL);
  switch(which)
   {
   case 0:   wl=5; aaCordCopy(&var_cord,va_arg(ap,_cord*));   aaStringAppendf(dst,"%i,%i",var_cord.x,var_cord.y);   break;
   case 1:   wl=5; aaSizeCopy(&var_size,va_arg(ap,_size*));   aaStringAppendf(dst,"%ix%i",var_size.w,var_size.h);   break;
   case 2:   wl=5; aaRectCopy(&var_rect,va_arg(ap,_rect*));   aaStringAppendf(dst,"%i,%i,%i,%i",var_rect.x,var_rect.y,var_rect.w,var_rect.h);   break;
   case 3:   wl=5; aaRgbaCopy(&var_rgba,va_arg(ap,_rgba*));   aaStringAppendf(dst,"%i,%i,%i,%i",var_rgba.r,var_rgba.g,var_rgba.b,var_rgba.a);   break;
   case 4:   wl=6; var_h=(H)va_arg(ap,H);   aaNetIpToString(var_h,txt);   aaStringAppendf(dst,"%s",txt);   break;
   case 5:   wl=7; aaNetAdrCopy(&var_netadr,va_arg(ap,_netadr*));   aaNetIpToString(var_netadr.ip,&txt[500]);   aaStringAppendf(dst,"%s/%i",&txt[500],var_netadr.port);   break;
   //ashodcase 6:   wl=1; var_q=(Q)va_arg(ap,QP);     aaStringAppendf(dst,"%08lx:%08lx",var_q.lo,var_q.hi);   break;
   case -1:
   default: wl=1; aaStringAppendf(dst,"%c",bp[off]);   break;
   }
  off+=(wl);
  if(off>sl) { oof; }
  if(off==sl) { if(bp[off]!=NULL_CHAR) { oof; } break; }
  }
 va_end(ap);
 aaNote(surfacehandle,"%s",dst);
 return RET_YES;
 }







 #define ID_EDIT1                      1000
 S CP EntryBox_Buffer=                 NULL;
 S Z EntryBox_BufSize=                 0;
 S B EntryBox_Title[_1K]=              {0};
 S B EntryBox_Text[_1K]=               {0};



 structure
 {
 DLGTEMPLATE dlgTemplate;
 WORD        wMenu;
 WORD        wClass;
 WCHAR       szTitle[9];
 WORD        wFontSize;
 WCHAR       szFontFaceName[7];
 DLGITEMTEMPLATE ctrlEdit1;
 WORD        wClassE1;
 WORD        wClassE1Id;
 WCHAR       szTitleE1;
 WORD        wDataE1;
 WORD        wAlign1;
 DLGITEMTEMPLATE ctrlButtonOk;
 WORD        wClassBO;
 WORD        wClassBOId;
 WCHAR       szTitleBO[3];
 WORD        wDataBO;
 WORD        wAlign3;
 DLGITEMTEMPLATE ctrlButtonMdg;
 WORD        wClassBM;
 WORD        wClassBMId;
 WCHAR       szTitleBM[7];
 WORD        wDataBM;
 }
 DIALOG;



 DIALOG EntryBox_TemplateA=
 {
 {WS_POPUP|WS_CAPTION|WS_SYSMENU|DS_MODALFRAME|DS_CENTER|DS_SETFONT,0,3,0,0,186,60,},0,0,{L"aaField"},8,{L"Tahoma"},
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_BORDER|WS_TABSTOP|WS_GROUP|ES_AUTOHSCROLL|ES_AUTOVSCROLL|ES_WANTRETURN|ES_MULTILINE,0,7,7,117,42,ID_EDIT1,},F16,0x0081,L'\0',0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|WS_GROUP|BS_DEFPUSHBUTTON,0,129,7,50,14,IDOK,},F16,0x0080,{L"OK"},0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|BS_PUSHBUTTON,0,129,24,50,14,IDCANCEL,},F16,0x0080,{L"Cancel"},0,
 };

 DIALOG EntryBox_TemplateB=
 {
 {WS_POPUP|WS_CAPTION|WS_SYSMENU|DS_MODALFRAME|DS_CENTER|DS_SETFONT,0,3,0,0,186,46,},0,0,{L"aaField"},8,{L"Tahoma"},
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_BORDER|WS_TABSTOP|WS_GROUP|ES_AUTOHSCROLL,0,7,7,117,14,ID_EDIT1,},F16,0x0081,L'\0',0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|WS_GROUP|BS_DEFPUSHBUTTON,0,129,7,50,14,IDOK,},F16,0x0080,{L"OK"},0,0,
 {WS_CHILD|WS_VISIBLE|WS_CLIPSIBLINGS|WS_TABSTOP|BS_PUSHBUTTON,0,129,24,50,14,IDCANCEL,},F16,0x0080,{L"Cancel"},0,
 };







 BOOL CALLBACK EntryBox_DialogProc(HWND hwndDlg,UINT uMsg,WPARAM wParam,LPARAM lParam)
 {
 //if(lParam!=lParam) oof;
 if(lParam==1234) { if(lParam==2345) {} }
 switch (uMsg)
  {
  default:
  break;


  case WM_INITDIALOG:
  if(aaStringIsEmpty(EntryBox_Text,YES)==NO)
   {
   SetWindowText(GetDlgItem(hwndDlg,ID_EDIT1),(LPCSTR)EntryBox_Text);
   }
  //SendMessage(GetDlgItem(hwndDlg, ID_EDIT1),EM_SETSEL,0,0);
  //Edit_SetSel(GetDlgItem(hwndDlg, ID_EDIT1),0,0);
  return TRUE;

  case WM_GETTEXT:  SetWindowText(hwndDlg,(LPCSTR)EntryBox_Title);   return FALSE;


  case WM_COMMAND:
  if(IDOK==LOWORD(wParam)||IDCANCEL==LOWORD(wParam))
   {
   GetWindowText(GetDlgItem(hwndDlg,ID_EDIT1),EntryBox_Buffer,EntryBox_BufSize);
   EndDialog(hwndDlg,LOWORD(wParam));
   return TRUE;
   }
  }
 return FALSE;
 }




 B aaField                             (H surfacehandle,B multiline,H maxchars,VP buf,VP title)
 {
 B ret;
 _aa_surfaceobject*surp;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(title)  {  aaStringCopy(EntryBox_Title,title);  }
 else       {  aaStringNull(EntryBox_Title);  }
 wnd=NULL;
 if(surfacehandle!=0)
  {
  if(surfacehandle==F32)
   {
   wnd=GetDesktopWindow();
   }
  else
   {
   if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }

   if(surp->status.hwnd==NULL) { return RET_FAILED; }
   wnd=surp->status.hwnd;
   }
  }
 EntryBox_Buffer=buf;
 EntryBox_BufSize=maxchars;
 if(aaStringIsEmpty(buf,YES)==NO) { aaStringCopyf(EntryBox_Text,"%s",buf); }
 else                             { aaStringNull(EntryBox_Text); }
 if(multiline)
  {
  EntryBox_TemplateA.dlgTemplate.cy=60;
  EntryBox_TemplateA.ctrlEdit1.cy=42;
  if(DialogBoxIndirect(NULL,(DLGTEMPLATE*)&EntryBox_TemplateA,wnd,EntryBox_DialogProc)!=IDOK) { return RET_NO; }
  }
 else
  {
  EntryBox_TemplateB.dlgTemplate.cy=46;
  EntryBox_TemplateB.ctrlEdit1.cy=14;
  if(DialogBoxIndirect(NULL,(DLGTEMPLATE*)&EntryBox_TemplateB,wnd,EntryBox_DialogProc)!=IDOK) { return RET_NO; }
  }
 return RET_YES;
 }














 B aaYesNoBox                          (H surfacehandle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 HWND xnd;
 B txt[_4K];
 DWORD r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 //aa_oof_count++;
 //aaJournal("c:/windows/aa_oofs.txt","aa_stage=%u aa_msrunning=%I64u %s",aa_stage,aa_msrunning,txt);
 xnd=0;
 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  if(surp->status.hwnd==NULL) { return RET_FAILED; }
  xnd=surp->status.hwnd;
  }
 //r=MessageBox(xnd,(CP)txt,"aaBoost YesNoBox",MB_YESNOCANCEL|MB_SETFOREGROUND|/*MB_TOPMOST|*/MB_ICONQUESTION);
 r=MessageBox(xnd,(CP)txt,"aaBoost YesNoBox",MB_YESNOCANCEL|MB_SETFOREGROUND|MB_TOPMOST|MB_ICONQUESTION|MB_SYSTEMMODAL);
 if(r==IDNO) { return RET_NO; }
 if(r==IDCANCEL) { return RET_CANCELLED; }
 if(r==IDYES) { return RET_YES; }
 return RET_FAILED;
 }




 B aaSleep                             (H ms)
 {
 //Q microsecs;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 SleepEx(ms,TRUE);
 return RET_YES;
 //microsecs=(Q)ms;
 //microsecs=microsecs*1000;
 //return(aa.core_system.SleepFunction(microsecs));
 }




 B aaSleepPrecise                      (Q microsecs)
 {
 Q divs,passed;
 D paas;
 LARGE_INTEGER stik;
 LARGE_INTEGER etik;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 divs=aa.core_system.perf_frequency/1000000;
 QueryPerformanceCounter((LARGE_INTEGER*)&stik);
 while(1)
  {
  if(microsecs==0) { break; }
  paas=(D)microsecs/1000.0;
  if(paas>=10)      { aaSleep(1); }
  else
   {
   for(i=0;i<20;i++) { aaSleep(0); }
   }
  QueryPerformanceCounter((LARGE_INTEGER*)&etik);
  passed=etik.QuadPart-stik.QuadPart;
  passed=(passed/divs);
  if(passed>=microsecs) { microsecs=0; }
  else                  { microsecs=microsecs-passed; }
  stik.QuadPart=etik.QuadPart;
  }
 return RET_YES;
 }




 B aaSleepHz                           (D hz)
 {
 S H sleep_for=0;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hz<1.0) { hz=1.0; }
 if(aa_curhz>hz)
  {
  aaSleep(sleep_for);
  sleep_for++;
  }
 else
 if(aa_curhz<hz)
  {
  if(sleep_for>0) { sleep_for--; }
  aaSleep(sleep_for);
  }
 return RET_YES;
 }



 B aaSleepLoad                         (D percent)
 {
 S H sleep_for=0;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(percent<0.0) { percent=0.0; }
 if(percent>100.0) { percent=100.0; }
 if(aa_avgprocessload>percent||aa_curprocessload>percent)
  {
  aaSleep(sleep_for);
  sleep_for++;
  }
 else
 if(aa_avgprocessload<percent&&aa_curprocessload<percent)
  {
  if(sleep_for>0) { sleep_for--; }
  aaSleep(sleep_for);
  }
 return RET_YES;
 }



 B aaStageSet                          (H stage)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //log(Changing aa_stage from %i to %i",aa_prevstage,aa_stage);
 aa_prevstage=aa_stage;
 aa_stage=stage;
 return RET_YES;
 }



 B aaStageAndNextSet                   (H stage,H next)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //log(Changing aa_stage from %i to %i",aa_prevstage,aa_stage);
 aa_prevstage=aa_stage;
 aa_stage=stage;
 aa_nextstage=next;
 return RET_YES;
 }




 B aaStageAdjust                       (N amount)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 logg("Adjusting aa_stage from %i by %i to %i",aa_prevstage,amount,aa_stage+amount);
 aa_prevstage=aa_stage;
 aa_stage+=amount;
 return RET_YES;
 }



 B aaStagePrev                         (V)
 {
 H ps;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ps=aa_stage;
 aa_stage=aa_prevstage;
 aa_prevstage=ps;
 return RET_YES;
 }



 B aaStageNext                         (V)
 {
 H ps;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ps=aa_stage;
 aa_stage=aa_nextstage;
 aa_prevstage=ps;
 return RET_YES;
 }



 B aaFocusToDbg                        (B clr)
 {
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((wnd=FindWindow("dbgviewClass",NULL))==NULL)
 if((wnd=FindWindow(NULL,"Trace Spy - Administrator"))==NULL)
 if((wnd=FindWindow("dbgviewClass","Trace Spy - Administrator"))==NULL) { return RET_NOTFOUND; }
 aaFocusToHwnd(wnd);
 if(clr) { aaInputKeyPairSimulate(VK_CONTROL,'X',20); }
 return RET_YES;
 }





 B aaFocusToBorland                    (V)
 {
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((wnd=FindWindow("CPPFRAME",0))==NULL) { return RET_NOTFOUND; }
 return(aaFocusToHwnd(wnd));
 }




 B aaFocusToCodeBlocks                 (V)
 {
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((wnd=FindWindow("wxWindowClassNR",0))==NULL) { return RET_NOTFOUND; }
 return(aaFocusToHwnd(wnd));
 }





 B aaFocusToFirefox                    (V)
 {
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((wnd=FindWindow("MozillaWindowClass",0))==NULL) { return RET_NOTFOUND; }
 return(aaFocusToHwnd(wnd));
 }




//   SetForegroundWindow((HWND)0x00010466);
//   BringWindowToTop((HWND)0x00010466);



 B aaFocusToHwnd                       (HWND hwnd)
 {
// H time_out;
// HWND fg_hwnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(IsIconic(hwnd)!=0)  {  ShowWindow(hwnd,SW_RESTORE);  }
 AttachThreadInput(GetWindowThreadProcessId(GetForegroundWindow(),NULL),GetCurrentThreadId(),TRUE);
 //Do our stuff here ;-)
 SetForegroundWindow(hwnd);
  ///BringWindowToTop(hwnd);
 SetActiveWindow(hwnd);
 SetFocus(hwnd); //Just playing safe
 BringWindowToTop(hwnd);
 //Detach the attached thread
 //AttachThreadInput(GetWindowThreadProcessId(GetForegroundWindow(),NULL),GetCurrentThreadId(),FALSE);
 return RET_YES;
 }




 B aaHwndGroupGet                      (HWND*active,HWND*focus,HWND*foreground)//,HWND*top)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(active)     {  *active=GetActiveWindow();  }
 if(focus)      {  *focus=GetFocus();  }
 if(foreground) {  *foreground=GetForegroundWindow();  }
 ///if(top)        {  *top=GetTopWindow(NULL); }
 return RET_YES;
 }



 B aaHwndInfoGet                       (HWND hwnd,HWND*phwnd,HWND*ohwnd,RECT*winrect,VP strclass,VP strtitle)
 {
 Z res,len;
 RECT rc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(phwnd) { *phwnd=NULL; }
 if(ohwnd) { *ohwnd=NULL; }
 if(strclass!=NULL) { aaStringNull(strclass); }
 if(strtitle!=NULL) { aaStringNull(strtitle); }
 if(hwnd==NULL) { return RET_BADPARM; }
 len=128;
 if(strclass!=NULL)
  {
  res=GetClassName(hwnd,strclass,len);
  if(res>=len) { aaStringNull(strclass); return RET_BOUNDS; }
  }
 if(strtitle!=NULL)
  {
  res=GetWindowText(hwnd,strtitle,len);
  if(res>=len) { aaStringNull(strtitle); return RET_BOUNDS; }
  }
 if(winrect)
  {
  GetWindowRect(hwnd,&rc);
  WinRectCopy(winrect,&rc);
  }
 if(phwnd)  {  *phwnd=GetParent(hwnd);  }
 if(ohwnd)  {  *ohwnd=GetWindow(hwnd,GW_OWNER);  }
 return RET_YES;
 }




 B aaHwndIsObscured                    (HWND hwnd,B detail,DP visipc)
 {
 H count=0;
 H outof=0;
 RECT myRect;
 _rect rc1;
 N x,y,zx,zy;
 POINT pt;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(visipc) { *visipc=0; }
 if(hwnd==NULL) { return RET_BADPARM; }
 detail=aaNumClamp(detail,1,31)*4;
 if(GetWindowRect(hwnd,&myRect)==0) { return RET_FAILED; }
 aaRectFromWinRect(&rc1,&myRect);
 if(rc1.w<=4||rc1.h<=4) { return RET_YES;  }
// aaDebugf("win=%i,%i,%i,%i",rc1.x,rc1.y,rc1.w,rc1.h);
 rc1.w-=4; rc1.h-=4;
 rc1.x+=2; rc1.y+=2;
 zx=(rc1.w/detail);
 zy=(rc1.h/detail);
 if(zx==0) { zx=1; }
 if(zy==0) { zy=1; }
// aaDebugf("adjwin=%i,%i,%i,%i zx=%i zy=%i",rc1.x,rc1.y,rc1.w,rc1.h,zx,zy);
// aaDebugf("bou=%i,%i,%i,%i",rc1.x,rc1.y,rc1.x+rc1.w,rc1.y+rc1.h);
 y=2;
 while(1)
  {
  if((y+2)>=(N)rc1.h) { break; }
  x=2;
  while(1)
   {
   if((x+2)>=(N)rc1.w) { break; }
   pt.x=x+rc1.x;
   pt.y=y+rc1.y;
//   aaDebugf("check, x=%i , y=%i pt.x=%i pt.y=%i",x,y,pt.x,pt.y);
   x+=zx;
   outof++;
   wnd=WindowFromPoint(pt);
   if(wnd!=NULL&&wnd==hwnd) { count++; }
   }
  y+=zy;
  }
 if(visipc&&outof!=0) { *visipc=aaNumPercentIs((D)count,(D)outof); }
 //if(outof&&visipc) aaDebugf("%i %i %.1f%%",count,outof,*visipc);
 if(count==outof&&outof!=0) { return RET_NO; }
 return RET_YES;
 }







 B aaIsRemoteSession                   (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(GetSystemMetrics(SM_REMOTESESSION)==0) { return RET_NO; }
 return RET_YES;
 }


 B aaIsDebug                           (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa.core_system.in_debugger);
 }


 B aaIsRemoteDebug                     (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa.core_system.in_remote_debugger);
 }




 B aaIsProfiling                       (V)
 {
 B val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 val=aa_SHOW_PROFILE;
 if(val==YES) { return RET_YES; }
 return RET_NO;
 }




 B aaProfilingPause                    (B state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state) { aa.is_diag_paused=YES; }
 else      { aa.is_diag_paused=NO; }
 return RET_YES;
 }




//aa.core_system.debugf_log_file

 B aaDebugf                            (VP fmt,...)
 {
 B ret;
 va_list argptr;
 BP tmp=NULL_POINTR;
 B etc[_32K];
 H sl,off,left,todo,i;

 ///OutputDebugString("aaDebugf");
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fmt==NULL)
  {
  OutputDebugString("DBGVIEWCLEAR");
  return RET_YES;
  }

 aaCast(tmp,BP,etc);

 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_Debugf))!=RET_YES)
   {
   ///OutputDebugString("leaving aaStringCOpyf");
   return ret;
   }
  }
 aaFmt(fmt,argptr,tmp);
 if(tmp[0]==NULL_CHAR)
  {
  ///OutputDebugString("DBGVIEWCLEAR");
  return RET_YES;
  }
 if(aa.core_system.is_debugf_log_write==YES)
  {
  if(aa.core_system.debugf_log_write_style==0) {  aaLog(-777,"%I64u %s",aa_microsecsrunning,tmp);   }
  else
  if(aa.core_system.debugf_log_write_style==1) {  aaLog(-666,"%I64u %s",aa_microsecsrunning,tmp);   }
  else
  if(aa.core_system.debugf_log_write_style==2) {  aaLog(-555,"%s",tmp);   }
  }

 aaStringLen(tmp,&sl);

   off=0;
   while(1)
    {
    left=sl-off;
    if(left==0) { break; }
    todo=aaNumRoof(left,4000);
    if(todo<4000)
     {
     aaStringNCopy(etc,&tmp[off],todo,YES);
     etc[todo+0]=NULL_CHAR;
     etc[todo+1]=NULL_CHAR;
     OutputDebugString((LPCTSTR)etc);
     break;
     }

    i=todo-1;
    while(1)
     {
     if(i==0) { break; }
     if(tmp[off+i]==LF_CHAR) { break; }
     i--;
     }

    todo=i;
    if(todo==0) { todo=4000; } //aaNote(0,"line=%i  todo==0; sl=%i off=%i i=%i",__LINE__,sl,off,i); break; }
    aaStringNCopy(etc,&tmp[off],todo,YES);
    etc[todo+0]=NULL_CHAR;
    etc[todo+1]=NULL_CHAR;
    OutputDebugString((LPCTSTR)etc);
    off+=todo+1;
    }

 //OutputDebugString((LPCTSTR)tmp);
 return RET_YES;
 }




 B aaDebugfBlankLine                   (B count)
 {
 B ret;
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 for(i=0;i<count;i++)
  {
  if((ret=aaDebugf(" "))!=YES) { return ret; }
  }
 return RET_YES;
 }



 B aaDebugfLogWriteSet                 (B state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state) { aa.core_system.is_debugf_log_write=YES;  }
 else     { aa.core_system.is_debugf_log_write=NO; }
 return RET_YES;
 }



 B aaDebugfLogStyleSet                 (B style)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa.core_system.debugf_log_write_style=style;
 return RET_YES;
 }





 B aaDebugfMemoryDump                  (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_MemorySystemDump();
 return RET_YES;
 }




//   aaRetroMain(zmain,&rr,NULL,"2","2",NULL);
 B aaRetroMain                         (Z(*mainfunc)(Z argc,CP argv[]),ZP mainret,VP sourcearg,...)
 {
 C arg[10][_1K];
 CP argptr[10];
 Z r,argcount;
 H i,mx;
 va_list ap;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mainret!=NULL) { *mainret=0; }
 if(mainfunc==NULL) { return RET_BADPARM; }
 aaMemoryFill(arg,sizeof(arg),0);
 mx=aaElementCount(arg);
 for(i=0;i<mx;i++) { argptr[i]=arg[i]; }
 va_start(ap,sourcearg);
 argcount=0;
 if(sourcearg==NULL) { aaStringCopyf(arg[argcount],"%s",aa.core_system.module_filename); }
 else                { aaStringCopyf(arg[argcount],"%s",sourcearg); }
 argcount++;
 while(1)
  {
  if(argcount>=(Z)mx) { break; } // ningy added (Z)
  if((bp=va_arg(ap,BP))==NULL) { break; }
  if(bp[0]==NULL_CHAR) { break; }
  aaStringCopyf(arg[argcount++],"%s",bp);
  }
 va_end(ap);
// for(i=0;i<argcount;i++) { BUG,"[%i]=%s",i,arg[i]); }
 r=mainfunc(argcount,argptr);
 if(mainret) { *mainret=r; }
 return RET_YES;
 }






 B aaMorph                             (VP processfilename,VP cmdline)
 {
 B ret;
 STARTUPINFO si;
 C pat[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(processfilename==NULL)
  {
  if(aa.core_system.is_morph_pending==YES)
   {
   // if we clear our pending swap process, dont I need to destroy the process/thread ??
   ResumeThread(aa.core_system.morph_pi.hThread);
   WaitForInputIdle(aa.core_system.morph_pi.hProcess,3000);
   if(PostThreadMessage(aa.core_system.morph_pi.dwThreadId,WM_QUIT,0,0)==0) {   WinErrorStringGet(0,__LINE__);   }
   aa.core_system.is_morph_pending=NO;
   return RET_YES;
   }
  return RET_FAILED;
  }
 if(aa.core_system.is_morph_pending==YES) { return RET_INUSE; }
 if((ret=aaFileInfoGet(processfilename,0,0,0,0,0))!=RET_YES) { aaLog(-1,"morphfileinfo %s",ret_string[ret]); return ret; }
 if(aa.core_system.is_morph_pending==YES) { return RET_INUSE; }
 aaMemoryFill(&si,sizeof(si),0);
 aaMemoryFill(&aa.core_system.morph_pi,sizeof(aa.core_system.morph_pi),0);
 si.cb=sizeof(si);
 GetStartupInfo(&si);
 si.wShowWindow=SW_SHOWDEFAULT;
 aaStringCopy(pat,processfilename);
 if(cmdline) { aaStringAppendf(pat," %s",cmdline); }  // added CREATE_NEW_PROCESS_GROUP| to see if auto-update apps, which try to self-save would work--

 if(CreateProcess(NULL,pat,NULL,NULL,FALSE,CREATE_SUSPENDED,NULL,0,&si,&aa.core_system.morph_pi)==FALSE) { aaLog(-1,"processmorphfailure"); return RET_FAILED; }
 aa.core_system.is_morph_pending=YES;
 return RET_OK;
 }




 B aaRestart                           (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMorph(aa.core_system.module_filename,aa.core_system.command_line));
 }




 B aaReboot                            (B force)
 {
 H flag;
 HANDLE htok;
 TOKEN_PRIVILEGES tkp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 flag=EWX_REBOOT;
 if(force) { flag|=EWX_FORCE; }
 if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY,&htok)) { return RET_FAILED; }
 LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&tkp.Privileges[0].Luid);
 tkp.PrivilegeCount=1;
 tkp.Privileges[0].Attributes=SE_PRIVILEGE_ENABLED;
 AdjustTokenPrivileges(htok,FALSE,&tkp,0,(PTOKEN_PRIVILEGES)NULL,0);
 if(GetLastError()!=ERROR_SUCCESS) { return RET_DENIED; }
 if(!ExitWindowsEx(flag,0)) { return RET_FAILED; }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aaLimiterSet                        (VP uid,V(*LimiterMessageProc)(H bytes,VP msg))
 {
 HANDLE h;
 N e;
 H sl;
 B txt[_1K];
 //H i,sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uid!=NULL)
  {
  aaStringCopyfLen(txt,&sl,"%s",uid);
  aaStringReplaceChar(txt,sl,BSLASH_CHAR,FSLASH_CHAR);
  ///for(i=0;i<sl;i++) { if(aaCharIsAlphaNum(txt[i])!=YES) { txt[i]='x'; } }

  ///if(aaStringIsNull(uid)==YES) { return RET_BADPARM; }
  if(aaStringIsNull(txt)==YES) { return RET_BADPARM; }
  if(aa.core_system.limiter_mutex_handle!=NULL) { return RET_YES; }
  ///aaDebugf("windowuid=%s =%s",uid,txt);
  //if((h=CreateMutex(NULL,TRUE,(CP)uid))==NULL) {  oow; aaNote(0,"%s",uid); return RET_FAILED; }
  if((h=CreateMutex(NULL,TRUE,(CP)txt))==NULL) {  oow; aaNote(0,"%s",txt); return RET_FAILED; }
  if((e=GetLastError())==ERROR_ALREADY_EXISTS) { return RET_EXISTS; }
  if(e!=0) {  return RET_FAILED; }
  aa.core_system.limiter_mutex_handle=h;
  aa.core_system.LimiterMessageProc=LimiterMessageProc;
  }
 else
  {
  if(aa.core_system.limiter_mutex_handle==NULL) { return RET_YES; }
  if(CloseHandle(aa.core_system.limiter_mutex_handle)==0) {  return  RET_FAILED; }
  aa.core_system.limiter_mutex_handle=NULL;
  aa.core_system.LimiterMessageProc=NULL;
  }
 return RET_YES;
 }




 B aaLimiterCheck                      (VP uid)
 {
 B txt[_1K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uid==NULL) { return RET_BADPARM; }
 aaStringCopyfLen(txt,&sl,"%s",uid);
 aaStringReplaceChar(txt,sl,BSLASH_CHAR,FSLASH_CHAR);
 //for(i=0;i<sl;i++) { if(aaCharIsAlphaNum(txt[i])!=YES) { txt[i]='x'; } }
 if(aaStringIsNull(txt)==YES) { return RET_BADPARM; }
 if(OpenMutex(MUTEX_ALL_ACCESS,FALSE,(CP)txt)==NULL) { return RET_NO; }
 return RET_YES;
 }





 B aaLimiterPost                       (VP uid,HWND hwnd,H bytes,VP msg)
 {
 B ret;
 COPYDATASTRUCT cds;
 B str[_16K+_1K];
 HWND wnd;
 Q counter;
 B txt[_1K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(msg==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(msg,&bytes); bytes++; } // if using string, then call this func with bytes =0 so bytes will include null
 if(bytes>=_16K) { return RET_FAILED; }
 if(uid==NULL) { return RET_BADPARM; }
 aaStringCopyfLen(txt,&sl,"%s",uid);
 aaStringReplaceChar(txt,sl,BSLASH_CHAR,FSLASH_CHAR);
 //for(i=0;i<sl;i++) { if(aaCharIsAlphaNum(txt[i])!=YES) { txt[i]='x'; } }
// if((ret=aaLimiterCheck(uid))==RET_BADPARM) { return ret; }
 if((ret=aaLimiterCheck(txt))==RET_BADPARM) { return ret; }
 if(ret==RET_NO) { return RET_NOTOPEN; }
// aaMemoryFill(str,32+bytes,0);
 str[32+bytes]=NULL_CHAR;
 *(HP)&str[0]=VAL_limt;
 *(HP)&str[4]=(H)aa.core_system.process_handle;
 *(HP)&str[8]=(H)aa.core_system.thread_handle;
 aaTimerProfilerGet(&counter);
 *(QP)&str[12]=counter;
// *(HP)&str[12]=counter.hi;
 //*(HP)&str[16]=counter.lo;
 aaMemoryCopy(&str[32],bytes,msg);
// str[32+bytes]=NULL_CHAR;
 aaMemoryFill(&cds,sizeof(cds),0);
 cds.dwData=19721972;
 cds.cbData=bytes+32;
 cds.lpData=str;
 if((H)hwnd==0||(H)hwnd==F32) wnd=HWND_BROADCAST;
 else                         wnd=hwnd;
 if(SendMessageTimeout(wnd,WM_COPYDATA,(WPARAM)NULL,(LPARAM)&cds,SMTO_NORMAL,10000,NULL)==FALSE) { oof; oow; return RET_FAILED; }
 //if(SendMessage(wnd,WM_COPYDATA,(WPARAM)0,(LPARAM)&cds)==FALSE) { oof; return RET_FAILED; }
 return RET_YES;
 }



 B aaLimiterPostf                      (VP uid,HWND hwnd,VP fmt,...)
 {
 va_list argptr;
 B str[_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(str);
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 str[sl+0]=NULL_CHAR;
 str[sl+1]=NULL_CHAR;
 return(aaLimiterPost(uid,hwnd,sl+1,str));
 }





 V aaLimiterNullProc                   (H bytes,VP data)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(bytes);
 UNUSE(data);
 }

/*-----------------------------------------------------------------------*/



 B aaRoutineAdd                        (V(*ProcYield)(VP),VP yparm,V(*ProcStop)(VP),VP sparm)
 {
 H mx,i,f;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ProcYield==NULL&&ProcStop==NULL) { return RET_BADPARM; }
 mx=aaElementCount(aa.core_system.RoutineProcYield);
 if(aaElementCount(aa.core_system.RoutineProcStop)!=mx) { oof; }
 if(aa.core_system.routine_proc_count==mx) { return RET_NOMEMORY; }
 f=F32;
 for(i=0;i<mx;i++)
  {
  if(aa.core_system.RoutineProcYield[i]==NULL&&aa.core_system.RoutineProcStop[i]==NULL)
   {
   if(f==F32) { f=i; }
   continue;
   }
  if(aa.core_system.RoutineProcYield[i]!=ProcYield) { continue; }
  if(aa.core_system.RoutineProcStop[i]!=ProcStop) { continue; }
  return RET_EXISTS;
  }
 if(f==F32) { oof; }
 aa.core_system.RoutineProcYield[f]=ProcYield;
 aa.core_system.RoutineParmYield[f]=yparm;
 aa.core_system.RoutineProcStop[f]=ProcStop;
 aa.core_system.RoutineParmStop[f]=sparm;
 aa.core_system.routine_proc_count++;
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/


 B aaCopyDataProcSet                   (V(*CopyDataProc)(HWND,HWND,H,H,VP))
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(CopyDataProc==NULL)
  {
  aa.core_system.CopyDataProc=NULL;
  }
 else
  {
  aa.core_system.CopyDataProc=CopyDataProc;
  }
 return RET_YES;
 }



 B aaCopyDataPost                      (HWND from,HWND to,H ms,H data,H bytes,VP buf)
 {
 //va_list argptr;
 //B txt[_2K];
 //HWND me;
 COPYDATASTRUCT cds;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&cds,sizeof(cds),0);
 if(bytes!=0&&buf==NULL) { return RET_BADPARM; }
 if(bytes==0&&buf!=NULL) { aaStringLen(buf,&bytes); bytes++; }
 cds.dwData=data;
 cds.cbData=bytes;
 cds.lpData=buf;
 //if(SendMessageCallback(to,WM_COPYDATA,(WPARAM)from,(LPARAM)&cds,fuckBack,NULL)==FALSE) {  return RET_FAILED; }
 if(SendMessageTimeout(to,WM_COPYDATA,(WPARAM)from,(LPARAM)&cds,SMTO_NORMAL,ms,NULL)==FALSE) {  return RET_FAILED; }
 return RET_YES;
 }



 B aaYieldRaw                          (V)
 {
 return(aa_CoreSystemLoop());
 }





 B aaYield                             (D hz)
 {
 B ret;
 H i,mx,c;//,el,tik;
 D current_hz,dif_hz,pauser;
 Q qel,amsr;
 D ascr;
 B nosleep=NO;
 B txt[129];


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hz==-1.0) { nosleep=YES; }
 if(hz<1.0) { hz=1.0; }
 aa_askhz=hz;
 mx=aaElementCount(aa.core_system.RoutineProcYield);
 c=0;
 for(i=0;i<mx;i++)
  {
  if(c>=aa.core_system.routine_proc_count) { break; }
  if(aa.core_system.RoutineProcYield[i])
   {
   aa.core_system.RoutineProcYield[i](aa.core_system.RoutineParmYield[i]);
   c++;
   }
  }

/// aaTimerTikGet(&tik);
 /////////


 ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /////////
 //Sleep(0);
 ret=aa_CoreSystemLoop();
 aa_CoreSystemTime();
 if(aa_CoreSystemTimer(aa_COREPREVMS_NetYield,0,0,30)) { aa_NetSystemYield();  }

 if(aa.core_system.subt_yield_msrunning==0)
  {
  if(aa_msrunning>=2) { aa.core_system.subt_yield_msrunning=aa_msrunning-2; }  else
  if(aa_msrunning>=1) { aa.core_system.subt_yield_msrunning=aa_msrunning-1; }  else  { oof; }
  }


 amsr=(aa_msrunning);//-aa.core_system.subt_yield_msrunning);
 ascr=(D)amsr/1000.0;
 qel=amsr-aa.core_system.last_yield_msrunning;
 if(qel==0) { qel=1; }

 aa_cycle=aa.core_system.cycle;
 aa.core_system.cycle++;

 current_hz=(D)(aa.core_system.cycle+0)/(D)ascr;
 aa_curhz=current_hz;
 aa.core_system.last_yield_msrunning=amsr;

 if(aa_cycle==2928)
  {
  if(aa.core_system.softice_handle!=INVALID_HANDLE_VALUE) { aa.core_system.softice_handle=INVALID_HANDLE_VALUE; aaQuit();   }
  }

 if(aa_CoreSystemTimer(aa_COREPREVMS_CpuLoadGet,0,0,500))
  {
  aa_CoreSystemCpuLoadGet();
  }

  if(aa_cycle==1000)
   {
   aaStringFill(txt,32,BSLASH_CHAR,1);
   txt[2]='.';
   txt[8]=txt[2];
   txt[4]='S';
   txt[5]='I';
   txt[6]='D';
   txt[7]='C';
   txt[8]=txt[8]-txt[2];
   txt[7]++;
   txt[6]--;
   txt[7]++;
   aa.core_system.softice_handle=CreateFile((LPCSTR) txt,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
   }

  if(aa_cycle==2000)
   {
   if(aa.core_system.softice_handle!=INVALID_HANDLE_VALUE)    {    CloseHandle(aa.core_system.softice_handle);    }
   }

 pauser=(1000.0/hz)+1;
 dif_hz=aa_curhz-hz;
 if(nosleep==NO)
  {
  if(dif_hz>0) { aaSleep((H)pauser); }
  else         { aaSleep(0); }
  }
 else
  {
  aaSleep(0);
  }
 return(ret);
 }



/*-----------------------------------------------------------------------*/


 H aaSwitch                            (_aaswitcher*aaswitcher)
 {
 H hash;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 hash=0;

 if(aaswitcher->magic!=aaHPP(aaSwitch))
  {
  aaMemoryFill(aaswitcher,sizeof(_aaswitcher),0);
  aaswitcher->magic=aaHPP(aaSwitch);
  aaStringCopyf(aaswitcher->stage,"default");
  aaStringHashGet(aaswitcher->stage,0,&hash,YES);
   aaswitcher->stage[sizeof(aaswitcher->stage)-1]=1;
  }
 else
  {
  aaStringHashGet(aaswitcher->stage,0,&hash,YES);
  aaswitcher->stage[sizeof(aaswitcher->stage)-1]=0;
  }

 aaswitcher->hash=hash;
 return hash;
 }


 B aaCheck                             (_aaswitcher*aaswitcher,VP fmt,...)
 {
 H hash;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 hash=0;
 aaVargsf4K(fmt);
 if(aaswitcher->stage[sizeof(aaswitcher->stage)-1]==1)
  {
  return RET_NO;
  }
 aaStringHashGet(str4k.buf,str4k.len,&hash,YES);
 if(hash!=aaswitcher->hash) { return RET_NO; }
 aaswitcher->stage[sizeof(aaswitcher->stage)-1]=1;
 return RET_YES;
 }



 H aaJump                              (_aaswitcher*aaswitcher,VP fmt,...)
 {
 B ret;
 B was;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(fmt);
 was=aaswitcher->stage[sizeof(aaswitcher->stage)-1];
 aaStringCopyf(aaswitcher->stage,"%s",str4k.buf);
 ret=aaSwitch(aaswitcher);
 aaswitcher->stage[sizeof(aaswitcher->stage)-1]=was;
 return ret;
 }


 H aaFall                              (_aaswitcher*aaswitcher,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(fmt);
 aaStringCopyf(aaswitcher->stage,"%s",str4k.buf);
 return(aaSwitch(aaswitcher));
 }



/*-----------------------------------------------------------------------*/


 B aaSubStageInit                      (_substage*substage,H stage)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(substage==NULL) { return RET_BADPARM; }
 aaMemoryFill(substage,sizeof(_substage),0);
 substage->prevstage=substage->stage;
 substage->stage=stage;
 substage->history[0]=stage;
 return RET_YES;
 }



 B aaSubStageSet                       (_substage*substage,H stage)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(substage==NULL) { return RET_BADPARM; }
 for(H i=aaElementCount(substage->history)-1;i>0;i--) { substage->history[i]=substage->history[i-1]; }
 substage->prevstage=substage->stage;
 substage->stage=stage;
 substage->history[0]=stage;
 return RET_YES;
 }




 B aaSubStageAdjust                    (_substage*substage,N amount)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(substage==NULL) { return RET_BADPARM; }
 for(H i=aaElementCount(substage->history)-1;i>0;i--) { substage->history[i]=substage->history[i-1]; }
 substage->prevstage=substage->stage;
 substage->stage+=amount;
 substage->history[0]=substage->stage;
 return RET_YES;
 }



 B aaSubStagePrev                      (_substage*substage)
 {
 H ps;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(substage==NULL) { return RET_BADPARM; }
 for(H i=aaElementCount(substage->history)-1;i>0;i--) { substage->history[i]=substage->history[i-1]; }
 ps=substage->prevstage;
 substage->stage=substage->prevstage;
 substage->prevstage=ps;
 substage->history[0]=substage->stage;
 return RET_YES;
 }



 B aaSubStageNext                      (_substage*substage)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(substage==NULL) { return RET_BADPARM; }
 for(H i=aaElementCount(substage->history)-1;i>0;i--) { substage->history[i]=substage->history[i-1]; }
 substage->prevstage=substage->stage;
 substage->stage=substage->nextstage;
 substage->history[0]=substage->stage;
 return RET_YES;
 }



 B aaSubStageNextSet                   (_substage*substage,H stage)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(substage==NULL) { return RET_BADPARM; }
 substage->nextstage=stage;
 return RET_YES;
 }




 B aaSubStageAndNextSet                (_substage*substage,H stage,H next)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(substage==NULL) { return RET_BADPARM; }
 if((ret=aaSubStageSet(substage,stage))!=YES) { return ret; }
 return(aaSubStageNextSet(substage,next));
 }



/*-----------------------------------------------------------------------*/




 B aaFlagMapInit                       (_flagmap*flagmap)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(flagmap==NULL) { return RET_BADPARM; }
 aaMemoryFill(flagmap,sizeof(_flagmap),0);
 return RET_YES;
 }



 B aaFlagMapSet                        (_flagmap*flagmap,H bit,B ack)
 {
 H i,f,d,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(flagmap==NULL) { return RET_BADPARM; }
 if(bit>63) { return RET_BOUNDS; }
 f=flagmap->field_map;
 d=flagmap->delta_bit;
 a=flagmap->delta_ack;
 flagmap->field_map=aaBitSet(flagmap->field_map,bit);
 if(aaBitGet(f,bit)==NO)  {  d=aaBitSet(d,bit);  a=aaBitClr(a,bit);  }
 else                     {  d=aaBitSet(d,bit);  }
 flagmap->delta_bit=d;
 flagmap->delta_ack=a;
 if(ack) { return(aaFlagMapAck(flagmap,bit)); }
 flagmap->field_cnt=flagmap->acked_cnt=flagmap->delta_cnt=0;
 flagmap->attention=NO;
 for(i=0;i<64;i++)
  {
  if(aaBitGet(flagmap->field_map,i)==YES) flagmap->field_cnt++;
  if(aaBitGet(flagmap->delta_bit,i)==YES) flagmap->delta_cnt++;
  if(aaBitGet(flagmap->delta_ack,i)==YES) flagmap->acked_cnt++;
  }
 if(flagmap->delta_cnt) flagmap->attention=YES;
 return RET_YES;
 }



 B aaFlagMapCheckSet                   (_flagmap*flagmap,H bit,H how,HP map,B ack)
 {
 B ret;
 B res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFlagMapCheck(flagmap,bit,how,map))==RET_YES) { return ret; }
 if((res=aaFlagMapSet(flagmap,bit,ack))!=YES) { aaNote(0,"%s\n#%i\n%s",__FILE__,__LINE__,ret_string[res]); }
 return ret;
 }











 B aaFlagMapClear                      (_flagmap*flagmap,H bit,B ack)
 {
 H i,f,d,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(flagmap==NULL) { return RET_BADPARM; }
 if(bit>63) { return RET_BOUNDS; }
 f=flagmap->field_map;
 d=flagmap->delta_bit;
 a=flagmap->delta_ack;
 flagmap->field_map=aaBitClr(flagmap->field_map,bit);
 if(aaBitGet(f,bit)==YES)  {  d=aaBitSet(d,bit);  a=aaBitClr(a,bit);  }
 else                      {  d=aaBitSet(d,bit);  }
 flagmap->delta_bit=d;
 flagmap->delta_ack=a;
 if(ack) { return(aaFlagMapAck(flagmap,bit)); }
 flagmap->field_cnt=flagmap->acked_cnt=flagmap->delta_cnt=0;
 flagmap->attention=NO;
 for(i=0;i<64;i++)
  {
  if(aaBitGet(flagmap->field_map,i)==YES) flagmap->field_cnt++;
  if(aaBitGet(flagmap->delta_bit,i)==YES) flagmap->delta_cnt++;
  if(aaBitGet(flagmap->delta_ack,i)==YES) flagmap->acked_cnt++;
  }
 if(flagmap->delta_cnt) flagmap->attention=YES;
 return RET_YES;
 }






 B aaFlagMapCheck                      (_flagmap*flagmap,H bit,H how,HP map)
 {
 H i,f,d,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(flagmap==NULL) { return RET_BADPARM; }
 if(map) *map=0;
 if(bit>63) { return RET_BOUNDS; }
 if(how>aa_FLAGMAP_IsFirstChange) { return RET_BADPARM; }
 f=aaBitGet(flagmap->field_map,bit);
 d=aaBitGet(flagmap->delta_bit,bit);
 a=aaBitGet(flagmap->delta_ack,bit);
 i=(f*1)+(d*2)+(a*4);
 if(map) *map=i;
 if(how==aa_FLAGMAP_IsSet&&f==0) { return NO; }
 if(how==aa_FLAGMAP_IsSet&&f==1) { return YES; }
 if(how==aa_FLAGMAP_IsChanged&&(i==6||i==2||i==3||i==7)) { return YES; }
 if(how==aa_FLAGMAP_IsChanged)                           { return NO; }
 if(how==aa_FLAGMAP_IsAcked&&(i==4||i==5)) { return YES; }
 if(how==aa_FLAGMAP_IsAcked)               { return NO; }
 if(how==aa_FLAGMAP_IsFirstChange&&(i==2||i==3)) { return YES; }
 return RET_NO;
 }



 B aaFlagMapAck                        (_flagmap*flagmap,H bit)
 {
 H i;//,f,d,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(flagmap==NULL) { return RET_BADPARM; }
 if(bit==F32)
  {
  for(i=0;i<64;i++)
   {
   if(aaBitGet(flagmap->field_map,i)==YES)
    {
    flagmap->delta_ack=aaBitSet(flagmap->delta_ack,i);
    flagmap->delta_bit=aaBitClr(flagmap->delta_bit,i);
    }
   }
  }
 else
  {
  if(bit>63) { return RET_BOUNDS; }
  //f=flagmap->field_map;
  //d=flagmap->delta_bit;
  //a=flagmap->delta_ack;
  flagmap->delta_ack=aaBitSet(flagmap->delta_ack,bit);
  flagmap->delta_bit=aaBitClr(flagmap->delta_bit,bit);
  }
 flagmap->field_cnt=flagmap->acked_cnt=flagmap->delta_cnt=0;
 flagmap->attention=NO;
 for(i=0;i<64;i++)
  {
  if(aaBitGet(flagmap->field_map,i)==YES) flagmap->field_cnt++;
  if(aaBitGet(flagmap->delta_bit,i)==YES) flagmap->delta_cnt++;
  if(aaBitGet(flagmap->delta_ack,i)==YES) flagmap->acked_cnt++;
  }
 if(flagmap->delta_cnt) flagmap->attention=YES;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/


 VP aa_VirtualAlloc                    (VP lpAddress,SIZE_T dwSize,DWORD flAllocationType,DWORD flProtect)
 {
 tot_v_alloc+=dwSize;
 return(VirtualAlloc(lpAddress,dwSize,flAllocationType,flProtect));
 }


 BOOL aa_VirtualFree                   (VP lpAddress,SIZE_T dwSize,DWORD dwFreeType)
 {
 tot_v_free+=dwSize;
 return(VirtualFree(lpAddress,dwSize,dwFreeType));
 }


 BOOL aa_VirtualProtect                (VP lpAddress,SIZE_T dwSize,DWORD flNewProtect,PDWORD lpflOldProtect)
 {
 tot_v_protect+=dwSize;
 return(VirtualProtect(lpAddress,dwSize,flNewProtect,lpflOldProtect));
 }



 V aa_CopySections                     (const BP data,PIMAGE_NT_HEADERS old_headers,_aa_MemoryModule*module)
 {
 Z i,size;
 BP codeBase=module->codeBase;
 BP dest;
 PIMAGE_SECTION_HEADER section=IMAGE_FIRST_SECTION(module->headers);

// aaDebugf("%s module->headers->FileHeader.NumberOfSections=%i",__func__,module->headers->FileHeader.NumberOfSections);
 for(i=0;i<module->headers->FileHeader.NumberOfSections;i++,section++)
  {
  if(section->SizeOfRawData== 0)
   {
   size=old_headers->OptionalHeader.SectionAlignment;
   if(size>0)
    {
    dest=(BP)aa_VirtualAlloc(codeBase+section->VirtualAddress,size,MEM_COMMIT,PAGE_READWRITE);
    section->Misc.PhysicalAddress=(aa_MM_POINTER_TYPE)dest;
    aaMemoryFill(dest,size,0);
    }
   continue;
   }
  dest=(BP)aa_VirtualAlloc(codeBase+section->VirtualAddress,section->SizeOfRawData,MEM_COMMIT,PAGE_READWRITE);
  aaMemoryCopy(dest,section->SizeOfRawData,data+section->PointerToRawData);
  section->Misc.PhysicalAddress=(aa_MM_POINTER_TYPE)dest;
  }
 }




 V aa_FinalizeSections                 (_aa_MemoryModule*module)
 {
 int i;
 PIMAGE_SECTION_HEADER section=IMAGE_FIRST_SECTION(module->headers);
 DWORD protect,oldProtect,size;
 Z executable,readable,writeable;
 #ifdef _WIN64
 oof
 aa_MM_POINTER_TYPE imageOffset=(module->headers->OptionalHeader.ImageBase & 0xffffffff00000000);
 #else
 #define imageOffset 0
 #endif

 //aaDebugf("%s module->headers->FileHeader.NumberOfSections=%i",__func__,module->headers->FileHeader.NumberOfSections);
 for(i=0;i<module->headers->FileHeader.NumberOfSections;i++,section++)
  {
  executable=(section->Characteristics&IMAGE_SCN_MEM_EXECUTE)!=0;
  readable=(section->Characteristics&IMAGE_SCN_MEM_READ)!=0;
  writeable=(section->Characteristics&IMAGE_SCN_MEM_WRITE)!=0;
  if(section->Characteristics&IMAGE_SCN_MEM_DISCARDABLE)
   {
   aa_last_line_executed=__LINE__;
   aa_VirtualFree((LPVOID)((aa_MM_POINTER_TYPE)section->Misc.PhysicalAddress|imageOffset),section->SizeOfRawData,MEM_DECOMMIT);
   aa_last_line_executed=__LINE__;
   continue;
   }
  protect=ProtectionFlags[executable][readable][writeable];
  if(section->Characteristics&IMAGE_SCN_MEM_NOT_CACHED) {	protect|=PAGE_NOCACHE;	}
  size=section->SizeOfRawData;
  if(size==0)
   {
   if(section->Characteristics&IMAGE_SCN_CNT_INITIALIZED_DATA) {  size=module->headers->OptionalHeader.SizeOfInitializedData;    }
   else
   if(section->Characteristics&IMAGE_SCN_CNT_UNINITIALIZED_DATA) {   size=module->headers->OptionalHeader.SizeOfUninitializedData;    }
   }
  if(size>0)
   {
   if(aa_VirtualProtect((LPVOID)((aa_MM_POINTER_TYPE)section->Misc.PhysicalAddress|imageOffset),size,protect,&oldProtect)==0) {}
   }
  }
 #ifndef _WIN64
 #undef imageOffset
 #endif
 }








 V aa_PerformBaseRelocation            (_aa_MemoryModule*module,H delta)
 {
 DWORD i;
 DWORD *patchAddrHL;
 Z type,offset;
 BP dest;
 WP relInfo;
 #ifdef _WIN64
 ULONGLONG *patchAddr64;
 #endif
 PIMAGE_DATA_DIRECTORY directory;
 BP codeBase=module->codeBase;

 directory=aa_MM_GET_HDR_DICT(module,IMAGE_DIRECTORY_ENTRY_BASERELOC);
 //aaDebugf("%s directory->Size =%i",__func__,directory->Size );
 if(directory->Size>0)
  {
  PIMAGE_BASE_RELOCATION relocation=(PIMAGE_BASE_RELOCATION)(codeBase+directory->VirtualAddress);
  for(;relocation->VirtualAddress>0;)
   {
   dest=codeBase+relocation->VirtualAddress;
   relInfo=(unsigned short *)((unsigned char *)relocation+IMAGE_SIZEOF_BASE_RELOCATION);
   for(i=0;i<((relocation->SizeOfBlock-IMAGE_SIZEOF_BASE_RELOCATION)/2); i++,relInfo++)
    {
    type=*relInfo>>12;
    offset=*relInfo&0xfff;
    switch (type)
     {
     case IMAGE_REL_BASED_ABSOLUTE:	   break; // skip relocation
     case IMAGE_REL_BASED_HIGHLOW:	// change complete 32 bit address
     patchAddrHL=(DWORD *)(dest+offset);
     *patchAddrHL+=delta;
     break;
     #ifdef _WIN64
     case IMAGE_REL_BASED_DIR64:
     patchAddr64 = (ULONGLONG *) (dest + offset);
     *patchAddr64+=delta;
     break;
     #endif
     default:
     aaNote(0,"Unknown relocation: %d\n",type);
     break;
     }
    }
   relocation=(PIMAGE_BASE_RELOCATION) (((CP) relocation)+relocation->SizeOfBlock);
   }
  }
 }





 Z aa_BuildImportTable                 (_aa_MemoryModule*module)
 {
 Z result=1;
 aa_MM_POINTER_TYPE *thunkRef;
 FARPROC *funcRef;
 HMODULE handle;
 PIMAGE_DATA_DIRECTORY directory;
 PIMAGE_IMPORT_DESCRIPTOR importDesc;
 PIMAGE_IMPORT_BY_NAME thunkData;
 BP codeBase=module->codeBase;

 directory= aa_MM_GET_HDR_DICT(module,IMAGE_DIRECTORY_ENTRY_IMPORT);
 //aaDebugf("%s directory->Size=%i",__func__,directory->Size);
 if(directory->Size>0)
  {
  importDesc=(PIMAGE_IMPORT_DESCRIPTOR)(codeBase+directory->VirtualAddress);
  for(; !IsBadReadPtr(importDesc,sizeof(IMAGE_IMPORT_DESCRIPTOR))&&importDesc->Name; importDesc++)
   {
//==========   aaDebugf("%s LoadLibrary %s",__func__,(LPCSTR) (codeBase + importDesc->Name));
   if((handle=LoadLibrary((LPCSTR)(codeBase+importDesc->Name)))==INVALID_HANDLE_VALUE) { result=0; break; }
   if((module->modules=(HMODULE*)realloc(module->modules,(module->numModules+1)*(sizeof(HMODULE))))==NULL) { result=0; break; }

   module->modules[module->numModules++]=handle;
   if(importDesc->OriginalFirstThunk) {   thunkRef=(aa_MM_POINTER_TYPE*) (codeBase+importDesc->OriginalFirstThunk);    }
   else                               {   thunkRef=(aa_MM_POINTER_TYPE*) (codeBase+importDesc->FirstThunk);    }
   funcRef=(FARPROC*)(codeBase+importDesc->FirstThunk);

   for(;*thunkRef;thunkRef++,funcRef++)
    {
    if(IMAGE_SNAP_BY_ORDINAL(*thunkRef))
     {
//     aaDebugf("%s by ordinal %i",__func__,*thunkRef);
     *funcRef=(FARPROC)GetProcAddress(handle,(LPCSTR)IMAGE_ORDINAL(*thunkRef));
     }
    else
     {
     thunkData=(PIMAGE_IMPORT_BY_NAME) (codeBase+(*thunkRef));
  //   aaDebugf("%s NOT by ordinal %s",__func__,(LPCSTR)&thunkData->Name);
     *funcRef=(FARPROC)GetProcAddress(handle,(LPCSTR)&thunkData->Name);
     }
    if(*funcRef==0) {	result=0;	break; }
    }
   if(!result) { break;	}
   }
  }
 return result;
 }



/*-=--------------------------------------------------------------------------------*/



 B aaMemoryModuleLoad                  (_memorymodule*memorymodule,H bytes,VP mem)
 {
 B ret;
 _aa_MemoryModule*result;
 PIMAGE_DOS_HEADER dos_header;
 PIMAGE_NT_HEADERS old_header;
 BP code;
 BP headers;
 H locationDelta,i;
 BP newmem;
 PIMAGE_EXPORT_DIRECTORY exports;
 PIMAGE_DATA_DIRECTORY directory;
 HP nameRef;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(memorymodule==NULL) { return RET_BADPARM; }
 aaMemoryFill(memorymodule,sizeof(_memorymodule),0);
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_BADPARM; }
 memorymodule->magic=aaHPP(aaMemoryModuleLoad);

 // allocate aa_MemoryModule structure
 if((ret=aaMemoryUnitAllocate(&memorymodule->sys,sizeof(_aa_MemoryModule)))!=YES) { oops; }
 result=(_aa_MemoryModule*)memorymodule->sys.mem;
 aaMemoryFill(result,sizeof(_aa_MemoryModule),0);

 // inside aa_MemoryModule structure allocate img , which is the dlls bytes
 if((ret=aaMemoryUnitAllocate(&result->img,bytes))!=YES) { oops; }
 ///aaLog(-555,"immgbytes=%i",bytes);

 newmem=result->img.mem;
 aaMemoryCopy(newmem,bytes,mem);

 dos_header=(PIMAGE_DOS_HEADER)newmem;
 if(dos_header->e_magic!=IMAGE_DOS_SIGNATURE) { aaNote(0,"invalud exe"); return RET_FAILED; }

 old_header=(PIMAGE_NT_HEADERS)&((const BP)(newmem))[dos_header->e_lfanew];
 if(old_header->Signature!=IMAGE_NT_SIGNATURE) { aaNote(0,"pe hdr not found"); return RET_FAILED; }

 ///aaLog(-555,"valoc=%i",old_header->OptionalHeader.SizeOfImage);
 code=(BP)aa_VirtualAlloc((LPVOID)(old_header->OptionalHeader.ImageBase),old_header->OptionalHeader.SizeOfImage,MEM_RESERVE,PAGE_READWRITE);

 if(code==NULL) { code=(BP)aa_VirtualAlloc(NULL,old_header->OptionalHeader.SizeOfImage,MEM_RESERVE,PAGE_READWRITE); }
 if(code==NULL) { aaNote(0,"memod memry"); return RET_FAILED; }
 result->magic=aa_MEMMODULE_MAGIC;
 result->codeBase=code;
 result->numModules=0;
 result->modules=NULL;
 result->initialized=0;

 ///aaLog(-555,"valoc2=%i",old_header->OptionalHeader.SizeOfImage);
 aa_VirtualAlloc(code,old_header->OptionalHeader.SizeOfImage,MEM_COMMIT,PAGE_READWRITE);

 ///aaLog(-555,"valoc3=%i",old_header->OptionalHeader.SizeOfHeaders);
 headers=(BP)aa_VirtualAlloc(code,old_header->OptionalHeader.SizeOfHeaders,MEM_COMMIT,PAGE_READWRITE);
 aaMemoryCopy(headers,dos_header->e_lfanew+old_header->OptionalHeader.SizeOfHeaders,dos_header);
 result->headers=(PIMAGE_NT_HEADERS)&((const BP)(headers))[dos_header->e_lfanew];
 result->headers->OptionalHeader.ImageBase=(H)code;
 aa_CopySections(newmem,old_header,result);
 locationDelta=(H)(code - old_header->OptionalHeader.ImageBase);
 if(locationDelta!=0)           { aa_PerformBaseRelocation(result,locationDelta); }
 if(!aa_BuildImportTable(result)) { oof; goto error; }
 aa_FinalizeSections(result);
 if(result->headers->OptionalHeader.AddressOfEntryPoint!=0)
  {
  if((result->EntryProc=(DllEntryProc)(code+result->headers->OptionalHeader.AddressOfEntryPoint))==0)
   {
   aaNote(0,"no entry point");
   goto error;
   }
  result->initialized=1;
  }
 if(result->initialized!=1) { oof; }
 result->cptr=code;

 directory= aaGetHdrDictionary(result,IMAGE_DIRECTORY_ENTRY_EXPORT);
 if(directory->Size!=0)
  {
  exports=(PIMAGE_EXPORT_DIRECTORY)(result->codeBase+directory->VirtualAddress);
  //if(exports->NumberOfNames==0||exports->NumberOfFunctions==0) { return RET_NOTFOUND; } // DLL doesn't export anything
  memorymodule->proc_count=exports->NumberOfNames;
  }
 if(memorymodule->proc_count)
  {
  if(aaMemoryAllocate((VP)&memorymodule->proc_entry,sizeof(_memorymoduleproc))!=YES) { oof; }
  directory=aaGetHdrDictionary((_aa_MemoryModule*)result,IMAGE_DIRECTORY_ENTRY_EXPORT);
  exports=(PIMAGE_EXPORT_DIRECTORY)(result->codeBase+directory->VirtualAddress);
  for(i=0;i<memorymodule->proc_count;i++)
   {
   nameRef=(HP)((Z)result->codeBase+(Z)(exports->AddressOfNames));
   // ordinal=(WORD*)((Z)codeBase+(Z)(exports->AddressOfNameOrdinals));
   nameRef+=i;//ndex;
   memorymodule->proc_entry[i].rsvd=0;
   aaStringCopy(memorymodule->proc_entry[i].name,(const CP)(result->codeBase+*nameRef));
   memorymodule->proc_entry[i].adr=0;
   if(memorymodule->proc_entry[i].name[0]==0) oof;
   //exports=(PIMAGE_EXPORT_DIRECTORY)(codeBase+directory->VirtualAddress);
   memorymodule->proc_entry[i].adr=(FARPROC)((Z)result->codeBase+*(HP)((Z)result->codeBase+(Z)exports->AddressOfFunctions+(i*4)));
   }
  }
 memorymodule->module_count=result->numModules;
 memorymodule->module_list=result->modules;
 return RET_YES;
 error:
 if(result->codeBase!=NULL)
  {
  aa_last_line_executed=__LINE__;
  ///aaLog(-555,"fa=%i",result->headers->OptionalHeader.SizeOfImage);
  aa_VirtualFree(result->codeBase,result->headers->OptionalHeader.SizeOfImage,MEM_RELEASE);
  aa_last_line_executed=__LINE__;
  }
 if(aaMemoryUnitRelease(&result->img)!=YES) oof;
 if(aaMemoryUnitRelease(&memorymodule->sys)!=YES) oof;
 if(memorymodule->proc_count!=0) { aaMemoryRelease(memorymodule->proc_entry);}
 aaMemoryFill(memorymodule,sizeof(_memorymodule),0);
 return RET_FAILED;
 }





 B aaMemoryModuleRelease               (_memorymodule*memorymodule)
 {
 Z i;
 _aa_MemoryModule*module;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memorymodule==NULL) { return RET_BADPARM; }
 if(memorymodule->magic!=aaHPP(aaMemoryModuleLoad)) { return RET_NOTINITIALIZED; }

 module=(_aa_MemoryModule*)memorymodule->sys.mem;
 if(module->magic!=aa_MEMMODULE_MAGIC) { return RET_NOTSTARTED; }
 if(module->initialized!=0)
  {
  if(memorymodule->is_attached)
   {
   (*module->EntryProc)((HINSTANCE)module->codeBase,DLL_PROCESS_DETACH,0);
   }
  memorymodule->is_attached=NO;
  module->initialized=0;
  }
 if(module->modules!=NULL)
  {
  for(i=0;i<module->numModules; i++)
   {
   if(module->modules[i]!=INVALID_HANDLE_VALUE)
    {
    //========== aaDebugf("%s FreeLibrary(%i)",__func__,i);
     if(FreeLibrary(module->modules[i])==0) {  oow; }
    }
   }
  free(module->modules);
  }
 if(module->codeBase!=NULL)
  {
  aa_last_line_executed=__LINE__;
  ///aaDebugf("fb=%i", module->headers->OptionalHeader.SizeOfImage);
  //aaDebugf("appVerif.exe shows virtualfree size is wrong:: fix me");
  ///VirtualFree(module->codeBase, module->headers->OptionalHeader.SizeOfImage, MEM_RELEASE);
  aa_last_line_executed=__LINE__;
  }
 //aaDebugf("REMEMBER: I commented out  B aa_InputSystemHookedKeyEventProc   code to ignore injects");
 if(module->img.mem!=NULL) { if(aaMemoryUnitRelease(&module->img)!=YES) { oof; } }
 if(aaMemoryUnitRelease(&memorymodule->sys)!=YES) oof;
 if(memorymodule->proc_count!=0) { aaMemoryRelease(memorymodule->proc_entry);}
 aaMemoryFill(memorymodule,sizeof(_memorymodule),0);
 return RET_YES;
 }






 B aaMemoryModuleAttach                (_memorymodule*memorymodule)
 {
 _aa_MemoryModule*module;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memorymodule==NULL) { return RET_BADPARM; }
 if(memorymodule->magic!=aaHPP(aaMemoryModuleLoad)) { return RET_NOTINITIALIZED; }
 oof;
 module=(_aa_MemoryModule*)memorymodule->sys.mem;
 if(memorymodule->is_attached) { return RET_YES; }
 if(!(*module->EntryProc)((HINSTANCE)module->cptr,DLL_PROCESS_ATTACH,0)) { aaNote(0,"cant attach"); return RET_FAILED; }
 memorymodule->is_attached=YES;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 #define SCRAP_NODE_UNUSED             0
 #define SCRAP_NODE_USED               1
 #define SCRAP_NODE_SPLIT              2
 #define SCRAP_NODE_FULL               3


 B aa_ScrapCombine                     (_scrap*scrap,Z index)
 {
 Z buddy;

 for(;;)
  {
  buddy=index-1+(index&1)*2;
  if(buddy<0||scrap->node->tree[buddy]!=SCRAP_NODE_UNUSED)
   {
   scrap->node->tree[index]=SCRAP_NODE_UNUSED;
   while(((index=(index+1)/2-1)>=0)&&scrap->node->tree[index]==SCRAP_NODE_FULL)
    {
    scrap->node->tree[index]=SCRAP_NODE_SPLIT;
    }
   break;
   }
  index=(index+1)/2-1;
  }
 return RET_YES;
 }




 B aa_ScrapMarkParent                  (_scrap*scrap,Z index)
 {
 Z buddy;

 for(;;)
  {
  buddy=index-1+(index&1)*2;
  if(buddy>0&&(scrap->node->tree[buddy]==SCRAP_NODE_USED||scrap->node->tree[buddy]==SCRAP_NODE_FULL))
   {
   index=(index+1)/2-1;
   scrap->node->tree[index]=SCRAP_NODE_FULL;
   continue;
   }
  break;
  }
 return RET_YES;
 }






 B aaScrapNew                          (_scrap*scrap,H bytes)
 {
 B ret;
 Z size,locs;
 H lev,siz;
 H level;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(scrap==NULL) { return RET_BADPARM; }
 lev=1;
 siz=1;
 while(1)
  {
  siz=siz<<1;
  if(siz>=bytes) { break; }
  lev++;
  }
 level=lev;
 if(level==0||level>28) { return RET_BOUNDS; }
 aaMemoryFill(scrap,sizeof(_scrap),0);
 scrap->magic=aaHPP(aaScrapNew);
 scrap->level=level;
 size=1<<level;
 locs=(sizeof(_scrapnode)+sizeof(B)*(size*2-2));
 if((ret=aaMemoryAllocate((VP)&scrap->node,locs))!=RET_YES) { return ret; }
 aaMemoryNameSet(scrap->node,"scrapnode");
 if((ret=aaMemoryAllocate((VP)&scrap->mem,size))!=RET_YES) { return ret; }
 aaMemoryNameSet(scrap->mem,"scrapmem");
 scrap->node->level=level;
 aaMemoryFill(scrap->node->tree,size*2-1,SCRAP_NODE_UNUSED);
 scrap->bytes_possible=size;
 scrap->bytes_allocated=0;
 scrap->blocks_allocated=0;
 return RET_YES;
 }





 B aaScrapDelete                       (_scrap*scrap)
 {
 if(scrap==NULL) { return RET_BADPARM; }
 if(scrap->magic!=aaHPP(aaScrapNew)) { return RET_NOTINITIALIZED; }
 aaMemoryRelease(scrap->node);
 aaMemoryRelease(scrap->mem);
 aaMemoryFill(scrap,sizeof(_scrap),0);
 return RET_YES;
 }





 B aaScrapBytesGet                     (_scrap*scrap,Z offset,HP bytes)
 {
 Z left,length,index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(scrap==NULL) { return RET_BADPARM; }
 if(scrap->magic!=aaHPP(aaScrapNew)) { return RET_NOTINITIALIZED; }
 left=0;
 length=1<<scrap->node->level;
 index=0;
 for(;;)
  {
  switch(scrap->node->tree[index])
   {
   case SCRAP_NODE_USED:
   if(bytes) { *bytes=length; }
   return RET_YES;
   case SCRAP_NODE_UNUSED:
   if(bytes) { *bytes=length; }
   return RET_YES;
   default:
   length/=2;
   if(offset<left+length) { index=index*2+1;   }
   else                   { left+=length; index=index*2+2;    }
   break;
   }
  }
 if(bytes) { *bytes=0; }
 return RET_FAILED;
 }




 B aaScrapInfoFromMemory               (_scrap*scrap,ZP offset,HP bytes,VP mem)
 {
 B ret;
 BP bp;
 Z off;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(scrap==NULL) { return RET_BADPARM; }
 if(scrap->magic!=aaHPP(aaScrapNew)) { return RET_NOTINITIALIZED; }
 if(offset) { *offset=-1; }
 if(mem==NULL) { return RET_BADPARM; }
 bp=(BP)mem;
 if(bp<scrap->mem) { return RET_FAILED; }
 off=bp-scrap->mem;
 if(off>(Z)scrap->bytes_possible) { return RET_FAILED; }
 if((ret=aaScrapBytesGet(scrap,off,&by))!=RET_YES) { return ret; }
 if(offset) { *offset=off; }
 if(bytes) { *bytes=by; }
 return RET_YES;
 }



 B aaScrapInfoFromOffset               (_scrap*scrap,Z offset,HP bytes,PP mem)
 {
 B ret;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(scrap==NULL) { return RET_BADPARM; }
 if(scrap->magic!=aaHPP(aaScrapNew)) { return RET_NOTINITIALIZED; }
 if(mem) { *mem=NULL; }
 if(offset<0) { return RET_FAILED; }
 if((H)offset>=scrap->bytes_possible) { return RET_FAILED; }
 if((ret=aaScrapBytesGet(scrap,offset,&by))!=RET_YES) { return ret; }
 if(mem) { *mem=&scrap->mem[offset]; }
 if(bytes) { *bytes=by; }
 return RET_YES;
 }





 B aaScrapAllocate                     (_scrap*scrap,H reqbytes,ZP offset,HP bytes,PP mem)
 {
 Z size,length;
 register Z index,level;
 Z indo,isp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(scrap==NULL) { return RET_BADPARM; }
 if(scrap->magic!=aaHPP(aaScrapNew)) { return RET_NOTINITIALIZED; }
 if(mem)    { *mem=0; }
 if(offset) { *offset=-1; }

 if(reqbytes==0) { size=1; }
 else
  {
  isp=!(reqbytes&(reqbytes-1));
  if(!isp)
   {
   reqbytes|=reqbytes>>1;
   reqbytes|=reqbytes>>2;
   reqbytes|=reqbytes>>4;
   reqbytes|=reqbytes>>8;
   reqbytes|=reqbytes>>16;
   reqbytes=reqbytes+1;
   }
  size=(Z)reqbytes;
  }
 length=1<<scrap->node->level;
 if(size>length)  {  return RET_BOUNDS;  }
 index=level=0;
 while(index>=0)
  {
  if(size==length)
   {
   if(scrap->node->tree[index]==SCRAP_NODE_UNUSED)
    {
    scrap->node->tree[index]=SCRAP_NODE_USED;
    aa_ScrapMarkParent(scrap,index);
    indo=((index+1)-(1<<level))<<(scrap->node->level-level);
    if(offset) { *offset=indo; }
    scrap->bytes_allocated+=size;
    scrap->blocks_allocated++;
    if(mem)   { *mem=&scrap->mem[indo]; }
    if(bytes) { *bytes=size; }
    aaMemoryFill(&scrap->mem[indo],size,0);
    return RET_YES;
    }
   }
  else
   {
   switch(scrap->node->tree[index])
    {
    case SCRAP_NODE_USED:
    case SCRAP_NODE_FULL:
    break;
    case SCRAP_NODE_UNUSED:
    scrap->node->tree[index]=SCRAP_NODE_SPLIT;
    scrap->node->tree[index*2+1]=SCRAP_NODE_UNUSED;
    scrap->node->tree[index*2+2]=SCRAP_NODE_UNUSED;
    default:
    index=index*2+1;
    length/=2;
    level++;
    continue;
    }
   }
  if(index&1)
   {
   ++index;
   continue;
   }
  for(;;)
   {
   level--;
   length*=2;
   index=(index+1)/2-1;
   if(index<0) { return RET_FAILED; }
   if(index&1) { ++index; break; }
   }
  }
 return RET_FAILED;
 }




 B aaScrapReAllocate                   (_scrap*scrap,H reqbytes,ZP offset,HP bytes,PP mem)
 {
 B ret;
 Z size,isp;
 Z ooff,noff;
 H by,nby;
 BP omem,nmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(scrap==NULL) { return RET_BADPARM; }
 if(scrap->magic!=aaHPP(aaScrapNew)) { return RET_NOTINITIALIZED; }
 if(offset==NULL) { return RET_BADPARM; }
 ooff=*offset;
 if(reqbytes==0) { size=1; }
 else
  {
  isp=!(reqbytes&(reqbytes-1));
  if(!isp)
   {
   reqbytes|=reqbytes>>1;
   reqbytes|=reqbytes>>2;
   reqbytes|=reqbytes>>4;
   reqbytes|=reqbytes>>8;
   reqbytes|=reqbytes>>16;
   reqbytes=reqbytes+1;
   }
  size=(Z)reqbytes;
  }
 if((ret=aaScrapInfoFromOffset(scrap,ooff,&by,(VP)&omem))!=RET_YES) { return ret; }
 //aaDebugf("realloc old=%i new=%i",by,size);
 if(by==(H)size)
  {
  if(mem) { *mem=omem; }
  return RET_YES;
  }

 if((ret=aaScrapAllocate(scrap,size,&noff,&nby,(VP)&nmem))!=RET_YES) { return ret; }
 if((H)size>=by) {  aaMemoryCopy(nmem,by,omem); }
 else         {  aaMemoryCopy(nmem,size,omem); }
 if((ret=aaScrapRelease(scrap,ooff))!=RET_YES) { return ret; }
 if(offset) { *offset=noff; }
 if(mem)    { *mem=nmem; }
 if(bytes)  { *bytes=nby; }
 return RET_YES;
 }







 B aaScrapRelease                      (_scrap*scrap,Z offset)
 {
 Z left,length,index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(scrap==NULL) { return RET_BADPARM; }
 if(scrap->magic!=aaHPP(aaScrapNew)) { return RET_NOTINITIALIZED; }
 left=0;
 length=1<<scrap->node->level;
 index=0;
 for(;;)
  {
  switch(scrap->node->tree[index])
   {
   case SCRAP_NODE_USED:
   //assert(offset == left);
   aa_ScrapCombine(scrap,index);
   scrap->blocks_allocated--;
   scrap->bytes_allocated-=length;
   //_combine(self,index);
   return RET_YES;
   case SCRAP_NODE_UNUSED:
   scrap->blocks_allocated--;
   scrap->bytes_allocated-=length;
   //assert(0);
   return RET_YES;
   default:
   length/=2;
   if(offset<left+length)  {  index=index*2+1;    }
   else                    {  left+=length; index=index*2+2;    }
   break;
   }
  }
 return RET_FAILED;
 }










/*-----------------------------------------------------------------------*/


 B aa_TimerSystemStart                 (V)
 {
 logg("aa_TimerSystemStart()");
 aa.timer_system.last_tik=GetTickCount();
 return RET_YES;
 }




 B aa_TimerSystemTimezoneGet           (V)
 {
 N rr,b;
 B txt[_1K];
 H sl,off;
 TIME_ZONE_INFORMATION tzi;

 if(aa.timer_system.is_timezone_ready==YES) { return RET_YES; }
 rr=GetTimeZoneInformation(&tzi);
 if(rr==TIME_ZONE_ID_STANDARD) { aa.timer_system.is_std=YES; }
 else
 if(rr==TIME_ZONE_ID_DAYLIGHT) { aa.timer_system.is_dls=YES; }
 b=(tzi.Bias*60);
 if(b<0) { b=aaNumAbs(b); }
 else      { b=aaNumNeg(b); }
 aa.timer_system.timezone_bias=b;
 aaStringFromWideString(txt,tzi.StandardName);
 if(txt[0]==NULL_CHAR)  {  aaStringFromWideString(txt,tzi.DaylightName);  }
 aaStringLen(txt,&sl);
 if(sl==0) { aaStringCopyf(txt,"GMT"); }
 else
  {
  if(aaStringFindChar(txt,sl,&off,SPACE_CHAR,YES,0,YES)!=YES) { txt[5]=NULL_CHAR; }
  else   {   txt[off]=NULL_CHAR;   }
  aaStringLen(txt,&sl);
  if(sl>4) { txt[4]=NULL_CHAR; }
  }
 aaStringCopy(aa.timer_system.timezone_string,txt);
 aa.timer_system.timezone_bias_total=(aa.timer_system.timezone_bias+(aa.timer_system.is_dls*3600));
 aa.timer_system.is_timezone_ready=YES;
 return RET_YES;
 }






 B aa_TimerSystemCpuSpeedGet           (V)
 {
 D mh2,speed;
 HKEY sub;
 H len,type;
 N r;
 B buf[_1K];

 mh2=0.0;
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=4; type=REG_DWORD;
  r=RegQueryValueEx(sub,"~MHz",NULL,&type,(BP)buf,&len);
  if(len<_1K) { buf[len]=NULL_CHAR; }
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  type=*(HP)&buf[0];  mh2=(D)type;  }
  }
 speed=mh2;
 aa.timer_system.cpu_mhz=(D)speed;
 return RET_YES;
 }







 V aa_TimerSystemStop                  (V)
 {
 logg("aa_TimerSystemStop();");
 logg("");
 }






/*-----------------------------------------------------------------------*/



 B aaTimerNull                         (_timer*timer,H count)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 aaMemoryZero(timer,sizeof(_timer)*count);
 return RET_YES;
 }




 B aaTimerInit                         (_timer*timer,H count)
 {
 _timer*t;
 H tik;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(t,_timer*,timer);
 aaTimerTikGet(&tik);
 while(1)
  {
  t->tik=tik;
  t->elapsed=0;
  t->magic=aa_TIMER_MAGIC;//'tmer';
  count--;
  if(count==0) { break; }
  t++;
  }
 return RET_YES;
 }







 B aaTimerUpdate                       (_timer*timer,H count)
 {
 H now,me;
 _timer*t;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(t,_timer*,timer);
 //if(t->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
 aaTimerTikGet(&now);
 while(1)
  {
  if(t->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
  if(now>=t->tik)   {  me=now-t->tik;  }
  else                {  me=(F32-t->tik)+(now+1);  }
  t->elapsed=me;
  count--;
  if(count==0)   {   break;   }
  t++;
  }
 return RET_YES;
 }







 B aaTimerPulse                        (_timer*timer,H ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(timer->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
 aaTimerUpdate(timer,1);
 if(timer->elapsed>=ms)
  {
  aaTimerInit(timer,1);
  return RET_YES;
  }
 return RET_NOTREADY;
 }




 B aaTimerElapsed                      (_timer*timer,H ms,B reinit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(timer->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
 aaTimerUpdate(timer,1);
 if(timer->elapsed>=ms)
  {
  if(reinit) { aaTimerInit(timer,1); }
  return RET_YES;
  }
 return RET_NO;
 }



 B aaTimerAdjust                       (_timer*timer,H count,N amnt)
 {
 _timer*t;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(timer==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(t,_timer*,timer);
 while(1)
  {
  if(t->magic!=aa_TIMER_MAGIC) { return RET_NOTSTARTED; }
  t->tik-=amnt;
  count--;
  if(count==0)   {   break;   }
  t++;
  }
 return RET_YES;
 }









/*-----------------------------------------------------------------------*/



 B aaTimerProfilerNull                 (_profiler*profiler)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 profiler->magic=0;
 profiler->c=0;
 ///zorke profiler->elapsed=0;
 profiler->ms=0;
 profiler->micro=0;
 profiler->nano=0;
 profiler->counter=0;
 return RET_YES;
 }






 B aaTimerProfilerInit                 (_profiler*profiler,H count)
 {
 _profiler*p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 if(count==0) {  return RET_BADPARM; }
 aaCast(p,_profiler*,profiler);
 while(1)
  {
  p->magic=aa_PROFILER_MAGIC;
///zorke   p->elapsed=0;
  p->ms=0;
  p->micro=0;
  p->nano=0;
  p->counter=0;
  aaTimerProfilerGet(&p->c);
  count--;
  if(count==0) { break; }
  p++;
  }
 return RET_YES;
 }




 B aaTimerProfilerUpdate               (_profiler*profiler,H count)
 {
 _profiler*p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) {  return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaCast(p,_profiler*,profiler);
 if(profiler->magic!=aa_PROFILER_MAGIC) {  oof; return RET_NOTSTARTED; }
 while(1)
  {
  aaTimerProfilerElapsed(p->c,&p->ms,&p->micro,&p->nano,&p->counter);
  count--;
  if(count==0) { break; }
  p++;
  }
 return RET_YES;
 }





 B aaTimerProfilerAdjust               (_profiler*profiler,H count,B what,G amnt)
 {
 B ret;
 G posi,co;
 _profiler*p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 if(count==0)       { return RET_BADPARM; }

 posi=aaNumAbs(amnt);
 if((ret=aaTimerCalculate(what,(Q)posi,0,0,0,&co))!=YES) { return ret; }
 //aaDebugf("posi=%I64d co=%I64d",posi,co);
 if(amnt<0) { posi=-co; }
 else       { posi=+co; }
 aaCast(p,_profiler*,profiler);
 while(1)
  {
  if(p->magic!=aa_PROFILER_MAGIC) { return RET_NOTSTARTED; }
  p->c+=(G)posi;
  aaTimerProfilerElapsed(p->c,&p->ms,&p->micro,&p->nano,&p->counter);
  count--;
  if(count==0)   {   break;   }
  p++;
  }
 return RET_YES;
 }






 B aaTimerProfilerPulse                (_profiler*profiler,B what,G elapsed)
 {
 B ok;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) { return RET_BADPARM; }
 if(profiler->magic!=aa_PROFILER_MAGIC) { return RET_NOTSTARTED; }

 aaTimerProfilerUpdate(profiler,1);
 ok=NO;
 if(what==PROFILER_COUNTER) {  if(profiler->counter>=elapsed) { ok=YES; } }
 else
 if(what==PROFILER_MS)      {  if(profiler->ms>=elapsed) { ok=YES; } }
 else
 if(what==PROFILER_MICRO)   {  if(profiler->micro>=elapsed) { ok=YES; } }
 else
 if(what==PROFILER_NANO)    {  if(profiler->nano>=elapsed) { ok=YES; } }
 else                       { return RET_BADPARM; }
 if(ok)
  {
  aaTimerProfilerInit(profiler,1);
  return RET_YES;
  }
 return RET_NOTREADY;
 }




 G aaTimerProfilerRead                 (_profiler*profiler,B what)
 {
 B ret;
 Q now;
 G val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(profiler==NULL) {  return RET_BADPARM; }
 if(profiler->magic!=aa_PROFILER_MAGIC) {  return 0; }
 if((ret=aaTimerProfilerGet(&now))!=RET_YES) { oops; return ret; }

 //aaTimerProfilerUpdate(profiler,1);

 val=0;
 if(what==PROFILER_COUNTER) {  val=now-profiler->c; }
 else
 if(what==PROFILER_MS)      {  val=((G)(now-profiler->c)*1000)/aa.core_system.perf_frequency; }
 else
 if(what==PROFILER_MICRO)   {  val=((G)(now-profiler->c)*1000000)/aa.core_system.perf_frequency; }
 else
 if(what==PROFILER_NANO)    {  val=((G)(now-profiler->c)*1000000000)/aa.core_system.perf_frequency; }
 else                       {  return RET_BADPARM; }
 return val;
 }






 B aaTimerProfilerGet                  (QP counter)
 {
 LARGE_INTEGER li;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(counter==NULL) {  return RET_BADPARM; }
 if(aa.core_system.perf_frequency==0) { oof; }
 QueryPerformanceCounter((LARGE_INTEGER*)&li);
 *counter=li.QuadPart;
 return RET_YES;
 }



 B aaTimerProfilerElapsed              (Q counter,GP mselapsed,GP microelapsed,GP nanoelapsed,GP counterselapsed)
 {
 B ret;
 Q now;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mselapsed!=NULL) { *mselapsed=0; }
 if(microelapsed!=NULL) { *microelapsed=0; }
 if(nanoelapsed!=NULL) { *nanoelapsed=0; }
 if((ret=aaTimerProfilerGet(&now))!=RET_YES) { oops; return ret; }
 if(aa.core_system.perf_frequency==0)  {  oof;  }
 if(counterselapsed) {  *counterselapsed=((G)(now-counter));  }
 if(mselapsed)     {  *mselapsed=((G)(now-counter)*1000)/aa.core_system.perf_frequency;  }
 if(microelapsed)  {  *microelapsed=((G)(now-counter)*1000000)/aa.core_system.perf_frequency;  }
 if(nanoelapsed)   {  *nanoelapsed=((G)(now-counter)*1000000000)/aa.core_system.perf_frequency;  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aaTimerCalculate                    (B what,Q elapsed,GP ms,GP micro,GP nano,GP counters)
 {
 Q v;
 D s;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(ms==NULL) { return RET_BADPARM; }
 v=elapsed;
 if(what==PROFILER_COUNTER)
  {
  if(counters) {  *counters=v; }
  s=(D)v;
  s=(s*1000000000.0)/(D)aa.core_system.perf_frequency;
  v=(Q)s;
  if(ms)       {  *ms=v/1000000;  }
  if(micro)    {  *micro=v/1000;  }
  if(nano)     {  *nano=v;  }
  }
 else
 if(what==PROFILER_MS)
  {
  if(ms)       {  *ms=v;  }
  if(micro)    {  *micro=v*1000;  }
  if(nano)     {  *nano=v*1000000;  }
  if(counters) {  s=1000.0/((D)v+0.1); s=(D)aa.core_system.perf_frequency/(D)s;  *counters=(G)s;  }
  }
 else
 if(what==PROFILER_MICRO)
  {
  if(ms)       {  *ms=v/1000;  }
  if(micro)    {  *micro=v;  }
  if(nano)     {  *nano=v*1000;  }
  if(counters) {  s=1000000.0/((D)v+0.1); s=(D)aa.core_system.perf_frequency/(D)s;  *counters=(G)s;  }
  }
 else
 if(what==PROFILER_NANO)
  {
  if(ms)       {  *ms=v/1000000;  }
  if(micro)    {  *micro=v/1000;  }
  if(nano)     {  *nano=v;  }
  if(counters) {  s=1000000000.0/((D)v+0.1); s=(D)aa.core_system.perf_frequency/(D)s;  *counters=(G)s;  }
  }
 else
  {
  return RET_BADPARM;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aaTimerTikGet                       (HP tik)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa.timer_system.last_tik=GetTickCount();
 *tik=aa.timer_system.last_tik;
 return RET_YES;
 }




 B aaTimerTikAdjust                    (HP tik,N amnt)
 {
 H t;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tik==NULL) { return RET_BADPARM; }
 t=*tik;
 t+=amnt;
 *tik=t;
 return RET_YES;
 }





 B aaTimerTikElapsed                   (H tik,HP mselapsed)
 {
 H now;
 H me;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaTimerTikGet(&now);
 if(now>=tik)   {  me=now-tik;  }
 else            {  me=(F32-tik)+(now+1);  }
 if(mselapsed) {  *mselapsed=me; }
 return RET_YES;
 }




 B aaTimerTikElapsedUsingTik           (H tik,H now,HP mselapsed)
 {
 ///H now;
 H me;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(now>=tik)   {  me=now-tik;  }
 else           {  me=(F32-tik)+(now+1);  }
 if(mselapsed)  {  *mselapsed=me; }
 return RET_YES;
 }



 B aaTimerTikToDuration                (H tik,_duration*duration)
 {
 H we,da,ho,mi,se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(duration==NULL) { return RET_BADPARM; }
 aaMemoryFill(duration,sizeof(_duration),0);
   we=tik/604800000L;
 tik-=(we*604800000L);
   da=tik/86400000L;
 tik-=(da*86400000L);
   ho=tik/3600000L;
 tik-=(ho*3600000L);
   mi=tik/60000L;
 tik-=(mi*60000L);
   se=tik/1000L;
 tik-=(se*1000L);
 duration->weeks=we;
 duration->days=da;
 duration->hours=ho;
 duration->mins=mi;
 duration->secs=se;
 duration->ms=tik;
 return RET_YES;
 }




 B aaTimerMsToDuration                 (H ms,_duration*duration)
 {
 H we,da,ho,mi,se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(duration==NULL) { return RET_BADPARM; }
 aaMemoryFill(duration,sizeof(_duration),0);
   we=ms/604800000L;
 ms-=(we*604800000L);
   da=ms/86400000L;
 ms-=(da*86400000L);
   ho=ms/3600000L;
 ms-=(ho*3600000L);
   mi=ms/60000L;
 ms-=(mi*60000L);
   se=ms/1000L;
 ms-=(se*1000L);
 duration->weeks=we;
 duration->days=da;
 duration->hours=ho;
 duration->mins=mi;
 duration->secs=se;
 duration->ms=ms;
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/


 B aaTimerPrimitive                    (H nowms,H prevms,HP elapsedms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(elapsedms==NULL) { return RET_BADPARM; }
 if(nowms>=prevms)    {  *elapsedms=nowms-prevms;  }
 else                   {  *elapsedms=(F32-prevms)+(nowms+1);  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaTimeNull                          (_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaMemoryFill(systime,sizeof(_systime),0);
 return RET_YES;
 }



 B aaTimeIsNull                        (_systime*systime)
 {
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaCast(hp,HP,systime);
 if(hp[0]==0&&hp[1]==0) { return RET_YES; }
 return RET_NO;
 }



 B aaTimeIsValid                       (_systime*systime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 if(systime->month<1||systime->month>12) { return RET_NO; }
 if(systime->dow>6) { return RET_NO; }
 if(systime->date<1||systime->date>31) { return RET_NO; }
 if(systime->month==2&&systime->date>29) { return RET_NO; }
 if(systime->hour>23) { return RET_NO; }
 if(systime->minute>59) { return RET_NO; }
 if(systime->second>59) { return RET_NO; }
 if(systime->ms>999) { return RET_NO; }
 // do leap checks etc
 return RET_YES;
 }




 B aaTimeSet                           (_systime*systime,H dow,H year,H month,H date,H hour,H minute,H second,H ms,N gmtdif)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
// aaNote(0,"%i",month);
 if(month<1||month>12) { return RET_BADPARM; }
 if(dow>6) { return RET_BADPARM; }
 if(date<1||date>31) { return RET_BADPARM; }
 if(month==2&&date>29) { return RET_BADPARM; }
 if(hour>23) { return RET_BADPARM; }
 if(minute>59) { return RET_BADPARM; }
 if(second>59) { return RET_BADPARM; }
 if(ms>999) { return RET_BADPARM; }
 if(gmtdif<-15||gmtdif>+15) { return RET_BADPARM; }
 systime->dow=dow;
 systime->year=year;
 systime->month=month;
 systime->date=date;
 systime->hour=hour;
 systime->minute=minute;
 systime->second=second;
 systime->ms=ms;
 systime->gmt_dif=(H)gmtdif;
 return RET_YES;
 }







 B aaTimeEqualsTime                    (_systime*systime,_systime*systime2,B extended)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 if(systime2==NULL) { return RET_BADPARM; }
 if(systime->dow!=systime2->dow) { return RET_NO; }
 if(systime->year!=systime2->year) { return RET_NO; }
 if(systime->month!=systime2->month) { return RET_NO; }
 if(systime->date!=systime2->date) { return RET_NO; }
 if(systime->hour!=systime2->hour) { return RET_NO; }
 if(systime->minute!=systime2->minute) { return RET_NO; }
 if(systime->second!=systime2->second) { return RET_NO; }
 if(extended==YES)
  {
  if(systime->ms!=systime2->ms) { return RET_NO; }
  if(systime->gmt_dif!=systime2->gmt_dif) { return RET_NO; }
  }
 return RET_YES;
 }





 B aaTimeCopy                          (_systime*systime,_systime*ssystime)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 if(ssystime==NULL) { return RET_BADPARM; }
 systime->dow=ssystime->dow;
 systime->year=ssystime->year;
 systime->month=ssystime->month;
 systime->date=ssystime->date;
 systime->hour=ssystime->hour;
 systime->minute=ssystime->minute;
 systime->second=ssystime->second;
 systime->ms=ssystime->ms;
 systime->gmt_dif=ssystime->gmt_dif;
 return RET_YES;
 }




 B aaTimeLocalGet                      (_systime*systime)
 {
 SYSTEMTIME st;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 GetLocalTime(&st);
 WinSystemTimeToSysTime(&st,systime);
 return RET_YES;
 }





 B aaTimeSystemGet                     (_systime*systime)
 {
 SYSTEMTIME st;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 GetSystemTime(&st);
 WinSystemTimeToSysTime(&st,systime);
 return RET_YES;
 }



 B aaTimeApply                         (_systime*systime)
 {
 SYSTEMTIME st;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 st.wYear=systime->year;
 st.wMonth=systime->month;
 st.wDayOfWeek=systime->dow;
 st.wDay=systime->date;
 st.wHour=systime->hour;
 st.wMinute=systime->minute;
 st.wSecond=systime->second;
 st.wMilliseconds=systime->ms;
 if(SetLocalTime(&st)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaTimeToCookieTimeString            (_systime*st,VP str)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 /*
  aaTimeLocalGet(&st);
  aaTimeAdjust(&st,0,-(app.si.timezone_bias_total));
  aaTimeAdjust(&st,0,33);
 */
 aaCast(bp,BP,str);
 aaTimeToString(st,bp,"GMT",0);
 bp[7]=bp[11]='-';
 // HttpServerHdrOutAppend(tcup,"set-cookie: test=cool; expires=%s;\r\n",str);
 return RET_YES;
 }







 B aaTimeFirstDayOfMonthGet            (H month,H year,HP dow)
 {
 H wd,i,dim;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dow==NULL) { return RET_BADPARM; }
 *dow=0;
 if(month<1||month>12) { return RET_BADPARM; }
 wd=1;
 for(i=1900;i<year;i++)
  {
  wd=(wd+365)%7;
  if(aaTimeIsLeapYear(i)==YES) { wd=(wd+1)%7; }
  }
 for(i=1;i<month;i++)
  {
  aaTimeDaysInMonthGet(i,year,&dim);
  wd=(wd+dim)%7;
  }
 *dow=wd;
 return RET_YES;
 }




 B aaTimeDayOfWeekGet                  (H date,H month,H year,HP dow)
 {
 static H t[12]={0,3,2,5,0,3,5,1,4,6,2,4 };

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dow==NULL) { return RET_BADPARM; }
 if(year>10000) { return RET_BADPARM; }
 if(month<1||month>12) { return RET_BADPARM; }
 if(date<1||date>31) { return RET_BADPARM; }
 year-=month<3;
 *dow=(year+year/4-year/100+year/400+t[month-1]+date)%7;
 return RET_YES;
 }





 B aaTimeIsLeapYear                    (H year)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(year>10000) { return RET_BADPARM; }
 if((year%4==0)&&(year%100!=0||year%400==0)) { return RET_YES; }
 return RET_NO;
 }




 B aaTimeDaysInMonthGet                (H month,H year,HP days)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(days==NULL) { return RET_BADPARM; }
 *days=0;
 if(month<1||month>12) { return RET_BADPARM; }

 switch (month)
  {
  case 2:
  if(aaTimeIsLeapYear(year)==YES) { *days=29;  }
  else { *days=28; }
  break;

  case 4:
  case 6:
  case 9:
  case 11:
  *days=30;
  break;

  default:
  *days=31;
  break;
  }
 return RET_YES;
 }




 B aaTimeToString                      (_systime*systime,VP str,VP tzstr,B longday)
 {
 _systime st;
 _systime*stp;
 //B txt[_1K];
 //H pos;
 B ret,a,b;
 H sl,dow;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(str==NULL) { return RET_BADPARM; }
 if((ret=aaStringNull(str))!=RET_YES) { return ret; }
 if(systime==NULL)  {  aaTimeLocalGet(&st);  aaCast(stp,_systime*,&st);  }
 else                 {  aaCast(stp,_systime*,systime);  }
 if(tzstr!=NULL)      { aaStringLen(tzstr,&sl);  if(sl!=3&&sl!=4) { return RET_BADPARM; }  }
 if(stp->date<1||stp->date>31) { return RET_FAILED; }
 //a=(B)stp->dow;
 //if(a>6)  {  return RET_FAILED; }
 b=(B)stp->month;
 if(b<1)  {  return RET_FAILED; }
 else
 if(b>12) {  return RET_FAILED; }
 aaTimeDayOfWeekGet(stp->date,stp->month,stp->year,&dow);
 a=(B)dow;
 aaStringCopyf(str,"%s, %02ld %s %04ld %02ld:%02ld:%02ld\0",(longday)?aa_timedayex[a]:aa_timeday[a],stp->date,aa_timemonth[b-1],stp->year,stp->hour,stp->minute,stp->second,stp->ms);
 if(tzstr) { aaStringAppendf(str," %s",tzstr); }
 return RET_YES;
 }




//Sat, 17 Jan 1981 8:00:00 GMT
//28-Nov-2009 18:12
 B aaTimeFromString                    (_systime*systime,VP str)
 {
 H sl,x;
 CP txt;
 C oc[7];
 B etc[129];
 B buf[_1K];
 H pos;
 N dif,o,t;
 _parser pa;
 B oldmode=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaTimeNull(systime);
 if(str==NULL) { return RET_BADPARM; }
 aaStringCopyf(buf,"%s",str);
 if(aaStringFindFirstIString(buf,0," gmt",0,&pos)==YES)  {  buf[pos]=0;  }
 aaStringLen(buf,&sl);
 if(sl==17)
  {
  aaParserInit(&pa,buf,sl);
  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);

  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->date=x;
  aaParserSeek(&pa,t);

  aaParserSeekToChar(&pa,'-',YES,YES);
  aaParserSeekToChar(&pa,'-',NO,YES);

  aaParserSeekToVisibleChar(&pa,YES);
  o=pa.offset;
  aaParserSeekToChar(&pa,'-',YES,YES);
  t=(pa.offset-o);

  aaParserSeek(&pa,-t);
  aaStringNCopy(etc,pa.bp,t,YES);
  for(x=0;x<12;x++)
   {
   aaStringNICompare(etc,aa_timemonth[x],3,&dif);
   if(dif!=0) { continue; }
   systime->month=x+1;
   break;
   }
  ///if(x==12)  {  BUGGY;  }
  aaParserSeek(&pa,t);

  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);
  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->year=x;
  aaParserSeek(&pa,t);
////
  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);
  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->hour=x;
  aaParserSeek(&pa,t);
////
  aaParserSeekToNumber(&pa,YES);
  o=pa.offset;
  aaParserSeekToNumber(&pa,NO);
  t=(pa.offset-o);
  aaParserSeek(&pa,-t);
  aaStringToNumber(pa.bp,t,&x,0,0,0);
  systime->minute=x;
  aaParserSeek(&pa,t);

  aaTimeDayOfWeekGet(systime->date,systime->month,systime->year,&x);
  systime->dow=x;

  return RET_YES;
  }


 if(sl<25)  { /*BUG,"timefromstring: %i",sl); BUGGY;*/  return RET_FAILED;  }

 aaCast(txt,CP,buf);
 for(x=0;x<7;x++)
  {
  aaStringNICompare(txt,aa_timeday[x],3,&dif);
  if(dif==0) { break; }
  }
 if(x==7)  {  return RET_FAILED;  }
 systime->dow=x;
 o=3;    if(txt[o]!=',') {    return RET_FAILED; }
 o=4;if(txt[o]!=SPACE_CHAR) {   return RET_FAILED; }
 o=5;if(aaCharIsNum(txt[o])==NO) {  return RET_FAILED; }
 o=6;
 if(txt[o]==SPACE_CHAR||txt[o]=='-') // handles single digit day of month, e.g jan 1 may, instead jan 1  may
  {
  t=1;
  }
 else
  {
  o=6;if(aaCharIsNum(txt[o])==NO) {   return RET_FAILED; }
  o=7;if(txt[o]!=SPACE_CHAR&&txt[o]!='-') {  return RET_FAILED; }
  t=0;
  }

 for(x=0;x<12;x++)
  {
  o=8-t; aaStringNICompare(&txt[o],aa_timemonth[x],3,&dif);
  if(dif==0) { break; }
  }
 if(x==12)      {        return RET_FAILED;      }

 o=11-t;if(txt[o]!=SPACE_CHAR&&txt[o]!='-') {   return RET_FAILED; }
 o=12-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=13-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=14-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=15-t;    if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=16-t;    if(txt[o]!=SPACE_CHAR&&txt[o]!='-') {    return RET_FAILED; }
 o=17-t;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=18-t;     if(txt[o]==':') { oldmode=1; }
             else
             if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }

 oldmode+=(B)t;
 o=19-oldmode;     if(txt[o]!=':') {    return RET_FAILED; }
 o=20-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=21-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=22-oldmode;     if(txt[o]!=':') {    return RET_FAILED; }
 o=23-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=24-oldmode;     if(aaCharIsNum(txt[o])==NO) { return RET_FAILED; }
 o=7;      oc[0]=txt[o];
 o=16;     oc[1]=txt[o];
 o=19;     oc[2]=txt[o];
 o=22-oldmode;     oc[3]=txt[o];
 o=25-oldmode;     oc[4]=txt[o];
 o=7;      txt[o]=NULL_CHAR;
 o=5;    systime->date=(B)atoi(&txt[o]);
         systime->month=(B)(x+1);
 o=16;     txt[o]=NULL_CHAR;
 o=12;   systime->year=(W)atoi(&txt[o]);
 o=19-oldmode;     txt[o]=NULL_CHAR;
 o=17;   systime->hour=(B)atoi(&txt[o]);
 o=22-oldmode;     txt[o]=NULL_CHAR;
 o=20-oldmode;   systime->minute=(B)atoi(&txt[o]);
 o=25-oldmode;     txt[o]=NULL_CHAR;
 o=23-oldmode;   systime->second=(B)atoi(&txt[o]);
         systime->ms=0;
         systime->gmt_dif=0;
  o=7;txt[o]=oc[0];
  o=16;txt[o]=oc[1];
 o=19-oldmode; txt[o]=oc[2];
 o=22-oldmode; txt[o]=oc[3];
 o=25-oldmode; txt[o]=oc[4];
 return RET_YES;
 }







 B aaTimeCompare                       (_systime*systime,_systime*systime2,GP secdif)
 {
 _systime st2;
 FILETIME ft1,ft2;
 SYSTEMTIME s1,s2;
 D v1,v2,dif;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(secdif==NULL) { return RET_BADPARM; }
 *secdif=0;
 if(systime==NULL) { return RET_BADPARM; }
 if(systime2==NULL) { aaTimeLocalGet(&st2); }
 else                 { aaTimeCopy(&st2,systime2); }
 WinSystemTimeFromSysTime(&s1,systime);
 if(SystemTimeToFileTime(&s1,&ft1)==0) { return RET_FAILED; }
 WinSystemTimeFromSysTime(&s2,&st2);
 if(SystemTimeToFileTime(&s2,&ft2)==0) { return RET_FAILED; }
 if(aa.math_system.four_billion==0.0) oof;
 v1=(D)ft1.dwHighDateTime; v1=v1*(D)aa.math_system.four_billion; v1=v1+(D)ft1.dwLowDateTime;
 v2=(D)ft2.dwHighDateTime; v2=v2*(D)aa.math_system.four_billion; v2=v2+(D)ft2.dwLowDateTime;
 v1=v1/(D)aa.math_system.ten_million;
 v2=v2/(D)aa.math_system.ten_million;
 dif=(D)v2-(D)v1;
 *secdif=(G)dif;
 return RET_YES;
 }








 B aaTimeAdjust                        (_systime*systime,_systime*ressystime,G secdif)
 {
 _systime st1;
 SYSTEMTIME s1,s2;
 FILETIME ft1;
 Q v1,v2,v3;
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { aaTimeLocalGet(&st1); }
 else                { aaTimeCopy(&st1,systime); }
 if(secdif==0)
  {
  if(ressystime!=NULL) { aaTimeCopy(ressystime,&st1); }
  return RET_YES;
  }
 WinSystemTimeFromSysTime(&s1,&st1);
 if(SystemTimeToFileTime(&s1,&ft1)==0) { return RET_FAILED; }

 if(aa.math_system.four_billion==0.0) oof;
 if(aa.math_system.ten_million==0.0) oof;
 if(aa.math_system.four_billion==0.0) oof;

 v2=(Q)ft1.dwHighDateTime;
 v3=v2*aa.math_system.four_billion;
 v2=(Q)ft1.dwLowDateTime;
 v1=v2+v3; // d1 holds time in 64bits ( as nano )
 if(secdif<0) { v=aaNumAbs(secdif); }
 else           { v=secdif; }
 v2=(Q)v;
 v2=v2*aa.math_system.ten_million;      // d2 is dif in nano
 if(secdif<0) { v1-=v2; }
 else           { v1+=v2; }
 v3=v1/aa.math_system.four_billion;
 ft1.dwHighDateTime=(H)v3;
 v2=v1-aa.math_system.four_billion;
 ft1.dwLowDateTime=(H)v2;
 if(FileTimeToSystemTime(&ft1,&s2)==0) { return RET_FAILED; }
 WinSystemTimeToSysTime(&s2,&st1);
 if(ressystime==NULL) { aaTimeCopy(systime,&st1); }
 else                   { aaTimeCopy(ressystime,&st1); }
 return RET_YES;
 }





 B aaTimeMsRunning                     (HP ms)
 {
 B ret;
 H el;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ms==NULL) { return RET_BADPARM; }
 ret=aaTimerTikElapsed(aa.core_system.aamain_tik,&el);
 if(ms) { if(el==0) { el=1; } *ms=el; }
 return ret;
 }




 B aaTimeLaunchTikGet                  (HP ms)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ms==NULL) { return RET_BADPARM; }
 *ms=aa.core_system.launch_tik;
 return RET_YES;
 }




 B aaTimeUtcGet                        (QP utc)
 {
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(utc==NULL) { return RET_BADPARM; }
 GetSystemTimeAsFileTime((FILETIME*)&v);
  //v=(Q)ft.dwHighDateTime*42949672945;
 //v=v+(Q)ft.dwLowDateTime;
 //v=((Q)ft.dwHighDateTime<<32);
 //v=v+ft.dwLowDateTime;
 *utc=v;
 return RET_YES;
 }



 B aaTimeSecsToDuration                (H s,_duration*duration)
 {
 H we,da,ho,mi,se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(duration==NULL) { return RET_BADPARM; }
 aaMemoryFill(duration,sizeof(_duration),0);
 //yr=s/31556952L; dura->years=yr; s-=(yr*31556952L);
 //mn=s/2592000L; duration->months=mn; s-=(mn*2592000L);
 we=s/604800L;  duration->weeks=we; s-=(we*604800L);
 da=s/86400L;   duration->days=da; s-=(da*86400L);
 ho=s/3600L;    duration->hours=ho; s-=(ho*3600L);
 mi=s/60L;      duration->mins=mi; s-=(mi*60L);
 se=s;          duration->secs=se;
 return RET_YES;
 }






 B aaTimeToUnixTime                    (_systime*systime,QP unixtime)
 {
 struct tm ti;
 time_t tt;
 _systime st;
 _systime*stp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(unixtime==NULL) { return RET_BADPARM; }
 *unixtime=0;
 //aaQuadSet(unixtime,0,0);
 if(systime==NULL)
  {
  aaTimeLocalGet(&st);
  aaCast(stp,_systime*,&st);
  }
 else
  {
  aaCast(stp,_systime*,systime);
  }
 ti.tm_sec=stp->second;
 ti.tm_min=stp->minute;
 ti.tm_hour=stp->hour;
 ti.tm_mday=stp->date;
 ti.tm_mon=stp->month-1;
 ti.tm_year=stp->year-1900;
 ti.tm_wday=stp->dow;
 ti.tm_yday=0;
 ti.tm_isdst=aa.timer_system.is_dls;
 tt=mktime(&ti);
 if(tt==-1) { return RET_FAILED; }
 *unixtime=(Q)tt;
 return RET_YES;
 }






 B aaTimeFromUnixTime                  (_systime*systime,Q unixtime)
 {
 struct tm*tmm;
 time_t t;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(systime==NULL) { return RET_BADPARM; }
 aaTimeNull(systime);
 if((G)unixtime<0) { return RET_FAILED; }
 *(HP)&t=(H)(unixtime);
 //time(&t);
 //tmm=gmtime(&t);
 tmm=localtime(&t);
 if((ret=aaTimeSet(systime,tmm->tm_wday,tmm->tm_year+1900,tmm->tm_mon+1,tmm->tm_mday,tmm->tm_hour,tmm->tm_min,tmm->tm_sec,0,0))!=RET_YES) { oops;   }
 return ret;
 }





 B aaTimeGetOfDay                      (struct timeval*tv)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 union { G ns100;  FILETIME ft;  } now;
 if(tv==NULL) { return RET_BADPARM; }
 GetSystemTimeAsFileTime (&now.ft);
 tv->tv_usec=(long)((now.ns100/10LL)%1000000LL);
 tv->tv_sec=(long)((now.ns100-116444736000000000LL)/10000000LL);
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaGeoLookup                         (VP countrycode,VP countryname,VP continent,HP index)
 {
 H i;
 BP cc;
 B str[5];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(countryname) { aaStringNull(countryname); }
 if(continent)   { aaStringNull(continent); }
 if(index)       { *index=0; }
 cc=(BP)countrycode;
 if(cc[0]>='a'&&cc[0]<='z') { str[0]=(cc[0]-'a')+'A'; }  else
 if(cc[0]>='A'&&cc[0]<='Z') { str[0]=cc[0]; } else { return RET_NOTFOUND; }
 if(cc[1]>='a'&&cc[1]<='z') { str[1]=(cc[1]-'a')+'A'; }  else
 if(cc[1]>='A'&&cc[1]<='Z') { str[1]=cc[1]; } else { return RET_NOTFOUND; }
 if(cc[2]!=NULL_CHAR)  { return RET_NOTFOUND; }
 for(i=0;i<251;i++)
  {
  if(aa_geo_country_code[i][0]==str[0]&&aa_geo_country_code[i][1]==str[1])
   {
   if(countryname) { aaStringCopyf(countryname,"%s",aa_geo_country_name[i]); }
   if(continent)   { aaStringCopyf(continent,"%s",aa_geo_continent[i]); }
   if(index)       { *index=i; }
   return RET_YES;
   }
  }
 return RET_NOTFOUND;
 }



 B aaGeoCountryNameToIndex             (VP countryname,HP index)
 {
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(countryname==NULL) { return RET_BADPARM; }
 if(index) { *index=0; }
 for(i=0;i<251;i++)
  {
  if(aaStringICompare(countryname,aa_geo_country_name[i],0)!=YES) { continue; }
  if(index) { *index=i; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }


 B aaGeoCountryCodeToIndex             (VP countrycode,HP index)
 {
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(countrycode==NULL) { return RET_BADPARM; }
 if(index) { *index=0; }
 for(i=0;i<251;i++)
  {
  if(aaStringICompare(countrycode,aa_geo_country_code[i],0)!=YES) { continue; }
  if(index) { *index=i; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }

/*-----------------------------------------------------------------------*/



 B aa_MemorySystemStart                (V)
 {
 B ret;
 N n,k;
 H c,poly,off;//,bytes;
 //BP mem;
 H mi,mx;
 HANDLE hprocess;
 B pterm[14]={0,1,2,4,5,7,8,10,11,12,16,22,23,26};
 ///MEMORYSTATUS mstatus;
 MEMORYSTATUSEX mstatus;
 //H opcode[50][2];
 Q crc64;

 //logg("aa_MemorySystemStart()");
 ///OutputDebugString("func=aa_MemorySystemStart()");
 poly=0L;

 for(n=0;n<14;n++) { poly|=1L<<(31-pterm[n]); }
 for(n=0;n<256;n++)
  {
  c=(H)n;
  for(k=0;k<8;k++)  { c=c&1?poly^(c>>1):c>>1; }
  aa.memory_system.crc_table[n]=c;
  }
 for(n=0;n<256;n++)
  {
  crc64=n;
  for(k=0;k<8;k++)
   {
   if(crc64&1) {  crc64>>= 1;    crc64^=aa_MEMORYCRC_POLYNOMIAL64;            }
   else        {  crc64>>=1; }
   }
  aa.memory_system.crc64_table[n]=crc64;
  }

 logg("aa.memory_system.crc_table created");

 aaMemoryFill(&mstatus,sizeof(mstatus),0);
 mstatus.dwLength=sizeof(mstatus);
 GlobalMemoryStatusEx(&mstatus);
 aa.memory_system.status.os_physical_total=mstatus.ullTotalPhys;
 aa.memory_system.status.os_physical_allocated=mstatus.ullTotalPhys-mstatus.ullAvailPhys;
 aa.memory_system.status.os_memory_load=(F)mstatus.dwMemoryLoad;
 aa.memory_system.status.os_virtual_total=mstatus.ullTotalVirtual;
 aa.memory_system.status.os_virtual_allocated=mstatus.ullTotalVirtual-mstatus.ullAvailVirtual;
    //hProcess=OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, app.si.process_id);
 //if(!hProcess) oof;
 //hprocess=OpenProcess(PROCESS_ALL_ACCESS, 0, GetCurrentProcessID);
 //CloseHandle(hprocess);

 //hprocess=GetCurrentProcess();
 hprocess=aa.core_system.process_handle;
 //SetProcessWorkingSetSize(hprocess, F32,F32);//_4MEG,_4MEG);//$FFFFFFFF, $FFFFFFFF) ;
 if(!GetProcessWorkingSetSize(hprocess,&mi,&mx)) { oof; }
 aa.memory_system.status.working_set_size_min=mi;
 aa.memory_system.status.working_set_size_max=mx;

//aaNote(0,"%i %i",mi,mx);
 //CloseHandle(hProcess);
 //qproflog(0,0);

// aaMemoryWorkingSetSizeSet(_256K,_2MEG);


 if(aa.core_system.in_remote_debugger&&aa_i_am==0) { oof; aaQuit(); }


 if((ret=aaMemoryCodeAllocate((VP)&aa.memory_system.cdecl_ram,512))!=YES) { oops; }
  off=0;
  aa_cdecl=aa.memory_system.cdecl_ram;

   aa.memory_system.cdecl_ram[off++]=0x55;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0xec;
   aa.memory_system.cdecl_ram[off++]=0x51;
   aa.memory_system.cdecl_ram[off++]=0x53;
   aa.memory_system.cdecl_ram[off++]=0x56;
   aa.memory_system.cdecl_ram[off++]=0x57;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0x4d; aa.memory_system.cdecl_ram[off++]=0x0c;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0x75; aa.memory_system.cdecl_ram[off++]=0x08;
   aa.memory_system.cdecl_ram[off++]=0x2b;  aa.memory_system.cdecl_ram[off++]=0xe1;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0xfc;
   aa.memory_system.cdecl_ram[off++]=0xf3;  aa.memory_system.cdecl_ram[off++]=0xa4;
   aa.memory_system.cdecl_ram[off++]=0xff;  aa.memory_system.cdecl_ram[off++]=0x55; aa.memory_system.cdecl_ram[off++]=0x10;
   aa.memory_system.cdecl_ram[off++]=0x89;  aa.memory_system.cdecl_ram[off++]=0x45; aa.memory_system.cdecl_ram[off++]=0xfc;
   aa.memory_system.cdecl_ram[off++]=0x03;  aa.memory_system.cdecl_ram[off++]=0x65; aa.memory_system.cdecl_ram[off++]=0x0c;
   aa.memory_system.cdecl_ram[off++]=0x8b;  aa.memory_system.cdecl_ram[off++]=0x45; aa.memory_system.cdecl_ram[off++]=0xfc;
   aa.memory_system.cdecl_ram[off++]=0x5f;
   aa.memory_system.cdecl_ram[off++]=0x5e;
   aa.memory_system.cdecl_ram[off++]=0x5b;
   aa.memory_system.cdecl_ram[off++]=0x59;
   aa.memory_system.cdecl_ram[off++]=0x5d;
   aa.memory_system.cdecl_ram[off]=0xc3;


  if(aa.core_system.in_debugger&&aa_i_am==0) { oof; aaQuit(); }

logg("");
 return RET_YES;
 }







 V aa_MemorySystemStop                 (V)
 {
 N l;

 aa.is_ready=NO;
 aa_last_line_executed=__LINE__;
 if(aa.memory_system.cdecl_ram!=NULL)
  {
  aa_last_line_executed=__LINE__;
  aaMemoryCodeRelease(aa.memory_system.cdecl_ram);
  aa.memory_system.cdecl_ram=NULL;
  }

 aa_last_line_executed=__LINE__;
 for(l=255;l>=0;l--)
  {
  if(aa.memory_system.temp_bytes[l]!=0)
   {
   logg("Releasing Memory_temp[%i] = %i bytes",l,aa.memory_system.temp_bytes[l]);
   aa_MemoryProtect(aa.memory_system.temp_mem[l],NO);
   aa_MemoryRelease(aa.memory_system.temp_mem[l]);
   aa.memory_system.temp_mem[l]=NULL;
///   aa.memory_system.temp_bytes[l]=0;
   }
  }
 aa_last_line_executed=__LINE__;

//aaNote(0,"%i %i",aa.memory_system.status.bytes_allocated,aa.memory_system.status.blocks_allocated);
 if(aa.memory_system.status.bytes_allocated!=0||aa.memory_system.status.blocks_allocated!=0)
  {
  aa_MemorySystemDump();
  }
 logg("");
 }





 V aa_MemorySystemDump                 (V)
 {
 H i,mx;
 _aa_memoryheader*memhdr;


 //logg("{");
 if(aa_hide_leak==NO)
  {
  if(aa.memory_system.status.bytes_allocated)
   {
   aaLog(-555,"!!!* Memory Leak: bytes_remain = %i  (user=%i)",aa.memory_system.status.bytes_allocated,aa.memory_system.status.user_bytes_allocated);
   }
  if(aa.memory_system.status.blocks_allocated)
   {
   aaLog(-555,"!!!* Memory Leak: blocks_remain = %i  (user=%i)",aa.memory_system.status.blocks_allocated,aa.memory_system.status.user_blocks_allocated);
   }
  mx=aaElementCount(aa.memory_system.table.block);
  for(i=0;i<mx;i++)
   {
   if(aa.memory_system.table.block[i]!=NULL)
    {
    memhdr=(_aa_memoryheader*)aa.memory_system.table.block[i];
    aaLog(-555," block[%-4i]=%p bytes=%-10u  prot=%-3s locked=%-3s user=%-3s realloc=%-8u (%s)",i,memhdr,memhdr->bytes,
                aaBoolString(memhdr->is_protected),aaBoolString(memhdr->is_locked),aaBoolString(memhdr->is_user),
                memhdr->realloc_count,memhdr->name);
    }
   }
  }
 //logg("}");
 }





 B aa_MemorySystemBlockTable           (VP mem,B isfree)
 {
 register H i,j,mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { oof; }
 mx=aaElementCount(aa.memory_system.table.block);
 isfree&=1;
 if(isfree)
  {
  for(i=0;i<mx;i++)
   {
   if(aa.memory_system.table.block[i]==mem)
    {
    aa.memory_system.table.block[i]=NULL;
    break;
    }
   }
  }
 else
  {
  for(i=0;i<mx;i++)
   {
   j=aa.memory_system.table_pf;
   aa.memory_system.table_pf++;
   aa.memory_system.table_pf%=mx;
   if(aa.memory_system.table.block[j]==NULL)
    {
    aa.memory_system.table.block[j]=mem;
    break;
    }
   }
  }
 if(i==mx) { oof; }
 return RET_YES;
 }








 B aa_MemoryAllocate                   (PP mem,H bytes,VP name,B lock)
 {
 _aa_memoryheader*memhdr;
 BP vmem;
 BP mem_ptr;
 H len;
 B type;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_last_line_executed=__LINE__;
 if(mem==NULL_POINTR||mem==NULL) { MessageBox(NULL,"memory allocate mem==NULL",__func__,MB_OK|MB_SYSTEMMODAL); return RET_BADPARM;  }
 if(bytes==0)  {  return RET_BADPARM;  }
 len=bytes+sizeof(_aa_memoryheader);
 aa_last_line_executed=__LINE__;
 ///////////////////////////
 ///sprintf(st,"%s:%u  %u %s",__func__,__LINE__,bytes,name); OutputDebugString(st);

 type=0;
  aa_last_line_executed=__LINE__;
  aa.memory_system.status.globalalloc_calls++;
  aa.memory_system.status.globalalloc_bytes+=(Q)len;
  if((vmem=GlobalAlloc(GPTR,len))==NULL)   {   return RET_NOMEMORY;   }
  aa_last_line_executed=__LINE__;
  ///aaMemoryZero(vmem,len);
  type='G';
 mem_ptr=vmem;
 aaCast(memhdr,_aa_memoryheader*,mem_ptr);
 memhdr->actual_ptr=(BP)(vmem);


 if(lock) { }
 memhdr->magic=VAL_aamh;
 memhdr->bytes=bytes;
 memhdr->actual_len=len;
 memhdr->mini_type=type;
 if(name) { aaStringCopy(memhdr->name,name); }
 else     { memhdr->name[0]=NULL_CHAR; }

 aa_MemorySystemBlockTable(vmem,NO);

 mem_ptr+=sizeof(_aa_memoryheader);
 *mem=mem_ptr;
 aa.memory_system.status.bytes_allocated+=memhdr->bytes;
 if(aa.memory_system.status.bytes_allocated>aa.memory_system.status.peak_bytes_allocated)  {  aa.memory_system.status.peak_bytes_allocated=aa.memory_system.status.bytes_allocated;  }
 aa.memory_system.status.blocks_allocated++;
 if(aa.memory_system.status.blocks_allocated>aa.memory_system.status.peak_blocks_allocated)  {  aa.memory_system.status.peak_blocks_allocated=aa.memory_system.status.blocks_allocated;  }
 aa.memory_system.alloc_calls++;

// aaDebugf("%s bytes=%u name=%s",__func__,bytes,name);
 //aaLog(-555,"%s bytes=%u name=%s",__func__,bytes,name);
// B fcetc[_2K]; sprintf(fcetc,"%s bytes=%u name=%s",__func__,bytes,name); OutputDebugString(fcetc);
 return RET_YES;
 }







 B aa_MemoryReAllocate                 (PP mem,H bytes)
 {
 B ret;
 _aa_memoryheader*memhdr;
 _aa_memoryheader*memhdrb;
 BP vmem;
 BP new_vmem;
 H rac;

 ///OutputDebugString("func=aa_memoryReAllocate");
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR) { oof;  return RET_BADPARM;  }
 if(*mem==NULL||*mem==NULL_POINTR) { oof; return RET_BADPARM;  }
 vmem=*mem;
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 vmem+=sizeof(_aa_memoryheader);
 if(memhdr->is_protected==YES) {  oof;  return RET_FORBIDDEN;  }
 aa.memory_system.realloc_calls++;
 if(bytes==memhdr->bytes)  {  return RET_YES;  }
 if(memhdr->is_locked) { aaNote(0,"zaq %i %i %s",memhdr->bytes,bytes,memhdr->name); }
 rac=memhdr->realloc_count;
 new_vmem=NULL;
 if((ret=aa_MemoryAllocate((VP)&new_vmem,bytes,memhdr->name,memhdr->is_locked))!=RET_YES) { return ret; }
 new_vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdrb,_aa_memoryheader*,new_vmem);
 memhdrb->realloc_count=rac+1;
 aaStringCopy(memhdrb->name,memhdr->name);
 new_vmem+=sizeof(_aa_memoryheader);
 if(bytes>=memhdr->bytes) { aaMemoryCopy(new_vmem,memhdr->bytes,vmem);  }
 else                     { aaMemoryCopy(new_vmem,bytes,vmem);   }
 if(aa_MemoryRelease(vmem)!=YES) oof;
 *mem=new_vmem;
 return RET_YES;
 }







 B aa_MemoryProtect                    (VP mem,B state)
 {
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR)
  {
  MessageBox(NULL,"memory protect mem==NULL",__func__,MB_OK|MB_SYSTEMMODAL);
  return RET_BADPARM;
  }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 //bitcoin if(memhdr->magic!=VAL_aamh) { return RET_FAILED; }
 if(state==YES) { memhdr->is_protected=YES; }
 else             { memhdr->is_protected=NO; }
 return RET_YES;
 }





 B aa_MemoryRelease                    (VP mem)
 {
 _aa_memoryheader*memhdr;
 BP vmem;
 H bytes;//,al;
// N dif;

 ///OutputDebugString("func=aa_memoryrelease");
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR)
  {
  MessageBox(NULL,"memory release mem==NULL",__func__,MB_OK|MB_SYSTEMMODAL);
  return RET_BADPARM;
  }
 vmem=mem;
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->is_protected==YES) { oof; return RET_FORBIDDEN; }
 bytes=memhdr->bytes;
 if(memhdr->is_locked==YES)  {  oof;  memhdr->is_locked=NO;  }
 memhdr->magic=0;
   if(memhdr->mini_type!='G') { oof; }
   if(GlobalFree(memhdr->actual_ptr)!=NULL)
    {
    oow;
    logg("%s:%i globalfree problem",__func__,__LINE__);
    aaNote(0,"bytes=%i %s",bytes,memhdr->name);
    return RET_FAILED;
    }
 aa_MemorySystemBlockTable(vmem,YES);
 aa.memory_system.status.bytes_allocated-=bytes;
 aa.memory_system.status.blocks_allocated--;
 aa.memory_system.release_calls++;
 return RET_YES;
 }





 B aa_MemoryTemp                       (PP mem,H bytes,B level)
 {
 B ret;
 BP new_mem;
 //C st[_2K];
 //H by;
 H oldby;
// BP bp;

 ///sprintf(st,"func=aa_memorytemp bytes=%i level=%i",bytes,level); OutputDebugString(st);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL||mem==NULL_POINTR)    {   return RET_BADPARM;   }
 if(bytes==0) { oof; }
 ///sprintf(st,"aa_MemoryTemp -- %i > %i lev=%i hits=%i tmpallocs=%i ",bytes,aa.memory_system.temp_bytes[level],level,aa.memory_system.temp_hits[level],aa.memory_system.temp_allocs[level]); OutputDebugString(st);
 oldby=aa.memory_system.temp_bytes[level];
 aa.memory_system.temp_hits[level]++;
 aa.memory_system.status.temp_calls++;
 if(bytes>aa.memory_system.temp_bytes[level])
  {
  ///sprintf(st,"%i>%i lev=%i",bytes,aa.memory_system.temp_bytes[level],level); OutputDebugString(st);
  if(aa.memory_system.temp_bytes[level]==0)
   {
   ///sprintf(st,"level zro ?? bytes=%i",bytes);  OutputDebugString(st);
   if((ret=aa_MemoryAllocate((VP)&new_mem,bytes,"Temp",NO))!=RET_YES) { oops;  return ret; }
   aa_MemoryProtect(new_mem,YES);
   aa.memory_system.temp_allocs[level]++;
   //sprintf(st,"start temp allocs for level %i",level);   OutputDebugString(st);
   }
  else
   {
   ///OutputDebugString("level NOT zro ??");
   new_mem=aa.memory_system.temp_mem[level];
   aa_MemoryProtect(new_mem,NO);
   if((ret=aa_MemoryReAllocate((VP)&new_mem,bytes))!=RET_YES) {   return ret; }
   aa_MemoryProtect(new_mem,YES);
   aa.memory_system.temp_reallocs[level]++;
   //sprintf(st,"inc temp allocs for level %i from %i",level,oldby);   OutputDebugString(st);
   }
  ///sprintf(st,"putting %i to temp_mem[lev=%i] which was %i",new_mem,level,aa.memory_system.temp_mem[level]);  OutputDebugString(st);
  aa.memory_system.temp_mem[level]=new_mem;
  aa.memory_system.temp_bytes[level]=bytes;
  }
 if(mem!=NULL) { *mem=aa.memory_system.temp_mem[level]; }
 if(oldby) {}
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/



 B aaMemoryStatus                      (_memorystatus*memorystatus)
 {
 H i;
 SYSTEM_INFO si;
 MEMORYSTATUSEX mstatus;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(memorystatus)
  {
  aaMemoryFill(&mstatus,sizeof(mstatus),0);
  mstatus.dwLength=sizeof(mstatus);
  GlobalMemoryStatusEx(&mstatus);
  aa.memory_system.status.os_physical_total=mstatus.ullTotalPhys;
  aa.memory_system.status.os_physical_allocated=mstatus.ullTotalPhys-mstatus.ullAvailPhys;
  aa.memory_system.status.os_memory_load=(F)mstatus.dwMemoryLoad;

  aa.memory_system.status.os_virtual_total=mstatus.ullTotalVirtual;
  aa.memory_system.status.os_virtual_allocated=mstatus.ullTotalVirtual-mstatus.ullAvailVirtual;


  aa.memory_system.status.pages_allocated=aa.page_system.pages_allocated;
  aa.memory_system.status.pages_commited=aa.page_system.pages_commited;
  aa.memory_system.status.total_object_handles=aa.object_system.total_count;
  for(i=0;i<256;i++)
   {
   aa.memory_system.status.object_handle_count[i]=aa.object_system.object[i].instance_count;
   }
  if(aa.memory_system.status.os_hardware_page_size==0)
   {
   GetSystemInfo(&si);
   aa.memory_system.status.os_hardware_page_size=si.dwPageSize;
   }

  aa.core_system.GetProcessMemoryInfo(aa.core_system.process_handle,&aa.memory_system.pmc,sizeof(aa.memory_system.pmc));
  aa.memory_system.status.os_page_fault_count=aa.memory_system.pmc.PageFaultCount;
  aa.memory_system.status.working_set_size_peak=aa.memory_system.pmc.PeakWorkingSetSize;
  aa.memory_system.status.process_virtual_usage=aa.memory_system.pmc.PrivateUsage;

  aa.memory_system.status.os_virtual_perc=aaNumPercentIs(aa.memory_system.status.os_virtual_allocated,aa.memory_system.status.os_virtual_total);
  aa.memory_system.status.os_physical_perc=aaNumPercentIs(aa.memory_system.status.os_physical_allocated,aa.memory_system.status.os_physical_total);
  }
 if(memorystatus)
  {
  aaMemoryCopy(memorystatus,sizeof(_memorystatus),&aa.memory_system.status);
  }
 return RET_YES;
 }



 B aaMemoryTableGet                    (_memorytable*memorytable)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memorytable)
  {
  aaMemoryCopy(memorytable,sizeof(_memorytable),&aa.memory_system.table);
  }
 return RET_YES;
 }



 B aaMemoryZero                        (VP dst,H bytes)
 {
 BP src;
 QP q_src;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  { return RET_BADPARM;  }
 if(bytes==0)   { return RET_YES; }
 aa.memory_system.status.bytes_filled+=bytes;
 aa.memory_system.status.fill_calls++;
 q_src=(QP)dst;
 while(1)
  {
  if(bytes<64) break;
  *(q_src+0)=*(q_src+1)=*(q_src+2)=*(q_src+3)=*(q_src+4)=*(q_src+5)=*(q_src+6)=*(q_src+7)=0;
  q_src+=8;
  bytes-=64;
  }
 while(1)
  {
  if(bytes<8) break;
  *(q_src+0)=0;
  q_src+=1;
  bytes-=8;
  }
 src=(BP)q_src;
 while(1)
  {
  if(bytes==0) break;
  *(src+0)=0;
  src+=1;
  bytes--;
  }
 return RET_YES;
 }






 B aaMemoryFill                        (VP dst,H bytes,B val)
 {
 register BP dptr;
 register HP hp;
 register H dwords;
 register H dw;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(bytes==0) { return RET_YES; }
 aa.memory_system.status.bytes_filled+=bytes;
 aa.memory_system.status.fill_calls++;

// aa_CoreSystemLog(-1,"Fill %lu",bytes);


 aaCast(dptr,BP,dst);

 if(bytes>=64)
  {
  dw=(val<<24)+(val<<16)+(val<<8)+val;
  aaCast(hp,HP,dst);
  dwords=bytes>>2;
  while(1)
   {
   if(dwords<2) { break; }
   hp[0]=dw;
   hp[1]=dw;
   dptr+=8;
   hp+=2;
   bytes-=8;
   dwords-=2;
   }
  if(bytes==0) { return RET_YES; }
  while(dwords--)
   {
   hp[0]=dw;
   dptr+=4;
   hp+=1;
   bytes-=4;
   }
  if(bytes==0) { return RET_YES; }
  }
 while(bytes--)
  {
  *dptr=val;
  dptr++;
  }
 return RET_YES;
 }



 #define NOTALIND(eex,eey)   (((N)eex&(sizeof(N)-1))|((N)eey&(sizeof(N)-1)))  // Nonzero if either eex or eey is not aligned on a "long" boundary.
 #define BIGBLOCKSIZE        (sizeof(N)<<2)      // How many bytes are copied each iteration of the 4X unrolled loop.
 #define LITTLEBLOCKSIZE     (sizeof(N))           // How many bytes are copied each iteration of the word copy loop.
 #define TOO_SMALL(LEN)      ((LEN)<(N)BIGBLOCKSIZE) // Threshhold for punting to the byte copier. ningy added (N)



 B aaMemoryCopy                        (VP dst,H bytes,VP src)
 {
 register CP dp=dst;
 register CP sp=src;
 register NP aligned_dst;
 register NP aligned_src;
 N len=(N)bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(len<0)      {  return RET_BADPARM; }
 if(len==0)     {  return RET_YES;  }
 if(src==NULL)  {  return RET_BADPARM;  }

 aa.memory_system.status.bytes_copied+=bytes;
 aa.memory_system.status.copy_calls++;

// if(bytes>_32K) { aaLog(-1,"Copy %p to %p %i  src=%i,%i,%i %c%c%c%c%c%c",src,dst,bytes,sp[0],sp[1],sp[2],sp[0],sp[1],sp[2],sp[3],sp[4],sp[5]); }

 if(sp<dp&&(dp<(sp+len)))
  {
  sp+=len;
  dp+=len;
  while(len--) { *--dp=*--sp; }
  }
 else
  {
  if(!TOO_SMALL(len)&&!NOTALIND(sp,dp))
   {
   aligned_dst=(NP)dp;
   aligned_src=(NP)sp;
   while(len>=(N)BIGBLOCKSIZE)    // ningy added (N)
    {
    *aligned_dst++=*aligned_src++;
    *aligned_dst++=*aligned_src++;
    *aligned_dst++=*aligned_src++;
    *aligned_dst++=*aligned_src++;
    len-=BIGBLOCKSIZE;
    }
   while(len>=(N)LITTLEBLOCKSIZE) // ningy added (N)
    {
    *aligned_dst++=*aligned_src++;
    len-=LITTLEBLOCKSIZE;
    }
   dp=(CP)aligned_dst;
   sp=(CP)aligned_src;
   }
  while(len--)   { *dp++=*sp++;   }
  }
 return RET_YES;
 }



 #define wsize                         sizeof(Z)
 #define wmask                         (wsize-1)


 B aaMemoryMove                        (VP dst,H bytes,VP src)
 {
 register CP dest=dst;
 register CP srce=src;
 register Z t;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dest==NULL)  {  return RET_BADPARM; }
 //if(bytes<0)      {  return RET_BADPARM; }
 if(bytes==0)     {  return RET_YES;     }
 if(srce==NULL)  {  return RET_BADPARM; }
 if(dest==srce)   {  return RET_YES;     }

 if((H)dest<(H)srce)
  {
  t=(Z)srce;
  if((t|(Z)dest)&wmask)
   {
   if((t^(Z)dest)&wmask||bytes<wsize) t=bytes;
   else                               t=wsize-(t&wmask);
   bytes-=t;
   do
    {
    *dest++=*srce++;
    }
    while(--t);
   }
  t=bytes/wsize;
  if(t)
  do
   {
   *(ZP)dest=*(ZP)srce;
   srce+=wsize;
   dest+=wsize;
   *dest++=*srce++;
   }
   while(--t);
  t=bytes&wmask;
  if(t)
  do
   {
   *dest++=*srce++;
   }
   while(--t);
  }
 else
  {
  srce+=bytes;
  dest+=bytes;
  t=(Z)srce;
  if((t|(Z)dest)&wmask)
   {
   if((t^(Z)dest)&wmask||bytes<=wsize)  t=bytes;
   else                                 t&=wmask;
   bytes-=t;
   do
    {
    *--dest=*--srce;
    }
    while(--t);
   }
  t=bytes/wsize;
  if(t)
  do
   {
   srce-=wsize;
   dest-=wsize;
   *(ZP)dest=*(ZP)srce;
   }
   while(--t);
  t=bytes&wmask;
  if(t)
  do
   {
   *--dest=*--srce;
   }
   while(--t);
  }
 return RET_YES;
 }



 B aaMemorySwap                        (VP dst,H bytes,VP src)
 {
 B block[_32K+_4K];
 H todo;
 BP dp,sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_YES; }
 dp=(BP)dst;
 sp=(BP)src;
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_32K);
  aaMemoryCopy(block,todo,dp);
  aaMemoryCopy(dp,todo,sp);
  aaMemoryCopy(sp,todo,block);
  bytes-=todo;
  dp+=todo;
  sp+=todo;
  }
 return RET_YES;
 }






 B aaMemoryTemp                        (PP mem,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa_MemoryTemp(mem,bytes,aa_MEMORYTEMP_User));
 }





 B aaMemoryAllocate                    (PP mem,H bytes)
 {
 B ret;
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_MemoryAllocate((VP)&vmem,bytes,"zser",NO))!=YES)
  {
  //aaNote(0,"ret=%s bytes=%uM",ret_string[ret],bytes/_1MEG);
  return ret;
  }
 aa.memory_system.status.user_bytes_allocated+=bytes;
 if(aa.memory_system.status.user_bytes_allocated>aa.memory_system.status.peak_user_bytes_allocated)  {  aa.memory_system.status.peak_user_bytes_allocated=aa.memory_system.status.user_bytes_allocated;  }
 aa.memory_system.status.user_blocks_allocated++;
 if(aa.memory_system.status.user_blocks_allocated>aa.memory_system.status.peak_user_blocks_allocated) {  aa.memory_system.status.peak_user_blocks_allocated=aa.memory_system.status.user_blocks_allocated;  }
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 memhdr->is_user=YES;
 ///logg("%s (reallocs=%i)(%i)(%s),ptr=%p",__func__,memhdr->realloc_count,memhdr->bytes,memhdr->name,mem);
 vmem+=sizeof(_aa_memoryheader);
 *mem=vmem;

 //B fcetc[_2K]; sprintf(fcetc,"%s bytes=%u name=%s",__func__,bytes,memhdr->name); OutputDebugString(fcetc);
 return RET_YES;
 }





 B aaMemoryReAllocate                  (PP mem,H bytes)
 {
 B ret;
 H by;
 _aa_memoryheader*memhdr;
 BP vmem;
 BP nmem;
 B was_user;
 B was_name[33];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aaMemoryBytesGet(*mem,&by))!=RET_YES)
  {
  aaNote(0,"%s %u ret=%s bytes=%u",__FUNCTION__,__LINE__,ret_string[ret],bytes);
  aaCast(vmem,BP,*mem);
  vmem-=sizeof(_aa_memoryheader);
  aaCast(memhdr,_aa_memoryheader*,vmem);
  if(memhdr->magic==VAL_aamh) { oof; }
  else { oof; }
  return ret;
  }
 aaCast(vmem,BP,*mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->is_user!=YES) { oof; return RET_FORBIDDEN; }
 if(bytes==0) { oof; }
 was_user=memhdr->is_user;
 aaStringCopy(was_name,memhdr->name);
 ///logg("%s (reallocs=%i)(%i)(%s),ptr=%p",__func__,memhdr->realloc_count,memhdr->bytes,memhdr->name,mem);
 vmem+=sizeof(_aa_memoryheader);
 if((ret=aaMemoryAllocate((VP)&nmem,bytes))!=YES) { /*oops; aaNote(0,"realloc from %u to %u",by,bytes);*/ return ret; }
 if(bytes>=by) { aaMemoryCopy(nmem,by,vmem);  }
 else          { aaMemoryCopy(nmem,bytes,vmem);   }
 aaCast(vmem,BP,*mem);
 if((ret=aaMemoryRelease(vmem))!=YES) { oops; }
 aaCast(vmem,BP,nmem);
// aa.memory_system.status.user_bytes_allocated+=bytes;
 ///aaCast(memhdr,_aa_memoryheader*,vmem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh) { oof; }
 memhdr->is_user=was_user;
 aaStringCopy(memhdr->name,was_name);
 ///logg("%s (reallocs=%i)(%i)(%s),ptr=%p",__func__,memhdr->realloc_count,memhdr->bytes,memhdr->name,memhdr);
 vmem+=sizeof(_aa_memoryheader);
 *mem=vmem;
 //logg("User call aaMemoryReAllocate (%i)",memhdr->bytes);
 ///aaLog(-777,"nice");
 return RET_YES;
 }







 B aaMemoryResize                      (PP mem,H bytes)
 {
 B ret;
 H by;
 _aa_memoryheader*memhdr;
 BP vmem;
 BP nmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aaMemoryBytesGet(*mem,&by))!=RET_YES)
  {
  aaNote(0,"%s %u ret=%s bytes=%u",__FUNCTION__,__LINE__,ret_string[ret],bytes);
  aaCast(vmem,BP,*mem);
  vmem-=sizeof(_aa_memoryheader);
  aaCast(memhdr,_aa_memoryheader*,vmem);
  if(memhdr->magic==VAL_aamh) { oof; }
  else { oof; }
  return ret;
  }
 aaCast(vmem,BP,*mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->is_user!=YES) { oof; return RET_FORBIDDEN; }
 if(bytes==0) { oof; }
 vmem+=sizeof(_aa_memoryheader);
 if((ret=aaMemoryAllocate((VP)&nmem,bytes))!=YES) { oops; aaNote(0,"realloc from %u to %u",by,bytes); return ret; }
 aaCast(vmem,BP,*mem);
 if((ret=aaMemoryRelease(vmem))!=YES) { oops; }
 aaCast(vmem,BP,nmem);
// aa.memory_system.status.user_bytes_allocated+=bytes;
 ///aaCast(memhdr,_aa_memoryheader*,vmem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh) { oof; }
 memhdr->is_user=YES;
 vmem+=sizeof(_aa_memoryheader);
 *mem=vmem;
 //logg("User call aaMemoryReAllocate (%i)",memhdr->bytes);
 ///aaLog(-777,"nice");
 return RET_YES;
 }





 B aaMemoryDuplicate                   (PP mem,VP src)
 {
 B ret;
 H bytes;
 BP nm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 *mem=NULL;
 if(src==NULL) { return RET_BADPARM; }
 OutputDebugString(__func__);
 if(aaMemoryIsAllocated(src,&bytes)==YES)
  {
  if((ret=aaMemoryAllocate((VP)&nm,bytes))!=YES) { oops; }
  *mem=nm;
  aaMemoryNameSet(nm,"memdup");
  return RET_YES;
  }
 aaStringLen(src,&bytes);
 if(bytes==0||bytes>=_4MEG) { oof; return RET_FAILED; }
 if((ret=aaMemoryAllocate((VP)&nm,bytes+1))!=YES) { oops; }
 aaMemoryNameSet(nm,"memdupb");
 aaStringNCopy(nm,src,bytes,YES);
 *mem=nm;
 return RET_YES;
 }





 B aaMemoryMake                        (PP mem,H bytes)
 {
 B ret;
 BP vmem;
 H oldbytes;
 //_aa_memoryheader*memhdr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==0)  { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if(*mem==NULL)
  {
  if((ret=aaMemoryAllocate((VP)&vmem,bytes))!=RET_YES) { oops; return ret; }
  aaMemoryNameSet(vmem,"memmak");
  *mem=vmem;
  return RET_YES;
  }
 aaCast(vmem,BP,*mem);
 vmem-=sizeof(_aa_memoryheader);
 //aaCast(memhdr,_aa_memoryheader*,vmem);
 vmem+=sizeof(_aa_memoryheader);
 if((ret=aaMemoryBytesGet(vmem,&oldbytes))!=RET_YES) { oof; return ret; }
 if(oldbytes==0) oof;
 if(oldbytes!=bytes)
  {
  if((ret=aaMemoryReAllocate((VP)&vmem,bytes))!=RET_YES) { oof; return ret; }
  }
 *mem=vmem;
 return RET_YES;
 }



 B aaMemoryNameSet                     (VP mem,VP fmt,...)
 {
 _aa_memoryheader*memhdr;
 BP vmem;
 aaVargsf(fmt);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) {  return RET_BADPARM; }
 if(str64k.len==0||((str64k.len+1)>=sizeof(memhdr->name))) { return RET_BOUNDS;  }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)  { oof;  return RET_NO;  }
 if(memhdr->is_user!=YES) {  oof; return RET_FORBIDDEN; }
 aaMemoryFill(memhdr->name,sizeof(memhdr->name),0);
 aaStringCopy(memhdr->name,str64k.buf);
 return RET_YES;
 }



 B aaMemoryNameGet                     (VP mem,VP name)
 {
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name==NULL) {  return RET_BADPARM; }
 aaStringNull(name);
 if(mem==NULL) {  return RET_BADPARM; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)  { oof;  return RET_NO;  }
 //if(memhdr->is_user!=YES) {  oof; return RET_FORBIDDEN; }
 aaStringCopy(name,memhdr->name);
 return RET_YES;
 }




 B aaMemoryIsAllocated                 (VP mem,HP bytes)
 {
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if(mem==NULL) {  return RET_NO; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)  {  return RET_NO;  }
 if(bytes) { *bytes=memhdr->bytes; }
 return RET_YES;
 }





 B aaMemoryBytesGet                    (VP mem,HP bytes)
 {
 _aa_memoryheader*memhdr;
 BP vmem;
 C delme[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if(mem==NULL) {  return RET_BADPARM; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
 if(memhdr->magic!=VAL_aamh)
  {
  sprintf(delme,"%s %u magic=%08x %08x rac=%i use=%i prot=%i lock=%i by=%i actlen=%i minitype=%i minindex=%i name=%s\r\n\0\0",
                 __func__,__LINE__,
                 memhdr->magic,VAL_aamh ,memhdr->realloc_count,memhdr->is_user,
                 memhdr->is_protected,memhdr->is_locked,
                 memhdr->bytes,memhdr->actual_len,
                 memhdr->mini_type,memhdr->mini_index,memhdr->name);
  OutputDebugString(delme);
  if(bytes) { *bytes=0; }
  return RET_FAILED;
  }
 if(bytes)
  {
  *bytes=memhdr->bytes;
  }
 return RET_YES;
 }


/// for each alloc, i should make a list in memory system, so we can enum blocks if needed
 B aaMemoryBlockGet                    (PP mem,HP bytes,H id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes) *bytes=0;
 if(mem) *mem=NULL;
 UNUSE(id);
 //aa.memory_system.status.user_blocks_allocated++;
 return RET_NOTINITIALIZED;
 }






 B aaMemoryRelease                     (VP mem)
 {
 B ret;
 H bytes;
 _aa_memoryheader*memhdr;
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaMemoryBytesGet(mem,&bytes))!=RET_YES) { return ret; } //oops; if(mem==NULL) oof; return ret; }
 aaCast(vmem,BP,mem);
 vmem-=sizeof(_aa_memoryheader);
 aaCast(memhdr,_aa_memoryheader*,vmem);
  //aaLog(-777,">>>>> aaMemoryReleasee release %i bytes, bytes_alloc=%i blocks_alloc=%i name=%s",bytes,aa.memory_system.status.bytes_allocated,aa.memory_system.status.blocks_allocated,memhdr->name);
 //bitcoin if(memhdr->magic!=VAL_aamh ) { oof; return RET_FAILED; }
 if(memhdr->is_user!=YES) {  oof; return RET_FORBIDDEN; }
 ///logg("%s (reallocs=%i)(%i)(%s),ptr=%p",__func__,memhdr->realloc_count,memhdr->bytes,memhdr->name,memhdr);
 if((ret=aa_MemoryRelease(mem))!=YES) {  oops; return ret; }
 aa.memory_system.status.user_bytes_allocated-=bytes;
 aa.memory_system.status.user_blocks_allocated--;
// aaLog(-777,"release %i",bytes);
 return RET_YES;
 }




 B aaMemoryAdlerCrcGet                 (VP mem,H bytes,HP crc)
 {
 H s1,s2,oldcrc;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_YES; }
 if(crc==NULL) { return RET_BADPARM; }
 oldcrc=*crc;
 aaCast(bp,BP,mem);
 s1=oldcrc&F16;
 s2=(oldcrc>>16)&F16;
 while(bytes>0)
  {
  s1+=*bp++;
  s2+=s1;
  bytes--;
  s1%=65521L;
  s2%=65521L;
  }
 oldcrc=(s2<<16)|s1;
 *crc=oldcrc;
 if(*crc==0) { oof; } // make so if crc==0 crc=1;
 return RET_YES;
 }






 B aaMemoryCrcGet                      (VP mem,H bytes,HP crc)
 {
 H oldcrc;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(crc==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_YES; }
 oldcrc=*crc;
 aaCast(bp,BP,mem);
 while(1)
  {
  oldcrc=(aa.memory_system.crc_table[((oldcrc)^(*bp))&0xff]^((oldcrc)>>8));
  bytes--;
  if(bytes==0) { break; }
  bp++;
  }
 *crc=oldcrc=~oldcrc;
 if(*crc==0) { oof; } // make so if crc==0 crc=1;
 return RET_YES;
 }





 B aaMemoryCrc64Get                    (VP mem,H bytes,QP crc)
 {
 Q oldcrc,lookup;
 H i;
 B index;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(crc==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_YES; }
 oldcrc=*crc;
 aaCast(bp,BP,mem);
 i=0;
 for(i=0;i<bytes;i++)
  {
  index=bp[i]^oldcrc;
  lookup=aa.memory_system.crc64_table[index];
  oldcrc>>=8;
  oldcrc^=lookup;
  }
 *crc=oldcrc;
 return RET_YES;
 }





 B aaMemoryHashGet                     (VP mem,H bytes,HP hash)
 {
 BP bp;
 H h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash==NULL) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 h=*hash;
 while(bytes--)
  {
  h+=*bp++;
  h+=(h<<10);
  h^=(h>>6);
  }
 h+=(h<<3);
 h^=(h>>11);
 h+=(h<<15);
 if(h==0) { h=1; }
 *hash=h;
 return RET_YES;
 }





 B aaMemoryValueFill                   (VP mem,H count,H valbytes,VP valmem)
 {
 BP bp;
 BP sp;
 H i,j,z;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_YES; }
 if(valbytes==0) { return RET_YES; }
 if(valmem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 aaCast(sp,BP,valmem);
 z=0;
 for(i=0;i<count;i++)
  {
  for(j=0;j<valbytes;j++)
   {
   bp[z++]=sp[j];
   }
  }
 return RET_YES;
 }







 B aaMemoryPokeByte                    (VP mem,H offset,B val)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 *bp=val;
 return RET_YES;
 }





 B aaMemoryPokeWord                    (VP mem,H offset,W val)
 {
 BP bp;
 WP wp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(wp,WP,bp);
 *wp=val;
 return RET_YES;
 }




 B aaMemoryPokeDword                   (VP mem,H offset,H val)
 {
 BP bp;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(hp,HP,bp);
 *hp=val;
 return RET_YES;
 }



 B aaMemoryPokeQuad                    (VP mem,H offset,Q val)
 {
 BP bp;
 QP qp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(qp,QP,bp);
 *qp=val;
 return RET_YES;
 }



 B aaMemoryPeekByte                    (VP mem,H offset,BP val)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 *val=*bp;
 return RET_YES;
 }




 B aaMemoryPeekWord                    (VP mem,H offset,WP val)
 {
 BP bp;
 WP wp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(wp,WP,bp);
 *val=*wp;
 return RET_YES;
 }




 B aaMemoryPeekDword                   (VP mem,H offset,HP val)
 {
 BP bp;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,mem);
 bp+=offset;
 aaCast(hp,HP,bp);
 *val=*hp;
 return RET_YES;
 }



 B aaMemoryPokeDwordAndInc             (VP mem,HP offset,H val)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(offset==NULL) { return RET_BADPARM; }
 off=*offset;
 aaCast(bp,BP,mem);
 *(HP)&bp[off]=val;
 *offset=off+4;
 return RET_YES;
 }


 B aaMemoryPeekDwordAndInc             (VP mem,HP offset,HP val)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(offset==NULL) { return RET_BADPARM; }
 if(val==NULL) { return RET_BADPARM; }
 off=*offset;
 aaCast(bp,BP,mem);
 *val=*(HP)&bp[off];
 *offset=off+4;
 return RET_YES;
 }






 B aaMemoryCompare                     (VP dst,H bytes,VP src,NP dif)
 {
 BP s1,s2;
 B c1,c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  if(bytes==0) { break; }
  c1=*s1;
  c2=*s2;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  bytes--;
  if(bytes==0) { break; }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }







 B aaMemoryRandomSet                   (VP dst,H bytes)
 {
 BP bp;
 H i,ra;
 BP rp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_FAILED; }
 bp=(BP)dst;
 for(i=0;i<bytes;i++)
  {
  if((i%4)==0)
   {
   ra=aaMathTwisterInt32(&aa.math_system.twister);
   rp=(BP)&ra;
   }
  bp[i]=rp[i%4];
  }
  /////aaMathTwisterInt32
 //aa_MathRandomGet(dst,bytes);
 return RET_YES;
 }



 B aaMemoryRandomDwordSet              (HP val,H lo,H hi)
 {
 H rn,v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if(lo>hi) { return RET_BADPARM; }
 rn=(hi-lo)+1;
 aaMemoryRandomSet(&v,4);
 v%=(rn);
 *val=(lo+v);
 return RET_YES;
 }


 B aaMemoryRandomHit                   (H lo,H hi,H eq)
 {
 B ret;
 H val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaMemoryRandomDwordSet(&val,lo,hi))!=YES) { return ret; }
 if(val!=eq) { return RET_NO; }
 return RET_YES;
 }




 B aaMemoryPageAllocate                (HP handle)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageAllocate(handle,NULL,"userpage"))!=RET_YES) { return ret; }
 aa.memory_system.status.user_pages_allocated++;
 if(aa.memory_system.status.user_pages_allocated>aa.memory_system.status.peak_user_pages_allocated)
  {
  aa.memory_system.status.peak_user_pages_allocated=aa.memory_system.status.user_pages_allocated;
  }
 return RET_YES;
 }




 B aaMemoryPageRelease                 (H handle)
 {
 B ret;
 B isprot,isuser;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isprot,&isuser))!=RET_YES) { return ret; }
 if(isuser==NO) { return RET_BADHANDLE; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if((ret=aa_PageRelease(handle))!=RET_YES) { return ret; }
 aa.memory_system.status.user_pages_allocated--;
 return RET_YES;
 }




 B aaMemoryPageProtect                 (H handle,B state)
 {
 B ret;
 B isprot,isuser;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isprot,&isuser))!=RET_YES) { return ret; }
 if(isuser==NO) { return RET_BADHANDLE; }
 if((ret=aa_PageProtect(handle,state))!=RET_YES) { return ret; }
 return RET_YES;
 }




 B aaMemoryPageGet                     (H handle,PP mem,BP isprotected)
 {
 B ret;
 B isuser;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,mem,isprotected,&isuser))!=RET_YES) { return ret; }
 if(isuser==NO) { return RET_BADHANDLE; }
 return RET_YES;
 }






 B aaMemoryCodeAllocate                (PP mem,H bytes)
 {
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 *mem=NULL;
 if(bytes==0) { aaNote(0,"aamemoryCodeallocate  %i",bytes); return RET_BADPARM; }
 if((vmem=VirtualAlloc(NULL,bytes+(aa_MEMORY_OPCODE_SAFETY*2),MEM_COMMIT,PAGE_EXECUTE_READWRITE))==NULL) // was PAGE_EXECUTE_READWRITE|PAGE_NOCACHE
  {
  return RET_NOMEMORY;
  }
 *mem=&vmem[aa_MEMORY_OPCODE_SAFETY];
 return RET_YES;
 }





 B aaMemoryCodeRelease                 (VP mem)
 {
 BP vmem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(vmem,BP,mem);
 vmem-=(aa_MEMORY_OPCODE_SAFETY);
 //aa_last_line_executed=__LINE__;
 if(VirtualFree(vmem,0,MEM_RELEASE)==0) { oof; oow; return RET_FAILED; }
 //aa_last_line_executed=__LINE__;
 return RET_YES;
 }







 B aaMemorySort                        (VP mem,H entries,H entrybytes,VP usrdata,B(*proc)(VP,H,H,VP,VP,VP,NP))
 {
 VP lbStack[qsMAXSTACK];
 VP ubStack[qsMAXSTACK];
 Z sp;
 N dif;
 Y offset;
 CP lb,ub,m,P,i,j;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(entrybytes==0) { return RET_BADPARM; }
 if(entrybytes>=_16K)  { return RET_NOMEMORY; }
 if(entries==0) { return RET_NOTFOUND; }
 UNUSE(usrdata);
 UNUSE(proc);
 if(entries==1) { return RET_YES; }
 lbStack[0]=(CP)mem;
 ubStack[0]=(CP)mem+(entries-1)*entrybytes;
 for(sp=0;sp>=0;sp--)
  {
  lb=(CP)lbStack[sp];
  ub=(CP)ubStack[sp];
  while(lb<ub)
   {
   offset=(ub-lb)>>1;
   P=lb+offset-offset%entrybytes;
   qsEXCHANGE(lb,P,(N)entrybytes);
   i=lb+entrybytes;
   j=ub;
   while(1)
    {
    while(1)
     {
     if(i>=j) break;
     if(proc) proc(mem,entries,entrybytes,usrdata,lb,i,&dif);
     else     aaMemoryCompareProc(mem,entries,entrybytes,usrdata,lb,i,&dif);
     if(dif<=0) break;
     i+=entrybytes;
     }
    //while (i < j&&proc(mem,entries,entrybytes,usrdata,lb, i)>0) i+=entrybytes;
    //while (j>=i&&proc(mem,entries,entrybytes,usrdata,j, lb)>0) j-=entrybytes;
    while(1)
     {
     if(j<i) break;
     if(proc) proc(mem,entries,entrybytes,usrdata,j,lb,&dif);
     else     aaMemoryCompareProc(mem,entries,entrybytes,usrdata,j,lb,&dif);
     if(dif<=0) break;
     j-=entrybytes;
     }
    if(i>=j) break;
    qsEXCHANGE(i,j,(N)entrybytes);
    j-=entrybytes;
    i+=entrybytes;
    }
   qsEXCHANGE(lb,j,(N)entrybytes);
   m=j;
   if(m-lb<=ub-m)  { if(m+entrybytes<ub) { lbStack[sp]=m+entrybytes;  ubStack[sp++]=ub;    }  ub=m-entrybytes;    }
   else             { if(m-entrybytes>lb) { lbStack[sp]=lb;  ubStack[sp++]=m-entrybytes;    }  lb=m+entrybytes;    }
   }
  }
 return RET_YES;
 }



 B aaMemoryCompareProc                 (VP mem,H entries,H entrybytes,VP usrdata,VP itema,VP itemb,NP dif)
 {
 UNUSE(mem);
 UNUSE(entries);
 UNUSE(entrybytes);
 UNUSE(usrdata);
 return(aaStringCompare(itemb,itema,dif));
 }



 B aaMemorySearch                      (VP mem,H entries,H entrybytes,VP usrdata,VP data,HP index,B(*proc)(VP,H,H,VP,VP,VP,NP))
 {
 H mid,lo,hi;
 BP bp;
 N res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(index) { *index=F32; }
 if(entrybytes==0) { return RET_BADPARM; }
 if(entrybytes>=_16K)  { return RET_NOMEMORY; }
 if(entries==0) { return RET_NOTFOUND; }
 //if(index==NULL) { return RET_BADPARM; }
 if(data==NULL) { return RET_BADPARM; }
 UNUSE(usrdata);
 UNUSE(proc);
 //*index=F32;
 aaCast(bp,BP,mem);
 lo=0;
 hi=entries-1;
 while((N)lo<=(N)hi)
  {
  //http://googleresearch.blogspot.com.au/2006/06/extra-extra-read-all-about-it-nearly.html
  mid=lo+((hi-lo)/2);
  ///mid=(lo+hi)/2;
//  *index=mid;
  if(proc) proc(mem,entries,entrybytes,usrdata,data,&bp[mid*entrybytes],&res);
  else     aaMemoryCompareProc(mem,entries,entrybytes,usrdata,data,&bp[mid*entrybytes],&res);
  if(res==0) { if(index) { *index=mid; } return RET_YES;}
  if(res>0)  { lo=mid+1;  }
  else       { hi=mid-1;  }
  }
 return RET_NOTFOUND;
 }




#if 0
 B aaMemoryArraySort                   (VP mem,H entries,H size,B issigned,B des,HP order)
 {
 H i,j,hold,which;
 G dif=0;
 BP arb;
 CP arc;
 IP ari;
 WP arw;
 NP arn;
 HP arh;
 GP arg;
 QP arq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }

 if(entries==0)
  {
  if(order) { order[0]=0; }
  return RET_YES;
  }
 if(order==NULL) { return RET_BADPARM; }
 des&=1;
 arc=(CP)mem; arb=(BP)mem;
 ari=(IP)mem; arw=(WP)mem;
 arn=(NP)mem; arh=(HP)mem;
 arg=(GP)mem; arq=(QP)mem;
 which=0;
 if(size==1&& issigned) { which=1; } else
 if(size==1&&!issigned) { which=2; } else
 if(size==2&& issigned) { which=3; } else
 if(size==2&&!issigned) { which=4; } else
 if(size==4&& issigned) { which=5; } else
 if(size==4&&!issigned) { which=6; } else
 if(size==8&& issigned) { which=7; } else
 if(size==8&&!issigned) { which=8; } else { return RET_BADPARM; }
 if(des==0) { for(i=0;i<entries;i++) { order[i]=entries-i-1;  } }
 else       { for(i=0;i<entries;i++) { order[i]=i;          } }
 for(i=0;i<entries-0;i++)
  {
  for(j=0;j<entries-1;j++)
   {
   if(which==1) {  dif=(G)arc[order[j+1]]-(G)arc[order[j]]; } else
   if(which==2) {  dif=(Q)arb[order[j+1]]-(Q)arb[order[j]]; } else
   if(which==3) {  dif=(G)ari[order[j+1]]-(G)ari[order[j]]; } else
   if(which==4) {  dif=(Q)arw[order[j+1]]-(Q)arw[order[j]]; } else
   if(which==5) {  dif=(G)arn[order[j+1]]-(G)arn[order[j]]; } else
   if(which==6) {  dif=(Q)arh[order[j+1]]-(Q)arh[order[j]]; } else
   if(which==7) {  dif=(G)arg[order[j+1]]-(G)arg[order[j]]; } else
   if(which==8) {  dif=(Q)arq[order[j+1]]-(Q)arq[order[j]]; }
   if((+des&&dif>0)||(!des&&dif<0))
    {
    hold=order[j];
    order[j]=order[j+1];
    order[j+1]=hold;
    }
   }
  }
 return RET_YES;
 }



#endif

 B aaMemoryOrderSort                   (VP mem,H entries,H stride,H offset,H size,B issigned,B des,HP order)
 {
 B ret;
 ///register
 H i,j;
 H hold,which;
 G dif=0;
 BP bp;
 BP arb[2];
 CP arc[2];
 IP ari[2];
 WP arw[2];
 NP arn[2];
 HP arh[2];
 GP arg[2];
 QP arq[2];

 BP tmp;
 BP blb;
 HP ord;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }

 ord=(HP)order;
 if(ord==NULL)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,entries*4,aa_MEMORYTEMP_OrderSort))!=RET_YES) { oops; }
  if((ret=aa_MemoryTemp((VP)&blb,entries*stride,aa_MEMORYTEMP_OrderBlob))!=RET_YES)    { oops; }
  ord=(HP)tmp;
  }
 if(ord==NULL) { return RET_BADPARM; }

 if(entries==0)
  {
  //if(order) { order[0]=0; }
  ord[0]=0;
  return RET_YES;
  }
 //if(order==NULL) { return RET_BADPARM; }
 des&=1;
 bp=(BP)mem;

 which=0;
 if(size==1&&issigned)  { which=1; } else
 if(size==1&&!issigned) { which=2; } else
 if(size==2&&issigned)  { which=3; } else
 if(size==2&&!issigned) { which=4; } else
 if(size==4&&issigned)  { which=5; } else
 if(size==4&&!issigned) { which=6; } else
 if(size==8&&issigned)  { which=7; } else
 if(size==8&&!issigned) { which=8; } else { return RET_BADPARM; }
 if(des==0) { for(i=0;i<entries;i++) { ord[i]=entries-i-1;  } }
 else       { for(i=0;i<entries;i++) { ord[i]=i;            } }

 for(i=0;i<entries-0;i++)
  {
  for(j=0;j<entries-1;j++)
   {
   bp=(BP)mem;
   bp+=(ord[j+1]*stride)+offset;
   arc[0]=(CP)bp; arb[0]=(BP)bp;
   ari[0]=(IP)bp; arw[0]=(WP)bp;
   arn[0]=(NP)bp; arh[0]=(HP)bp;
   arg[0]=(GP)bp; arq[0]=(QP)bp;

   bp=(BP)mem;
   bp+=(ord[j]*stride)+offset;
   arc[1]=(CP)bp; arb[1]=(BP)bp;
   ari[1]=(IP)bp; arw[1]=(WP)bp;
   arn[1]=(NP)bp; arh[1]=(HP)bp;
   arg[1]=(GP)bp; arq[1]=(QP)bp;

   if(which==1) {  dif=(G)*arc[0]-(G)*arc[1]; } else
   if(which==2) {  dif=(Q)*arb[0]-(Q)*arb[1]; } else
   if(which==3) {  dif=(G)*ari[0]-(G)*ari[1]; } else
   if(which==4) {  dif=(Q)*arw[0]-(Q)*arw[1]; } else
   if(which==5) {  dif=(G)*arn[0]-(G)*arn[1]; } else
   if(which==6) {  dif=(Q)*arh[0]-(Q)*arh[1]; } else
   if(which==7) {  dif=(G)*arg[0]-(G)*arg[1]; } else
   if(which==8) {  dif=(Q)*arq[0]-(Q)*arq[1]; }

   if((+des&&dif>0)||(!des&&dif<0))
    {
    hold=ord[j];
    ord[j]=ord[j+1];
    ord[j+1]=hold;
    }
   }
  }
 if(order==NULL)
  {
  aaMemoryCopy(blb,entries*stride,mem);
  bp=(BP)mem;
  for(i=0;i<entries;i++)
   {
   aaMemoryCopy(&bp[i*stride],stride,&blb[ord[i]*stride]);
   }
  }




 return RET_YES;
 }





 B aaMemoryUnitAllocate                (_memoryunit*memoryunit,H bytes)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_BADPARM; }
 memoryunit->bytes=0;
 memoryunit->mem=NULL;
 if((ret=aaMemoryAllocate((VP)&memoryunit->mem,bytes))!=YES)
  {
  aaNote(0,"memoryunitalloc %s %uM",ret_string[ret],bytes/_1MEG);
  return ret;
  }
 aaMemoryNameSet(memoryunit->mem,"MemoryUnit");
 memoryunit->bytes=bytes;
 return RET_YES;
 }






 B aaMemoryUnitReAllocate              (_memoryunit*memoryunit,H bytes)
 {
 B ret;
 H from;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { return RET_BADPARM; }
 if(memoryunit->bytes==0) { return RET_FAILED; }
 if(memoryunit->mem==NULL) { return RET_FAILED; }
 from=memoryunit->bytes;
 if((ret=aaMemoryReAllocate((VP)&memoryunit->mem,bytes))!=YES)
  {
  UNUSE(from);
//  aaNote(0,"memoryunitRealloc %s from %uM %uM",ret_string[ret],from/_1MEG,bytes/_1MEG);
  return ret;
  }
 memoryunit->bytes=bytes;
 return RET_YES;
 }




 B aaMemoryUnitMake                    (_memoryunit*memoryunit,H bytes)
 {
 B ret;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { return RET_BADPARM; }
 if(bytes==0) { return RET_BADPARM; }
 if(aaMemoryBytesGet(memoryunit->mem,&by)!=YES)
  {
  if((ret=aaMemoryUnitAllocate(memoryunit,bytes))!=YES) { return ret; }
  }
 if(by!=memoryunit->bytes) { oof; }
 if(bytes==memoryunit->bytes) { return RET_YES; }
 if((ret=aaMemoryUnitReAllocate(memoryunit,bytes))!=YES) { return ret; }
 return RET_YES;
 }





 B aaMemoryUnitRelease                 (_memoryunit*memoryunit)
 {
 B ret;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(memoryunit==NULL) { oof; return RET_BADPARM; }
 if(memoryunit->bytes==0) { oof; return RET_FAILED; }
 if(memoryunit->mem==NULL) { oof; return RET_FAILED; }
 if((ret=aaMemoryBytesGet(memoryunit->mem,&bytes))!=YES) { oops; return ret; }
 if(bytes!=memoryunit->bytes) { oof; return RET_FAILED; }
 if((ret=aaMemoryRelease(memoryunit->mem))!=YES) { oops; }
 memoryunit->bytes=0;
 memoryunit->mem=NULL;
 return RET_YES;
 }






 B aaMemoryWorkingSetSizeSet           (H minbytes,H maxbytes)
 {
 H s,mi,mx;
 HANDLE h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minbytes==0||minbytes==F32) { minbytes=aa.memory_system.status.working_set_size_min; }
 if(maxbytes==0||maxbytes==F32) { maxbytes=aa.memory_system.status.working_set_size_max; }
 if(minbytes>maxbytes) { s=minbytes; minbytes=maxbytes; maxbytes=s; }
 ///if(minbytes==F32) { return RET_BOUNDS; }
 //if(maxbytes==F32) { return RET_BOUNDS; }
 //if(minbytes==0||maxbytes==0) { return RET_BOUNDS; }
 h=aa.core_system.process_handle;
 if(SetProcessWorkingSetSize(h,minbytes,maxbytes)==0) { oof; oow; return RET_FAILED; }
 if(!GetProcessWorkingSetSize(h,&mi,&mx)) { oof; oow; return RET_FAILED; }
 aa.memory_system.status.working_set_size_min=mi;
 aa.memory_system.status.working_set_size_max=mx;
 return RET_YES;
 }




 B aaMemoryWorkingSetFlush             (V)
 {
 B ret;
 HANDLE h;
 H mi,mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 mi=aa.memory_system.status.working_set_size_min;
 mx=aa.memory_system.status.working_set_size_max;
 h=aa.core_system.process_handle;
 if(SetProcessWorkingSetSize(h,F32,F32)==0) { oof; oow; return RET_FAILED; }
 aa.memory_system.status.working_set_flush_count++;
 if((ret=aaMemoryWorkingSetSizeSet(mi,mx))!=YES) { oops; return ret; }
 return RET_YES;
 }








/*-----------------------------------------------------------------------*/


 B aaGroupofCreate                     (_groupof*groupof,H width,H initialslots)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(groupof);
 if(width==0) { return RET_BADPARM; }
 aaMemoryFill(groupof,sizeof(_groupof),0);
 groupof->magic=aaHPP(aaGroupofCreate);
 groupof->width=width;
 if(initialslots!=0)
  {
  if((ret=aaMemoryAllocate((VP)&groupof->mem,initialslots*groupof->width))!=YES) { oops; }
  if((ret=aaMemoryAllocate((VP)&groupof->rsvd,(initialslots/8)+1))!=YES) { oops; }
  aaMemoryNameSet(groupof->mem,"grpofmem");
  aaMemoryNameSet(groupof->rsvd,"grpofrsvd");
  groupof->allocs++;
  groupof->slots=initialslots;
  }
 return RET_YES;
 }



 B aaGroupofDestroy                    (_groupof*groupof)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(groupof);
 if(groupof->magic!=aaHPP(aaGroupofCreate)) { return RET_NOTINITIALIZED; }
 if(groupof->width==0) { return RET_FAILED; }
 if(groupof->slots!=0)
  {
  aaMemoryRelease(groupof->rsvd);
  aaMemoryRelease(groupof->mem);
  }
 aaMemoryFill(groupof,sizeof(_groupof),0);
 return RET_YES;
 }




 B aaGroupofNew                        (_groupof*groupof,HP index,PP mem)
 {
 B ret;
 H left,add,i,j;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(groupof);
 if(groupof->magic!=aaHPP(aaGroupofCreate)) { return RET_NOTINITIALIZED; }
 if(groupof->width==0) { return RET_FAILED; }
 left=groupof->slots-groupof->count;
 if(left<10)
  {
  add=50+groupof->slots+(groupof->slots*.8);
  if(groupof->slots==0)
   {
   ret=aaMemoryAllocate((VP)&groupof->mem,add*groupof->width);
   ret=aaMemoryAllocate((VP)&groupof->rsvd,(add/8)+1);
   aaMemoryNameSet(groupof->mem,"grpofmem");
   aaMemoryNameSet(groupof->rsvd,"grpofrsvd");
   }
  else
   {
   ret=aaMemoryReAllocate((VP)&groupof->mem,add*groupof->width);
   ret=aaMemoryReAllocate((VP)&groupof->rsvd,(add/8)+1);
   }
  if(ret!=RET_YES) { oops; }
  groupof->allocs++;
  groupof->slots=add;
  }
 j=groupof->count;
 if(j>0) j--;
 for(i=0;i<groupof->slots;i++)
  {
  if(aaBitGet(groupof->rsvd[j/8],(j%8))==0) { break; }
  j++;
  if(j>=groupof->slots) { j=0; }
  }
 if(i==groupof->slots) { oof; }
 i=j;
 groupof->rsvd[i/8]=aaBitSet(groupof->rsvd[i/8],(i%8));
 if(index) { *index=i; }
 if(mem)   { *mem=&groupof->mem[i*groupof->width]; }
 aaMemoryFill(&groupof->mem[i*groupof->width],groupof->width,0);
 groupof->count++;
 return RET_YES;
 }




 B aaGroupofGet                        (_groupof*groupof,H index,PP mem)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(groupof);
 if(groupof->magic!=aaHPP(aaGroupofCreate)) { return RET_NOTINITIALIZED; }
 if(groupof->width==0) { return RET_FAILED; }
 if(index>=groupof->slots) { return RET_BADHANDLE; }
 if(aaBitGet(groupof->rsvd[index/8],(index%8))==0) { return RET_BADHANDLE; }
 if(mem) { *mem=&groupof->mem[index*groupof->width]; }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 #ifndef O_RDWR
 #define O_RDWR                        00000002
 #endif
 #ifndef O_CREAT
 #define O_CREAT                       00000100
 #endif
 #ifndef O_RDONLY
 #define O_RDONLY                      00000000
 #endif
 #ifndef O_TRUNC
 #define O_TRUNC                       00001000
 #endif




 B aaSerialMemNew                      (_serialmem*serialmem,H bytes)
 {
 B ret;
 SYSTEM_INFO si;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(serialmem==NULL) { return RET_BADPARM; }
 aaMemoryFill(serialmem,sizeof(_serialmem),0);
 serialmem->magic=aaHPP(aaSerialMemNew);
 GetSystemInfo(&si);
 //si.dwPageSize;
 serialmem->req_bytes=bytes;
 serialmem->adj_bytes=(bytes/si.dwPageSize)*si.dwPageSize;
 if((bytes%si.dwPageSize)!=0) { serialmem->adj_bytes+=si.dwPageSize; }
 if(serialmem->adj_bytes==0)  { serialmem->adj_bytes+=si.dwPageSize; }
 if((ret=aaMemoryAllocate((VP)&serialmem->memory,serialmem->adj_bytes))!=YES) { oops; }
 serialmem->base=(VP)&serialmem->memory[0];
 return RET_YES;
 }

 B aaSerialMemDelete                   (_serialmem*serialmem)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(serialmem==NULL) { return RET_BADPARM; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return RET_NOTINITIALIZED; }
 if(serialmem->adj_bytes!=0)
  {
  aaMemoryRelease(serialmem->memory);
  }
 aaMemoryFill(serialmem,sizeof(_serialmem),0);
 return RET_YES;
 }


 B aaSerialMemMalloc                   (_serialmem*serialmem,H bytes,PP xptr)
 {
 _serialnode*temp;
 _serialnode*current;
 ZP ptr;
 Z i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(serialmem==NULL) { return RET_BADPARM; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return RET_NOTINITIALIZED; }
 if(xptr==NULL) { return RET_BADPARM; }
 *xptr=NULL;
 current=(_serialnode*)serialmem->base;
 ptr=NULL;
 i=0;
 while(PE(serialmem,current->next)!=NULL)
  {
  current=(_serialnode*)(PE(serialmem,current->next));
  if(current->status==0)
   {
   if(PE(serialmem,current->next)!=NULL)
    {
    if((Z)((CP)PE(serialmem,current->next)-(CP)PE(serialmem,current->ref))>=(Z)bytes)
     {
     if(((Z)((CP)PE(serialmem,current->next)-(CP)PE(serialmem,current->ref))-bytes)>sizeof(_serialnode))
      {
      current->status=1;
      ptr=(ZP)PE(serialmem,current->ref);
      temp=(_serialnode*)(PE(serialmem,current->next));
      current->next=VE(serialmem,(CP)(ptr)+bytes);
      current=(_serialnode*)(PE(serialmem,current->next));
      current->next=VE(serialmem,temp);
      current->ref=VE(serialmem,(CP)current+sizeof(_serialnode));
      current->status=0;
      }
     else
      {
      current->status=1;
      ptr=PE(serialmem,current->ref);
      i++;
      break;
      }
     }
    }
   else
    {
    ptr=PE(serialmem,current->ref);
    current->status=1;
    current->next=(Z)(current->ref+bytes);
    current=(_serialnode*)(PE(serialmem,current->next));
    current->ref=VE(serialmem,(CP)current+sizeof(_serialnode));
    current->status=0;
    i++;
    break;
    }
   }
  i++;
  }
 if(i==0)
  {
  current->next=VE(serialmem,(CP)current+sizeof(_serialnode));
  current=(_serialnode*)(PE(serialmem,current->next));
  current->ref=VE(serialmem,(CP)current+sizeof(_serialnode));
  ptr=PE(serialmem,current->ref);
  current->status=1;
  current->next=(Z)(current->ref+bytes);
  current=(_serialnode*)(PE(serialmem,current->next));
  current->ref=VE(serialmem,(CP)current+sizeof(_serialnode));
  current->status=0;
  }
 *xptr=ptr;
 return RET_YES;
 }


 B aaSerialMemFree                     (_serialmem*serialmem,VP ptr)
 {
 _serialnode*current;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(serialmem==NULL) { return RET_BADPARM; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return RET_NOTINITIALIZED; }
 if(ptr==NULL) { return RET_BADPARM; }
 current=(_serialnode*)serialmem->base;
 while(PE(serialmem,current->next)!=NULL)
  {
  current=(_serialnode*)(PE(serialmem,current->next));;
  if(current->status==1&&PE(serialmem,current->ref)==ptr)
   {
   current->status=0;
   break;
   }
  }
 aa_SerialMemDefrag(serialmem);
 return RET_YES;
 }


 B aaSerialMemInfoToString             (_serialmem*serialmem,H maxchars,VP str)
 {
 _serialnode*current;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(maxchars);
 if(serialmem==NULL) { return RET_BADPARM; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return RET_NOTINITIALIZED; }
 current=(_serialnode*)serialmem->base;
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 aaStringAppendf(str,"_____________________________\n");
 aaStringAppendf(str,"start address:%p\n",&serialmem->memory[0]);
 aaStringAppendf(str,"end address:%p\n",&serialmem->memory[serialmem->adj_bytes-1]);
 aaStringAppendf(str,"_____________________________\n");
 aaStringAppendf(str,"me:%p\n",current);
 aaStringAppendf(str,"ref:%p\n",PE(serialmem,current->ref));
 aaStringAppendf(str,"status:%d\n",current->status);
 aaStringAppendf(str,"next:%p\n",PE(serialmem,current->next));
 aaStringAppendf(str,"_____________________________\n");
 while(PE(serialmem,current->next)!=NULL)
  {
  current=(_serialnode*)(PE(serialmem,current->next));
  aaStringAppendf(str,"me:%p\n",current);
  aaStringAppendf(str,"ref:%p\n",PE(serialmem,current->ref));
  aaStringAppendf(str,"status:%d\n",current->status);
  aaStringAppendf(str,"next:%p\n",PE(serialmem,current->next));
  aaStringAppendf(str,"_____________________________");
  }
 return RET_YES;
 }



 B aaSerialMemMap                      (_serialmem*serialmem,VP file,...)
 {
 Z i,fd,result;
 CP map;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(serialmem==NULL) { return RET_BADPARM; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return RET_NOTINITIALIZED; }
 if(file==NULL) { return RET_BADPARM; }
 aaVargsf4K(file);
 fd=open((CP)str4k.buf,O_RDWR|O_CREAT|O_TRUNC,(mode_t)0600);//S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);//,(mode_t)0600);
 if(fd==-1)              { oof; perror("Error opening file for writing"); exit(EXIT_FAILURE);    }
 result=lseek(fd,serialmem->adj_bytes-1,SEEK_SET);
 if(result==-1)          { close(fd); perror("Error calling lseek() to 'stretch' the file"); exit(EXIT_FAILURE);    }
 result=write(fd,"",1);
 if(result!=1)           { close(fd); perror("Error writing last byte of the file"); exit(EXIT_FAILURE);    }
 map=aa_mmap(0,serialmem->adj_bytes,PROT_READ|PROT_WRITE,MAP_SHARED,fd,0);
 if(map==MAP_FAILED)     { close(fd); perror("Error mmapping the file"); exit(EXIT_FAILURE);    }
 for(i=0;i<(Z)serialmem->adj_bytes;i++) { map[i]=serialmem->memory[i];    }
 if(aa_munmap(map,serialmem->adj_bytes)==-1) { perror("Error un-mmapping the file");   }
 close(fd);
 return RET_YES;
 }




 B aaSerialMemUnMap                    (_serialmem*serialmem,PP physaddr,VP file,...)
 {
 Z i,fd;
 _serialnode*temp;
 CP map;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(serialmem==NULL) { return RET_BADPARM; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return RET_NOTINITIALIZED; }
 if(file==NULL) { return RET_BADPARM; }
 aaVargsf4K(file);
 if(physaddr==NULL) { return RET_BADPARM; }
 *physaddr=NULL;
 fd=open((CP)str4k.buf,O_RDONLY,(mode_t)0600);
 if(fd==-1)              { perror("Error opening file for reading"); exit(EXIT_FAILURE);    }
 map=aa_mmap(0,serialmem->adj_bytes,PROT_READ,MAP_SHARED,fd,0);
 if(map==MAP_FAILED)     { close(fd); perror("Error mmapping the file"); exit(EXIT_FAILURE);    }
 for(i=0;i<(Z)serialmem->adj_bytes;i++) { serialmem->memory[i]=map[i];    }
 if(aa_munmap(map,serialmem->adj_bytes)==-1) { perror("Error un-mmapping the file");    }
 serialmem->base=(VP)&serialmem->memory[0];
 temp=(_serialnode*)serialmem->base;
 temp=(_serialnode*)(PE(serialmem,temp->next));
 close(fd);
 *physaddr=PE(serialmem,temp->ref);
 return RET_YES;
 }




VP aaSerialMemPhys                     (_serialmem*serialmem,Y virtaddr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(serialmem==NULL) { return NULL; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return NULL; }
 return PE(serialmem,virtaddr);
 }

 Y aaSerialMemVirt                     (_serialmem*serialmem,VP physaddr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(serialmem==NULL) { return -1; }
 if(serialmem->magic!=aaHPP(aaSerialMemNew)) { return -1; }
 return VE(serialmem,physaddr);
 }




/*-----------------------------------------------------------------------*/



 B aaBloomNew                          (_bloom*bloom,H maxentries,D error)
 {
 B ret;
 D num,denom,dentries;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(maxentries==0) { return RET_BOUNDS; }
 if(error<=0.0) { error=0.000001; }
 else
 if(error>=1.0) { error=0.999999; }
 aaMemoryFill(bloom,sizeof(_bloom),0);
 bloom->magic=aaHPP(aaBloomNew);
 bloom->max_entries=maxentries;
 bloom->error=error;
 num=logf(bloom->error);
 denom=0.480453013918201;
 bloom->bpe=-(num/denom);
 dentries=(D)maxentries;
 bloom->bits=(N)(dentries*bloom->bpe);
 if(bloom->bits%8) { bloom->bytes=(bloom->bits/8)+1;  }
 else              { bloom->bytes=bloom->bits/8;      }
 bloom->hashes=(N)ceil(0.693147180559945*bloom->bpe);
 if((ret=aaMemoryAllocate((VP)&bloom->bf,bloom->bytes))!=YES) { oops; }
 return RET_YES;
 }




 B aaBloomLoad                         (_bloom*bloom,VP file,...)
 {
 B ret;
 _bloom bloo;
 H bytes,loaded;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(file==NULL) { return RET_BADPARM; }
 aaVargsf4K(file);
 bytes=sizeof(_bloom)-sizeof(BP);
 if((ret=aaFileLoadToBuffer(str4k.buf,0,bytes,&bloo,&loaded))!=YES) { return ret;  }
 if(loaded!=bytes) { return RET_FAILED; }
 if((ret=aaMemoryAllocate((VP)&bloo.bf,bloo.bytes))!=YES) { oops; return ret; }
 bytes+=sizeof(BP);
 bloo.magic=aaHPP(aaBloomNew);
 aaMemoryCopy(bloom,bytes,&bloo);
 bytes-=sizeof(BP);
 if((ret=aaFileLoadToBuffer(str4k.buf,bytes,bloom->bytes,bloom->bf,&loaded))!=YES) { oops;}
 if(loaded!=(H)bloom->bytes) { oof; }
 return RET_YES;
 }


 B aaBloomDelete                       (_bloom*bloom)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 if(bloom->bf!=NULL&&bloom->bytes!=0) { aaMemoryRelease(bloom->bf); }
 aaMemoryFill(bloom,sizeof(_bloom),0);
 return RET_YES;
 }



 B aaBloomSave                         (_bloom*bloom,VP file,...)
 {
 B ret;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 if(file==NULL) { return RET_BADPARM; }
 aaVargsf4K(file);
 bytes=sizeof(_bloom)-sizeof(BP);
 aaFileDelete("%s",str4k.buf);
 bytes=sizeof(_bloom)-sizeof(BP);
 if((ret=aaFileSaveFromMemory(str4k.buf,bytes,bloom))!=YES) { oops; return ret; }
 if((ret=aaFileAppendFromMemory(str4k.buf,bloom->bytes,bloom->bf))!=YES) { oops; return ret; }
 return RET_YES;
 }






 B aaBloomFind                         (_bloom*bloom,H bytes,VP data)
 {
 H a,b,x,byte,mask;
 N i,hits;
 B c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes==0)   { aaStringLen(data,&bytes);  }
 if(bytes==0)   { return RET_BADPARM; }
 a=0x9747b28c;  aaMemoryCrcGet(data,bytes,&a);
 b=a;           aaMemoryCrcGet(data,bytes,&b);
 hits=0;
 for(i=0;i<bloom->hashes;i++)
  {
  x=(a+i*b)%bloom->bits;
  byte=x>>3;
  c=bloom->bf[byte];
  mask=1<<(x%8);
  if(c&mask) {  hits++;  }
  else  {   }
  }
 if(hits!=bloom->hashes) { return RET_NOTFOUND; }
 return RET_POSSIBLE;
 }





 B aaBloomFindf                        (_bloom*bloom,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 aaVargsf(fmt);
 return(aaBloomFind(bloom,str64k.len,str64k.buf));
 }



 B aaBloomAdd                          (_bloom*bloom,H bytes,VP data)
 {
 H a,b,x,byte,mask;
 N i,hits;
 B c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes==0)   { aaStringLen(data,&bytes);  }
 if(bytes==0) { return RET_BADPARM; }
 a=0x9747b28c;  aaMemoryCrcGet(data,bytes,&a);
 b=a;           aaMemoryCrcGet(data,bytes,&b);
 hits=0;
 for(i=0;i<bloom->hashes;i++)
  {
  x=(a+i*b)%bloom->bits;
  byte=x>>3;
  c=bloom->bf[byte];
  mask=1<<(x%8);
  if(c&mask) {  hits++;   }
  else
   {
   bloom->bf[byte]=c|mask;
   }
  }
 if(hits==bloom->hashes) { return RET_COLLISION; }
 return RET_YES;
 }





 B aaBloomAddf                         (_bloom*bloom,VP fmt,...)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bloom==NULL) { return RET_BADPARM; }
 if(bloom->magic!=aaHPP(aaBloomNew)) { return RET_NOTINITIALIZED; }
 aaVargsf(fmt);
 return(aaBloomAdd(bloom,str64k.len,str64k.buf));
 }




/*-----------------------------------------------------------------------*/

 #define aaChainEntry(x)               if(chain==NULL)                          { return RET_BADPARM;        } \
                                       if(chain->magic!=aaHPP(aaChainNew)&&(x)) { return RET_NOTINITIALIZED; }


 B aa_ChainLinkSlotsExpand             (_chain*chain)
 {
 B ret;
 D div;
 H chlisi,state,add;

 aaChainEntry(1);
 chlisi=chain->link_slots;
 if(chlisi<0x0100) { state=0; add=0x0150; } else
 if(chlisi<0x0200) { state=1; add=0x0300; } else
 if(chlisi<0x0400) { state=2; add=0x0450; } else
                   { state=3; add=0x0600; }
 div=(30+(state*10))/100.0;
 add=(add+chlisi)+(chlisi*div);
 //aaDebugf("slots from %i to %i div=%.3f",chlisi,add,div);
 if(add==chain->link_slots) {  aaNote(0,"redundent memory reallocation with same size, %i",add);  }
 if(chain->link_slots==0)   {  ret=aaMemoryAllocate((VP)&chain->link,add*sizeof(_chainlink));     }
 else                       {  ret=aaMemoryReAllocate((VP)&chain->link,add*sizeof(_chainlink));   }
 if(ret!=RET_YES)           {  oops;  }
 chain->link_slots=add;
 chain->link_avail=chain->link_slots-chain->link_count;
 return RET_YES;
 }





 B aa_ChainMemoryLenExpand             (_chain*chain)
 {
 B ret;
 D div;
 H add,chlisi,state;

 aaChainEntry(1);
 chlisi=chain->mem.bytes;
 if(chlisi<0x1100) { state=0; add=0x1150; } else
 if(chlisi<0x2200) { state=1; add=0x2300; } else
 if(chlisi<0x3400) { state=2; add=0x3450; } else
                   { state=3; add=0x4600; }
 div=(30+(state*10))/100.0;
 add=(add+chlisi)+(chlisi*div);
 //aaDebugf("membytes from %i to %i div=%.3f",chlisi,add,div);
 if(add==chain->mem.bytes) {  aaNote(0,"redundent memory reallocation with same size, %i",add);  }
 if(chain->mem.bytes==0)   { ret=aaMemoryUnitAllocate(&chain->mem,add);    }
 else                      { ret=aaMemoryUnitReAllocate(&chain->mem,add);  }
 if(ret!=RET_YES)          { oops; }
 return RET_YES;
 }






 B aaChainNew                          (_chain*chain)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(0);
 aaMemoryFill(chain,sizeof(_chain),0);
 chain->magic=aaHPP(aaChainNew);
 chain->link_first=CHAINLINK_NULL;
 chain->link_last=CHAINLINK_NULL;
 return RET_YES;
 }






 B aaChainDelete                       (_chain*chain)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(chain->link_slots!=0)  { aaMemoryRelease(chain->link);      }
 if(chain->mem.bytes)      { aaMemoryUnitRelease(&chain->mem);  }
 aaMemoryFill(chain,sizeof(_chain),0);
 return RET_YES;
 }











 B aaChainLinkClear                    (_chain*chain,_chainlink*link)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(link==NULL)  {oof; }
 link->state=0;
 link->offset=0;
 link->bytes=0;
 link->have=0;
 link->prev=CHAINLINK_NULL;
 link->next=CHAINLINK_NULL;
 link->self=CHAINLINK_NULL;
 return RET_YES;
 }




 B aaChainLinkNew                      (_chain*chain,_chainlink*link,H bytes,PP data)
 {
 B ret;
 H base,j,i,go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(link==NULL)  {oof; }
 if(chain->link_avail<4)
  {
  if((ret=aa_ChainLinkSlotsExpand(chain))!=RET_YES) { oops; }
  }
 base=chain->link_count;
 go=0;
 for(j=0;j<chain->link_slots;j++)
  {
  i=base+j;
  if(i>=chain->link_slots) { i=0; }
  if(aaBitGet(chain->link[i].state,0)==0) { break; }
  go++;
  }
 if(j==chain->link_slots) { oof; }
 aaChainLinkClear(chain,&chain->link[i]);
 chain->link[i].state=aaBitSet(chain->link[i].state,0);
 chain->link[i].self=i;
 chain->link[i].prev=CHAINLINK_NULL;
 chain->link[i].next=CHAINLINK_NULL;
 chain->link_count++;
 chain->link_usage++;
 chain->link_avail=chain->link_slots-chain->link_count;
 aaChainLinkLengthSet(chain,&chain->link[i],bytes,0);
 aaMemoryCopy(link,sizeof(_chainlink),&chain->link[i]);
 if(data)
  {
  if(link->have==0) { *data=NULL; }
  else              { *data=&chain->mem.mem[link->offset]; }
  }
 return RET_YES;
 }






 B aaChainLinkLengthSet                (_chain*chain,_chainlink*link,H bytes,PP data)
 {
 H avail;
 H todo;
 H plus;
 B buf[_4K];
 BP ptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(link==NULL) { oof; }
 if(link==NULL) { return RET_BADPARM; }
 avail=chain->mem.bytes-chain->mem.used;

 //if(link->have!=0)
 //if(bugbug)  {  aaDebugf("change len, self=%i byte=%i have=%i to=%i",link->self,link->bytes,link->have,bytes);  }

 if((bytes+_1K)>=avail)  {  aa_ChainMemoryLenExpand(chain);  }

 plus=16;

 if(link->have==0)
  {
  link->offset=chain->mem.used;
  link->have=bytes+plus;
  link->bytes=bytes;
  chain->mem.used+=(link->have+1);
  if(data)
   {
   if(link->have==0) { *data=NULL; }
   else              { *data=&chain->mem.mem[link->offset]; }
   }
  aaChainLinkSet(chain,link);
  return RET_YES;
  }



 if(bytes>=link->have)
  {
  ptr=&chain->mem.mem[link->offset];
  todo=link->have;
  aaMemoryCopy(buf,todo,ptr);

  link->offset=chain->mem.used;
  link->bytes=bytes;
  link->have=bytes+plus;
  chain->mem.used+=(link->have+1);

  ptr=&chain->mem.mem[link->offset];
  aaMemoryCopy(ptr,todo,buf);
  if(data)
   {
   if(link->have==0) { *data=NULL; }
   else              { *data=&chain->mem.mem[link->offset]; }
   }
  aaChainLinkSet(chain,link);
  return RET_YES;
  }


 link->bytes=bytes;
 if(data)
  {
  if(link->have==0) { *data=NULL; }
  else              { *data=&chain->mem.mem[link->offset]; }
  }
 aaChainLinkSet(chain,link);

 return RET_YES;
 }














 B aaChainLinkSet                      (_chain*chain,_chainlink*link)
 {
 H index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(link==NULL)  {oof; }
 if(link==NULL) { return RET_BADPARM; }
 if(link->self>=chain->link_count) { return RET_BOUNDS; }
 index=link->self;
 aaMemoryCopy(&chain->link[index],sizeof(_chainlink),link);
 return RET_YES;
 }








 B aaChainLinkGet                      (_chain*chain,H linkindex,_chainlink*link,PP data)
 {
 _chainlink*cl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(link==NULL)  {oof; }
 if(linkindex==CHAINLINK_FIRST) linkindex=chain->link_first;
 if(linkindex==CHAINLINK_LAST) linkindex=chain->link_last;

 cl=(_chainlink*)&chain->link[linkindex];
 if(linkindex==CHAINLINK_NULL||linkindex>=chain->link_count)
  {
  aaChainLinkClear(chain,cl);
  if(link) {  aaMemoryCopy(link,sizeof(_chainlink),cl); }
  if(data)
   {
   if(cl->have==0) { *data=NULL; }
   else            { *data=&chain->mem.mem[cl->offset]; }
   }
  return RET_BOUNDS;
  }
 if(link) {  aaMemoryCopy(link,sizeof(_chainlink),cl); }
 if(data)
  {
  if(cl->have==0) { *data=NULL; }
  else            { *data=&chain->mem.mem[cl->offset]; }
  }
 return RET_YES;
 }










 B aaChainLinkTraverse                 (_chain*chain,H linkindex,N amount,HP nlinkindex,_chainlink*link,PP data)
 {
 _chainlink*linkptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(linkindex==CHAINLINK_FIRST) linkindex=chain->link_first;
 if(linkindex==CHAINLINK_LAST) linkindex=chain->link_last;
 aaDebugf("trav li=%i",linkindex);
 linkptr=(_chainlink*)&chain->link[linkindex];
 if(amount<0)
  {
  amount=aaNumAbs(amount);
  while(1)
   {
   if(aaBitGet(linkptr->state,1)==1)
    {
    if(linkptr->prev==CHAINLINK_NULL) { break; }
    linkptr=(_chainlink*)&chain->link[linkptr->prev];
    continue;
    }
   if(linkptr->prev==CHAINLINK_NULL) {  break; }
   linkptr=(_chainlink*)&chain->link[linkptr->prev];
   amount--;
   if(amount==0) { break; }
   }
  }
 else
 if(amount>0)
  {
  while(1)
   {
   if(aaBitGet(linkptr->state,1)==1)
    {
    if(linkptr->prev==CHAINLINK_NULL) { break; }
    linkptr=(_chainlink*)&chain->link[linkptr->next];
    continue;
    }
   if(linkptr->next==CHAINLINK_NULL) {  break; }
   linkptr=(_chainlink*)&chain->link[linkptr->next];
   amount--;
   if(amount==0) { break; }
   }
  }
 if(nlinkindex)
  {
  *nlinkindex=linkptr->self;
  }
 if(data)
  {
  *data=&chain->mem.mem[linkptr->offset];
  }
 if(link)
  {
  aaMemoryCopy(link,sizeof(_chainlink),linkptr);
  }
 return RET_YES;
 }












 B aaChainLinkInsert                   (_chain*chain,H linkindex,H destindex)
 {
 _chainlink newlink;
 _chainlink oldlink;
 _chainlink nxtlink;
 _chainlink fstlink;
 _chainlink lstlink;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(chain->link_first==CHAINLINK_NULL&&chain->link_last!=CHAINLINK_NULL) { oof; }
 if(chain->link_last==CHAINLINK_NULL&&chain->link_first!=CHAINLINK_NULL) { oof; }

 if(linkindex==CHAINLINK_FIRST) linkindex=chain->link_first;
 if(linkindex==CHAINLINK_LAST) linkindex=chain->link_last;
// if(destindex==CHAINLINK_FIRST) destindex=chain->link_first;
// if(destindex==CHAINLINK_LAST) destindex=chain->link_last;


 if(destindex==CHAINLINK_FIRST)
  {
  if(chain->link_first==CHAINLINK_NULL)
   {
   aaChainLinkGet(chain,linkindex,&newlink,NULL);
   chain->link_first=newlink.self;
   chain->link_last=newlink.self;
   newlink.prev=CHAINLINK_NULL;
   newlink.next=CHAINLINK_NULL;
   aaChainLinkSet(chain,&newlink);
   return RET_YES;
   }
  aaChainLinkGet(chain,linkindex,&newlink,NULL);
  aaChainLinkGet(chain,chain->link_first,&fstlink,NULL);
  newlink.prev=fstlink.self;
  fstlink.next=newlink.self;
  chain->link_first=newlink.self;
  newlink.next=CHAINLINK_NULL;
  aaChainLinkSet(chain,&newlink);
  aaChainLinkSet(chain,&fstlink);
  return RET_YES;
  }
 if(destindex==CHAINLINK_LAST)
  {
  if(chain->link_last==CHAINLINK_NULL)
   {
   aaChainLinkGet(chain,linkindex,&newlink,NULL);
   chain->link_last=newlink.self;
   chain->link_first=newlink.self;
   newlink.prev=CHAINLINK_NULL;
   newlink.next=CHAINLINK_NULL;
   aaChainLinkSet(chain,&newlink);
   return RET_YES;
   }
  aaChainLinkGet(chain,linkindex,&newlink,NULL);
  aaChainLinkGet(chain,chain->link_last,&lstlink,NULL);
  newlink.prev=lstlink.self;
  lstlink.next=newlink.self;
  chain->link_last=newlink.self;
  aaChainLinkSet(chain,&newlink);
  aaChainLinkSet(chain,&lstlink);
  return RET_YES;
  }
 aaChainLinkGet(chain,destindex,&oldlink,NULL);
 aaChainLinkGet(chain,oldlink.next,&nxtlink,NULL);
 aaChainLinkGet(chain,linkindex,&newlink,NULL);

 newlink.prev=oldlink.self;
 newlink.next=nxtlink.self;

 oldlink.next=newlink.self;
 nxtlink.prev=newlink.self;

 aaChainLinkSet(chain,&newlink);
 aaChainLinkSet(chain,&oldlink);
 aaChainLinkSet(chain,&nxtlink);
 return RET_YES;
 }






 B aaChainLinkRemove                   (_chain*chain,H linkindex)
 {
 B was_first;
 B was_last;
 _chainlink oldlink;
 _chainlink prvlink;
 _chainlink nxtlink;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaChainEntry(1);
 if(chain->link_first==CHAINLINK_NULL&&chain->link_last!=CHAINLINK_NULL) { oof; }
 if(chain->link_last==CHAINLINK_NULL&&chain->link_first!=CHAINLINK_NULL) { oof; }

 if(linkindex==CHAINLINK_FIRST) linkindex=chain->link_first;
 if(linkindex==CHAINLINK_LAST) linkindex=chain->link_last;


 aaChainLinkGet(chain,linkindex,&oldlink,NULL);
 if(aaBitGet(oldlink.state,1)==1) { return RET_FAILED; }

 aaChainLinkGet(chain,oldlink.next,&nxtlink,NULL);
 aaChainLinkGet(chain,oldlink.prev,&prvlink,NULL);



 was_first=was_last=NO;

 if(chain->link_first==linkindex)
  {
  was_first=YES;
  chain->link_first=oldlink.next;
  }
 if(chain->link_last==linkindex)
  {
  was_last=YES;
  chain->link_last=oldlink.prev;
  }

 UNUSE(was_first);
 UNUSE(was_last);


 prvlink.next=nxtlink.self;
 nxtlink.prev=prvlink.self;
 oldlink.next=CHAINLINK_NULL;
 oldlink.prev=CHAINLINK_NULL;
 oldlink.state=aaBitSet(oldlink.state,1);

 chain->link_removes++;
 chain->link_usage--;


 aaChainLinkSet(chain,&oldlink);
 aaChainLinkSet(chain,&prvlink);
 aaChainLinkSet(chain,&nxtlink);

 if(chain->link_usage==0)
  {
  chain->link_last=CHAINLINK_NULL;
  chain->link_first=CHAINLINK_NULL;
  }


 return RET_YES;
 }






/*-----------------------------------------------------------------------*/
//http://www.geeksforgeeks.org/iterative-quick-sort/



 B aaSorterNew                         (_sorter*sorter,G entries,VP data,B(*proc)(_sorter*,H,G,G,VP,NP))
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(sorter==NULL) { return RET_BADPARM; }
 if(entries==0) { return RET_BOUNDS; }
 if(proc==NULL) { return RET_BADPARM; }
 aaMemoryFill(sorter,sizeof(_sorter),0);
 sorter->magic=aaHPP(aaSorterNew);
 sorter->entries=entries;
 sorter->proc=(VP)proc;
 sorter->stage=150;
 sorter->data=data;
 sorter->eff=logf((D)sorter->entries);

 sorter->top=-1;
 sorter->stack_size=1000;
 sorter->stack_left=sorter->stack_size;
 if((ret=aaMemoryAllocate((VP)&sorter->stack,sorter->stack_size*sizeof(G)))!=YES) { oops; }
 aaMemoryNameSet(sorter->stack,"sortstack");
 sorter->l=0;
 sorter->h=sorter->entries-1;
 sorter->i=0;

 return RET_YES;
 }





 B aaSorterDelete                      (_sorter*sorter)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(sorter==NULL) { return RET_BADPARM; }
 if(sorter->magic!=aaHPP(aaSorterNew)) { return RET_NOTINITIALIZED; }
 if(sorter->stack!=NULL)      { if(aaMemoryRelease(sorter->stack)!=YES) oof;  }
 ///if(sorter->is_userorder==NO) { if(aaMemoryRelease(sorter->order)!=YES) oof;  }
 aaMemoryFill(sorter,sizeof(_sorter),0);
 return RET_YES;
 }







 B aaSorterSort                        (_sorter*sorter,H ita)
 {
 B ret;
 B(*proc)(_sorter*,H,G,G,VP,NP);
 N dif;
 register H itb,itc;
 //register G go,yo;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sorter==NULL) { return RET_BADPARM; }
 if(sorter->magic!=aaHPP(aaSorterNew)) { return RET_NOTINITIALIZED; }
 proc=sorter->proc;
 itc=ita;
 if(itc==0) { itc=1; }
 itb=0;
 while(1)//for(go=0;go<ita;go++)
  {
  if(sorter->stage!=500&&sorter->stage!=600) { sorter->total_its++; }
  switch(sorter->stage)
   {
   case 100:
   break;



   case 150:
   itb++;
   sorter->stack[++sorter->top]=sorter->l;
   sorter->stack[++sorter->top]=sorter->h;
   sorter->stack_left-=2;
   if(sorter->stack_left<10) { oof; }
   sorter->stage=200;
   break;


   case 200:
   itb++;
   if(sorter->top<0) { sorter->stage=500; break; }
   sorter->h=sorter->stack[sorter->top--];
   sorter->l=sorter->stack[sorter->top--];
   sorter->stack_left+=2;
   sorter->stage=250;
   break;



   case 250:
   itb++;
   sorter->oh=sorter->h;
   if((ret=proc(sorter,SORTER_GET,sorter->h,-1,sorter->tmp_buf,NULL))!=YES)
    {
    if(ret==RET_CANCELLED) { sorter->stage=600; break; }
    //if(ret==RET_IGNORE)     {     oops;     }
    oops;
    }
   sorter->hit[0]++;
   sorter->i=sorter->l-1;
   sorter->j=sorter->l;
   sorter->stage=300;
   break;



   case 300:
   while(1)
    {
    itb++;
    sorter->total_its++;
    if(sorter->j>(sorter->h-1)) {  sorter->stage=350; break; }
    sorter->hit[1]++;

    if((ret=proc(sorter,SORTER_CMP,sorter->j,sorter->oh,sorter->tmp_buf,&dif))!=YES)
     {
     if(ret==RET_IGNORE) { oops; sorter->j++; continue; }
     //if(ret==RET_CANCELLED) { sorter->stage=600; break; }
     oops;
     }

    if(dif<=0)
     {
     sorter->hit[2]++;
     sorter->i++;
     if(sorter->j!=sorter->i)
      {
      sorter->hit[3]++;
      if((ret=proc(sorter,SORTER_SWP,sorter->j,sorter->i,NULL,NULL))!=YES)
       {
       if(ret==RET_CANCELLED) { sorter->stage=600; break; }
       oops;
       }
      }
     }

    sorter->j++;
    if(itb>=itc) { break; }
    }
   break;



   case 350:
   itb++;
   if((sorter->i+1)!=sorter->h)
    {
    sorter->hit[4]++;
    if((ret=proc(sorter,SORTER_SWP,sorter->i+1,sorter->h,NULL,NULL))!=YES)
     {
     if(ret==RET_CANCELLED) { sorter->stage=600; break; }
     oops;
     }
    }
   sorter->p=sorter->i+1;
   if((sorter->p-1)>sorter->l)
    {
    sorter->hit[5]++;
    sorter->stack[++sorter->top]=sorter->l;
    sorter->stack[++sorter->top]=sorter->p-1;
    sorter->stack_left-=2;
    if(sorter->stack_left<10) { oof; }
    }
   if((sorter->p+1)<sorter->h)
    {
    sorter->hit[6]++;
    sorter->stack[++sorter->top]=sorter->p+1;
    sorter->stack[++sorter->top]=sorter->h;
    sorter->stack_left-=2;
    if(sorter->stack_left<10) { oof; }
    }
   sorter->stage=200;
   break;



   case 500:
   return RET_YES;

   case 600:
   return RET_CANCELLED;
   }
  itb++;
  if(itb>=itc) { break; }
  }

 if(sorter->stage==500) { return RET_YES; }
 if(sorter->stage==600) { return RET_CANCELLED; }
 return RET_NOTREADY;
 }







/*-----------------------------------------------------------------------*/



 B aaListNew                           (_list*list)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 aaMemoryFill(list,sizeof(_list),0);
 list->magic=aaHPP(aaListNew);
 list->slots=10;
 list->id_counter=0;
 if((ret=aaMemoryAllocate((VP)&list->entry,list->slots*sizeof(_listentry)))!=YES) { oops; }
 if((ret=aaMemoryNameSet(list->entry,"listentry"))!=YES) { oops; }
 if((ret=aaMemoryUnitAllocate(&list->mun,(128+256)*list->slots))!=YES) { oops; }
 if((ret=aaMemoryNameSet(list->mun.mem,"listmun"))!=YES) { oops; }
// list->lo_slot=0;
// list->hi_slot=0;
 list->allocs=1;
 //aaLog(-555,"listnew");
 return RET_YES;
 }




 B aaListClone                         (_list*list,_list*slist)
 {
 B ret;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(list);
 aaMissingParm(slist);
 if(slist->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if((ret=aaListNew(list))!=YES) { oops; }

 aaMemoryFill(list,sizeof(_list),0);
 list->magic=aaHPP(aaListNew);
 list->slots=slist->slots;
 //list->lo_slot=slist->lo_slot;
 //list->hi_slot=slist->hi_slot;
 list->id_counter=slist->id_counter;

 if(slist->slots!=0)
  {
  list->slots=slist->slots;
  if((ret=aaMemoryAllocate((VP)&list->entry,list->slots*sizeof(_listentry)))!=YES) { oops; }
  if((ret=aaMemoryNameSet(list->entry,"listentry"))!=YES) { oops; }
  for(i=0;i<slist->slots;i++)
   {
   aaMemoryCopy(&list->entry[i],sizeof(_listentry),&slist->entry[i]);
   }
  list->count=slist->count;
  }

 if(slist->mun.bytes)
  {
  if((ret=aaMemoryUnitAllocate(&list->mun,slist->mun.bytes))!=YES) { oops; }
  if((ret=aaMemoryNameSet(list->mun.mem,"listmun"))!=YES) { oops; }
  aaMemoryCopy(list->mun.mem,slist->mun.bytes,slist->mun.mem);
  }
 aaMemoryCopy(list->user_data,sizeof(list->user_data),slist->user_data);
 list->user_index=slist->user_index;
// list->smallest_entry=slist->smallest_entry;
 //list->largest_entry=slist->largest_entry;
 list->remove_count=slist->remove_count;
 list->allocs=1;
 return RET_YES;
 }




#if 1


 B aaListOpen                          (_list*list,VP fmt,...)
 {
 va_list argptr;
 B ret;
 B str[_2K];
 B txt[_4K];
 B line[16][256];
 H hash[16];
 H chars,li,i,j,mx,pos,sl,count;
 G vals[16];
 _filestreamunit fsu;
 _listentry lent;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaMissingParm(list);
 ret=aaFileExists("%s",str);
 if(ret!=RET_YES) { return RET_NOTFOUND;  }

 //if((ret=aaListNew(list))!=YES) { oops; }
 if((ret=aaFileStreamCreate(&fsu.handle,str,aa_FILECREATE_OPEN,3,3,0,0))!=YES) { oops; }
 li=0;
 while(1)
  {
  ret=aaFileStreamStringRead(fsu.handle,&chars,0,sizeof(txt),txt);
  if(ret!=RET_YES) { oops; break; }
  if(txt[0]=='#') { continue; }
  if(aaStringICompare(txt,"mun=",0)==YES)  { break;  }
  //aaDebugf("%s",txt);
  aaStringCopyf(line[li],"%s",txt);
  li++;
  }
 mx=aaElementCount(vals);
 for(i=0;i<mx;i++) { vals[i]=-1; hash[i]=0; }
 for(i=0;i<li;i++)
  {
  if(aaStringFindChar(line[i],0,&pos,'=',YES,0,YES)!=YES)
   {
   oof;
   //aaDebugf("%s",line[i]);
   break;
   }
  aaStringHashGet(line[i],pos,&hash[i],NO);
  aaStringDeleteChars(line[i],0,0,pos+1);
  aaStringLen(line[i],&sl);
  aaStringCountHex(line[i],sl,&count,YES);
  if(count!=sl)
   {
   oof;
   //aaDebugf("i=%i sl=%i count=%i %s",i,sl,count,line[i]);
   break;
   }
  //aaDebugf("0x%08x=%s",hash[i],line[i]);
  }
 if(i!=li) {  aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 aaMemoryFill(list,sizeof(_list),0);
 //list->magic=aaHPP(aaListNew);

 for(i=0;i<li;i++) { if(hash[i]==0x5dccb711)  { break; }}
 if(i==li) {  aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 aaStringToNumber(line[i],0,0,0,&vals[i],0);
 list->count=(H)vals[i];

 for(i=0;i<li;i++) { if(hash[i]==0x59a59c3e)  { break; }}
 if(i==li) {  aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 aaStringToNumber(line[i],0,0,0,&vals[i],0);
 list->slots=(H)vals[i];

 for(i=0;i<li;i++) { if(hash[i]==0xa13c79ef)  { break; }}
 if(i==li) {  aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 aaStringToNumber(line[i],0,0,0,&vals[i],0);
 list->offset=(H)vals[i];

 for(i=0;i<li;i++) { if(hash[i]==0x93a27392)  { break; }}
 if(i==li) {  aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 aaStringToNumber(line[i],0,0,0,&vals[i],0);
 list->id_counter=(Q)vals[i];


 for(i=0;i<li;i++) { if(hash[i]==0x694878af)  { break; }}
 if(i==li) {  aaFileStreamDestroy(fsu.handle); oof;  return RET_FAILED; }
 aaStringToNumber(line[i],0,0,0,&vals[i],0);
 list->remove_count=(H)vals[i];

 for(i=0;i<li;i++) { if(hash[i]==0x5c6ab17d)  { break; }}
 if(i==li) {  aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 aaStringToNumber(line[i],0,0,0,&vals[i],0);
 list->user_index=(H)vals[i];

 for(i=0;i<li;i++) { if(hash[i]==0x10669e95)  { break; }}
 if(i==li) {  aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 aaStringLen(line[i],&sl);
 if((sl%2)!=0) { aaFileStreamDestroy(fsu.handle); oof; return RET_FAILED; }
 sl/=2;
 if(sl!=sizeof(list->user_data)) {  aaFileStreamDestroy(fsu.handle); oof;  return RET_FAILED; }
 for(j=0;j<sl;j++)
  {
  aaStringToNumber(&line[i][(j*2)],2,0,0,&vals[i],0);
  list->user_data[j]=(B)vals[i];
  }
 //aaNote(0,"%i",list->offset);
 if(list->offset!=0)
  {
  if((ret=aaMemoryUnitAllocate(&list->mun,list->offset))!=YES) { oops; }
  if((ret=aaFileStreamRead(fsu.handle,(H)list->offset,list->mun.mem))!=YES) { oops; }
  }
 else
  {
  if((ret=aaMemoryUnitAllocate(&list->mun,_2K))!=YES) { oops; }
  }
 if((ret=aaMemoryAllocate((VP)&list->entry,list->slots*sizeof(_listentry)))!=YES) { oops; }
 aaMemoryNameSet(list->entry,"listentry");
 i=0;
 for(j=0;j<list->slots;j++)
  {
  if((ret=aaFileStreamRead(fsu.handle,sizeof(_listentry),&lent))!=YES) { oops; }
  if(lent.key_len==0||lent.val_len==0) { continue; }
  aaMemoryCopy(&list->entry[i],sizeof(_listentry),&lent);
  i++;
  }
 list->magic=aaHPP(aaListNew);
 aaFileStreamDestroy(fsu.handle);
 return RET_YES;
 }





 B aaListSave                          (_list*list,VP fmt,...)
 {
 va_list argptr;
 B ret;
 B str[_2K];
 B tok[_2K];
 H i;
 _filestreamunit fsu;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 aaFileDelete("%s",str);
 ret=aaFileStreamCreate(&fsu.handle,str,aa_FILECREATE_CREATENEW,3,3,0,0);
 if(ret!=RET_YES) { oops; }
 aaFileStreamStatus(fsu.handle,&fsu.status);
 aaFileStreamWritef(fsu.handle,"#aaList\r\n");
 aaFileStreamWritef(fsu.handle,"count=%u\r\n",list->count);
 aaFileStreamWritef(fsu.handle,"slots=%u\r\n",list->slots);
 aaFileStreamWritef(fsu.handle,"offset=%u\r\n",list->offset);
 aaFileStreamWritef(fsu.handle,"id_counter=%I64u\r\n",list->id_counter);
// aaFileStreamWritef(fsu.handle,"smallest_entry=%u\r\n",list->smallest_entry);
 //aaFileStreamWritef(fsu.handle,"largest_entry=%u\r\n",list->largest_entry);
 aaFileStreamWritef(fsu.handle,"remove_count=%u\r\n",list->remove_count);
 aaFileStreamWritef(fsu.handle,"user_index=%u\r\n",list->user_index);
 aaStringNull(tok);
 for(i=0;i<sizeof(list->user_data);i++)  {  aaStringAppendf(tok,"%02x",list->user_data[i]);  }
 aaFileStreamWritef(fsu.handle,"user_data=%s\r\n",tok);
 aaFileStreamWritef(fsu.handle,"mun=\r\n",tok);
 if(list->offset)
  {
  aaFileStreamWrite(fsu.handle,list->offset,list->mun.mem);
  }
 for(i=0;i<list->slots;i++)
  {
  aaFileStreamWrite(fsu.handle,sizeof(_listentry),&list->entry[i]);
  }


 aaFileStreamDestroy(fsu.handle);
 return RET_YES;
 }



#endif


 B aaListDelete                        (_list*list)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(list->entry!=NULL) { aaMemoryRelease(list->entry);  }
 if(list->mun.bytes)   { aaMemoryUnitRelease(&list->mun); }
 aaMemoryFill(list,sizeof(_list),0);
 return RET_YES;
 }






 B aaListAppend                        (_list*list,HP index,VP key,H bytes,VP val)
 {
 B ret;
 H hash,left,add;
 Q xi;
 H ksl,vsl,li;
 //H flag;
 B keybuf[_8K];
 //N dif;
 //BP skp,lkp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }

 aaStringNull(keybuf);
 if(key!=NULL)  { aaStringCopyfLen(keybuf,&ksl,"%s",key);                    }
 else           { aaStringCopyfLen(keybuf,&ksl,"id%I64u",list->id_counter);  }
 if(ksl==0)     { aaNote(0,"ksl=0, key=[%s]",key); return RET_BADPARM; }

 vsl=0;
 if(bytes!=0&&val==NULL) { return RET_BADPARM; }
 if(val!=NULL)
  {
  if(bytes==0) { aaStringLen(val,&bytes); }
  if(bytes==0) { oof; return RET_BADPARM; }
  vsl=bytes;
  }


 left=list->slots-list->count;
 if(left<5)
  {
  if(list->slots<100)   { add=20+list->slots+(list->slots*.3);   } else
  if(list->slots<1000)  { add=200+list->slots+(list->slots*.5);  } else
  if(list->slots<5000)  { add=2000+list->slots+(list->slots*.6); } else
                        { add=2000+list->slots+(list->slots*.8); }
  if((ret=aaMemoryReAllocate((VP)&list->entry,add*sizeof(_listentry)))!=YES) { oops; return ret; }
  list->slots=add;
  list->allocs++;
  }
 left=list->mun.bytes-list->offset;
 if(left<(ksl+vsl+_4K))
  {
  if(list->mun.bytes<_4K)   {  add=list->mun.bytes+(list->mun.bytes*.2)+ksl+vsl+_5K;   } else
  if(list->mun.bytes<_64K)  {  add=list->mun.bytes+(list->mun.bytes*.3)+ksl+vsl+_8K;   } else
  if(list->mun.bytes<_256K) {  add=list->mun.bytes+(list->mun.bytes*.4)+ksl+vsl+_32K;  } else
                            {  add=list->mun.bytes+(list->mun.bytes*.5)+ksl+vsl+_128K; }

  if((ret=aaMemoryUnitReAllocate(&list->mun,add))!=YES) { oops; return ret; }
  list->allocs++;
  }



 if(list->remove_count==0)
  {
  li=list->count;
  if(list->entry[li].key_len!=0) { oof; }
  }
 else
  {
  for(li=0;li<list->slots;li++)
   {
   if(list->entry[li].key_len==0) { break; }
   }
  if(li==list->slots) { oof; }
  }


 xi=list->id_counter;

 hash=0;
 aaStringHashGet(keybuf,ksl,&hash,NO);
 list->entry[li].id=xi;
 list->entry[li].key_len=ksl;
 list->entry[li].val_len=vsl;
 list->entry[li].hash=hash;


 if(list->entry[li].rsvd[1]>=(ksl+2))
  {
  aaStringNCopy(&list->mun.mem[list->entry[li].rsvd[0]],keybuf,ksl,YES);
  list->entry[li].key_off=list->entry[li].rsvd[0];
  }
 else
  {
  aaStringNCopy(&list->mun.mem[list->offset],keybuf,ksl,YES);
  list->entry[li].key_off=list->offset;
  list->offset+=(ksl+2);
  }

 if(list->entry[li].rsvd[3]>=(vsl+2))
  {
  aaMemoryCopy(&list->mun.mem[list->entry[li].rsvd[2]],vsl,val);
  list->entry[li].val_off=list->entry[li].rsvd[2];
  list->mun.mem[list->entry[li].val_off+vsl]=NULL_CHAR;
  }
 else
  {
  aaMemoryCopy(&list->mun.mem[list->offset],vsl,val);
  list->mun.mem[list->offset+vsl]=NULL_CHAR;
  list->entry[li].val_off=list->offset;
  list->offset+=(vsl+2);
  }

 list->entry[li].rsvd[0]=list->entry[li].rsvd[1]=list->entry[li].rsvd[2]=list->entry[li].rsvd[3]=0;

 if(index) { *index=li; }
 list->count++;
 list->id_counter++;
 return RET_YES;
 }





 B aaListAppendf                       (_list*list,HP index,VP key,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_32K];
 B kstr[_32K];
 H klen,vlen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 vlen=0;
 if(fmt)
  {
  aaFmt(fmt,argptr,str);
  aaStringLen(str,&vlen);
  }

 if(vlen==0) { aaStringCopyfLen(str,&vlen,"id%I64u",list->id_counter);   }

 klen=0;
 if(key)     { aaStringCopyfLen(kstr,&klen,"%s",key);  }
 if(klen==0) { aaStringCopyfLen(kstr,&klen,"id%I64u",list->id_counter);  }
 ret=aaListAppend(list,index,kstr,vlen,str);
 if(ret!=RET_YES)
  {
  aaDebugf("kstr=%s",kstr);
  aaDebugf("klen=%i",klen);
  aaDebugf("vlen=%i",vlen);
  aaDebugf("sstr=%s",str);
  }
 return ret;
 }






 B aaListFind                          (_list*list,H from,HP index,VP key,...)
 {
 va_list argptr;
 B str[_32K];
 H i,hash,ksl,checked;//,flag;
 //BP skp,lkp;
 //N dif;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 aaMissingParm(key);
 aaFmt(key,argptr,str);
 aaStringLen(str,&ksl);
 if(ksl==0)         { return RET_NOTFOUND; }
 if(list->count==0) { return RET_NOTFOUND; }
 if(from>=list->slots) { return RET_NOTFOUND; }

 hash=0;
 aaStringHashGet(str,ksl,&hash,NO);
 //aaDebugf("checking my hash %x against all ",hash);
 checked=0;
 for(i=from;i<list->slots;i++)
  {
  if(checked>=list->count) { break; }
  if(list->entry[i].key_len==0) { continue; }
  checked++;
  //aaDebugf("i=%i hash=%x me=%x",i,list->entry[i].hash,hash);
  if(list->entry[i].hash!=hash) { continue; }
  if(index) { *index=i; }
  return RET_YES;
  }

 return RET_NOTFOUND;
 }










 B aaListRemove                        (_list*list,H index)
 {
 //BP kp,skp,lkp;
 //N dif;
 //H i,s,j;
 //H i,flag,checked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(index>=list->slots) { return RET_NOTFOUND; }
 if(list->entry[index].key_len==0) { return RET_NOTFOUND; }
 if(list->count==0) { return RET_NOTFOUND; }

 list->entry[index].rsvd[0]=list->entry[index].key_off;
 list->entry[index].rsvd[1]=list->entry[index].key_len+2;
 list->entry[index].rsvd[2]=list->entry[index].val_off;
 list->entry[index].rsvd[3]=list->entry[index].val_len+2;
 aaMemoryFill(&list->mun.mem[list->entry[index].key_off],list->entry[index].key_len,0);
 list->entry[index].key_len=0;
 list->entry[index].val_len=0;
 list->remove_count++;
 list->count--;
 //if(flag==0) { return RET_YES; }

 return RET_YES;
 }







 B aaListPointerGet                    (_list*list,H index,PP key,PP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(index>=list->slots) { return RET_NOTFOUND; }
 if(list->entry[index].key_len==0) { return RET_NOTFOUND; }
 if(key) { *key=&list->mun.mem[list->entry[index].key_off]; }
 if(val) { *val=&list->mun.mem[list->entry[index].val_off]; }
 return RET_YES;
 }






 B aaListPointerGetByNumber            (_list*list,HP index,H numbr,PP key,PP val)
 {
 H i,c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(numbr>=list->count) { return RET_NOTFOUND; }
 for(c=i=0;i<list->slots;i++)
  {
  if(list->entry[i].key_len==0) { continue; }
  if(c==numbr)
   {
   if(key) { *key=&list->mun.mem[list->entry[i].key_off]; }
   if(val) { *val=&list->mun.mem[list->entry[i].val_off]; }
   if(index) { *index=i; }
   return RET_YES;
   }
  c++;
  }
 return RET_FAILED;
 }


#if 0


 B aaListUpdate                        (_list*list,H index)
 {
 //B ret;
 BP skp,lkp;
 BP keybuf;
 N dif;
 H ksl,flag,hash;
 Q xi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 if(index>=list->slots) { return RET_NOTFOUND; }
 if(list->entry[index].key_len==0) { return RET_NOTFOUND; }

 keybuf=&list->mun.mem[list->entry[index].key_off];
 aaStringLen(keybuf,&ksl);
 if(ksl==0) { oof; }
 if(ksl>list->entry[index].key_len) { oof; }
 xi=list->entry[index].id;
 list->entry[index].key_len=ksl;

 flag=0;
 while(1)
  {
  if(list->count==0) { flag=3;  break; }
  skp=&list->mun.mem[list->entry[list->smallest_entry].key_off];
  lkp=&list->mun.mem[list->entry[list->largest_entry].key_off];

  aaStringICompare(keybuf,skp,&dif);
  if(dif<0) { flag=aaBitSet(flag,0); }

  aaStringICompare(keybuf,lkp,&dif);
  if(dif>0) { flag=aaBitSet(flag,1); }
  break;
  }

 ///xi=list->entreyid_counter;
 if(aaBitGet(flag,0)) { list->smallest_entry=xi;   }
 if(aaBitGet(flag,1)) { list->largest_entry=xi;    }

 hash=0;
 aaStringHashGet(keybuf,ksl,&hash,NO);
 list->entry[index].hash=hash;

 return RET_YES;
 }


#endif



 B aaListReset                         (_list*list)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(list);
 if(list->magic!=aaHPP(aaListNew)) { return RET_NOTINITIALIZED; }
 list->count=0;
// list->lo_slot=0;
 //list->hi_slot=0;
 list->offset=0;
 list->id_counter=0;
// list->unique_count=0;
// list->smallest_entry=0;
 //list->largest_entry=0;
  list->remove_count=0;


 aaMemoryFill(list->user_data,sizeof(list->user_data),0);
 list->user_index=0;
 aaMemoryFill(list->entry,list->slots*sizeof(_listentry),0);
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/






 B aaOptionsNew                        (_options*options)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(options);
 aaMemoryFill(options,sizeof(_options),0);
 aaMagicSet(options,aaOptionsNew);
 aaListNew(&options->list);
 return RET_YES;
 }





 B aaOptionsDelete                     (_options*options)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMagicCheck(options,aaOptionsNew);
 if(options->list.magic==aaHPP(aaListNew)) { aaListDelete(&options->list); }
 aaMemoryFill(options,sizeof(_options),0);
 return RET_YES;
 }








 B aaOptionsSet                        (_options*options,VP data,...)
 {
 B ret;
 B str[_4K];
 B txt[2][_2K];
 H bytes,cha,index;
 _parser pa;
 va_list argptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMagicCheck(options,aaOptionsNew);
 aaFmt(data,argptr,str);

 aaStringLen(str,&bytes);
 aaParserInit(&pa,str,bytes);
 if(aaParserSeekToVisibleChar(&pa,YES)!=YES) oof;
 aaParserStackPush(&pa);
 aaParserSeekToCharList(&pa,"= ",YES);
 if(pa.ch=='=')
  {
  aaParserStackString(&pa,&cha,sizeof(txt[0]),txt[0],YES);
  aaParserSeek(&pa,1);
  }
 else
 if(pa.ch==' ')
  {
  aaParserStackString(&pa,&cha,sizeof(txt[0]),txt[0],YES);
  aaParserSeekToChar(&pa,'=',YES,YES);
  aaParserSeek(&pa,1);
  }
 aaParserSeekToVisibleChar(&pa,YES);
 aaStringCopy(txt[1],pa.bp);
 aaStringRemoveSpaces(txt[1],0,YES,YES);
 ret=aaListFind(&options->list,0,&index,"%s",txt[0]);
 if(ret==RET_NOTFOUND)
  {
  if((ret=aaListAppendf(&options->list,&index,txt[0],"%s",txt[1]))!=YES) { oops; }
  return RET_YES;
  }
 if(ret!=RET_YES) { oops; }
 if((ret=aaListRemove(&options->list,index))!=YES) { oops; }
 if((ret=aaListAppendf(&options->list,&index,txt[0],"%s",txt[1]))!=YES) { oops; }
 return RET_YES;
 }




VP aaOptionsGet                        (_options*options,DP num,VP data,...)
 {
 B ret;
 B str[_4K];
 H bytes,index;
 //H count;
 //G gv;
 D dub;
 BP vp,kp;
 va_list argptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(options==NULL) { return NULL; }
 if(aaMagicIsNot(options,aaOptionsNew)) { return NULL; }
 aaFmt(data,argptr,str);
 aaStringLen(str,&bytes);
 aaStringRemoveSpaces(str,bytes,YES,YES);
 aaStringLen(str,&bytes);
 if(aaListFind(&options->list,0,&index,"%s",str)!=YES) {  return NULL; }
 if((ret=aaListPointerGet(&options->list,index,(VP)&kp,(VP)&vp))!=RET_YES) { oops; return NULL; }




 if(aaStringIsNumerical(vp,YES,YES,options->list.entry[index].val_len)==YES)
  {
  aaStringToDouble(vp,options->list.entry[index].val_len,&dub);
  if(num) { *num=dub; }
  aaMemoryCopy(options->buf,options->list.entry[index].val_len,vp);
  options->buf[options->list.entry[index].val_len]=0;
  }
 else
  {
  if(num) { *num=666.666; }
  aaMemoryCopy(options->buf,options->list.entry[index].val_len,vp);
  options->buf[options->list.entry[index].val_len]=0;
  }
 return options->buf;
 }





/*-----------------------------------------------------------------------*/


 B aaDataAllocate                      (_data*data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 aaMemoryFill(data,sizeof(_data),0);
 data->field_slots=1;
 if((ret=aaMemoryMake((VP)&data->field_array,data->field_slots*sizeof(HP)))!=YES)
  {
  aaMemoryFill(data,sizeof(_data),0);
  return ret;
  }
 if((ret=aa_MemoryProtect(data->field_array,YES))!=YES) { oops; }
 data->magic=aa_DATA_MAGIC;
 return RET_YES;
 }






 B aaDataRelease                       (_data*data)
 {
 B ret;
 BP ff;
 H i,by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(data->field_slots!=0)
  {
  for(i=0;i<data->field_slots;i++)
   {
   if(data->field_array[i]!=0)
    {
    aaCast(ff,VP,data->field_array[i]);
    if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
    if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
    aaMemoryRelease(ff);
    data->total_bytes-=(by-8);
    data->field_array[i]=0;
    data->field_count--;
    }
   }
  if(data->field_count!=0) { oof; }
  if((ret=aa_MemoryProtect(data->field_array,NO))!=YES) { oops; }
  if((ret=aaMemoryRelease(data->field_array))!=YES) { oops; }
  }
 aaMemoryFill(data,sizeof(_data),0);
 return RET_YES;
 }





 B aaDataReset                         (_data*data)
 {
 B ret;
 BP ff;
 H i,by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(data->field_slots!=0)
  {
  for(i=0;i<data->field_slots;i++)
   {
   if(data->field_array[i]!=0)
    {
    aaCast(ff,VP,data->field_array[i]);
    if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
    if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
    aaMemoryRelease(ff);
    data->total_bytes-=(by-8);
    data->field_array[i]=0;
    data->field_count--;
    }
   }
  if(data->field_count!=0) { oof; }
  aaMemoryFill(data->field_array,data->field_slots*sizeof(H),0);
  }
 return RET_YES;
 }




 B aaDataFieldAdd                      (_data*data,HP index,H bytes,H alias,PP mem)
 {
 B ret;
 H left,i,add;
 BP ff;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=F32; }
 if(bytes==0) { return RET_BADPARM; }
 if(mem!=NULL) { *mem=NULL; }
 left=data->field_slots-data->field_count;
 if(left==0)
  {
  add=6+(data->field_slots/16);
  if((ret=aa_MemoryProtect(data->field_array,NO))!=YES) { oops; }
  if((ret=aaMemoryMake((VP)&data->field_array,(data->field_slots+add)*sizeof(HP)))!=YES) { oops; }
  if((ret=aa_MemoryProtect(data->field_array,YES))!=YES) { oops; }
  data->field_slots+=add;
  }
 for(i=0;i<data->field_slots;i++)
  {
  if(data->field_array[i]==0) { break; }
  }
 if(i==data->field_slots) { oof; }
 aaCast(ff,VP,data->field_array[i]);
 if((ret=aaMemoryMake((VP)&ff,bytes+8))!=YES) { oops; }
 if((ret=aa_MemoryProtect(ff,YES))!=YES) { oops; }
 *(HP)&ff[0]=alias;
 *(HP)&ff[4]=bytes;
// BUG,"total_bytes=(%i) + %i = %i",data->total_bytes,bytes,data->total_bytes+bytes);
 data->total_bytes+=(bytes);
 #ifdef WAGO
 data->field_array[i]=(H)ff;
 #else
 (VP)data->field_array[i]=ff;
 #endif
 if(index) { *index=i; }
 if(mem)   { *mem=&ff[8]; }
 data->field_count++;
 return RET_YES;
 }







 B aaDataFieldRemove                   (_data*data,H index)
 {
 B ret;
 BP ff;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_YES; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
 if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
// BUG,"total_bytes=(%i) - %i-4 = %i",data->total_bytes,by,data->total_bytes-(by-4));
 data->total_bytes-=(by-8);
 if((ret=aaMemoryRelease((VP)ff))!=YES) { oops; }
 data->field_array[index]=0;
 data->field_count--;
// BUG,"fc=%i",data->field_count);
 return RET_YES;
 }




 B aaDataFieldWrite                    (_data*data,HP index,H bytes,H alias,VP mem)
 {
 BP ptr;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=F32; }
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0)  {  aaStringLen(mem,&bytes);  }
 if(bytes==0) { return RET_BADPARM; }
 ret=aaDataFieldAdd(data,index,bytes,alias,(VP)&ptr);
 if(ret!=YES) { return ret; }
 aaMemoryCopy(ptr,bytes,mem);
 ptr[bytes]=0;
 return RET_YES;
 }





 B aaDataFieldWritef                   (_data*data,HP index,H alias,VP fmt,...)
 {
 va_list argptr;
 B str[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 return(aaDataFieldWrite(data,index,0,alias,str));
 }



 B aaDataFieldRead                     (_data*data,H index,HP bytes,HP alias,H maxbytes,VP mem)
 {
 B ret;
 BP ff;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes) { *bytes=0; }
 if(alias) { *alias=0; }
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_BADHANDLE; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
 if(bytes)
  {
  *bytes=by-8;
  }
 if(alias) { *alias=*(HP)&ff[0]; }
 if((by-8)>maxbytes) { return RET_BOUNDS; }
 if(mem) { aaMemoryCopy(mem,by-8,&ff[8]); }
 return RET_YES;
 }





 B aaDataFieldSizeSet                  (_data*data,H index,H bytes,PP mem)
 {
 B ret;
 BP ff;
 H by,al;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_BADHANDLE; }
 if(mem!=NULL) { *mem=NULL; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
 if(bytes==0)
  {
  if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
  if((ret=aaMemoryRelease((VP)ff))!=YES) { oops; }
  data->total_bytes-=(by-8);
  data->field_array[index]=0;
  if(mem) { *mem=0; }
  data->field_count--;
  return RET_YES;
  }
 al=*(HP)&ff[0];
 data->total_bytes-=(by-8);
 if((ret=aa_MemoryProtect(ff,NO))!=YES) { oops; }
 if((ret=aaMemoryMake((VP)&ff,bytes+8))!=YES) { oops; }
 if((ret=aa_MemoryProtect(ff,YES))!=YES) { oops; }
 data->total_bytes+=(bytes);
 #ifdef WAGO
 data->field_array[index]=(H)ff;
 #else
 (VP)data->field_array[index]=ff;
 #endif
 *(HP)&ff[0]=al;
 *(HP)&ff[4]=(by-4);
 if(mem) { *mem=&ff[8]; }
 return RET_YES;
 }



 B aaDataFieldInfoGetByNumber          (_data*data,H numbr,HP bytes,HP index,HP alias,PP mem)
 {
 B ret;
 BP ff;
 H by,i,n;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=0; }
 if(alias) { *alias=0; }
 if(bytes) { *bytes=0; }
 if(mem!=NULL) { *mem=NULL; }
 if(numbr>=data->field_slots) { return RET_BADHANDLE; }
 if(numbr>=data->field_count) { return RET_BADHANDLE; }
 n=0;
 for(i=0;i<data->field_slots;i++)
  {
  if(data->field_array[i]==0) { continue; }
  if(numbr!=n) { n++; continue; }
  aaCast(ff,VP,data->field_array[i]);
  if(ff==NULL) { oof; }
  if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
  if(bytes) { *bytes=by-8;}
  if(index) { *index=i;  }
  if(alias) { *alias=*(HP)&ff[0]; }
  if(mem) { *mem=&ff[8]; }
  return RET_YES;
  }
 return RET_FAILED;
 }





 B aaDataFieldInfoGetByAlias           (_data*data,H alias,HP bytes,HP index,PP mem)
 {
 B ret;
 BP ff;
 H i,by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(index) { *index=F32; }
 if(bytes) { *bytes=0; }
 if(mem!=NULL) { *mem=NULL; }
 for(i=0;i<data->field_slots;i++)
  {
  if(data->field_array[i]==0) { continue;  }
  aaCast(ff,VP,data->field_array[i]);
  if(ff==NULL) { continue; }
  if(*(HP)&ff[0]!=alias) { continue; }
  if(bytes)
   {
   if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
   *bytes=by-4;
   }
  if(index) { *index=i; }
  if(mem) { *mem=&ff[8]; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }





 B aaDataFieldInfoGetByIndex           (_data*data,H index,HP bytes,HP alias,PP mem)
 {
 B ret;
 BP ff;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if(data->magic!=aa_DATA_MAGIC) { return RET_NOTSTARTED; }
 if(alias) { *alias=0; }
 if(bytes) { *bytes=0; }
 if(mem!=NULL) { *mem=NULL; }
 if(index>=data->field_slots) { return RET_BADHANDLE; }
 if(data->field_array[index]==0) { return RET_BADHANDLE; }
 aaCast(ff,VP,data->field_array[index]);
 if(ff==NULL) { oof; }
 if(bytes)
  {
  if((ret=aaMemoryBytesGet(ff,&by))!=YES) { oops; }
  *bytes=by-8;
  }
 if(alias) { *alias=*(HP)&ff[0]; }
 if(mem) { *mem=&ff[8]; }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_PageSystemStart                  (V)
 {
 B ret;
// H han;

 logg("aa_PageSystemStart()");
 logg("{");
 aa.page_system.bytes_per_page=aa_PAGE_BYTES;
 aa.page_system.books_per_system=aa_PAGE_MAX_BOOKS;
 aa.page_system.pages_per_system=aa_PAGE_MAX_BOOKS*aa_PAGE_PER_BOOK;
 aa.page_system.bytes_per_book=aa.page_system.bytes_per_page*aa_PAGE_PER_BOOK;
 aa.page_system.bytes_accessable=aa.page_system.bytes_per_book*aa.page_system.books_per_system;
 logg("aa_PageSystemStart calling aa_MemoryAlloc()");
 if((ret=aa_MemoryAllocate((VP)&aa.page_system.book,aa.page_system.books_per_system*sizeof(_aa_pagebook),"AllBooks",NO))!=RET_YES) {  return ret;  }
 aa_MemoryProtect(aa.page_system.book,YES);
 logg("bytes per page = %i",aa.page_system.bytes_per_page);
 logg("pages per book = %i",aa_PAGE_PER_BOOK);
 logg("bytes per book = %i",aa.page_system.bytes_per_book);
 logg("books per system = %i",aa.page_system.books_per_system);
 logg("pages per system= %i",aa.page_system.pages_per_system);
 logg("bytes accessable = %i",aa.page_system.bytes_accessable);
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 InitializeCriticalSection(&aa.page_system.mutex);
 #endif
//coffin aa_PageAllocate(&han,NULL,"basebook");
//coffin aa_PageRelease(han);
 logg("}");
 logg("");
 return RET_YES;
 }






 V aa_PageSystemStop                   (V)
 {
 N b,p;

 logg("aa_PageSystemStop()");
 if(aa.page_system.book!=NULL)
  {
  logg("Pages commited: %i",aa.page_system.pages_commited);
  logg("Pages allocated: %i",aa.page_system.pages_allocated);
  if(aa.page_system.pages_allocated!=0)
   {
   for(b=(aa_PAGE_MAX_BOOKS-1);b>=0;b--)
    {
    if(aa.page_system.book[b].mem!=NULL)
     {
     for(p=0;p<aa_PAGE_PER_BOOK;p++)
      {
      if(aa.page_system.book[b].in_use[p]!=NO)
       {
       logg("book[%i].page[%i] was in use at aa_PageSystemStop()",b,p);
       }
      }
     }
    }
   }
  for(b=(aa_PAGE_MAX_BOOKS-1);b>=0;b--)
   {
   if(aa.page_system.book[b].mem!=NULL)
    {
    if(aa_MemoryRelease(aa.page_system.book[b].mem)!=RET_YES) { oof; Boop; }
    aa.page_system.pages_commited-=aa_PAGE_PER_BOOK;
    aa.page_system.pages_allocated-=aa.page_system.book[b].usage;
    logg("Book[%i] released (%i pages de-commited) ( and with it %i pages deallocated)",b,aa_PAGE_PER_BOOK,aa.page_system.book[b].usage);
    aaMemoryFill(&aa.page_system.book[b],sizeof(_aa_pagebook),0);
    }
   }
  aa_MemoryProtect(aa.page_system.book,NO);
  aa_MemoryRelease(aa.page_system.book);
  aa.page_system.book=NULL;
  }
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 DeleteCriticalSection(&aa.page_system.mutex);
 #endif
 logg("");
 }






 B aa_PageAllocate                     (HP handle,PP mem,VP name)
 {
 H b,p;
 H fb;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL)  { return RET_BADPARM; }
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 logg("aa_PageAllocate(%s) currently ( %i commited, %i allocated )",name,aa.page_system.pages_commited,aa.page_system.pages_allocated);
 fb=F32;
 for(b=0;b<aa_PAGE_MAX_BOOKS;b++)
  {
  if(aa.page_system.book[b].mem==NULL&&fb==F32) { fb=b; }
  if(aa.page_system.book[b].mem!=NULL&&aa.page_system.book[b].usage<aa_PAGE_PER_BOOK)
   {
   for(p=0;p<aa_PAGE_PER_BOOK;p++)
    {
    if(aa.page_system.book[b].in_use[p]==NO) { break; }
    }
   if(p==aa_PAGE_PER_BOOK) { oof;  Boop; Boop; }
   if(name) { aaStringNCopy(aa.page_system.book[b].name[p],name,10,YES); }
   aa.page_system.book[b].in_use[p]=YES;
   aa.page_system.book[b].usage++;
   aaMemoryFill(&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page],aa.page_system.bytes_per_page,0); // is this needed ?? ashod
   if(mem) { *mem=&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page]; }
   *handle=aa_PAGE_BASE_HANDLE+(b*aa_PAGE_PER_BOOK)+p;
   aa.page_system.pages_allocated++;
   if(aa.page_system.pages_allocated>aa.memory_system.status.peak_pages_allocated)
    {
    aa.memory_system.status.peak_pages_allocated=aa.page_system.pages_allocated;
    }
   //logg(" page_system.book[%i].mem[%i*bytesperpage]",b,p);
   #if USE_PAGE_CRITICAL_SECTION==1
   LeaveCriticalSection(&aa.page_system.mutex);
   #endif
   return RET_YES;
   }
  }
 if(fb==F32) { aaNote(0,"bubble head %s",name); }
 b=fb; p=0;
// BUG,"^about to alloc bookmemory for(%s)",name);
 if(aa_MemoryAllocate((VP)&aa.page_system.book[b].mem,aa.page_system.bytes_per_page*aa_PAGE_PER_BOOK,"bookmem",NO)!=YES) { oof; }
 logg(" (%s) [%i][%i] is YES",name,b,p);
 aa.page_system.book[b].in_use[p]=YES;
 aaMemoryFill(&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page],aa.page_system.bytes_per_page,0);
 if(mem) { *mem=&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page]; }
 *handle=aa_PAGE_BASE_HANDLE+(b*aa_PAGE_PER_BOOK)+p;
 aa.page_system.book[b].usage=1;
 if(name) { aaStringNCopy(aa.page_system.book[b].name[p],name,10,YES); }
 aa.page_system.pages_allocated++;
 if(aa.page_system.pages_allocated>aa.memory_system.status.peak_pages_allocated)
  {
  aa.memory_system.status.peak_pages_allocated=aa.page_system.pages_allocated;
  }
 aa.page_system.pages_commited+=aa_PAGE_PER_BOOK;
 if(aa.page_system.pages_commited>aa.memory_system.status.peak_pages_commited)
  {
  aa.memory_system.status.peak_pages_commited=aa.page_system.pages_commited;
  }
 logg("aa_PageAllocate(%s) now: alloc=%i commit=%i",aa.page_system.book[b].name[p],aa.page_system.pages_allocated,aa.page_system.pages_commited);
 logg("book[%i] created",b);
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }





 B aa_PageRelease                      (H handle)
 {
 B ret,isp;
 H b,p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isp,NULL))!=RET_YES) { return ret; }
 if(isp==YES)
  {
  logg("cannot released protected page");
  oof;
  return RET_FORBIDDEN;
  }
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 handle-=aa_PAGE_BASE_HANDLE;
 b=handle/aa_PAGE_PER_BOOK;
 p=handle%aa_PAGE_PER_BOOK;
 aa.page_system.book[b].in_use[p]=NO;
 aa.page_system.pages_allocated--;
 aa.page_system.book[b].usage--;
 aa.page_system.book[b].name[p][0]=NULL_CHAR;
 if(aa.page_system.book[b].usage==0&&aa.page_system.pages_allocated!=0)
  {
 // log(book[%i] hit zero usage, so releasing",b);
 // aa_MemoryRelease(aa.page_system.book[b].mem);
 // aa.page_system.book[b].mem=NULL;
 // aa.page_system.pages_commited-=aa_PAGE_PER_BOOK;
  }
// logg("aa_PageRelease() page_system.book[%i].[%i]",b,p);
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }





 B aa_PageProtect                      (H handle,B state)
 {
 B ret,isp;
 H b,p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_PageStatus(handle,NULL,&isp,NULL))!=RET_YES) { return ret; }
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 handle-=aa_PAGE_BASE_HANDLE;
 b=handle/aa_PAGE_PER_BOOK;
 p=handle%aa_PAGE_PER_BOOK;
 if(state==YES) { aa.page_system.book[b].protection[p]=YES; }
 else             { aa.page_system.book[b].protection[p]=NO; }
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }







 B aa_PageStatus                       (H handle,PP mem,BP isprotected,BP isuser)
 {
 H b,p;
 B ret;
 N dif;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(isuser) { *isuser=NO; }
 if(isprotected) { *isprotected=NO; }
 if(mem) { *mem=NULL; }
 if(handle<aa_PAGE_BASE_HANDLE) {  return RET_BADHANDLE; }
 handle-=aa_PAGE_BASE_HANDLE;
 b=handle/aa_PAGE_PER_BOOK;
 if(b>=aa_PAGE_MAX_BOOKS)  {   return RET_BADHANDLE; }
 p=handle%aa_PAGE_PER_BOOK;
 if(aa.page_system.book[b].mem==NULL) {   return RET_BADHANDLE; }
 if(aa.page_system.book[b].in_use[p]==NO) {  return RET_BADHANDLE; }
 if(aa.page_system.book[b].usage==0)
  {
  logg("what the hell");
  return RET_FAILED;
  }
 if(isuser)
  {
  ret=aaStringCompare(aa.page_system.book[b].name[p],"userpage",&dif);
  if(ret==RET_YES&&dif==0) { *isuser=YES; }
  }
 if(mem) { *mem=&aa.page_system.book[b].mem[p*aa.page_system.bytes_per_page]; }
 if(isprotected) { *isprotected=aa.page_system.book[b].protection[p]; }
 return RET_YES;
 }









 B aa_PageArrayIo                      (HP harray,H hcount,H offset,H bytes,VP data,B writemode)
 {
 B ret;
 H last_offset;
 BP ptr;
 register BP bp;
 H p,o,todo,go;
 H icnt,istr,ioff,iby,ihan,ih;
 H stride;
 B txt[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(harray==NULL) { return RET_BADPARM; }
 if(hcount==0)  {   return RET_BADPARM; }
 stride=aa.page_system.bytes_per_page;
 if(stride!=aa.page_system.bytes_per_page) { aaNote(0,"stride=%i bytes_per_page=%i",stride,aa.page_system.bytes_per_page); }
 if(stride>aa.page_system.bytes_per_page) { return RET_FAILED; }
 last_offset=(hcount*stride);
 if(offset>=last_offset)
  {
  logg("hc=%i st=%i lo=%i off=%i ",hcount,stride,last_offset,offset);
  aaNote(0,"hc=%i st=%i lo=%i off=%i ",hcount,stride,last_offset,offset);
  return RET_BOUNDS;
  }
 if(bytes>(last_offset-offset)) {  return RET_BOUNDS; }
 if(bytes==0) {  return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
  // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 ihan=harray[offset/stride];
 icnt=hcount;
 istr=stride;
 ioff=offset;
 iby=bytes;
 aaCast(bp,BP,data);
 go=0;
 ih=harray[0];
 while(1)
  {
  p=offset/stride; // p==0 ?, when i pass harray is index 0 ?? ie is my harray passed corresponding to H offset/stride ??
  o=offset%stride;
  if((ret=aa_PageStatus(harray[p],(VP)&ptr,NULL,NULL))!=YES)
   {
   aa_craperr++;
   aaStringCopyf(txt,"Please report this as a screenshot to apakian@gmail.com\r\n%s handle=%i p=%i o=%i write=%i (cnt=%i str=%i off=%i by=%i) first han=%i go=%i ih=%i",ret_string[ret],harray[p],p,o,writemode,icnt,istr,ioff,iby,ihan,go,ih);
   aaStringAppendf(txt,"\n   ....  %s handle=%i p=%i o=%i write=%i (cnt=%i str=%i off=%i by=%i) first han=%i go=%i",ret_string[ret],harray[p],p,o,writemode,icnt,istr,ioff,iby,ihan,go);
   aaStringAppendf(txt,"\n . .. .LINE=%i %s handle=%i p=%i write=%i (cnt=%i str=%i off=%i by=%i)",__LINE__,ret_string[ret],harray[p],p,writemode,icnt,istr,ioff,iby);
//   BUG,"%s",txt);
   aaHistory(-1,"%s",txt);
   //prevent_warning(icnt);
   ///prevent_warning(istr);
   //prevent_warning(ioff);
   //prevent_warning(iby);
   break;
   }
  todo=bytes;
  if(todo>=(stride-o)) { todo=(stride-o); } // was>not >=
  if((todo==bytes)&&bytes==1) // quick goey ,, dont call memorycopy if single byte IO
   {
   if(writemode==YES) {  ptr[o]=bp[0]; }
   else               {  bp[0]=ptr[o]; }
   break;
   }
  if(writemode==YES) {  aaMemoryCopy(&ptr[o],todo,bp); }
  else               {  aaMemoryCopy(bp,todo,&ptr[o]); }
  offset+=todo;
  bytes-=todo;
  if(bytes==0) { break; }
  bp+=todo;
  go++;
  }
   // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }







 B aa_PageArrayFill                    (HP harray,H hcount,H offset,H bytes,B val)
 {
 H last_offset;
 BP ptr;
 H p,o,todo;
 H stride=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(harray==NULL) { return RET_BADPARM; }
 if(hcount==0)  { return RET_BADPARM; }
 if(stride==0) { stride=aa.page_system.bytes_per_page; }
 if(stride>aa.page_system.bytes_per_page) { return RET_FAILED; }
 last_offset=(hcount*stride);
 if(offset>=last_offset) { return RET_BOUNDS; }
 if(bytes>(last_offset-offset)) { return RET_BOUNDS; }
 if(bytes==0) { return RET_YES; }
  // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 EnterCriticalSection(&aa.page_system.mutex);
 #endif
 while(1)
  {
  p=offset/stride;
  o=offset%stride;
  if(aa_PageStatus(harray[p],(VP)&ptr,NULL,NULL)!=RET_YES) { oof; Boop; }
  todo=bytes;
  if(todo>(stride-o)) todo=(stride-o);
  aaMemoryFill(&ptr[o],todo,val);
  offset+=todo;
  bytes-=todo;
  if(bytes==0) { break; }
  }
 // monkey dolphin
 #if USE_PAGE_CRITICAL_SECTION==1
 LeaveCriticalSection(&aa.page_system.mutex);
 #endif
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_ObjectSystemStart                (V)
 {
 logg("aa_ObjectSystemStart()");
 aa.object_system.id_head=1;
 aa.object_system.sesh_counter=aa.core_system.launch_tik;
 logg("");
 return RET_YES;
 }





 V aa_ObjectSystemStop                 (V)
 {
 N i;

 logg("aa_ObjectSystemStop()");
 for(i=127;i>-1;i--)
  {
  aa_ObjectUndefine((B)i);
  }
 logg("");
 }






 B aa_ObjectDefine                     (B id,H bytes,H limit,H initial,B(*Destructor)(H),VP name)
 {
 B txt[129];
 B ret;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(txt);
 if(name)
  {
  if((ret=aaStringLen(name,&sl))!=RET_YES) { return ret; }
  if(sl>13) { sl=13; }
  aaStringNCopy(txt,name,sl,YES);
  }
 if(txt[0]==NULL_CHAR) { aaStringCopyf(txt,"obj#%i",id); }
 if(bytes==0)  { return RET_BADPARM; }
 if(id==0)     { return RET_FORBIDDEN; }
 if(aa.object_system.object[id].instance_limit!=0) { return RET_EXISTS; }
 if(limit==0) { return RET_BOUNDS; }
 if(limit>aa_OBJ_MAX_PER_ID) { return RET_BOUNDS; }
 aaMemoryFill(&aa.object_system.object[id],sizeof(_aa_object),0);
 aa.object_system.object[id].instance_limit=limit;
 aa.object_system.object[id].instance_bytes=bytes;
 aa.object_system.object[id].instance_initial=initial;
 if(Destructor) { aa.object_system.object[id].Destructor=Destructor;  }
 aaStringCopy(aa.object_system.object[id].name,txt);
 //aaLog(-777,"aa_ObjectDefine(%i,%i,%i,%p) %s",id,bytes,limit,Destructor,aa.object_system.object[id].name);
 return RET_YES;
 }





 B aa_ObjectUndefine                   (B id)
 {
 H h,base;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.object_system.object[id].instance_limit==0) { return RET_NOTFOUND; }
 base=id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;

 if(aa.object_system.object[id].instance_slots!=0&&aa.object_system.object[id].instance_count!=0)
  {
 // if(id==aa.font_system.object_id&&aa.object_system.object[id].instance_count<=2) {}
  //else // 2 fonts are created by system, so dont include them in this check
   {
//   aaLog(-777,"aa_objectUndefine(%i) instance_slots=%i instance_count=%i (%s)",id,aa.object_system.object[id].instance_slots,aa.object_system.object[id].instance_count,aa.object_system.object[id].name);
   }
  aaLog(-777,"aa_objectUndefine(%-3i) instance_slots=%-5i instance_count=%-5i (%s)",id,aa.object_system.object[id].instance_slots,aa.object_system.object[id].instance_count,aa.object_system.object[id].name);
  }

 if(id==aa.surface_system.object_id) // destroy surfaces in reverse order, to prevent windows non-windestroy problem
  {
  for(h=(aa.object_system.object[id].instance_slots-1);h!=F32;h--)
   {
   if(aa.object_system.object[id].instance_count==0) { break; }
   if(aa_ObjectCheck((B)id,base+h,NULL,&isprot)==RET_YES)
    {
    if(isprot) { aa_ObjectProtect(id,base+h,NO); }
    if(aa.object_system.object[id].Destructor) { aa.object_system.object[id].Destructor(base+h);   }
    else                                       { aa_ObjectDestroy((B)id,base+h);   }
    }
   }
  }
 else
  {
  for(h=0;h<aa.object_system.object[id].instance_slots;h++)
   {
   if(aa.object_system.object[id].instance_count==0) { break; }
   if(aa_ObjectCheck((B)id,base+h,NULL,&isprot)==RET_YES)
    {
    if(isprot) { aa_ObjectProtect(id,base+h,NO); }
    if(aa.object_system.object[id].Destructor)   { aa.object_system.object[id].Destructor(base+h);  }
    else                                         { aa_ObjectDestroy((B)id,base+h);   }
    }
   }
  }
 if(aa.object_system.object[id].instance_count!=0) { return RET_FAILED;  }
 // code was in objectdestroy before
 if(aa.object_system.object[id].instance_slots!=0)
  {
  if(aa_MemoryRelease(aa.object_system.object[id].instance_mem)!=RET_YES)
   {
   logg("** aa_ObjectUndefine(%i) failed to release memory",id);
   oof;
   Boop;
   }
  aa.object_system.object[id].instance_slots=0;
  aa.object_system.object[id].instance_mem=NULL;
  }
 return RET_YES;
 }






 B aa_ObjectCreate                     (B id,HP handle,PP mem)
 {
 B ret;
 H available_slots;
 H slots_to_add;
 H bytes;
 BP bp;
 _aa_objectinstanceheader*oih;
 H instance_stride;
 H base,h;
 B txt[129];

 #if aa_USE_GLOBAL_MUTEX==1
 EnterCriticalSection(&global_mutex);
 #endif
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { oof; return RET_BADPARM; }
 *handle=0;
 if(mem) { *mem=NULL; }
 if(aa.object_system.object[id].instance_limit==0) { aaNote(0,"%s id=%i",__func__,id); aaNote(0,"and=%i",aa.object_system.object[id].instance_count);     return RET_NOTFOUND; }
 //aaLog(-777,"aa_ObjectCreate(id=%i);",id);
 if(aa.object_system.object[id].instance_count>=aa.object_system.object[id].instance_limit)
  {
  aaNote(0,"id=%i instance_count=%i instance_limit=%i",id,aa.object_system.object[id].instance_count,aa.object_system.object[id].instance_limit);
  #if aa_USE_GLOBAL_MUTEX==1
  LeaveCriticalSection(&global_mutex);
  #endif
  return RET_NOMEMORY;
  }
// logg("aa_ObjectCreate(%i,%s)",id,aa.object_system.object[id].name);
 available_slots=aa.object_system.object[id].instance_slots-aa.object_system.object[id].instance_count;
// aaLog(-1,"aa_ObjectCreate(%i,%s) availslots=%i ",id,aa.object_system.object[id].name,available_slots);
 if(available_slots<2)
  {
  if(available_slots==0&&aa.object_system.object[id].instance_count==0)
   {
   slots_to_add=aa.object_system.object[id].instance_initial;
   if(slots_to_add==0) { slots_to_add=4; }
   }
  else
   {
   slots_to_add=aa.object_system.object[id].instance_slots/8;
   slots_to_add=aaNumMin(slots_to_add,8);
   slots_to_add=aaNumFloor(slots_to_add,2);
   }
  slots_to_add=aaNumRoof(slots_to_add,(aa.object_system.object[id].instance_limit-aa.object_system.object[id].instance_slots));
  if(slots_to_add!=0)   //if(slots_to_add==0) { aaNote(0,"id=%i avail=%i slots2add=%i limit=%i islots=%i icoun=%i",id,available_slots,slots_to_add,aa.object_system.object[id].instance_limit,aa.object_system.object[id].instance_slots,aa.object_system.object[id].instance_count); }
   {
   if(aa.object_system.object[id].instance_slots==0)
    {
    // thread_object (crashes with vidcap create with multiple handles, so make it allocate a lot first time (do same for event objects ?? )
    if(id==1||id==2)     {     slots_to_add=32;     }
    bytes=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
             /* aaLog(-555,"ma  sta=%i by=%i ===%i",slots_to_add,bytes,bytes*slots_to_add); */
    aaStringCopyf(txt,"%s.instdata",aa.object_system.object[id].name);
    if((ret=aa_MemoryAllocate((VP)&bp,bytes*slots_to_add,txt,NO))!=RET_YES)    { oof;   Boop;    return ret;    }
    aa.object_system.object[id].instance_mem=bp;
    }
   else
    {
    bytes=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
    bp=aa.object_system.object[id].instance_mem;
    ///logg("aa_ObjectCreate calling aa_MemoryReAllocate() %s",aa.object_system.object[id].name);
             /* aaLog(-555,"mb  sta=%i by=%i ==%i",slots_to_add,bytes,bytes*(slots_to_add+aa.object_system.object[id].instance_slots)); */
    if((ret=aa_MemoryReAllocate((VP)&bp,bytes*(slots_to_add+aa.object_system.object[id].instance_slots)))!=RET_YES)    { oof;   Boop;    return ret;    }
    aa.object_system.object[id].instance_mem=bp;
    }
   }
  aa.object_system.object[id].instance_slots+=slots_to_add;
  }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 bp=aa.object_system.object[id].instance_mem;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==NO)
   {
   oih->in_use=YES;
   //oih->sesh=aa.object_system.sesh_counter;
   oih->sesh=(aa.object_system.object[id].sesh_counter*32)+aa.object_system.sesh_counter;
   aa.object_system.sesh_counter++;
   aa.object_system.object[id].sesh_counter++;
   base=(H)id*aa_OBJ_MAX_PER_ID;
   base+=aa_OBJ_BASE_HANDLE;
   *handle=(base+h);
   bp+=sizeof(_aa_objectinstanceheader);
   aaMemoryFill(bp,aa.object_system.object[id].instance_bytes,0);
   if(mem)    {    *mem=bp;    }
   bp-=sizeof(_aa_objectinstanceheader);
   aa.object_system.object[id].instance_count++;
   aa.object_system.total_count++;
   #if aa_USE_GLOBAL_MUTEX==1
   LeaveCriticalSection(&global_mutex);
   #endif
   //B fcetc[_2K]; sprintf(fcetc,"%s id=%i",__func__,id); OutputDebugString(fcetc);
   return RET_YES;
   }
  bp+=(instance_stride);
  }
 Boop;
 oof;
 #if aa_USE_GLOBAL_MUTEX==1
 LeaveCriticalSection(&global_mutex);
 #endif
 return RET_FAILED;
 }






 B aa_ObjectCheck                      (B id,H handle,PP mem,BP isprotected)
 {
 register BP bp;
 _aa_objectinstanceheader*oih;
 H base,h,instance_stride;

 #ifdef aa_DIAGNOSE
 aa_ZIAG(__FUNCTION__);
 aa.object_system.object_check_count[id]++;
 #endif
 if(mem)         { *mem=NULL; }
 if(isprotected) { *isprotected=NO; }
 if(aa.object_system.object[id].instance_limit==0) {  return RET_BADHANDLE; }
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 if(handle<base) {   return RET_BADHANDLE; }
 h=handle-base;
 if(h>=aa.object_system.object[id].instance_slots) {    return RET_BADHANDLE; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 bp=aa.object_system.object[id].instance_mem;
 bp+=(h*instance_stride);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 if(oih->in_use==NO) {  return RET_BADHANDLE; }
 if(isprotected)     {  *isprotected=oih->is_protected; }
 if(mem)             {  bp+=sizeof(_aa_objectinstanceheader);  *mem=bp;  }
 return RET_YES;
 }






 B aa_ObjectProtect                    (B id,H handle,B state)
 {
 B ret;
 BP mem;
 _aa_objectinstanceheader*oih;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(id,handle,(VP)&mem,NULL))!=RET_YES) { return ret; }
 mem-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,mem);
 if(state)   { oih->is_protected=YES; }
 else        { oih->is_protected=NO;  }
 return RET_YES;
 }





 B aa_ObjectDestroy                    (B id,H handle)
 {
 B ret;
 BP mem;
 _aa_objectinstanceheader*oih;

 #if aa_USE_GLOBAL_MUTEX==1
 EnterCriticalSection(&global_mutex);
 #endif
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(id,handle,(VP)&mem,NULL))!=RET_YES)
  {
  #if aa_USE_GLOBAL_MUTEX==1
  LeaveCriticalSection(&global_mutex);
  #endif
  return ret;
  }
 mem-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,mem);
 if(oih->is_protected==YES) { oof; return RET_FORBIDDEN; }
 aaMemoryFill(mem,aa.object_system.object[id].instance_bytes,0);
 oih->in_use=NO;
 aa.object_system.object[id].instance_count--;
 aa.object_system.total_count--;
 #if aa_USE_GLOBAL_MUTEX==1
 LeaveCriticalSection(&global_mutex);
 #endif
 return RET_YES;
 }




 B aa_ObjectIdNew                      (BP id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==NULL) { return RET_BADPARM; }
 *id=aa.object_system.id_head++;
 return RET_YES;
 }







 B aa_ObjectNext                       (B id,HP handle,PP mem,HP iterationcounter)
 {
 register BP bp;
 _aa_objectinstanceheader*oih;
 H base,h,instance_stride;
 register H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL&&mem==NULL)  {  return RET_BADPARM;  }
 if(handle) { *handle=0; }
 if(mem)    { *mem=NULL; }
 if(iterationcounter==NULL)  {  return RET_BADPARM;  }
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 if(aa.object_system.object[id].instance_count==0) { return RET_NOTFOUND; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 h=*iterationcounter;
 for(i=0;i<aa.object_system.object[id].instance_slots;i++)
  {
  if(h>=aa.object_system.object[id].instance_slots) { h=0; }
  bp=aa.object_system.object[id].instance_mem;
  bp+=(h*instance_stride);
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   if(handle) {  *handle=(base+h);  }
   *iterationcounter=h+1;
   //if(isprotected) { *isprotected=oih->is_protected; }
   if(mem) { bp+=sizeof(_aa_objectinstanceheader); *mem=bp;    }
   return RET_YES;
   }
  h++;
  }
 *iterationcounter=h+1;
 return RET_NOTFOUND;
 }




 B aa_ObjectFromHandle                 (BP id,H handle)
 {
 H base,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) { return RET_BADHANDLE; }
 if(id!=NULL) { *id=0; }
 for(i=0;i<256;i++)
  {
  base=(H)i*aa_OBJ_MAX_PER_ID;
  base+=aa_OBJ_BASE_HANDLE;
  if(aa.object_system.object[i].instance_limit==0) {  continue; }
  if(handle<base) { continue; }
  if(handle>=(base+aa.object_system.object[i].instance_limit)) { continue; }
  if(id) { *id=(B)i; }
  break;
  }
 if(i==256) { return RET_FAILED; }
 return RET_YES;
 }



 B aa_ObjectHandleToIndex              (B id,H handle,HP index)
 {
 H base,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) { return RET_BADHANDLE; }
 if(index!=NULL) { *index=0; }
 i=(H)id;
 while(1)
  {
  base=(H)i*aa_OBJ_MAX_PER_ID;
  base+=aa_OBJ_BASE_HANDLE;
  if(aa.object_system.object[i].instance_limit==0) {  return RET_BADHANDLE; }
  if(handle<base) { return RET_BADHANDLE; }
  if(handle>=(base+aa.object_system.object[i].instance_limit)) { return RET_BADHANDLE; }
  if(index) { *index=(handle-base); }
  break;
  }
 return RET_YES;
 }



 B aa_ObjectIndexToHandle              (B id,H index,HP handle)
 {
 H base,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) { return RET_BADHANDLE; }
 if(handle!=NULL) { *handle=0; }
 i=(H)id;
 while(1)
  {
  base=(H)i*aa_OBJ_MAX_PER_ID;
  base+=aa_OBJ_BASE_HANDLE;
  if(aa.object_system.object[i].instance_limit==0) {  return RET_BADHANDLE; }
  if(index>=aa.object_system.object[i].instance_limit) { return RET_BOUNDS; }
  if(handle) { *handle=(index+base); }
  break;
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/



 B aa_ThreadSystemStart                (V)
 {
 aa_ObjectIdNew(&aa.thread_system.object_id);
 logg("aa_ThreadSystemStart()");
 aa_ObjectDefine(aa.thread_system.object_id,sizeof(_aa_threadobject),768,256,aaThreadDestroy,"Thread");
 logg("");
 return RET_YES;
 }



 V aa_ThreadSystemStop                 (V)
 {
 logg("aa_ThreadSystemStop()");
 aa_ObjectUndefine(aa.thread_system.object_id);
 logg("");
 }


/*-----------------------------------------------------------------------*/





 B aa_PoolSystemStart                  (V)
 {
 aa_ObjectIdNew(&aa.pool_system.object_id);
 logg("aa_PoolSystemStart()");
 aa_ObjectDefine(aa.pool_system.object_id,sizeof(_aa_poolobject),512,64,aaPoolDestroy,"Pool");
 logg("");
 return RET_YES;
 }



 V aa_PoolSystemStop                   (V)
 {
 logg("aa_PoolSystemStop()");
 aa_ObjectUndefine(aa.pool_system.object_id);
 logg("");
 }





 B aa_PoolSystemAddPages               (PP ptr,H qty)
 {
 B ret;
 _aa_poolobject*poop;
 H bytes,add,from;

 aaCast(poop,_aa_poolobject*,*ptr);
 if(qty==0) { return RET_YES; }
 add=poop->pages_allocated+qty;
 bytes=sizeof(_aa_poolpage)*add;
 if(poop->pages_allocated==0)
  {
  ret=aaMemoryAllocate((VP)&poop->page,bytes);
  aaMemoryNameSet(poop->page,"pppage"); //charlie
  }
 else
  {
  ret=aaMemoryReAllocate((VP)&poop->page,bytes);
  }
 if(ret!=YES) { oops; }
 for(from=0;from<qty;from++)
  {
  aaMemoryFill(&poop->page[poop->pages_allocated+from],sizeof(_aa_poolpage),0);
  }
 poop->pages_allocated=add;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aa_ProcessSystemStart               (V)
 {
 aa_ObjectIdNew(&aa.process_system.object_id);
 logg("aa_ProcessSystemStart()");
 aa_ObjectDefine(aa.process_system.object_id,sizeof(_aa_processobject),512,64,aaProcessDestroy,"Process");
 logg("");
 return RET_YES;
 }


 V aa_ProcessSystemStop                (V)
 {
 logg("aa_ProcessSystemStop()");
 aa_ObjectUndefine(aa.process_system.object_id);
 logg("");
 }





 // inherit has just been added, but previously we just passed inherit=true
 B aa_ProcessSystemCreate              (HP handle,VP processfilename,VP commandline,B clmode,B inherit,B startpaused,B detach,B newroot,W showcmd,B isconsole,VP desktop)
 {
 B ret;
 _aa_processobject*prop;
 B pat[_2K];
 H fl;
 BOOL bo;
 C one[_2K];
 C two[_2K];
 C txt[_2K];
 //C dir[_2K];


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 //if(processfilename==NULL) { return RET_BADPARM; }
 if(processfilename!=NULL)
  {
  if(aaFileExists(processfilename)!=YES) { return RET_NOTFOUND; }
  }
 if((ret=aa_ObjectCreate(aa.process_system.object_id,handle,(VP)&prop))!=RET_YES) { oops; return ret; }
 prop->self_handle=*handle;
 aaMemoryFill(&prop->si,sizeof(STARTUPINFO),0);
 aaMemoryFill(&prop->pi,sizeof(PROCESS_INFORMATION),0);
 prop->si.cb=sizeof(prop->si.cb);
 prop->si.dwFlags=STARTF_USESHOWWINDOW;
 prop->si.wShowWindow=showcmd;
 if(showcmd==F16)     { prop->si.dwFlags=0;  prop->si.wShowWindow=SW_HIDE;  }
 GetStartupInfo(&prop->si);
 aaStringNull(pat);
  fl=0;
  fl|=CREATE_SUSPENDED;
//  fl|=CREATE_NEW_CONSOLE;
  if(detach)           { fl|=DETACHED_PROCESS; }
  if(showcmd==SW_HIDE) { fl|=CREATE_NO_WINDOW; }
  if(newroot)          { fl|=CREATE_NEW_PROCESS_GROUP; }
  if(detach)      { prop->status.is_detached=YES; }
  if(newroot)     { prop->status.is_newroot=YES; }
  if(inherit)     { prop->status.is_inherit=YES; }
  if(aaStringIsNull(desktop)==NO)
   {
   aaStringCopyf(prop->status.desktop,"%s",desktop);
   aaStringCopyf(prop->si.lpDesktop,"%s",desktop);
   }

  if(clmode==0||clmode==1)
   {
   aaStringCopyf(one,"%s",processfilename);
   aaStringCopyf(two,"%s",commandline);
   aaStringCopyf(txt,"\"%s\" %s",one,two);
   bo=CreateProcess(NULL,(LPTSTR)txt,NULL,NULL,(inherit==YES)?TRUE:FALSE,fl,NULL,NULL,&prop->si,&prop->pi);
   }
  else
  if(clmode==2)
   {
   aaStringCopyf(one,"%s",processfilename);
   aaStringCopyf(two,"\"%s\"",commandline);
   bo=CreateProcess((LPTSTR)one,(LPTSTR)two,NULL,NULL,(inherit==YES)?TRUE:FALSE,fl,NULL,NULL,&prop->si,&prop->pi);
   }
  if(bo==0)
   {
   oow;
   aa_ObjectDestroy(aa.process_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  if(startpaused==YES) {  prop->status.is_paused=YES; }
  else                 {  ResumeThread(prop->pi.hThread);  }
  aaTimerTikGet(&prop->ms_root);
  if(isconsole) {  prop->status.is_console=YES; }
  else          {  prop->status.is_console=NO; }
  prop->status.tid=prop->pi.dwThreadId;
  prop->status.pid=prop->pi.dwProcessId;
  prop->status.thread_handle=prop->pi.hThread;
  prop->status.process_handle=prop->pi.hProcess;
 if(processfilename) {   aaStringCopyf(prop->status.file_name,"%s",processfilename); }
 aaStringCopyf(prop->status.cmd_line,"%s",commandline);
 return RET_YES;
 }





 BOOL CALLBACK aa_ProcessSystemEnum    (HWND hwnd,LPARAM lParam)
 {
 Z cl,tl;
 B txt[_2K];
 B str[_2K];
 _aa_processobject*prop;

 prop=(_aa_processobject*)lParam;
 aaStringNull(txt);
 aaStringNull(str);
 cl=GetClassName(hwnd,(LPSTR)txt,_1K);
 tl=GetWindowText(hwnd,(LPSTR)str,_1K);
 //aaDebugf("h=%08x",hwnd);
 ///aaDebugf("self=%x",prop->self_handle);
// if(cl) aaDebugf("c=%s",txt);
// if(tl) aaDebugf("t=%s",str);
 if(cl&&tl)
  {
  //aaLog(-777,"c=%s",txt);
  //aaLog(-777,"t=%s",str);
  prop->status.hwnd=hwnd;

  return FALSE;
  }
//   BUG,"Class = %s, wind=%s ",txt,str);
 return TRUE;
 }



/*-----------------------------------------------------------------------*/

 B aa_FiberSystemStart                 (V)
 {
 aa_ObjectIdNew(&aa.fiber_system.object_id);
 logg("aa_FiberSystemStart()");
 aa_ObjectDefine(aa.fiber_system.object_id,sizeof(_aa_fiberobject),512,5,aaFiberDestroy,"Fiber");
 logg("");
 return RET_YES;
 }



 V aa_FiberSystemStop                  (V)
 {
 logg("aa_FiberSystemStop()");
 aa_ObjectUndefine(aa.fiber_system.object_id);
 logg("");
 }




 B aa_FiberSystemModuleInit            (V)
 {
 if(aa.core_system.kernel_module==NULL) { return RET_FAILED; }
 while(1)
  {
  aa.fiber_system.CreateFiber=(VP)GetProcAddress(aa.core_system.kernel_module,"CreateFiber");
  aa.fiber_system.ConvertThreadToFiber=(VP)GetProcAddress(aa.core_system.kernel_module,"ConvertThreadToFiber");
  aa.fiber_system.SwitchToFiber=(VP)GetProcAddress(aa.core_system.kernel_module,"SwitchToFiber");
  aa.fiber_system.DeleteFiber=(VP)GetProcAddress(aa.core_system.kernel_module,"DeleteFiber");
  break;
  }
 if(aa.fiber_system.CreateFiber==NULL||aa.fiber_system.ConvertThreadToFiber==NULL||
    aa.fiber_system.SwitchToFiber==NULL||aa.fiber_system.DeleteFiber==NULL)
  {
  aa.fiber_system.CreateFiber=NULL;
  aa.fiber_system.ConvertThreadToFiber=NULL;
  aa.fiber_system.SwitchToFiber=NULL;
  aa.fiber_system.DeleteFiber=NULL;
  return RET_FAILED;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aa_WinEnumSystemStart               (V)
 {
 logg("aa_WinEnumSystemStart()");
 aa_ObjectIdNew(&aa.winenum_system.object_id);
 aa_ObjectDefine(aa.winenum_system.object_id,sizeof(_aa_winenumobject),512,8,aaWinEnumDestroy,"WinEnum");
 logg("");
 return RET_YES;
 }




 V aa_WinEnumSystemStop                (V)
 {
 logg("aa_WinEnumSystemStop()");
 aa_ObjectUndefine(aa.winenum_system.object_id);
 logg("");
 }




/*-----------------------------------------------------------------------*/



 B aa_DynbufSystemStart                (V)
 {
 logg("aa_DynbufSystemStart()");
 aa_ObjectIdNew(&aa.dynbuf_system.object_id);
 aa_ObjectDefine(aa.dynbuf_system.object_id,sizeof(_aa_dynbufobject),8192,256,aaDynbufDestroy,"Dynbuf");
 logg("");
 return RET_YES;
 }





 V aa_DynbufSystemStop                 (V)
 {
 logg("aa_DynbufSystemStop()");
 aa_ObjectUndefine(aa.dynbuf_system.object_id);
 logg("");
 }




 B aa_DynbufSystemExtend               (PP ptr,H by)
 {
 B ret;
 _aa_dynbufobject*dynp;
 H bytes;

 aaCast(dynp,_aa_dynbufobject*,*ptr);
 if(by==0) { return RET_YES; }
 bytes=dynp->status.bytes_allocated+by;
 if(dynp->status.bytes_allocated!=0)
  {
  if((ret=aa_MemoryProtect(dynp->status.mem,NO))!=YES) { oops; }
  if((ret=aa_MemoryReAllocate((VP)&dynp->status.mem,bytes))!=YES) { oops; }
  }
 else
  {
  if((ret=aa_MemoryAllocate((VP)&dynp->status.mem,bytes,"dynbyf",NO))!=YES) { oops; }
  }
 if((ret=aa_MemoryProtect(dynp->status.mem,YES))!=YES) { oops; }

 dynp->status.bytes_allocated=bytes;
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/




 B aa_ArraySystemStart                 (V)
 {
 logg("aa_ArraySystemStart()");
 aa_ObjectIdNew(&aa.array_system.object_id);
 aa_ObjectDefine(aa.array_system.object_id,sizeof(_aa_arrayobject),512,256,aaArrayDestroy,"Array");
 logg("");
 return RET_YES;
 }



 V aa_ArraySystemStop                  (V)
 {
 logg("aa_ArraySystemStop()");
 aa_ObjectUndefine(aa.array_system.object_id);
 logg("");
 }



 B aa_ArraySystemExtendPageSlots       (PP mem,H by)
 {
 B ret;
 _aa_arrayobject*arp;
 BP vmem;
// H old_bytes;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(arp,_aa_arrayobject*,*mem);
 if(by==0) { return RET_YES; }
 if(arp->slots_allocated==0)
  {
  bytes=by*sizeof(H);
  if((ret=aa_MemoryAllocate((VP)&vmem,bytes,"ArrayPgeSlot",NO))!=RET_YES) { return ret; }
  aaCast(arp->pge_slot,HP,vmem);
  arp->slots_allocated=by;
//  logg("aa_ArraySystemExtendPageSlots(by %i) calling aa_MemoryReAllocate(%i -> %i)",by,0,bytes);
  }
 else
  {
//  old_bytes=(arp->slots_allocated)*sizeof(H);
  bytes=(arp->slots_allocated+by)*sizeof(H);
  aaCast(vmem,BP,arp->pge_slot);
//  logg("aa_ArraySystemExtendPageSlots(by %i) calling aa_MemoryReAllocate(%i -> %i)",by,old_bytes,bytes);
  if((ret=aa_MemoryReAllocate((VP)&vmem,bytes))!=RET_YES) { return ret; }
  aaCast(arp->pge_slot,HP,vmem);
  arp->slots_allocated+=by;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aa_QueSystemStart                   (V)
 {
 logg("aa_QueSystemStart()");
 aa_ObjectIdNew(&aa.que_system.object_id);
 aa_ObjectDefine(aa.que_system.object_id,sizeof(_aa_queobject),_32K,512,aaQueDestroy,"Que");

 logg("");
 return RET_YES;
 }



 V aa_QueSystemStop                    (V)
 {
 logg("aa_QueSystemStop()");
 aa_ObjectUndefine(aa.que_system.object_id);
 logg("");
 }




 B aa_QueSystemExtendPageSlots         (PP mem,H by)
 {
 B ret;
 _aa_queobject*quep;
 BP vmem;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //aa_last_line_executed=__LINE__;
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(quep,_aa_queobject*,*mem);
 if(by==0) { return RET_YES; }
 //aa_last_line_executed=__LINE__;
 if(quep->slots_allocated==0)
  {
  aa_last_line_executed=__LINE__;
  bytes=by*sizeof(H);
  if((ret=aa_MemoryAllocate((VP)&vmem,bytes,"QuePgeSlot",NO))!=RET_YES) { return ret; }
  aaCast(quep->pge_slot,HP,vmem);
  quep->slots_allocated=by;
  }
 else
  {
  aa_last_line_executed=__LINE__;
  bytes=(quep->slots_allocated+by)*sizeof(H);
  aaCast(vmem,BP,quep->pge_slot);
  if((ret=aa_MemoryReAllocate((VP)&vmem,bytes))!=RET_YES) { return ret; }
  aaCast(quep->pge_slot,HP,vmem);
  quep->slots_allocated+=by;
  }
  aa_last_line_executed=__LINE__;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 V aa_huffmanWriteTreeAndMakeTable     (BP out,HP outbitctr,H outlen,_aahuff_enctable*et,H code,Y bits,struct _aahuff_node *t)
 {
 _aahuff_enctable *eti;
 Y i;
 H byte_index;

 byte_index=(*outbitctr)++>>3;
 byte_index*=(byte_index<outlen);
 if(t->lr[0])
  {
  out[byte_index]<<=1;
  aa_huffmanWriteTreeAndMakeTable(out,outbitctr,outlen,et,code,bits+1,t->lr[0]);
  aa_huffmanWriteTreeAndMakeTable(out,outbitctr,outlen,et,code|(1<<bits),bits+1,t->lr[1]);
  }
 else
  {
  out[byte_index]=(out[byte_index]<<1)|1;
  for(i=0;i<9;++i)
   {
   byte_index=(*outbitctr)++>>3;
   if(byte_index>=outlen) return;
   out[byte_index]=(out[byte_index]<<1)|((B)((t->c>>i)&1));
   }
  eti=&(et[t->c]);
  eti->code=code;
  eti->bits=bits;
  }
 }



 B aa_huffmanReadTree                  (BP in,HP inbitctr,H inlen,BP *heapptr,BP heapend,struct _aahuff_node**hnptr)
 {
 struct _aahuff_node *n;
 Y i;
 H byte_index;

 n=(struct _aahuff_node *)(*heapptr);
 *heapptr+=sizeof(struct _aahuff_node);
 if(*heapptr>heapend)
  {
  *hnptr=(struct _aahuff_node *)0;
  return RET_YES;
  }
 byte_index=*inbitctr>>3;
 byte_index*=(byte_index<inlen);
 if(((in[byte_index]>>(~((*inbitctr)++)&7))&1))
  {
  n->lr[0]=(struct _aahuff_node *)0;
  n->lr[1]=(struct _aahuff_node *)0;
  n->c=0;
  for(i=0;i<9;++i)
   {
   byte_index=*inbitctr>>3;
   if(byte_index>=inlen)
    {
    *hnptr=(struct _aahuff_node *)0;
    return RET_YES;
    }
   n->c|=(((Y)(in[byte_index]>>(~((*inbitctr)++)&7)))&1)<<i;
   }
  }
 else
  {
  aa_huffmanReadTree(in,inbitctr,inlen,heapptr,heapend,&n->lr[0]);
  aa_huffmanReadTree(in,inbitctr,inlen,heapptr,heapend,&n->lr[1]);
  if(!((n->lr[0])&&(n->lr[1])))
   {
   *hnptr=(struct _aahuff_node *)0;
   return RET_YES;
   }
  }
 *hnptr=n;
 return RET_YES;
 }





 H aa_huffmanCompress                  (BP in,H inlen,BP out,H outlen,VP huffheap)
 {
 _aahuff_enctable *et,*eti;
 struct _aahuff_node *t,*n;
 struct _aahuff_node *pair[2];
 BP heapptr=(BP)huffheap;
 H i,code,byte_index,outbitctr;
 Y bits,b;
 DP counts;
 D lowest_prob,total_symbols;

 counts=(DP)heapptr;
 heapptr+=(sizeof(D)*257);
 for(i=0;i<256;++i) counts[i]=0.0;
 counts[256]=1.0;
 for(i=0;i<inlen;++i) counts[(H)in[i]]+=1.0;
 t=(struct _aahuff_node *)0;
 total_symbols=(D)(inlen+1);
 for(i=0;i<=256;++i)
  {
  if(counts[i]>0.0)
   {
   n=(struct _aahuff_node *)heapptr;
   heapptr+=sizeof(struct _aahuff_node);
   if(t) t->qprev=n;
   n->qprev=(struct _aahuff_node *)0;
   n->qnext=t;
   n->lr[0]=(struct _aahuff_node *)0;
   n->lr[1]=(struct _aahuff_node *)0;
   n->prob=counts[i]/total_symbols;
   n->c=(Y)i;
   t=n;
   }
  }
 while(t->qnext)
  {
  for(i=0;i<2;++i)
   {
   lowest_prob=1.0;
   pair[i]=(struct _aahuff_node *)0;
   n=t;
   while(n)
    {
    if(n->prob<=lowest_prob) { lowest_prob=n->prob; pair[i]=n;	}
    n=n->qnext;
    }
   if(pair[i]->qprev) pair[i]->qprev->qnext=pair[i]->qnext;
   else                t=pair[i]->qnext;
   if(pair[i]->qnext) pair[i]->qnext->qprev=pair[i]->qprev;
   }
  n=(struct _aahuff_node *)heapptr;
  heapptr+=sizeof(struct _aahuff_node);
  n->lr[0]=pair[0];
  n->lr[1]=pair[1];
  n->prob=pair[0]->prob+pair[1]->prob;
  if(t) t->qprev=n;
  n->qprev=(struct _aahuff_node *)0;
  n->qnext=t;
  t=n;
  }
 et=(_aahuff_enctable *)heapptr;
 heapptr+=(sizeof(_aahuff_enctable)*257);
 outbitctr=0;
 aa_huffmanWriteTreeAndMakeTable(out,&outbitctr,outlen,et,0,0,t);
 for(i=0;i<inlen;++i)
  {
  eti=&(et[(H)in[i]]);
  code=eti->code;
  bits=eti->bits;
  for(b=0;b<bits;++b)
   {
   byte_index=outbitctr++>>3;
   if(byte_index>=outlen) { return (F32-1); }
   out[byte_index]=(out[byte_index]<<1)|(B)(code&1);
   code>>=1;
   }
  }
 code=et[256].code;
 bits=et[256].bits;
 for(b=0;b<bits;++b)
  {
  byte_index=outbitctr++>>3;
  if(byte_index>=outlen) { oof; return F32; }
  out[byte_index]=(out[byte_index]<<1)|(B)(code&1);
  code>>=1;
  }
 if(outbitctr>(outlen<<3)) { oof; return F32; }
 else
 if((outbitctr&7)) { out[i=(outbitctr>>3)]<<=8 - (outbitctr&7); return (i+1);	}
 return (outbitctr>>3);
 }




 H aa_huffmanDecompress                (BP in,H inlen,BP out,H outlen,VP huffheap,H hs)
 {
 struct _aahuff_node *t,*n;
 BP heapptr=(BP)huffheap;
 H inbitctr,outptr;
 H byte_index=0;

 inbitctr=0;
 //t=huffmanReadTree(in,&inbitctr,inlen,&heapptr,heapptr+HUFF_HEAP_SIZE);
 aa_huffmanReadTree(in,&inbitctr,inlen,&heapptr,heapptr+hs,&t);
 if(!t) return 0;
 outptr=0;
 for(;;)
  {
  n=t;
  while(n->lr[0])
   {
   byte_index=inbitctr>>3;
   if(byte_index>=inlen) { return F32; }
   n=n->lr[((H)(in[byte_index]>>(~(inbitctr++)&7)))&1];
   }
  if(n->c==256) break;
  if(outptr==outlen) { return (F32-1); }
  out[outptr++]=(B)n->c;
  }
 return outptr;
 }


/*-----------------------------------------------------------------------*/



 B aa_GeneralEventSystemStart          (V)
 {
 H i;

 logg("aa_GeneralEventSystemStart()");
 for(i=0;i<aa_MAX_GENERAL_QUES;i++)
  {
  aaQueCreate(&aa.generalevent_system.object[i].que_handle);
  aaTimerTikGet(&aa.generalevent_system.object[i].tik);
  logg("Generate event que handle = %i",aa.generalevent_system.object[i].que_handle);
  }
 logg("");
 return RET_YES;
 }



 V aa_GeneralEventSystemStop           (V)
 {
 H i;

 logg("aa_GeneralEventSystemStop()");
 for(i=0;i<aa_MAX_GENERAL_QUES;i++)
  {
  if(aa.generalevent_system.object[i].que_handle!=0)
   {
   aaQueDestroy(aa.generalevent_system.object[i].que_handle);
   aa.generalevent_system.object[i].que_handle=0;
   }
  }
 logg("");
 }







/*-----------------------------------------------------------------------*/



 B aa_NetSystemStart                   (V)
 {
 B ret;
// BP mem;
 B buf[_1K];
 H i;
 _localip lip;

 logg("aa_NetSystemStart()");

 if(WSAStartup(MAKEWORD(2,2),&aa.net_system.ws_data))  { oof; return RET_FAILED;  }
 aa.core_system.SleepFunction=aa_CoreSystemSleepPrecise;
 while(1)
  {
  ret=RET_FAILED;
  aaStringCopyf(buf,"aa.Sniff.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.sniff_message_id=RegisterWindowMessage((CP)buf))==0) break;
  aaStringCopyf(buf,"aa.Icmp.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.icmp_message_id=RegisterWindowMessage((CP)buf))==0) break;
  aaStringCopyf(buf,"aa.Dns.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.dns_message_id=RegisterWindowMessage((CP)buf))==0) break;
  aaStringCopyf(buf,"aa.Tcp.Msg.Name.%lu",GetTickCount());
  if((aa.net_system.tcp_message_id=RegisterWindowMessage((CP)buf))==0) break;
//  aaLog(-777,"tcp_msg_id=%i",aa.net_system.tcp_message_id);
  ret=RET_YES;
  break;
  }
 if(ret==RET_FAILED)  { oof; WSACleanup();  return RET_FAILED;  }
 aaStringCopyf(aa.net_system.class_name,"aa.net_system.Class.Name.%lu",GetTickCount());
 WinWndClassExSet(&aa.net_system.class_data,0,aa_NetSystemProc,aa.net_system.class_name);
 if(RegisterClassEx(&aa.net_system.class_data)==0)  {  oof; WSACleanup();  return RET_FAILED;  }
//   aaLog(-1,"line=%-6lu tik=%lu ",__LINE__,GetTickCount()%20000);
 aa.net_system.window=CreateWindowEx(WS_EX_TOOLWINDOW,(LPCTSTR)aa.net_system.class_name,NULL,0,10,10,4,4,NULL,NULL,aa.core_system.this_instance,NULL);
 if(aa.net_system.window==NULL)
  {
  oow;
  WSACleanup();
  UnregisterClass((LPCTSTR)aa.net_system.class_name,aa.core_system.this_instance);
  aa.net_system.class_name[0]=NULL_CHAR;
  return RET_FAILED;
  }
 logg("%s:%i net_system.window hwnd=%x",__func__,__LINE__,aa.net_system.window);
 if(SetWindowText(aa.net_system.window,(LPSTR)"aa.net_system.window")==0) { oof; }

 aa_ObjectIdNew(&aa.net_system.dns_object_id);
 aa_ObjectIdNew(&aa.net_system.sniff_object_id);
 aa_ObjectIdNew(&aa.net_system.icmp_object_id);
 aa_ObjectIdNew(&aa.net_system.udp_object_id);
 aa_ObjectIdNew(&aa.net_system.stunclient_object_id);
 aa_ObjectIdNew(&aa.net_system.tcpport_object_id);
 aa_ObjectIdNew(&aa.net_system.tcpcall_object_id);
 aa_ObjectIdNew(&aa.net_system.cgiclient_object_id);
 aa_ObjectIdNew(&aa.net_system.server_object_id);
 aa_ObjectIdNew(&aa.net_system.wock_object_id);

 aa_ObjectDefine(aa.net_system.dns_object_id,sizeof(_aa_netdnsobject),2048,256,aaNetDnsDestroy,"Dns");
 aa_ObjectDefine(aa.net_system.sniff_object_id,sizeof(_aa_netsniffobject),512,4,aaNetSniffDestroy,"Sniff");
 aa_ObjectDefine(aa.net_system.icmp_object_id,sizeof(_aa_neticmpobject),512,8,aaNetIcmpDestroy,"Icmp");
 aa_ObjectDefine(aa.net_system.udp_object_id,sizeof(_aa_netudpobject),512,64,aaNetUdpDestroy,"Udp");
 aa_ObjectDefine(aa.net_system.stunclient_object_id,sizeof(_aa_netstunclientobject),512,4,aaNetStunClientDestroy,"StunCli");
 aa_ObjectDefine(aa.net_system.tcpcall_object_id,sizeof(_aa_nettcpcallobject),aa_NET_MAX_TCP_CALLS,256,aaNetTcpCallDestroy,"TcpCall");
 aa_ObjectDefine(aa.net_system.tcpport_object_id,sizeof(_aa_nettcpportobject),aa_NET_MAX_TCP_PORTS,32,aaNetTcpPortDestroy,"Tcp-Port");
 aa_ObjectDefine(aa.net_system.cgiclient_object_id,sizeof(_aa_netcgiclientobject),_32K,64,aaNetCgiClientDestroy,"CgiCli");
 aa_ObjectDefine(aa.net_system.server_object_id,sizeof(_aa_netserverobject),_32K,32,aaNetServerDestroy,"Server");
 aa_ObjectDefine(aa.net_system.wock_object_id,sizeof(_aa_netwockobject),_32K,32,aaNetWockDestroy,"Wock");

 aa.net_system.net_status.max_tcp_calls=aa_NET_MAX_TCP_CALLS;
 aa.net_system.net_status.max_tcp_ports=aa_NET_MAX_TCP_PORTS;


 if((ret=aaNetLocalIpGet(&lip,NO,YES))!=YES) { oops; }
 for(i=0;i<32;i++)
  {
  if(lip.ip[i]==0) continue;
  if(lip.type[i]!='P') continue;
  aa.net_system.net_status.public_ip[aa.net_system.net_status.public_ip_count]=lip.ip[i];
  aa.net_system.net_status.broadcast_ip[aa.net_system.net_status.public_ip_count]=lip.bcast_ip[i];
  aa.net_system.net_status.public_ip_count++;
  }

 //aa
 for(i=0;i<3;i++) {  aaTimerTikGet(&aa.net_system.sub_yield_tik[i]); }
 return RET_YES;
 }






 V aa_NetSystemStop                    (V)
 {
 logg("aa_NetSystemStop()");
 aaNetPortListStop();

 aa_ObjectUndefine(aa.net_system.wock_object_id);
 aa_ObjectUndefine(aa.net_system.server_object_id);
 aa_ObjectUndefine(aa.net_system.cgiclient_object_id);
 aa_ObjectUndefine(aa.net_system.tcpport_object_id);
 aa_ObjectUndefine(aa.net_system.tcpcall_object_id);
 aa_ObjectUndefine(aa.net_system.stunclient_object_id);
 aa_ObjectUndefine(aa.net_system.udp_object_id);
 aa_ObjectUndefine(aa.net_system.icmp_object_id);
 aa_ObjectUndefine(aa.net_system.sniff_object_id);
 aa_ObjectUndefine(aa.net_system.dns_object_id);
 WSACleanup();
 aa.core_system.SleepFunction=aa_CoreSystemSleepStandard;
 DestroyWindow(aa.net_system.window);
 UnregisterClass((LPCTSTR)aa.net_system.class_name,aa.core_system.this_instance);
 aa.net_system.window=NULL;
 aa.net_system.class_name[0]=NULL_CHAR;
 logg("");
 }






 B aa_NetSystemLocalEmailCheck         (V)
 {
 DWORD type,len;
 HKEY sub;
 LONG r;
 B buf[_1K];
 H index,ei;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ei=0;
 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Internet Account Manager\\Accounts\\00000001",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=63; type=REG_SZ;
  r=RegQueryValueEx(sub,"HTTPMail User Name",NULL,&type,(BP)buf,&len);
  if(len<_1K) { buf[len]=NULL_CHAR; }
  if(r==ERROR_SUCCESS) {  aaStringCopy(aa.net_system.local_email[ei++],buf);  }
  len=63; type=REG_SZ;
  r=RegQueryValueEx(sub,"SMTP Email Address",NULL,&type,(BP)buf,&len);
  if(len<_1K) { buf[len]=NULL_CHAR; }
  if(r==ERROR_SUCCESS) {   aaStringCopy(aa.net_system.local_email[ei++],buf);  }
  RegCloseKey(sub);
  }
 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\UnreadMail",0,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  index=0;
  while(1)
   {
   len=63;
   r=RegEnumKey(sub,index,(CP)buf,len);
   if(r==   ERROR_NO_MORE_ITEMS) { break; }
   if(r==ERROR_SUCCESS)
    {
    aaStringLen(buf,&len);
    if(len>0&&len<64)  {  aaStringCopy(aa.net_system.local_email[ei++],buf);     break;     }
    }
   else   { aaNote(0,"check line %i",__LINE__); }
   index++;
   }
  RegCloseKey(sub);
  }
 aa.net_system.local_email_count=(B)ei;
 aa.net_system.local_email_checked=YES;
 return RET_YES;
 }






 B aa_NetSystemResolveIpPortPair       (SOCKET sock,HP locip,WP locport,HP remip,WP remport)
 {
 N len;
 struct sockaddr_in addr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(locip)   { *locip=0; }
 if(locport) { *locport=0; }
 if(remip)   { *remip=0; }
 if(remport) { *remport=0; }

 if(locip!=NULL||locport!=NULL)
  {
  len=sizeof(addr);
  WinSockAddrSet(&addr,AF_INET,0,0);
  if(getsockname(sock,(struct sockaddr *)&addr,(VP)&len)!=SOCKET_ERROR) //(Z FAR*)
   {
   if(locport) { *locport=htons(addr.sin_port); }
   if(locip)
    {
//    count-=got, *(char **)(void *)&buffer+=size*got;
    *locip=*((HP)&addr.sin_addr);
    if(*locip==0)
     {
     aa_last_line_executed=__LINE__;
     aa_NetSystemLocalHostGet(locip,1);
     if(*locip==0) { return RET_FAILED; }
     }
    }
   }
  else {    return RET_FAILED; }
  }
 if(remip!=NULL||remport!=NULL)
  {
  len=sizeof(addr);
  WinSockAddrSet(&addr,AF_INET,0,0);
  if(getpeername(sock,(struct sockaddr *)&addr,(VP)&len)!=SOCKET_ERROR) // (Z FAR*)&ilen, (struct sockaddr *)&addr
   {
   if(remport) { *remport=htons(addr.sin_port); }
   if(remip)   { *remip=*(HP)&addr.sin_addr; }
   }
  else { return RET_FAILED; }
  }
 return RET_YES;
 }










 B aa_NetSystemFindDnsByResolverHandle (HP handle,PP mem,HANDLE resolverhandle)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_netdnsobject*dnsp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.dns_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(dnsp,_aa_netdnsobject*,bp);
   if(dnsp->resolver_handle==resolverhandle)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }





 B aa_NetSystemFindSniffBySock         (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_netsniffobject*snifp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.sniff_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(snifp,_aa_netsniffobject*,bp);
   if(snifp->sock==sock)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }




 B aa_NetSystemFindIcmpBySock          (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_neticmpobject*icmpp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.icmp_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(icmpp,_aa_neticmpobject*,bp);
   if(icmpp->sock==sock)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }








 B aa_NetSystemFindPortBySock          (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_nettcpportobject*prtp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.tcpport_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(prtp,_aa_nettcpportobject*,bp);
   if(prtp->sock==sock&&prtp->socket_used==YES)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }








 B aa_NetSystemFindCallBySock          (HP handle,PP mem,SOCKET sock,B mustbeincall,B mustbeoutcall)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_nettcpcallobject*calp;
 H base,h,instance_stride;
 H checked;
 B id,ok;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mustbeoutcall==YES&&mustbeincall==YES) { return RET_BADPARM; }
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(calp,_aa_nettcpcallobject*,bp);
   if(calp->sock==sock&&calp->socket_used==YES)
    {
    ok=NO;
    if(mustbeincall==NO&&mustbeoutcall==NO) { ok=YES; }
    else
     {
     if(mustbeincall==YES&&calp->status.is_incoming==YES) { ok=YES; }
     if(mustbeoutcall==YES&&calp->status.is_incoming==NO) { ok=YES; }
     }
    if(ok==YES)
     {
     if(handle) { *handle=base+h; }
     if(mem)    { *mem=bp; }
     return RET_YES;
     }
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }






 B aa_NetSystemFindCallByPortSock      (HP handle,PP mem,SOCKET sock)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_nettcpcallobject*calp;
 H base,h,instance_stride,checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(calp,_aa_nettcpcallobject*,bp);
   if(calp->port_sock==sock&&calp->socket_used==YES)
    {
    if(calp->status.is_incoming==YES)
     {
     if(handle) { *handle=base+h; }
     if(mem)    { *mem=bp; }
     return RET_YES;
     }
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }




 B aa_NetSystemFindUdpByAddress        (HP handle,PP mem,H ip,W port)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_netudpobject*udpp;
 H base,h,instance_stride;
 H checked;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.net_system.udp_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 checked=0;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  if(checked>=aa.object_system.object[id].instance_count) { break; }
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   checked++;
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(udpp,_aa_netudpobject*,bp);
   if(udpp->status.local_adr.ip==ip&&udpp->status.local_adr.port==port)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }





 B aa_NetSystemLocalHostGet            (HP localip,H count)
 {
 B txt[129];
 struct hostent *phe;
 H i,c;
 struct in_addr addr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(localip==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 aaMemoryFill(localip,count*4,0);
 logg("Calling get host name");
 aa_last_line_executed=__LINE__;
 if(gethostname((CP)txt,sizeof(txt))==SOCKET_ERROR)
  {
  logg("gethostname failuree");
  return RET_FAILED;
  }
 logg("host name = %s  (calling gethostbyname)",txt);
 aa_last_line_executed=__LINE__;
 phe=gethostbyname((CP)txt);
 if(phe==NULL) {  return RET_FAILED; }
 c=0;
 for(i=0;phe->h_addr_list[i]!=0;++i)
  {
  localip[c]=0;
  aaMemoryCopy(&addr,sizeof(struct in_addr),phe->h_addr_list[i]);
  localip[c]=*((HP)&addr);
//  logg("...   Localip[%i]=%i",c,localip[c]);
//  sg(-1,"...   %i Localip[%i]=%i",i,c,localip[c]);
  if(localip[c]!=0) { c++; }
  if(c==count)  { break;  }
  }
  aa_last_line_executed=__LINE__;
 if(c==0) {  return RET_NOTFOUND; }
 return RET_YES;
 }





 B aa_NetSystemTcpCallCreate           (HP handle,H ip,W port,H sip,W sport)
 {
 B ret,isprot;
 _aa_nettcpcallobject*calp;
 SOCKET sock;
 struct sockaddr_in addr;
 //BP bp;
// _aa_objectinstanceheader*oih;
 N error;
 N oval,olen;
 UNUSE(oval);
 UNUSE(olen);
 UNUSE(sip);
 UNUSE(sport);

 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,*handle,(VP)&calp,&isprot))!=RET_YES) { oops; return ret; }
 if(isprot==YES) { oof; return RET_FORBIDDEN; }
 if(calp->dns_handle) { oof; return RET_BADSTATE; }

 sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP); // was zero instead of proto_tcp
 if(sock==INVALID_SOCKET)  {   aa_ObjectDestroy(aa.net_system.tcpcall_object_id,*handle);  *handle=0;  return RET_FAILED;  }


 if(sip||sport)
  {
  WinSockAddrSet(&addr,AF_INET,sip,htons(sport));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr)))
   {
   oof;
   //aaNote(0,"bind line %i %i",__LINE__,WSAGetLastError());
   aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
   closesocket(sock);
   *handle=0;
   return RET_INUSE;
   }
  }

  calp->socket_used=YES;
  WinSockAddrSet(&addr,AF_INET,ip,htons(port));
  while(1)
   {
   if(WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CONNECT|FD_CLOSE)) { oof; oow; ret=RET_FAILED; break; }
   error=connect(sock,(struct sockaddr *)&addr,sizeof(addr));
   if(error==0) { oof; ret=RET_FAILED; break; }
   if(error==SOCKET_ERROR)
    {
    error=WSAGetLastError();
    if(error==WSAENOBUFS||error!=WSAEWOULDBLOCK)
     {
     /* aaNote(0,"line=%i error=%i (%i,%i)",__LINE__,error,WSAENOBUFS,WSAEWOULDBLOCK);*/ /* BUG,"line=%i error=%i (%i,%i)",__LINE__,error,WSAENOBUFS,WSAEWOULDBLOCK); */
     ret=RET_FAILED;
     break;
     }
    }
   if((ret=aaQueCreate(&calp->xmit_que))!=RET_YES) {  break; }
   if((ret=aaQueCreate(&calp->rcve_que))!=RET_YES) {  break; }
   logg("tcpcallcreate xmit que handle = %i",calp->xmit_que);
   logg("tcpcallcreate rcve que handle = %i",calp->rcve_que);
   break;
   }

  if(ret!=RET_YES)
   {
   oops;
   logg("oops=%i line=%i",ret,__LINE__);
   aa_ObjectDestroy(aa.net_system.tcpcall_object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }

  calp->sock=sock;
  calp->status.sock=sock;
  calp->status.remote_adr.ip=ip;
  calp->status.remote_adr.port=port;
  if((ret=aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,0,0))!=YES)
   {
   oops; // otherwise callstatus returns localip/port=0.0 remoteip/port=0.0
   }
  aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
  aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);
  calp->inactive_rcve_ms_root=calp->ms_root;
  calp->inactive_xmit_ms_root=calp->ms_root;

  /// calp->status.inactivity=0; // dec08
  aa.net_system.net_status.current_outgoing_tcp_call_count++;
  aa.net_system.net_status.total_outgoing_tcp_call_count++;
  aaNetTcpCallSlicerLengthSet(*handle,_8K,_8K);//512,512);
  aaNetTcpCallBufferLengthSet(*handle,_32K,_32K);
 ///aaNetTcpCallNoDelaySet(*handle,NO);
  calp->status.user_data=calp->user_data;
  calp->status.user_bytes=sizeof(calp->user_data);
//  {  L opt,olen;  opt=TRUE; olen=sizeof(BOOL);  if(setsockopt(calp->sock,SOL_SOCKET,SO_DONTLINGER,(CP)&opt,olen)!=0) oof;  }
 aaNetTcpCallStatus(*handle,0);
 return RET_YES;
 }




 B aa_NetSystemNextTcpCall             (HP handle,PP ptr,W matchport,HP iterationcounter)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 H base,h,instance_stride,i;
 B id;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
  if(ptr) { *ptr=NULL; }
 if(handle==NULL)  {  return RET_BADPARM;  }
 if(iterationcounter==NULL)  {  return RET_BADPARM;  }
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 h=*iterationcounter;
 for(i=0;i<aa.object_system.object[id].instance_slots;i++)
  {
  if(h>=aa.object_system.object[id].instance_slots) { h=0; }
  bp=aa.object_system.object[id].instance_mem;
  bp+=(h*instance_stride);
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   calp=(_aa_nettcpcallobject*)(bp+sizeof(_aa_objectinstanceheader));
   if(matchport==0||calp->status.local_adr.port==matchport)
    {
    *handle=(base+h);
    *iterationcounter=h+1;
    if(ptr) {  bp+=sizeof(_aa_objectinstanceheader);    *ptr=bp;    }
    return RET_YES;
    }
   }
  h++;
  }
 *iterationcounter=h+1;
 return RET_NOTFOUND;
 }














 B aa_NetSystemProcessTcp              (PP mem)
 {
 B ret;
 _questatus qs;
 _aa_nettcpcallobject*calp;
 _aa_queobject*quep;
 N done;
 H todo,err;
 B temp[_64K];
 H max_todo;
 //BP temp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_ProcessTcp))!=RET_YES)

 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(calp,_aa_nettcpcallobject*,*mem);

 if(calp->status.is_closed_by_local==YES)
  {
  aaTimerTikElapsed(calp->local_closed_ms_root,&calp->status.local_closed_ms);
  calp->status.closed_ms=calp->status.local_closed_ms;
  }
 if(calp->status.is_closed_by_remote==YES)
  {
  aaTimerTikElapsed(calp->remote_closed_ms_root,&calp->status.remote_closed_ms);
  calp->status.closed_ms=calp->status.remote_closed_ms;
  }

 max_todo=calp->status.rcve_slicer_length;//aa_TCP_RCVE_MTU;
 if(calp->is_rcve_backoff==YES) { max_todo=1; }

 if(calp->status.is_rcve_paused==NO&&calp->is_rcve_backoff==NO)
  {
  if((ret=aa_ObjectCheck(aa.que_system.object_id,calp->rcve_que,(VP)&quep,NULL))!=RET_YES) { return ret; }
  done=recv(calp->sock,(CP)temp,max_todo,0);

   if(done==SOCKET_ERROR)
    {
    err=WSAGetLastError();
    if(err==10054)
     {
     if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
     calp->status.is_closed_by_remote=YES;
     }
    }

  if(done!=SOCKET_ERROR&&done!=0)
   {
   if((ret=aaQueWrite(calp->rcve_que,done,temp))!=RET_YES) { oof; Boop; return ret; }
   aaQueStatus(calp->rcve_que,&qs); //donky qs is never used
   calp->status.rcve_bytes=qs.bytes; // donky
   aa.net_system.net_status.total_tcp_bytes_in+=(Q)(done);
   calp->status.rcve_bytes_total+=(Q)done;
   aaTimerTikGet(&calp->inactive_rcve_ms_root);
   calp->status.rcve_inactivity=0;
   }
  }


 max_todo=calp->status.xmit_slicer_length;//aa_TCP_XMIT_MTU;
 if(calp->is_xmit_slowdown||calp->is_xmit_backoff==YES) { max_todo=1;   }


 if(calp->status.is_xmit_paused==NO)//&& calp->is_xmit_backoff==NO )
  {
  if((ret=aa_ObjectCheck(aa.que_system.object_id,calp->xmit_que,(VP)&quep,NULL))!=RET_YES) { return ret; }
  if(quep->status.bytes!=0)
   {
   todo=quep->status.bytes;
   todo=aaNumRoof(todo,max_todo);
   todo=aaNumRoof(todo,sizeof(temp));
   if((ret=aaQuePeek(calp->xmit_que,0,todo,temp))!=RET_YES) { oof; Boop; return ret; }
   done=send(calp->sock,(CP)temp,todo,0);
   if(done==SOCKET_ERROR)
    {
    err=WSAGetLastError();
    //if(calp->status.remote_adr.port==80)
     {
     //aaDebugf("xmit erro=%i",err);
     }
    if(err==10035||err==10055)
     {
     if(calp->is_xmit_slowdown<100)
      {
      calp->is_xmit_slowdown++;
//      aaDebugf("slot=%i",calp->is_xmit_slowdown);
      }
     }
    if(err==10054)
     {
     if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
     calp->status.is_closed_by_remote=YES;
     }
    }
   if(done!=SOCKET_ERROR)//&& done!=0 )
    {
    if(done!=0)
     {
     if((ret=aaQueDiscard(calp->xmit_que,done))!=RET_YES) { oof; Boop;return ret; }
     aaQueStatus(calp->xmit_que,&qs); //donky qs is never used
     calp->status.xmit_bytes=qs.bytes; // donky
     aaTimerTikGet(&calp->inactive_xmit_ms_root);
     calp->status.xmit_inactivity=0;
     if(calp->is_xmit_slowdown) { calp->is_xmit_slowdown--;  }
     }
    calp->status.xmit_bytes_total+=(Q)(done); // shit me ?!? was +8
    aa.net_system.net_status.total_tcp_bytes_out+=(Q)(done); // shit me ?!?
    }
   }
  }
 else
  {
  aaDebugf("eoke");
  }



 if((ret=aaQueStatus(calp->rcve_que,&qs))!=RET_YES) { oof; Boop; return ret; }
 calp->status.rcve_bytes=qs.bytes;
  if((ret=aaQueStatus(calp->xmit_que,&qs))!=RET_YES) { oof; Boop;return ret; }
//  if(qs.bytes<calp->status.xmit_bytes) { aaTimerTikGet(&calp->inactive_xmit_ms_root); calp->status.xmit_inactivity=0; }
  calp->status.xmit_bytes=qs.bytes;



 if(calp->status.max_rcve_rate!=0)
  {
  if(calp->is_rcve_backoff==NO&&calp->status.rcve_rate>(calp->status.max_rcve_rate*1.0))  {  calp->is_rcve_backoff=YES; }
  else
  if(calp->is_rcve_backoff==YES&&calp->status.rcve_rate<calp->status.max_rcve_rate) { calp->is_rcve_backoff=NO;  }
  }


 if(calp->status.max_xmit_rate!=0)
  {
  if(calp->is_xmit_backoff==NO&&calp->status.xmit_rate>(calp->status.max_xmit_rate*1.0))  {  calp->is_xmit_backoff=YES; }
  else
  if(calp->is_xmit_backoff==YES&&calp->status.xmit_rate<calp->status.max_xmit_rate) { calp->is_xmit_backoff=NO;  }
  }
 return RET_YES;
 }







 B aa_NetSystemCalculateUdpTimers      (PP mem)
 {
 _aa_netudpobject*udpp;
 D d1,d2;
 H tik,el;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(udpp,_aa_netudpobject*,*mem);

 udpp->calc_timer_cycle++;

 aaTimerTikGet(&tik);
 aaTimerTikElapsedUsingTik(udpp->sub_tik,tik,&el);

 //if(aaHz(500)||udpp->calc_timer_cycle<20)
 if((el>=(H)(1000.0/500.0))||udpp->calc_timer_cycle<20)
  {
  udpp->sub_tik=tik;
  aaTimerTikElapsed(udpp->ms_root,&udpp->status.ms);
  aaTimerTikElapsed(udpp->inactive_ms_root,&udpp->status.inactivity);
  }

 aaTimerProfilerUpdate(&udpp->recent_profiler,1);
 if(udpp->recent_profiler.nano<=10000) { return RET_YES; } // and recent profiler, must be at least 0.1 secs within its frequency

 #if 0
 udpp->hires_elapsed=udpp->hires_elapsed+udpp->recent_profiler.elapsed;
 #endif


 d1=udpp->recent_profiler.ms+aa_NET_RECENT_FREQ;
 d2=udpp->rcve_bytes_total_recent+udpp->rcve_bytes_total_previous;   d2=d2/d1;   udpp->status.rcve_byte_rate=(H)d2;
 d2=udpp->xmit_bytes_total_recent+udpp->xmit_bytes_total_previous;   d2=d2/d1;   udpp->status.xmit_byte_rate=(H)d2;
 d2=udpp->rcve_pkts_total_recent+udpp->rcve_pkts_total_previous;     d2=d2/d1;   udpp->status.rcve_pkt_rate=(H)d2;
 d2=udpp->xmit_pkts_total_recent+udpp->xmit_pkts_total_previous;     d2=d2/d1;   udpp->status.xmit_pkt_rate=(H)d2;


  if(udpp->recent_profiler.ms>=aa_NET_RECENT_FREQ)
   {
   aaTimerProfilerInit(&udpp->recent_profiler,1);
   udpp->rcve_bytes_total_previous=udpp->rcve_bytes_total_recent;
   udpp->xmit_bytes_total_previous=udpp->xmit_bytes_total_recent;
   udpp->rcve_pkts_total_previous=udpp->rcve_pkts_total_recent;
   udpp->xmit_pkts_total_previous=udpp->xmit_pkts_total_recent;
   udpp->rcve_bytes_total_recent=0;
   udpp->xmit_bytes_total_recent=0;
   udpp->rcve_pkts_total_recent=0;
   udpp->xmit_pkts_total_recent=0;
   }


 #if 0
 d1=udpp->hires_elapsed/1000.0;
 d2=udpp->status.total_bytes_sent;     d2=d2/d1; udpp->status.avg_xmit_byte_rate=(H)d2;
 d2=udpp->status.total_bytes_received; d2=d2/d1; udpp->status.avg_rcve_byte_rate=(H)d2;
 d2=udpp->status.total_pkts_sent;      d2=d2/d1; udpp->status.avg_xmit_pkt_rate=(H)d2;
 d2=udpp->status.total_pkts_received;  d2=d2/d1; udpp->status.avg_rcve_pkt_rate=(H)d2;
 #endif


 return RET_YES;
 }







 B aa_NetSystemProcessUdp              (PP mem)
 {
 B ret;
 _questatus qs;
 _aa_netudpobject*udpp;
 struct sockaddr_in addr;
 N len,bytes;
 B tmp[128];
 fd_set set;
 struct timeval tv;
 Z flags;
 Z val;
 B can_xmit;
 B isok;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(udpp,_aa_netudpobject*,*mem);
 aa_NetSystemCalculateUdpTimers((VP)&udpp);

  FD_ZERO(&set);
  FD_SET(udpp->sock,&set);
  WSASetLastError(0);
  tv.tv_sec=0;
  tv.tv_usec=0;
  val=select(0,&set,0,0,&tv);
  if(val==SOCKET_ERROR) { oof;  oow; }
  if(val>=1)
  {
  if(FD_ISSET(udpp->sock,&set)!=0)
   {
   len=sizeof(addr);
   flags=0;
   if((bytes=recvfrom(udpp->sock,(CP)&aa.net_system.tmpbuf[sizeof(addr)+4],0x10000,flags,(struct sockaddr *)&addr,(ZP)&len))>=0)
    {
    aaMemoryCopy(&aa.net_system.tmpbuf[0],sizeof(addr),&addr);
    *(HP)&aa.net_system.tmpbuf[sizeof(addr)]=bytes;

    //aaFileSaveFromMemory("dms.bom",65535,aa.net_system.tmpbuf);
    if((ret=aaQueWrite(udpp->rcve_que,sizeof(addr)+4+bytes,aa.net_system.tmpbuf))!=RET_YES) { oops; return ret; }
    if(flags==MSG_PEEK) {   recvfrom(udpp->sock,0,0,0,0,0); }
    udpp->status.rcve_bytes_total+=(Q)bytes;
    udpp->rcve_bytes_total_recent+=(bytes+8); // add 8 bytes udp overhead for rate timings
    udpp->rcve_pkts_total_recent++;
    udpp->status.rcve_pkts_qued++;
    aa.net_system.net_status.total_udp_packets_received++;
    aaTimerTikGet(&udpp->inactive_ms_root);
    udpp->status.inactivity=0;
    }
   }
  }

 if(udpp->status.xmit_pkts_qued!=0)
  {
  can_xmit=YES;
  if(udpp->status.xmit_speed!=0.0)
   {
   aaTimerProfilerUpdate(&udpp->xmit_profiler,1);
   if(udpp->xmit_profiler.ms<udpp->status.xmit_speed)
    {
    if(udpp->status.xmit_pkts_total!=udpp->last_total_pkts_sent)
     {
     udpp->status.xmit_que_misses++;  // ashead
     udpp->last_total_pkts_sent=udpp->status.xmit_pkts_total;//total_pkts_sent;
     }
    can_xmit=NO;
    }
   }
  if(can_xmit==YES)
   {
   isok=YES;
   if(udpp->status.is_flowcontrol_set==YES)
    {
    isok=NO;
    FD_ZERO(&set);
    FD_SET(udpp->sock,&set);
    WSASetLastError(0);
    tv.tv_sec=0;
    tv.tv_usec=0;
    val=select(0,0,&set,0,&tv);
    if(val==SOCKET_ERROR) { oof; oow; }
    if(FD_ISSET(udpp->sock,&set)!=0) { isok=YES; }
    }

   if(isok==YES)
    {
    aaQueStatus(udpp->xmit_que,&qs);
    if(qs.bytes<(sizeof(addr)+4))   { return RET_YES; }
    if((ret=aaQuePeek(udpp->xmit_que,0,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
    aaMemoryCopy(&addr,sizeof(addr),&tmp[0]); // optim: change to cast
    aaMemoryPeekDword(&tmp[sizeof(addr)],0,(HP)&bytes); // optim: change to cast
    if(qs.bytes<(sizeof(addr)+4+bytes)) { return RET_YES; }
    if(aaQuePeek(udpp->xmit_que,0,sizeof(addr)+4+bytes,aa.net_system.tmpbuf)!=RET_YES) { return RET_FAILED; }
    if((len=sendto(udpp->sock,(CP)&aa.net_system.tmpbuf[sizeof(addr)+4],bytes,0,(struct sockaddr *)&addr,sizeof(addr)))>=0)
     {
     if(len!=bytes) { oof; return RET_FAILED; }
     udpp->status.xmit_bytes_total+=bytes;
     udpp->xmit_bytes_total_recent+=(bytes+8);
     udpp->xmit_pkts_total_recent++;
     if((ret=aaQueDiscard(udpp->xmit_que,bytes+sizeof(addr)+4))!=RET_YES)  { oops; return ret; }
     udpp->status.xmit_pkts_total++;
     udpp->status.xmit_pkts_qued--;
     aa.net_system.net_status.total_udp_packets_sent++;
     if(udpp->status.xmit_speed!=0.0)  {   aaTimerProfilerInit(&udpp->xmit_profiler,1); }
     }
    }
   }
  }


// aa_NetSystemCalculateUdpTimers((VP)&udpp);
 return RET_YES;
 }







 B aa_NetSystemProcessIcmp             (PP mem,B doread,B dowrite)
 {
 B ret;
 _questatus qs;
 _aa_neticmpobject*icmpp;
 _aa_netipheader*iph;
 struct sockaddr_in addr;
 N len,bytes;
 BP tmpbuf=NULL_POINTR;
 B tmp[128];
 D d1,d2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(icmpp,_aa_neticmpobject*,*mem);
 if((ret=aa_MemoryTemp((VP)&tmpbuf,_64K+_1K,aa_MEMORYTEMP_IcmpProc))!=RET_YES) { return ret; }
 icmpp->calc_timer_cycle++;
 if(icmpp->calc_timer_cycle%10==0||icmpp->calc_timer_cycle<20)
  {
  aaTimerTikElapsed(icmpp->ms_root,&icmpp->status.ms);
  aaTimerTikElapsed(icmpp->inactive_ms_root,&icmpp->status.inactivity);
  d1=(D)icmpp->status.ms/1000.0;
  if(d1!=0.0)
   {
   d2=icmpp->status.total_bytes_sent;     d2=d2/d1; icmpp->status.xmit_byte_rate=(H)d2;
   d2=icmpp->status.total_bytes_received; d2=d2/d1; icmpp->status.rcve_byte_rate=(H)d2;
   d2=icmpp->status.total_pkts_sent;      d2=d2/d1; icmpp->status.xmit_pkt_rate=(H)d2;
   d2=icmpp->status.total_pkts_received;  d2=d2/d1; icmpp->status.rcve_pkt_rate=(H)d2;
   }
  }
// icmpp->status.rcve_byte_rate=
// BUG,"%i %i %i",icmpp->status.total_bytes_received,icmpp->status.ms,icmpp->status.total_bytes_received/(icmpp->status.ms+1));
 if(doread)
  {
  len=sizeof(addr);

  if((bytes=recvfrom(icmpp->sock,(CP)tmpbuf,0x10000,0,(struct sockaddr *)&addr,(ZP)&len))>=0)
   {
   if((ret=aaQueWrite(icmpp->rcve_que,sizeof(addr),&addr))!=RET_YES) { return ret; }
   bytes-=sizeof(_aa_netipheader);
   bytes-=sizeof(_aa_neticmpheader);
   if((ret=aaQueWrite(icmpp->rcve_que,4,&bytes))!=RET_YES) { return ret; }
   aaCast(iph,_aa_netipheader*,tmpbuf);
   if((ret=aaQueWrite(icmpp->rcve_que,4,&iph->dst_ip.s_addr))!=RET_YES) { return ret; }
   if((ret=aaQueWrite(icmpp->rcve_que,sizeof(_aa_neticmpheader),&tmpbuf[sizeof(_aa_netipheader)]))!=RET_YES) { return ret; }
   if(bytes!=0)
    {
    if((ret=aaQueWrite(icmpp->rcve_que,bytes,&tmpbuf[sizeof(_aa_netipheader)+sizeof(_aa_neticmpheader)]))!=RET_YES) { return ret; }
    }
   icmpp->status.rcve_pkts_qued++;
   }
  }

 if(dowrite&&icmpp->status.xmit_pkts_qued!=0)
  {
  aaQueStatus(icmpp->xmit_que,&qs);
  if(qs.bytes<(sizeof(addr)+4+sizeof(_aa_neticmpheader)))   { return RET_YES; }
  if((ret=aaQuePeek(icmpp->xmit_que,0,sizeof(addr)+4+sizeof(_aa_neticmpheader),tmp))!=RET_YES) { return ret; }
  aaMemoryCopy(&addr,sizeof(addr),&tmp[0]); // optim: change to cast
  aaMemoryPeekDword(&tmp[sizeof(addr)],0,(HP)&bytes); // optim: change to cast
  if(qs.bytes<(sizeof(addr)+4+sizeof(_aa_neticmpheader)+bytes)) { return RET_YES; }
  if(aaQuePeek(icmpp->xmit_que,sizeof(addr)+4,sizeof(_aa_neticmpheader)+bytes,tmpbuf)!=RET_YES) { return RET_FAILED; }
  if((len=sendto(icmpp->sock,(CP) tmpbuf,sizeof(_aa_neticmpheader)+bytes,0,(struct sockaddr *)&addr,sizeof(addr)))>=0)
   {
   if(len!=(N)(sizeof(_aa_neticmpheader)+bytes)) { oof; Boop; return RET_FAILED; } // ningy added (N)
   if((ret=aaQueDiscard(icmpp->xmit_que,sizeof(addr)+4+len))!=RET_YES)  { return ret; }
   icmpp->status.total_pkts_sent++;
   icmpp->status.xmit_pkts_qued--;
   }
//  else
//   {
//   Z ee=WSAGetLastError();    BUG,"%i",ee);
//   }
  }
 return RET_YES;
 }


////



 B aa_NetSystemProcessSniff            (PP mem)
 {
 B ret;
 _aa_netsniffobject*snifp;
 D d1,d2;
 BP tmpbuf=NULL_POINTR;
 N bytes;
 _sniffheaderip*snh;
 _sniffheadertcp*snhtcp;
// B rdot[65];
//  B ldot[65];
 WP wp;
 BP actual_data_ptr;
 H actual_data_len;
 H val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  { return RET_BADPARM; }
 aaCast(snifp,_aa_netsniffobject*,*mem);
 snifp->calc_timer_cycle++;
 if(snifp->calc_timer_cycle%5==0||snifp->calc_timer_cycle<20)
  {
  aaTimerTikElapsed(snifp->ms_root,&snifp->status.ms);
  aaTimerTikElapsed(snifp->inactive_ms_root,&snifp->status.inactivity);
  d1=(D)snifp->status.ms/1000.0;
  if(d1!=0.0)
   {
   d2=snifp->status.total_bytes_received; d2=d2/d1; snifp->status.rcve_byte_rate=(H)d2;
   d2=snifp->status.total_pkts_received;  d2=d2/d1; snifp->status.rcve_pkt_rate=(H)d2;
   }
  }
 if((ret=aa_MemoryTemp((VP)&tmpbuf,_64K+_1K,aa_MEMORYTEMP_SniffProc))!=RET_YES) { oops; return ret; }
 bytes=recv(snifp->sock,(CP)tmpbuf,65535,0);

 if(bytes!=SOCKET_ERROR)
  {
  if(bytes>1500) { aaNote(0,"lll %i",bytes); } //appLog(2,"sssssss %i",bytes);
  if(bytes>=(int)sizeof(_sniffheaderip))
   {
   snh=(_sniffheaderip*)tmpbuf;
   snh->tot_len=aaNumSwapWord(snh->tot_len);
   snh->packet_id=aaNumSwapWord(snh->packet_id);
   snh->hdr_crc=aaNumSwapWord(snh->hdr_crc);
   wp=(WP)&tmpbuf[6];
   *wp=aaNumSwapWord(*wp);
   if(snh->frag_offset!=0) { aaNote(0,"fragoff=%i",snh->frag_offset); return RET_NO; }
   if(snh->protocol!=6) { return RET_NO; } // only tcp allowed for now
   if(snh->protocol==6)
    {
    snhtcp=(_sniffheadertcp*)&tmpbuf[sizeof(_sniffheaderip)];
    snhtcp->src_port=aaNumSwapWord(snhtcp->src_port);
    snhtcp->dst_port=aaNumSwapWord(snhtcp->dst_port);
    snhtcp->seq_number=aaNumSwapDword(snhtcp->seq_number);
    snhtcp->ack_number=aaNumSwapDword(snhtcp->ack_number);
    snhtcp->window=aaNumSwapWord(snhtcp->window);
    snhtcp->crc=aaNumSwapWord(snhtcp->crc);
    actual_data_ptr=(BP)&tmpbuf[sizeof(_sniffheaderip)+(snhtcp->data_offset*4)];
    actual_data_len=(bytes-(actual_data_ptr-tmpbuf));//-sizeof(_sniffheaderip);
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(Q),&aa_msrunning))!=RET_YES) { oops; return ret; }
    val=bytes;
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    val=snh->hlen*4;
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    if((ret=aaQueWrite(snifp->rcve_que,val,snh))!=RET_YES) { oops; return ret; }
    val=(snhtcp->data_offset*4);//-(snh->hlen*4);// ;//bytes-(snh->hlen*4);
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    if((ret=aaQueWrite(snifp->rcve_que,val,snhtcp))!=RET_YES) { oops; return ret; }
    val=actual_data_len;
    if((ret=aaQueWrite(snifp->rcve_que,sizeof(H),&val))!=RET_YES) { oops; return ret; }
    if(val>0)
     {
     if((ret=aaQueWrite(snifp->rcve_que,val,actual_data_ptr))!=RET_YES) { oops; return ret; }
     }
    snifp->status.rcve_pkts_qued++;
    return RET_YES;
    }
   }
  else
   {
   ///appLog(2,"gracefull close ?? %i",bytes);
   }
  }
 else
  {
  int e=WSAGetLastError();
  if(e!=WSAEWOULDBLOCK) {}//appLog(2,".. wsaerr=%i",WSAGetLastError());
  }

 return RET_NO;
 }






 K aa_NetSystemProc                    (HWND wnd,UINT msg,WPARAM wparm,LPARAM lparm)
 {
 _aa_netdnsobject*dnsp;
 _aa_netsniffobject*snifp;
 _aa_neticmpobject*icmpp;
 //_aa_netudpobject*udpp;
 _aa_nettcpportobject*prtp;
 _aa_nettcpcallobject*calp;
 N len;
 struct sockaddr_in addr;
 SOCKET new_sock;
 H call_handle,go,prq;
 BP bp;
 _aa_objectinstanceheader*oih;
  H sh;
  S B isin=0;


 if(isin==0)
  {
  isin=1;
  }
 else
  {
  logg("zzzalready in %i msg=%i",isin,msg);
  }



 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

#if 0
 if(wnd!=aa.net_system.window&&aa.net_system.window!=0)
  {
  aa_last_line_executed=__LINE__;
  B c_txt[_1K],t_txt[_1K];
  aa_CoreSystemWindowsMsgToString(msg,aa_last_line_info);
  ///aaHwndInfoGet(wnd,NULL,NULL,NULL,c_txt,t_txt);
  aaLog(-777,"wnd=%x nw=%x %i %s c=%s t=%s",wnd,aa.net_system.window,aa_last_line_executed,aa_last_line_info,c_txt,t_txt);
  //return DefWindowProc(wnd, msg, wparm, lparm);
  return 0;
  }
  #endif

//aa_last_line_executed=__LINE__;  aa_CoreSystemWindowsMsgToString(msg,aa_last_line_info); aaLog(-777,"%i msg=%u %x %i %s",__LINE__,msg,wnd,aa_last_line_executed,aa_last_line_info);


 if(msg==aa.net_system.dns_message_id)
  {
  if(aa_NetSystemFindDnsByResolverHandle(NULL,(VP)&dnsp,(HANDLE)wparm)==YES)
   {
   //BUG,"dns==%i",HIWORD(lparm));
   switch(HIWORD(lparm))
    {
    case 0:                dnsp->stage=3;   break; // complete
    case WSAHOST_NOT_FOUND: dnsp->stage=2;   break; // dns not found
    case WSANO_DATA: dnsp->stage=2;   break; // dns not found ( but i think this could mean something else )
    default:    dnsp->stage=1; break; // dns failed
    }
   logg("NetSystemProc: DnsEvent: = %i",HIWORD(lparm));
   }
  isin=0;
  return 0;
  }



 if(msg==aa.net_system.sniff_message_id)
  {
  if(aa_NetSystemFindSniffBySock(NULL,(VP)&snifp,(SOCKET)wparm)==YES)
   {
   switch(LOWORD(lparm))
    {
    case FD_READ:
    prq=snifp->status.rcve_pkts_qued;
    for(go=0;go<256;go++)
     {
     aa_NetSystemProcessSniff((VP)&snifp);
     if(snifp->status.rcve_pkts_qued==prq) break;
     prq=snifp->status.rcve_pkts_qued;
     }
 ///   if(go>5) appLog(2,"a.. %i %i %i",go,prq,snifp->status.rcve_pkts_qued);
    break;
    case FD_WRITE:
    ///appLog(2,"sniff fdwri");
    break;
    case FD_ACCEPT:
    ///appLog(2,"sniff fdacc");
    break;
    case FD_CLOSE:
    //appLog(2,"sniff fdclo");
    break;
    case FD_CONNECT:
    //appLog(2,"sniff fdcon");
    break;

    /*
    default:
    break;
    */
    }
   }
     isin=0;
  return 0;
  }




 if(msg==aa.net_system.icmp_message_id)
  {
  if(aa_NetSystemFindIcmpBySock(NULL,(VP)&icmpp,(SOCKET)wparm)==YES)
   {
   switch(LOWORD(lparm))
    {
    case FD_WRITE:
    aa_NetSystemProcessIcmp((VP)&icmpp,NO,YES);
    break;
    case FD_READ:
    aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
    break;
    default:
    break;
    }
   }
     isin=0;
  return 0;
  }





 if(msg==aa.net_system.tcp_message_id)
  {
  switch(LOWORD(lparm))
   {
   case FD_ACCEPT: ///////////////////////////////////////////////////////
   if(aa_NetSystemFindPortBySock(NULL,(VP)&prtp,(SOCKET)wparm)==YES)
    {
    len=sizeof(addr);
    if((new_sock=accept(wparm,(struct sockaddr *)&addr,(Z FAR*)&len))==INVALID_SOCKET) { break; }

    // replace beep: in the event of object instance limit reached, with portstatus.calls_dropped
    //               then close the socket and break from case..
    if(aa_ObjectCreate(aa.net_system.tcpcall_object_id,&call_handle,(VP)&calp)!=YES) { oof; Boop; }
    calp->self_handle=call_handle;
    calp->status.is_inprogress=YES;
    calp->status.is_incoming=YES;
    calp->status.index=call_handle-((aa.net_system.tcpcall_object_id*aa_OBJ_MAX_PER_ID)+aa_OBJ_BASE_HANDLE);
    calp->sock=new_sock;
    calp->status.sock=new_sock;
    calp->port_sock=wparm;
    calp->socket_used=YES;
    if(aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,&calp->status.remote_adr.ip,&calp->status.remote_adr.port)!=YES)
     {
     logg("jesse");
     }
    aaTimerTikGet(&calp->ms_root);
    calp->inactive_rcve_ms_root=calp->ms_root;
    calp->inactive_xmit_ms_root=calp->ms_root;
    calp->status.rcve_inactivity=0;
    calp->status.xmit_inactivity=0;
    prtp->status.calls_waiting++;
    prtp->status.calls_total++;
    prtp->status.calls_inuse++;
    aaCast(bp,BP,calp);
    bp-=sizeof(_aa_objectinstanceheader);
    aaCast(oih,_aa_objectinstanceheader*,bp);
    calp->status.session=oih->sesh;
    calp->status.rcve_slicer_length=_4K;//512;
    calp->status.xmit_slicer_length=_4K;//512;
    calp->status.number=aa.net_system.net_status.total_tcp_call_count;

  aaStringCopyf(calp->status.hancock,"%s",aa_common_name[calp->status.is_incoming][calp->status.number%26]);
  if((calp->status.number/26)>0) aaStringAppendf(calp->status.hancock,"%u",(calp->status.number/26));

//    aaStringCopyf(calp->status.hancock,"%s%u",aa_common_name[calp->status.number%2][calp->status.number%26],calp->status.number/26);

    aa.net_system.net_status.total_tcp_call_count++;
    aa.net_system.net_status.current_incoming_tcp_call_count++;
    aa.net_system.net_status.total_incoming_tcp_call_count++;
    aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);
    aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
    logg("--call local sock = %i",calp->sock);
    logg("--port sock wparm = %i",calp->port_sock);
    }
   else
    {
    //BUGGY;
    oof;
    closesocket((SOCKET)wparm);
    }
   break;


   case FD_CONNECT: ///////////////////////////////////////////////////////
   if(aa_NetSystemFindCallBySock(NULL,(VP)&calp,(SOCKET)wparm,NO,YES)==YES)
    {
    if(HIWORD(lparm))
     {
     if(calp->status.is_closed_by_local==NO)
      {
      if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
      calp->status.is_closed_by_remote=YES;
      }
     calp->status.is_closed=YES;
     break;
     }
    if(WSAAsyncSelect(calp->sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CLOSE))//|FD_READ|FD_WRITE))
     {
     oof;
     oow;
     calp->status.is_failed=YES;
     break;
     }
    if(aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,&calp->status.remote_adr.ip,&calp->status.remote_adr.port)!=YES)
     {
     aaNote(0,"ewdkewo");
     }
    aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);
    aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
    aa.net_system.net_status.current_tcp_calls_connected++;
    calp->status.is_connected=YES;
    if(calp->status.is_nodelay)
     {
     Z bnod=(Z)calp->status.is_nodelay;
     setsockopt(calp->sock,IPPROTO_TCP,TCP_NODELAY,(CP)&bnod,sizeof(Z));
     }
    }
   break;




   case FD_CLOSE: // check HIWORD(lparm) for error for all cases
   if(aa_NetSystemFindCallBySock(NULL,(VP)&calp,(SOCKET)wparm,NO,NO)==YES)
    {
    if(calp->status.is_closed_by_remote!=YES) aaTimerTikGet(&calp->remote_closed_ms_root);
    calp->status.is_closed_by_remote=YES;
    calp->status.is_closed=YES;
    }
   break;

   default:
   break;
   }
    isin=0;
  return 0;
  }

/*
  if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,NULL,(HWND)wparm)!=YES)
   {
   return 1;
   }
*/

#if 1
//sprintf(aa_last_line_info,"msg=%i ",msg);
 if(msg==WM_QUIT)
  {
  logg("NetSystemProc: Window %i got WM_QUIT",(H)wnd);
  }

 if(msg==WM_SETFOCUS)
  {

  if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,NULL,(HWND)wparm)==YES) // ashod ?
   {
   aaSurfaceFocus(sh);
//   aaDebugf("set focus net");
   }
  else
   {
   //aaDebugf("gogog");
   }
  }

#endif

// return 0;
aa_last_line_executed=__LINE__;
  isin=0;
//return 1;
 return DefWindowProc(wnd,msg,wparm,lparm);
 }











 B aa_NetSystemYield                   (V)
 {
 _aa_netudpobject*udpp;
 _aa_nettcpcallobject*calp;
 H tik,i,el[6];
  //_aa_nettcpportobject*prtp;
//  _tcpportmanager pman;
 // H han;
// _tcpcallunit cu;
// H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaTimerTikGet(&tik);
 for(i=0;i<3;i++)  {  aaTimerTikElapsedUsingTik(aa.net_system.sub_yield_tik[i],tik,&el[i]);  }

 if(el[0]>=(H)(1000.0/2.0)) // commented out october september 2015
  {
  if(aa_ObjectNext(aa.net_system.tcpcall_object_id,0,(VP)&calp,&aa.net_system.yield_tcpcall_counter)==YES) { aa_NetSystemProcessTcp((VP)&calp); }
  aa.net_system.sub_yield_tik[0]=tik;
  }
 if(el[1]>=(H)(1000.0/1.5))
  {
  if(aa_ObjectNext(aa.net_system.udp_object_id,0,(VP)&udpp,&aa.net_system.yield_udp_counter)==YES) {  aa_NetSystemProcessUdp((VP)&udpp); }
  aa.net_system.sub_yield_tik[1]=tik;
  }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aa_FontSystemStart                  (V)
 {
 B ret;
 _aa_fontobject*fntp;
 H i,x,y,off,img_off,nd;

 logg("aa_FontSystemStart()");
 font_4x8=0;
 font_4x16=0;
 font_8x8=0;
 font_8x16=0;
 font_8x32=0;
 font_16x16=0;
 font_16x32=0;


 aa_ObjectIdNew(&aa.font_system.object_id);
 aa_ObjectDefine(aa.font_system.object_id,sizeof(_aa_fontobject),300,16,aaFontDestroy,"Font");

 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_8x8,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_8x8;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font8x8");
 aaSizeSet(&fntp->status.size,8,8);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->img,8*8*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x8); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_8x8,YES);
 for(i=0;i<256;i++)
  {
  fntp->char_width[i]=8;
  off=i*8;
  img_off=((i/16)*(16*64))+((i%16)*8);
  for(y=0;y<8;y++)
   {
   nd=(y*16*8);
   for(x=0;x<8;x++)
    {
    if(aaBitGet(aa_fontdos[off],x)==YES) { fntp->img[img_off+(nd)+x]=255; }
    else                                 { fntp->img[img_off+(nd)+x]=0; }
    }
   off++;
   }
  }

 /////////////
 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_8x16,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_8x16;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font8x16");
 aaSizeSet(&fntp->status.size,8,16);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->img,8*16*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x16); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_8x16,YES);
 for(i=0;i<256;i++)
  {
  fntp->char_width[i]=8;
  off=i*8;
  img_off=((i/16)*(16*128))+((i%16)*8);
  for(y=0;y<16;y++)
   {
   nd=(y*16*8);
   for(x=0;x<8;x++)
    {
    if(aaBitGet(aa_fontdos[off],x)==YES) { fntp->img[img_off+(nd)+x]=255; }
    else                                   { fntp->img[img_off+(nd)+x]=0; }
    }
   if((y%2)==1){   off++; }
   }
  }
 ////


 ///-///////////
 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_8x32,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_8x32;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font8x32");
 aaSizeSet(&fntp->status.size,8,32);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->img,8*32*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x32); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_8x32,YES);
 for(i=0;i<256;i++)
  {
  fntp->char_width[i]=8;
  off=i*8;
  img_off=((i/16)*(16*256))+((i%16)*8);
  for(y=0;y<32;y++)
   {
   nd=(y*16*8);
   for(x=0;x<8;x++)
    {
    if(aaBitGet(aa_fontdos[off],x)==YES) { fntp->img[img_off+(nd)+x]=255; }
    else                                 { fntp->img[img_off+(nd)+x]=0; }
    }
   if((y%4)==3){   off++; }
   }
  }
 ////





 /////////////
 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_4x8,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_4x8;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font4x8");
 aaSizeSet(&fntp->status.size,4,8);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->img,4*8*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x16); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_4x8,YES);
 for(i=0;i<256;i++)
  {
  fntp->char_width[i]=4;
  off=i*8;
  img_off=((i/16)*(16*32))+((i%16)*4);
  for(y=0;y<8;y++)
   {
   nd=(y*16*4);
   for(x=0;x<4;x++)
    {
    if(aaBitGet(aa_fontdos[off],(x*2))==YES) { fntp->img[img_off+(nd)+x]=255; }
    else                                       { fntp->img[img_off+(nd)+x]=0; }
    }
   off++;
   }
  }
 ////

 /////////////
 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_4x16,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_4x16;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font4x16");
 aaSizeSet(&fntp->status.size,4,16);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->img,4*16*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x16); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_4x16,YES);
 for(i=0;i<256;i++)
  {
  fntp->char_width[i]=4;
  off=i*8;
  img_off=((i/16)*(16*64))+((i%16)*4);
  for(y=0;y<16;y++)
   {
   nd=(y*16*4);
   for(x=0;x<4;x++)
    {
    if(aaBitGet(aa_fontdos[off],(x*2))==YES) { fntp->img[img_off+(nd)+x]=255; }
    else                                      { fntp->img[img_off+(nd)+x]=0; }
    }
   //off++;
   if((y%2)==1){   off++; }
   }
  }
 ////

 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_16x16,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_16x16;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font16x16");
 aaSizeSet(&fntp->status.size,16,16);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->img,16*16*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x8); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_16x16,YES);

 for(i=0;i<256;i++)
  {
  fntp->char_width[i]=16;
  off=i*8;
  img_off=((i/16)*(16*256))+((i%16)*16);
  for(y=0;y<16;y++)
   {
   nd=(y*16*16);
   for(x=0;x<16;x++)
    {
    if(aaBitGet(aa_fontdos[off],x/2)==YES)     {     fntp->img[img_off+(nd)+x]=255;     }
    else                                         {     fntp->img[img_off+(nd)+x]=0;     }
    }
   if((y%2)==1){   off++; }
   }
  }

 ////

 if((ret=aa_ObjectCreate(aa.font_system.object_id,&font_16x32,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=font_16x32;
 fntp->status.is_mono_width=YES;
 fntp->status.is_mono_forced=NO;
 aaStringCopy(fntp->status.face_name,"aa.system.font16x32");
 aaSizeSet(&fntp->status.size,16,32);
 aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.size);
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 if((ret=aa_MemoryAllocate((VP)&fntp->img,16*32*256,"SysFont",NO))!=RET_YES) { aa_ObjectDestroy(aa.font_system.object_id,font_8x8); oops; return ret; }
 aa_ObjectProtect(aa.font_system.object_id,font_16x32,YES);


 for(i=0;i<256;i++)
  {
  fntp->char_width[i]=16;
  off=i*8;
  img_off=((i/16)*(16*512))+((i%16)*16);
  for(y=0;y<32;y++)
   {
   nd=(y*16*16);
   for(x=0;x<16;x++)
    {
    if(aaBitGet(aa_fontdos[off],x/2)==YES)     {     fntp->img[img_off+(nd)+x]=255;     }
    else                                         {     fntp->img[img_off+(nd)+x]=0;     }
    }
   if((y%4)==3){   off++; }
   }
  }


 aa.font_system.font_4x8=font_4x8;
 aa.font_system.font_4x16=font_4x16;
 aa.font_system.font_8x8=font_8x8;
 aa.font_system.font_8x16=font_8x16;
 aa.font_system.font_8x32=font_8x32;
 aa.font_system.font_16x16=font_16x16;
 aa.font_system.font_16x32=font_16x32;

 logg("");
 return RET_YES;
 }







 V aa_FontSystemStop                   (V)
 {
 aa_ObjectProtect(aa.font_system.object_id,font_4x8,NO);
 aaFontDestroy(aa.font_system.font_4x8);
 aa_ObjectProtect(aa.font_system.object_id,font_4x16,NO);
 aaFontDestroy(aa.font_system.font_4x16);
 aa_ObjectProtect(aa.font_system.object_id,font_8x8,NO);
 aaFontDestroy(aa.font_system.font_8x8);
 aa_ObjectProtect(aa.font_system.object_id,font_8x16,NO);
 aaFontDestroy(aa.font_system.font_8x16);
 aa_ObjectProtect(aa.font_system.object_id,font_8x32,NO);
 aaFontDestroy(aa.font_system.font_8x32);
 aa_ObjectProtect(aa.font_system.object_id,font_16x16,NO);
 aaFontDestroy(aa.font_system.font_16x16);
 aa_ObjectProtect(aa.font_system.object_id,font_16x32,NO);
 aaFontDestroy(aa.font_system.font_16x32);
 aa_ObjectUndefine(aa.font_system.object_id);
 logg("aa_FontSystemStop()");
 logg("");
 }





 K aa_FontCallBack                     (ENUMLOGFONT FAR*lpelf,NEWTEXTMETRIC FAR*lpntm,Z FontType,LPARAM lParam)
 {
 B ret;
 BP mem,prv;
 _data*dp;
 H sl;

 if(lpntm||FontType||lParam) {}
 aaCast(dp,_data*,lParam);
 if(dp==NULL) { return 0; }
 aaStringLen(lpelf->elfFullName,&sl);
 if(sl>32) { return 1; }
 oof;
 if(dp->field_count!=0)    { aaDataFieldInfoGetByIndex(dp,dp->field_count-1,0,0,(VP)&prv); }
 else                      { prv=NULL; }
 if(prv!=NULL)             { if(aaStringICompare(lpelf->elfFullName,prv,0)==YES) { return 1; }  }
 if((ret=aaDataFieldAdd(dp,0,33,0,(VP)&mem))!=YES) { oops; }
 aaStringCopy(mem,lpelf->elfFullName);
 return 1;
 }



/*-----------------------------------------------------------------------*/


/* http://www.catch22.net/tuts/tips2
void ForceVisibleDisplay(HWND hwnd)
{
    RECT rect;
    GetWindowRect(hwnd, &rect);

    // check if the specified window-rectangle is visible on any display
    if(NULL==MonitorFromRect(&rect, MONITOR_DEFAULTTONULL))
    {
        HMONITOR hMonitor;
        MONITORINFO mi = { sizeof(mi) };

        // find the nearest display to the rectangle
        hMonitor = MonitorFromRect(&rect, MONITOR_DEFAULTTONEAREST);

        GetMonitorInfo(hMonitor, &mi);

        // center window rectangle
        rect.left = mi.rcWork.left + ((mi.rcWork.right - mi.rcWork.left) - (rect.right-rect.left))/2;
        rect.top  = mi.rcWork.top  + ((mi.rcWork.bottom - mi.rcWork.top) - (rect.bottom-rect.top))/2;

        SetWindowPos(hwnd, 0, rect.left, rect.top, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
    }
}

*/

 B aa_DisplaySystemStart               (V)
 {
 logg("aa_DisplaySystemStart()");
 return RET_YES;
 }



 V aa_DisplaySystemStop                (V)
 {
 logg("aa_DisplaySystemStop()");
 if(aa.display_system.is_revert==YES)
  {
  oof;
  ///aaDisplaySet(&aa.display_system.launch_display_info.screen_size,aa.display_system.launch_display_info.screen_bits,NO);
  }
 if(aa.display_system.gdi32_module!=NULL)
  {
  FreeLibrary(aa.display_system.gdi32_module);
  aa.display_system.gdi32_module=NULL;
  }
 }





 B aa_DisplaySystemLoadModules         (V)
 {
 HANDLE mod;

 logg("aa_DisplaySystemLoadModules");
 if(aa.display_system.gdi32_module==NULL)
  {
  if((mod=LoadLibrary("gdi32.dll"))==NULL) {  return RET_FAILED; }
  aa.display_system.gdi32_module=mod;
  if((aa.display_system.GetDeviceGammaRamp=(getDeviceGammaRamp)GetProcAddress(aa.display_system.gdi32_module,"GetDeviceGammaRamp"))==NULL) { oof; oow; }
  if((aa.display_system.SetDeviceGammaRamp=(setDeviceGammaRamp)GetProcAddress(aa.display_system.gdi32_module,"SetDeviceGammaRamp"))==NULL) { oof; oow; }
  }

 return RET_YES;
 }






 B aa_DisplayGetMonitorSizeFromEDID    (HKEY hDevRegKey,WP WidthMm,WP HeightMm)
 {
 N retValue,i;
 H dwType,AcutalValueNameLength,edidsize;
 TCHAR valueName[NAME_SIZE];
 B EDIDdata[_1K];

 AcutalValueNameLength=NAME_SIZE;
 edidsize=sizeof(EDIDdata);
 for(i=0,retValue=ERROR_SUCCESS;retValue!=ERROR_NO_MORE_ITEMS;++i)
  {
  retValue=RegEnumValue(hDevRegKey,i,&valueName[0],&AcutalValueNameLength,NULL,&dwType,EDIDdata,&edidsize);
  if(retValue!=ERROR_SUCCESS)                   { continue; }
  if(aaStringICompare(valueName,"EDID",0)!=YES) { continue; }
  *WidthMm=((EDIDdata[21]))*10;
  *HeightMm=((EDIDdata[22]))*10;
//  aaNote(0,"is %i,%i",*WidthMm,*HeightMm);
  return 1;
  }
 return 0;
 }






 B aa_DisplayGetSizeForDevID           (CP TargetDevID,WP WidthMm,WP HeightMm)
 {
 B bRes;
 H i;
 SP_DEVINFO_DATA devInfoData;
 VP devInfo;
 HKEY hDevRegKey;

 UNUSE(TargetDevID);
 devInfo=SetupDiGetClassDevsExA(&GUID_CLASS_MONITOR,NULL,NULL,DIGCF_PRESENT,NULL,NULL,NULL);
 if(NULL==devInfo) return 0;
 bRes=0;
 for(i=0;ERROR_NO_MORE_ITEMS!=GetLastError();++i)
  {
  memset(&devInfoData,0,sizeof(devInfoData));
  devInfoData.cbSize=sizeof(devInfoData);
  //aaNote(0,"%s %s",__func__,devInfo);
  if(SetupDiEnumDeviceInfo(devInfo,i,&devInfoData))
   {
   hDevRegKey=SetupDiOpenDevRegKey(devInfo,&devInfoData,DICS_FLAG_GLOBAL,0,DIREG_DEV,KEY_READ);
   if(!hDevRegKey||(hDevRegKey==INVALID_HANDLE_VALUE)) { continue; }
//   oof;
   bRes=aa_DisplayGetMonitorSizeFromEDID(hDevRegKey,WidthMm,HeightMm);
   RegCloseKey(hDevRegKey);
   if(bRes) { break; }
   }
  }
 SetupDiDestroyDeviceInfoList(devInfo);
 return bRes;
 }




/*-----------------------------------------------------------------------*/




 B aa_SurfaceSystemStart               (V)
 {
 logg("aa_SurfaceSystemStart()");
 aa_ObjectIdNew(&aa.surface_system.object_id);
 aa_ObjectDefine(aa.surface_system.object_id,sizeof(_aa_surfaceobject),1000,16,aaSurfaceDestroy,"Surface");
 aa.surface_system.caret_speed=GetCaretBlinkTime();
// if((aa.surface_system.tool_tip_window=CreateWindowEx(0,TOOLTIPS_CLASS,NULL,TTS_ALWAYSTIP,0,0,2,2,NULL,NULL,aa.core_system.this_instance,NULL))==NULL) { oof; }
 logg("");
 return RET_YES;
 }




 V aa_SurfaceSystemStop                (V)
 {
 logg("aa_SurfaceSystemStop()");
 aa_ObjectUndefine(aa.surface_system.object_id);
// if(aa.surface_system.tool_tip_window!=0) {  DestroyWindow(aa.surface_system.tool_tip_window); }
 logg("");
 }






 B aa_SurfaceSystemFindSurfaceByHwnd   (HP handle,PP mem,HWND hwnd)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_surfaceobject*surp;
 H base,h,instance_stride;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }
 if(mem) { *mem=0; }
 id=aa.surface_system.object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(surp,_aa_surfaceobject*,bp);
   if(surp->status.hwnd==hwnd)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }





 V aa_SurfaceSystemYuvTablesInit       (V)
 {
 H i;

 if(aa.surface_system.yuva_tables_init!=YES)
  {
  for(i=0;i<256;i++)
   {
   aa.surface_system.RGB_Y_tab[i]=FIX_OUT(RGB_Y_OUT)*(i-Y_ADD_OUT);
   aa.surface_system.B_U_tab[i]=FIX_OUT(B_U_OUT)*(i-U_ADD_OUT);
   aa.surface_system.G_U_tab[i]=FIX_OUT(G_U_OUT)*(i-U_ADD_OUT);
   aa.surface_system.G_V_tab[i]=FIX_OUT(G_V_OUT)*(i-V_ADD_OUT);
   aa.surface_system.R_V_tab[i]=FIX_OUT(R_V_OUT)*(i-V_ADD_OUT);
   }
  aa.surface_system.yuva_tables_init=YES;
  }
 }







 B aaSurfacePixelPutProc               (VP surfs,N x,N y,_rgba*p1)
 {
 B ret;
 H off;
 _aa_surfaceobject*surp;
 _rgba*pn;
 _rgba temp_rgba;
 N a1,a2;
 N xx,yy,px,py,zx,zy;
 _pixelstyle*pstylep;
 N xs,xe;
 N ys,ye;
 B alpha;
 B falpha;
 B halpha;
 D lumr,lumg,lumb;
 D dubr,dubg,dubb;

 aaCast(surp,_aa_surfaceobject*,surfs);
 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 xx=x;
 yy=y;
 if(p1==NULL) { return RET_BADPARM; }

 if(pstylep->mode==0)  // base brush
  {
  while(1)
   {
   if(xx<0||yy<0||xx>=(N)surp->status.size.w||yy>=(N)surp->status.size.h) { ret=RET_BOUNDS; break; }
   if(p1->a==0) { ret=RET_YES; break; }
   if(surp->status.is_clipper)
    {
    if(xx<surp->status.clipper_rect.x||yy<surp->status.clipper_rect.y)   { ret=RET_BOUNDS; break; }
    if(xx>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { ret=RET_BOUNDS; break; }
    if(yy>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { ret=RET_BOUNDS; break; }
    }
   pn=surp->status.mem;
   if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-yy)-1)*surp->status.size.w)+xx; }
   else                           { off=(yy*surp->status.size.w)+xx; }

   if(surp->status.is_masknot)
    {
    if(surp->status.mask_not.r!=pn[off].r||surp->status.mask_not.g!=pn[off].g||surp->status.mask_not.b!=pn[off].b)
     {
     ret=RET_YES;
     break;
     }
    }
   if(surp->status.is_mask)
    {
    if(surp->status.mask.r==pn[off].r&&surp->status.mask.g==pn[off].g&&surp->status.mask.b==pn[off].b)
     {
     ret=RET_YES;
     break;
     }
    }

   if(p1->a==255)
    {
    pn[off]=*p1;
    //aaDebugf("set %i,%i,%i",pn[off].r,pn[off].g,pn[off].b);
    }
   else
    {
    temp_rgba=pn[off];
    a1=(N)(255-p1->a);
    a2=(N)(p1->a);
    pn[off].b=(B)(((a1*temp_rgba.b)+(a2*p1->b))>>8);
    pn[off].g=(B)(((a1*temp_rgba.g)+(a2*p1->g))>>8);
    pn[off].r=(B)(((a1*temp_rgba.r)+(a2*p1->r))>>8);
    pn[off].a=255;
    }
   ret=RET_YES;
   break;
   }
  return ret;
  }




 if(pstylep->mode==1) // fill brush
  {
  xs=xx-pstylep->nparm0; xe=xx+pstylep->nparm0;
  ys=yy-pstylep->nparm1; ye=yy+pstylep->nparm1;


  ret=RET_YES;
  for(yy=ys;yy<ye;yy++)
   {
   for(xx=xs;xx<xe;xx++)
    {
    if(xx<0||yy<0||xx>=(N)surp->status.size.w||yy>=(N)surp->status.size.h) {  ret=RET_BOUNDS; continue; }
    if(p1->a==0) { ret=RET_YES; continue; }
    if(surp->status.is_clipper)
     {
     if(xx<surp->status.clipper_rect.x||yy<surp->status.clipper_rect.y)   { ret=RET_BOUNDS; continue; }
     if(xx>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { ret=RET_BOUNDS; continue; }
     if(yy>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { ret=RET_BOUNDS; continue; }
     }
    pn=surp->status.mem;
    if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-yy)-1)*surp->status.size.w)+xx; }
    else                           { off=(yy*surp->status.size.w)+xx; }

    if(p1->a==255)
     {
     pn[off]=*p1;
     }
    else
     {
     temp_rgba=pn[off];
     a1=(N)(255-p1->a);
     a2=(N)(p1->a);
     pn[off].b=(B)(((a1*temp_rgba.b)+(a2*p1->b))>>8);
     pn[off].g=(B)(((a1*temp_rgba.g)+(a2*p1->g))>>8);
     pn[off].r=(B)(((a1*temp_rgba.r)+(a2*p1->r))>>8);
     pn[off].a=255;
     }
    ret=RET_YES;
    }
   }

  return ret;
  }





 if(pstylep->mode==2) // soft brush
  {
  xe=pstylep->nparm0;
  ye=pstylep->nparm1;

  falpha=p1->a;
  halpha=falpha/2;
  alpha=falpha;

  ret=RET_YES;
  for(py=0;py<ye;py++)
   {
   zy=(yy+py);
   zy=zy-(ye/2);
   if(zy<0||zy>=(N)surp->status.size.h) { continue; } // break; }
   for(px=0;px<xe;px++)
    {
    zx=(xx+px);
    zx=zx-(xe/2);
    if(zx<0||zy>=(N)surp->status.size.w) { continue; }
    if(surp->status.is_clipper)
     {
     if(zx<surp->status.clipper_rect.x||zy<surp->status.clipper_rect.y)   { ret=RET_BOUNDS; continue; }
     if(zx>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { ret=RET_BOUNDS; continue; }
     if(zy>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { ret=RET_BOUNDS; continue; }
     }
    pn=surp->status.mem;
    if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-zy)-1)*surp->status.size.w)+zx; }
    else                           { off=(zy*surp->status.size.w)+zx; }
    lumr=1.0;
    lumg=1.0;
    lumb=1.0;
    alpha=falpha;
    if(px>3) alpha=halpha;
    if(py<3) { lumr=0.3; lumg=0.4; lumb=0.2; }
    if(px>5) { lumr=2.3; lumg=2.3; lumb=2.3; }
    if(alpha!=0)
     {
     if(alpha==255)
      {
      pn[off]=*p1;
      }
     else
      {
      temp_rgba=pn[off];
      a1=(N)(255-alpha);
      a2=(N)(alpha);

      dubr=p1->r*lumr;
      dubg=p1->g*lumg;
      dubb=p1->b*lumb;

      dubr=dubr*(D)a2;
      dubg=dubg*(D)a2;
      dubb=dubb*(D)a2;


      pn[off].b=(B)((((a1*temp_rgba.b)+(N)dubr))>>8);
      pn[off].g=(B)((((a1*temp_rgba.g)+(N)dubg))>>8);
      pn[off].r=(B)((((a1*temp_rgba.r)+(N)dubb))>>8);
      pn[off].a=255;
      }
#if 0
     if(lumr!=1.0)
      {
      dubr=pn[off].r;
      dubr=dubr*lumr;
      dubr=aaNumClamp(dubr,0.0,255.0);
      pn[off].r=(B)dubr;
      }

     if(lumg!=1.0)
      {
      dubg=pn[off].g;
      dubg=dubg*lumg;
      dubg=aaNumClamp(dubg,0.0,255.0);
      pn[off].g=(B)dubg;
      }

     if(lumb!=1.0)
      {
      dubb=pn[off].b;
      dubb=dubb*lumb;
      dubb=aaNumClamp(dubb,0.0,255.0);
      pn[off].b=(B)dubb;
      }

     #endif
     }



    ret=RET_YES;
    }
   }

  return ret;
  }



 return RET_YES;
 }







/*
  case aa_PIXELSTYLE_FILL:
  aaRectSet(&r1,x-pxsz,y-pxsz,pxsz*2,pxsz*2);
  aaSurfacePixelPutProcGet(sp->self_handle,&proc_save);
  aaSurfacePixelPutProcSet(sp->self_handle,NULL);
  aaSurfaceFill(sp->self_handle,&r1,&pa);
  aaSurfacePixelPutProcSet(sp->self_handle,proc_save);
  break;
  */



 B aaSurfacePixelSetProc               (VP surfs,N x,N y,_rgba*p1)
 {
 H off;
 _aa_surfaceobject*surp;
 _rgba*pn;

 ///aa_ZIAG("aaSurfacePixelSetProc");
 if(p1==NULL) { return RET_BADPARM; }
 aaCast(surp,_aa_surfaceobject*,surfs);
 if(x<0||y<0)              { return RET_BOUNDS; }
 if(x>=(N)surp->status.size.w) { return RET_BOUNDS; }
 if(y>=(N)surp->status.size.h) { return RET_BOUNDS; }
 if(surp->status.is_clipper)
  {
  if(x<surp->status.clipper_rect.x) { return RET_BOUNDS; }
  if(y<surp->status.clipper_rect.y) { return RET_BOUNDS; }
  if(x>=(N)(surp->status.clipper_rect.x+surp->status.clipper_rect.w)) { return RET_BOUNDS; }
  if(y>=(N)(surp->status.clipper_rect.y+surp->status.clipper_rect.h)) { return RET_BOUNDS; }
  }
 pn=surp->status.mem;
 if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-y)-1)*surp->status.size.w)+x; }
 else                             { off=(y*surp->status.size.w)+x; }
// off=(y*surp->status.size.w)+x;
// off=(((surp->status.size.h-y)-1)*surp->status.size.w)+x;
 pn[off]=*p1;
 return RET_YES;
 }





 B aaSurfacePixelGetProc               (VP surfs,N x,N y,_rgba*p1)
 {
 H off;
 _aa_surfaceobject*surp;
 _rgba*pn;

 //aa_ZIAG("aaSurfacePixelGetProc");
 if(p1==NULL) { return RET_BADPARM; }
 aaCast(surp,_aa_surfaceobject*,surfs);
 if(x<0||y<0)              { p1->a=0; return RET_BOUNDS; }
 if(x>=(N)surp->status.size.w) { p1->a=0; return RET_BOUNDS; }
 if(y>=(N)surp->status.size.h) { p1->a=0; return RET_BOUNDS; }

 pn=surp->status.mem;
 if(surp->status.is_vflip==YES) { off=(((surp->status.size.h-y)-1)*surp->status.size.w)+x; }
 else                             { off=(y*surp->status.size.w)+x; }
// off=(y*surp->status.size.w)+x;
// off=(((surp->status.size.h-y)-1)*surp->status.size.w)+x;
 *p1=pn[off];
 return RET_YES;
 }










 B aa_SurfaceDecodeJpegBlock           (_aa_surfacejpegdecoder*dec,NP dat,N dc,N ac,N qt,NP old_dc)
 {
 N data,num_zeros,num_bits,val,hval,coef,i,j,found,o,p,catagory,result;
 I zz[64];
 _aa_surfacejpeghuffnode*dc_node;
 _aa_surfacejpeghuffnode*ac_node;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 dc_node=dec->huffman_node+(dc<<8);
 ac_node=dec->huffman_node+(ac<<8)+512;
 // huffman decode
 result=0;
 if(*dec->data==F8&&(*(dec->data+1)>=0xd0&&*(dec->data+1)<=0xd7))
  {
  val=(1<<dec->bits)-1;
  if((dec->byte&val)==val) { result=-2; }
  }
 if(result==0)
  {
  val=0;
  found=-1;
  for(i=1;i<=16; i++)
   {
   dec->bits--;
   if(dec->bits<0) { dec->bits=7;  dec->byte=*(++dec->data);  if(dec->byte==F8) { dec->data++; }  }
   hval= (N)((dec->byte&(1<<dec->bits))?1:0);
   val=(val<<1)|hval;
   for(j=0; j<256; j++)
    {
    if(dc_node[j].length>i) { break; }
    if((dc_node[j].length==i)&&(dc_node[j].index==val)) { found=j; break; }
    }
   if(found>-1) { break; }
   }
  if(found==-1) { result=-1; }
  else             { result=dc_node[found].code; }
  }
 //////
 data=result;
 // huffman get bits
 catagory=data&F4; result=0;
 for(i=0;i<catagory; i++)
  {
  if(--dec->bits<0) { dec->bits=7; dec->byte=*(++dec->data); if(dec->byte==0xff) { dec->data++; } }
  val=((dec->byte&(1<<dec->bits))?1:0);
  result=(result<<1)|val;
  }
 if(result<(1<<(catagory-1)))  { result-=((1<<catagory)-1); }
 /////
 *old_dc+= result;
 dat[0]=*old_dc;
 coef=1;
 do
  {
  // huffman decode
  result=0;
  if(*dec->data==F8&&(*(dec->data+1)>=0xd0&&*(dec->data+1)<=0xd7))
   {
   val=(1<<dec->bits)-1;
   if((dec->byte&val)==val) { result=-2; }
   }
  if(result==0)
   {
   val=0;
   found=-1;
   for(i=1;i<=16;i++)
    {
    dec->bits--;
    if(dec->bits<0) { dec->bits=7;  dec->byte=*(++dec->data);  if(dec->byte==F8) { dec->data++; }  }
    hval= (N)((dec->byte&(1<<dec->bits))?1:0);
    val=(val<<1)|hval;
    for(j=0;j<256;j++)
     {
     if(ac_node[j].length>i) { break; }
     if((ac_node[j].length==i)&&(ac_node[j].index==val)) { found=j; break; }
     }
    if(found>-1) { break; }
    }
   if(found==-1) { result=-1; }
   else          { result=ac_node[found].code; }
   }
  //////
  data=result;
  if(data==-2) data=0;
  else
  if(data==-1) //optim:
   {
   for(i=0;i<64;i++) dat[i]=0;
   for(i=0;i<8;i++) dat[(i<<3)|i]=255;
   for(i=0;i<8;i++) dat[(i<<3)|(7-i)]=255;
   return 1;
   }
  num_zeros=data>>4;
  num_bits=data&0xf;

  // huffman get bits
  catagory=num_bits; result=0;
  for(i=0;i<catagory;i++)
   {
   if(--dec->bits<0) { dec->bits=7; dec->byte=*(++dec->data); if(dec->byte==0xff) { dec->data++; } }
   val= ((dec->byte&(1<<dec->bits))?1:0);
   result=(result<<1)|val;
   }
  if(result<(1<<(catagory-1)))  { result-=((1<<catagory)-1); }
  //////
  val=result;
  if((num_zeros==0)&&(num_bits==0))  // end of block *
   {
   for(i=coef;i<64;i++) dat[i]=0;
   break;
   }
  else
  if((num_zeros==15)&&(num_bits==0))  // 16 zeros RLE *
   {
   for(i=0;i<16;i++)  dat[coef+i]=0;
   coef+=16;
   }
  else
   {                                   // normal zero run length *
   for(i=0;i<num_zeros&&coef<64;i++)  dat[coef++]=0;
   if(coef>= 64) break;
   dat[coef++]=val;
   }
  }
 while(coef<64);
 for(i=0;i<64;i++)
  {
  o=aa_math_scan_zigzag[i];
  zz[o]=(I)dat[i];
  if(qt==0)   {   zz[o]*=(I)dec->dequant[i   ]; }
  else        {   zz[o]*=(I)dec->dequant[i+64]; }
  }
 aaMathDct(zz,NO,YES);
 for(i=0;i<64;i++)
  {
  p=zz[i]+128;
  p=aaNumClamp(p,0,255);
  dat[i]=(B)p;
  }
 return 0;
 }





 B aa_SurfaceDecodeTgaRle              (NP duppixcount,NP blockcount,HP off,VP mem,B bits,_rgba*p1)
 {
 N dup_pixel_count;
 N block_count,i;
 H o;
 B source_pixel_size;
 BP bp;
 BP tga_pixel;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 source_pixel_size=(B)(bits/7);
 dup_pixel_count=*duppixcount;
 block_count=*blockcount;
 o=*off;
 aaCast(bp,BP,mem);
 aaCast(tga_pixel,BP,p1);
 while(1)
  {
  if(dup_pixel_count>0) { dup_pixel_count--; break; }
  if(--block_count<0) // Time to read RLE block header?
   {
   i=bp[o++]; // decrement pixels remaining in block
   if(i&0x80)
    {
    dup_pixel_count=i&0x7F; // number of dups after this one
    block_count=0; // then read new block header
    }
   else
    {
    block_count=i&0x7F;
    } // number of pixels after this one
   }
  for(i=0;i<source_pixel_size;i++)   {  tga_pixel[i]=bp[o++]; }
  break;
  }
 *duppixcount=dup_pixel_count;
 *blockcount=block_count;
 *off=o;
 return RET_YES;
 }






 B aa_SurfaceSortSpots                 (PP mem)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 H i,bytes,nbytes,bbytes,obytes,obbytes;
 Z smoff;
 Z mx,my,hs;
 Z spot_num[_4K];
//citsys01:  Z spot_idn[_4K];
 Z spot_dep[_4K];
 Z spot_ord[_4K];
 _rect rc1,rc2;
 Z xx,yy;
 Q tm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 tm=aaMicrosecsRunning();
 aaCast(surp,_aa_surfaceobject*,*mem);
 aaRectSet(&surp->status.spot_depth_rect,0,0,0,0);
 aa_stats[5]++;
 if(surp->status.spot_count==0)
  {
  surp->status.spot_order_ok=YES;
  return RET_YES;
  }
 aa_stats[6]++;
 for(i=0;i<surp->status.spot_count;i++)
  {
  if(aaSurfaceSpotFindByNumber(surp->status.self_handle,i,&sspot)!=YES) { oof; continue; }
  spot_num[i]=sspot->id;
//citsys01:  spot_idn[i]=sspot->index;
  spot_dep[i]=sspot->depth;
  }

 //if((ret=aaMemoryArraySort(spot_dep,surp->status.spot_count,sizeof(Z),YES,NO,(HP)spot_ord))!=YES) { oops; }
 if((ret=aaMemoryOrderSort(spot_dep,surp->status.spot_count,4,0,sizeof(Z),YES,NO,(HP)spot_ord))!=YES) { oops; }


 for(i=0;i<surp->status.spot_count;i++)
  {
  surp->status.spot_id_order[i]=spot_num[spot_ord[i]];
  //citsys01: surp->status.spot_index_order[i]=spot_idn[spot_ord[i]];
  }
 aaRectSet(&rc2,0,0,0,0);
 aaRectSet(&rc1,0,0,0,0);
 for(i=0;i<surp->status.spot_count;i++)
  {
  hs=(surp->status.spot_count-1)-i;
  //hs=i;
  if((ret=aaSurfaceSpotFindById(surp->status.self_handle,surp->status.spot_id_order[hs],&sspot))!=YES) { oops; break; }
  if(i==0)     {     aaRectCopy(&rc1,&sspot->rect);     }
  else         {     aaRectAdd(&rc1,&sspot->rect,&rc1);     }
  }
 aaRectCopy(&surp->status.spot_depth_rect,&rc1);
  bytes=bbytes=0;
 nbytes=surp->status.spot_depth_rect.w*surp->status.spot_depth_rect.h*sizeof(Z);
 if(nbytes==0) { nbytes=1; }
 if(surp->status.spot_depth_map!=NULL) { aaMemoryBytesGet(surp->status.spot_depth_map,&bytes);  }
 if(surp->status.spot_id_map!=NULL)    { aaMemoryBytesGet(surp->status.spot_id_map,&bbytes);  }
 if(nbytes>=bytes)
  {
 // aaLog(-555,"%s %i %i %i",__func__,__LINE__,nbytes,bytes);
  if(bytes==0)
   {
   ret=aaMemoryAllocate((VP)&surp->status.spot_depth_map,nbytes);
   aaMemoryNameSet(surp->status.spot_depth_map,"spdpemap"); //charlie
   }
  else            { ret=aaMemoryReAllocate((VP)&surp->status.spot_depth_map,nbytes);    }
  if(ret!=YES)    { oops; }
  }
 if(nbytes>=bbytes)
  {
  //aaLog(-555,"%s %i %i %i",__func__,__LINE__,nbytes,bbytes);
  if(bbytes==0)
   {
   ret=aaMemoryAllocate((VP)&surp->status.spot_id_map,nbytes);
   aaMemoryNameSet(surp->status.spot_id_map,"spidmap"); //charlie
   }
  else            { ret=aaMemoryReAllocate((VP)&surp->status.spot_id_map,nbytes);    }
  if(ret!=YES)    { oops; }
  }
 if(aaMemoryBytesGet(surp->status.spot_depth_map,&obytes)!=YES) oof;
 if(aaMemoryBytesGet(surp->status.spot_id_map,&obbytes)!=YES) oof;
 for(i=0;i<surp->status.spot_count;i++)
   {
  hs=(surp->status.spot_count-1)-i;
  hs=i;
  if(aaSurfaceSpotFindById(surp->status.self_handle,surp->status.spot_id_order[hs],&sspot)!=YES) { oof; break; }
  //aaLog(-555,"%i %i %i,%i %i %i",i,hs,sspot->rect.w,sspot->rect.h,sspot->index,sspot->id);
  for(my=0;my<(N)sspot->rect.h;my++)
   {
   for(mx=0;mx<(N)sspot->rect.w;mx++)
    {
    yy=sspot->rect.y;
    xx=sspot->rect.x;
    smoff=(yy-surp->status.spot_depth_rect.y)+my;
    smoff=smoff*surp->status.spot_depth_rect.w;
    smoff=smoff+((xx-surp->status.spot_depth_rect.x)+mx);
    surp->status.spot_depth_map[smoff]=sspot->depth;
    surp->status.spot_id_map[smoff]=sspot->id;
    }
   }
  }
 tm=aaMicrosecsRunning()-tm;
 ///aaLog(-666,"took %.3fms (%I64u microsecs)",tm/1000.0,tm);
 surp->status.spot_order_ok=YES;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aa_PngReadBit                       (HP bitpointer,BP bitstream)
 {
 B result=(B)((bitstream[(*bitpointer)>>3]>>((*bitpointer)&0x7))&1);
 (*bitpointer)++;
 return result;
 }



 H aa_PngReadBits                      (HP bitpointer,BP bitstream,H nbits)
 {
 H result=0,i;
 for(i=0;i<nbits; i++) result|=((H)aa_PngReadBit(bitpointer,bitstream))<<i;
 return result;
 }




 V aa_PngHuffmanTreeInit               (pnghufftree*tree,HP buffer,H numcodes,H maxbitlen)
 {
 tree->tree2d=buffer;
 tree->numcodes=numcodes;
 tree->maxbitlen=maxbitlen;
 }




 V aa_PngHuffmanTreeCreateLengths      (upng_t*upng,pnghufftree*tree,HP bitlen)
 {
 H tree1d[PNG_MAX_SYMBOLS];
 H blcount[PNG_MAX_BIT_LENGTH];
 H nextcode[PNG_MAX_BIT_LENGTH];
 H bits,n,i;
 B bit;
 H nodefilled=0;
 H treepos=0;

 aaMemoryFill(blcount,sizeof(blcount),0);
 aaMemoryFill(nextcode,sizeof(nextcode),0);
 for(bits=0; bits<tree->numcodes; bits++) {	blcount[bitlen[bits]]++;	}
 for(bits=1; bits<=tree->maxbitlen; bits++) {	nextcode[bits]=(nextcode[bits-1]+blcount[bits-1])<<1;	}
 for(n=0; n<tree->numcodes; n++) { if(bitlen[n]!=0) {tree1d[n]=nextcode[bitlen[n]]++; } }
 for(n=0; n<tree->numcodes*2; n++) { tree->tree2d[n]=32767;}
 for  (n=0; n<tree->numcodes; n++)
  {
  for(i=0;i<bitlen[n]; i++)
   {
   bit=(B)((tree1d[n]>>(bitlen[n]-i-1))&1);
   if(treepos>tree->numcodes-2) { PNG_SET_ERROR(upng,RET_CORRUPTED);	return;		}
   if(tree->tree2d[2*treepos+bit]==32767)
    {
    if(i+1==bitlen[n]) { tree->tree2d[2*treepos+bit]=n; treepos=0; }
    else                    { nodefilled++; tree->tree2d[2*treepos+bit]=nodefilled+tree->numcodes; treepos=nodefilled;	}
    }
   else { treepos=tree->tree2d[2*treepos+bit]-tree->numcodes; }
   }
  }
 for(n=0; n<tree->numcodes*2; n++) { if(tree->tree2d[n]==32767) { tree->tree2d[n]=0; } }
 }




 H aa_PngHuffmanDecodeSymbol           (upng_t*upng,BP in,HP bp,pnghufftree*codetree,H inlength)
 {
 H treepos=0,ct;
 B bit;
 for(;;)
  {
  if(((*bp)&0x07)==0&&((*bp)>>3)>inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED);	return 0;		}
  bit=aa_PngReadBit(bp,in);
  ct=codetree->tree2d[(treepos<<1)|bit];
  if(ct<codetree->numcodes) { return ct; }
  treepos=ct-codetree->numcodes;
  if(treepos>=codetree->numcodes) {	PNG_SET_ERROR(upng,RET_CORRUPTED);	return 0;		}
  }
 }





 V  aa_PngGetTreeInflateDynamic         (upng_t*upng,pnghufftree*codetree,pnghufftree*codetreeD,pnghufftree*codelengthcodetree,BP in,HP bp,H inlength)
 {
 H codelengthcode[PNG_NUM_CODE_LENGTH_CODES];
 H bitlen[PNG_NUM_DEFLATE_CODE_SYMBOLS];
 H bitlenD[PNG_NUM_DISTANCE_SYMBOLS];
 H n,hlit,hdist,hclen,i,code,replength,value;

 if((*bp)>>3>=inlength-2) { PNG_SET_ERROR(upng,RET_CORRUPTED); return;	}
 aaMemoryFill(bitlen,sizeof(bitlen),0);
 aaMemoryFill(bitlenD,sizeof(bitlenD),0);
 hlit=aa_PngReadBits(bp,in,5)+257;
 hdist=aa_PngReadBits(bp,in,5)+1;
 hclen=aa_PngReadBits(bp,in,4)+4;
 for(i=0;i<PNG_NUM_CODE_LENGTH_CODES; i++)
  {
  if(i<hclen) { codelengthcode[PNG_CLCL[i]]=aa_PngReadBits(bp,in,3); }
  else         { codelengthcode[PNG_CLCL[i]]=0;	}
  }
 aa_PngHuffmanTreeCreateLengths(upng,codelengthcodetree,codelengthcode);
 if(upng->error!=RET_YES) {	return;	}
 i=0;
 while(i<hlit+hdist)
  {
  code=aa_PngHuffmanDecodeSymbol(upng,in,bp,codelengthcodetree,inlength);
  if(upng->error!=RET_YES) { break; }
  if(code<=15)
   {
   if(i<hlit) {bitlen[i]=code;}
   else          {bitlenD[i-hlit]=code;}
   i++;
   }
  else
  if(code==16)
   {
   replength=3;
   if((*bp)>>3>=inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
   replength+=aa_PngReadBits(bp,in,2);
   if((i-1)<hlit) {	value=bitlen[i-1];}
   else                { value=bitlenD[i-hlit-1]; }
    for(n=0; n<replength; n++)
    {
    if(i>=hlit+hdist) { PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
    if(i<hlit) { bitlen[i]=value; }
    else          { bitlenD[i-hlit]=value; }
    i++;
    }
   }
  else
  if(code==17)
   {
   replength=3;
   if((*bp)>>3>=inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
   replength+=aa_PngReadBits(bp,in,3);
   for(n=0; n<replength; n++)
    {
    if(i>=hlit+hdist) {PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
    if(i<hlit) {bitlen[i]=0;	}
    else          {bitlenD[i-hlit]=0; }
    i++;
    }
   }
  else
  if(code==18)
   {
   replength=11;
   if((*bp)>>3>=inlength) {PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
   replength+=aa_PngReadBits(bp,in,7);
   for(n=0; n<replength; n++)
    {
    if(i>=hlit+hdist) {  PNG_SET_ERROR(upng,RET_CORRUPTED); break; }
    if(i<hlit) bitlen[i]=0;
    else          bitlenD[i-hlit]=0;
    i++;
    }
   }
  else
   {
   PNG_SET_ERROR(upng,RET_CORRUPTED);
    break;
   }
  }
 if(upng->error==RET_YES&&bitlen[256]==0) {	PNG_SET_ERROR(upng,RET_CORRUPTED);	}
 if(upng->error==RET_YES) { aa_PngHuffmanTreeCreateLengths(upng,codetree,bitlen); }
 if(upng->error==RET_YES) { aa_PngHuffmanTreeCreateLengths(upng,codetreeD,bitlenD);	}
 }





 V aa_PngInflateHuffman                             (upng_t*upng,BP out,H outsize,BP in,HP bp,HP pos,H inlength,H btype)
 {
 H codetree_buffer[PNG_DEFLATE_CODE_BUFFER_SIZE];
 H codetreeD_buffer[PNG_DISTANCE_BUFFER_SIZE];
 H codelengthcodetree_buffer[PNG_CODE_LENGTH_BUFFER_SIZE];
 pnghufftree codelengthcodetree;
 H code,done=0;
 pnghufftree codetree;
 pnghufftree codetreeD;
 H length,codeD,distance,numextrabitsD;
 H start,forward,backward,numextrabits;

 if(btype==1)
  {
  aa_PngHuffmanTreeInit(&codetree,(HP)PNG_FIXED_DEFLATE_CODE_TREE,PNG_NUM_DEFLATE_CODE_SYMBOLS,PNG_DEFLATE_CODE_BITLEN);
  aa_PngHuffmanTreeInit(&codetreeD,(HP)PNG_FIXED_DISTANCE_TREE,PNG_NUM_DISTANCE_SYMBOLS,PNG_DISTANCE_BITLEN);
  }
 else
 if(btype==2)
  {
  aa_PngHuffmanTreeInit(&codetree,codetree_buffer,PNG_NUM_DEFLATE_CODE_SYMBOLS,PNG_DEFLATE_CODE_BITLEN);
  aa_PngHuffmanTreeInit(&codetreeD,codetreeD_buffer,PNG_NUM_DISTANCE_SYMBOLS,PNG_DISTANCE_BITLEN);
  aa_PngHuffmanTreeInit(&codelengthcodetree,codelengthcodetree_buffer,PNG_NUM_CODE_LENGTH_CODES,PNG_CODE_LENGTH_BITLEN);
  aa_PngGetTreeInflateDynamic(upng,&codetree,&codetreeD,&codelengthcodetree,in,bp,inlength);
  }
 while(done==0)
  {
  code=aa_PngHuffmanDecodeSymbol(upng,in,bp,&codetree,inlength);
  if(upng->error!=RET_YES) { return; }
  if(code==256) { done=1; }
  else
  if(code<=255)
   {
   if((*pos)>=outsize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return;	}
   out[(*pos)++]=(B)(code);
   }
  else
  if(code>=PNG_FIRST_LENGTH_CODE_INDEX&&code<=PNG_LAST_LENGTH_CODE_INDEX)
   {
   length=PNG_LENGTH_BASE[code-PNG_FIRST_LENGTH_CODE_INDEX];
   numextrabits=PNG_LENGTH_EXTRA[code-PNG_FIRST_LENGTH_CODE_INDEX];
   if(((*bp)>>3)>=inlength) {	PNG_SET_ERROR(upng,RET_CORRUPTED); return;}
   length+=aa_PngReadBits(bp,in,numextrabits);
   codeD=aa_PngHuffmanDecodeSymbol(upng,in,bp,&codetreeD,inlength);
   if(upng->error!=RET_YES) { return; }
   if(codeD>29) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
   distance=PNG_DISTANCE_BASE[codeD];
   numextrabitsD=PNG_DISTANCE_EXTRA[codeD];
   if(((*bp)>>3)>=inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
   distance+=aa_PngReadBits(bp,in,numextrabitsD);
   start=(*pos);
   backward=start-distance;
   if((*pos)+length>=outsize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
   for(forward=0; forward<length; forward++)
    {
    out[(*pos)++]=out[backward];
    backward++;
    if(backward>=start) { backward=start-distance; }
    }
   }
  }
 }





 V aa_PngInflateUncompressed           (upng_t*upng,BP out,H outsize,BP in,HP bp,HP pos,H inlength)
 {
 H p,len,nlen,n;

 while(((*bp)&0x7)!=0) { (*bp)++;	}
 p=(*bp)/8;
 if(p>=inlength-4) {	PNG_SET_ERROR(upng,RET_CORRUPTED);return;	}
 len=in[p]+256*in[p+1];
 p+=2;
 nlen=in[p]+256*in[p+1];
 p+=2;
 if(len+nlen!=65535) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
 if((*pos)+len>=outsize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
 if(p+len>inlength) { PNG_SET_ERROR(upng,RET_CORRUPTED); return; }
 for(n=0; n<len; n++) { out[(*pos)++]=in[p++];	}
 (*bp)=p*8;
 }





 B aa_PngUzInflateData                 (upng_t*upng,BP out,H outsize,BP in,H insize,H inpos)
 {
 H bp=0;
 H pos=0;
 H done=0;

 while(done==0)
  {
  H btype;
  if((bp>>3)>=insize) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error;	}
  done=aa_PngReadBit(&bp,&in[inpos]);
  btype=aa_PngReadBit(&bp,&in[inpos])|(aa_PngReadBit(&bp,&in[inpos])<<1);
  if(btype==3) { PNG_SET_ERROR(upng,RET_CORRUPTED);return upng->error;		}
  else
  if(btype==0) { aa_PngInflateUncompressed(upng,out,outsize,&in[inpos],&bp,&pos,insize); }
  else            {aa_PngInflateHuffman(upng,out,outsize,&in[inpos],&bp,&pos,insize,btype); }
  if(upng->error!=RET_YES) { return upng->error; }
  }
 return upng->error;
 }





 B aa_PngUzInflate                     (upng_t*upng,BP out,H outsize,BP in,H insize)
 {
 if(insize<2) { PNG_SET_ERROR(upng,RET_CORRUPTED);  return upng->error;	}
 if((in[0]*256+in[1])%31!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error; }
 if((in[0]&15)!=8||((in[0]>>4)&15)>7) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error; }
 if(((in[1]>>5)&1)!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error; }
 aa_PngUzInflateData(upng,out,outsize,in,insize,2);
 return upng->error;
 }




 Z aa_PngPathPredictor                 (Z a,Z b,Z c)
 {
 Z p=a+b-c;
 Z pa=p>a?p-a : a-p;
 Z pb=p>b?p-b : b-p;
 Z pc=p>c?p-c : c-p;
 if(pa<=pb&&pa<=pc) return a;
 else
 if(pb<=pc)  	 return b;
 else 	 	 return c;
 }






 V aa_PngUnfilterScanLine              (upng_t*upng,BP recon,BP scanline,BP precon,H bytewidth,B filterType,H length)
 {
 H i;
 switch (filterType)
  {
  case 0: for(i=0;i<length; i++) 	recon[i]=scanline[i];	break;
  case 1: for(i=0;i<bytewidth; i++) recon[i]=scanline[i];
          for(i=bytewidth;i<length; i++) recon[i]=scanline[i]+recon[i-bytewidth];
          break;
  case 2: if(precon) for(i=0;i<length; i++)	recon[i]=scanline[i]+precon[i];
          else        for(i=0;i<length; i++)	recon[i]=scanline[i];
          break;
  case 3: if(precon)
           {
           for(i=0;i<bytewidth; i++) recon[i]=scanline[i]+precon[i]/2;
           for(i=bytewidth;i<length; i++) recon[i]=scanline[i]+((recon[i-bytewidth]+precon[i])/2);
           }
          else
           {
           for(i=0;i<bytewidth; i++) recon[i]=scanline[i];
           for(i=bytewidth;i<length; i++) recon[i]=scanline[i]+recon[i-bytewidth]/2;
           }
          break;
  case 4: if(precon)
           {
           for(i=0;i<bytewidth; i++) recon[i]=(B)(scanline[i]+aa_PngPathPredictor(0,precon[i],0));
           for(i=bytewidth;i<length; i++) recon[i]=(B)(scanline[i]+aa_PngPathPredictor(recon[i-bytewidth],precon[i],precon[i-bytewidth]));
           }
          else
           {
           for(i=0;i<bytewidth; i++) recon[i]=scanline[i];
           for(i=bytewidth;i<length; i++) recon[i]=(B)(scanline[i]+aa_PngPathPredictor(recon[i-bytewidth],0,0));
           }
          break;
  default: PNG_SET_ERROR(upng,RET_CORRUPTED); break;
  }
 }


 V aa_PngUnfilter                      (upng_t*upng,BP out,BP in,H w,H h,H bpp)
 {
 BP prevline=0;
 H bytewidth=(bpp+7)/8;
 H linebytes=(w*bpp+7)/8;
 H outindex,y;
 H inindex;
 B filterType;

 for(y=0; y<h; y++)
  {
  outindex=linebytes*y;
  inindex=(1+linebytes)*y;
  filterType=in[inindex];
  aa_PngUnfilterScanLine(upng,&out[outindex],&in[inindex+1],prevline,bytewidth,filterType,linebytes);
  if(upng->error!=RET_YES) { return;	}
  prevline=&out[outindex];
  }
 }





 V aa_PngRemovePaddingBits             (BP out,BP in,H olinebits,H ilinebits,H h)
 {
 B bit;
 H x,y,diff=ilinebits-olinebits;
 H obp=0,ibp=0;
 for(y=0; y<h; y++)
  {
  for(x=0; x<olinebits; x++)
   {
   bit=(B)((in[(ibp)>>3]>>(7-((ibp)&0x7)))&1);
   ibp++;
   if(bit==0) out[(obp)>>3]&=(B)(~(1<<(7-((obp)&0x7))));
   else       out[(obp)>>3]|=(1<<(7-((obp)&0x7)));
   ++obp;
   }
  ibp+=diff;
  }
 }





 V aa_PngPostProcessScanLines          (upng_t*upng,BP out,BP in,upng_t*info_png)
 {
 H bpp=info_png->bpp;
 H w=info_png->width;
 H h=info_png->height;
 if(bpp==0) {PNG_SET_ERROR(upng,RET_CORRUPTED);	return;	}
 if(bpp<8&&w*bpp!=((w*bpp+7)/8)*8)
  {
  aa_PngUnfilter(upng,in,in,w,h,bpp); if(upng->error!=RET_YES) { return; }
  aa_PngRemovePaddingBits(out,in,w*bpp,((w*bpp+7)/8)*8,h);
  }
 else { aa_PngUnfilter(upng,out,in,w,h,bpp);	}
 }




 B aa_PngHeader                        (upng_t*upng)
 {
 if(upng->error!=RET_YES) {return upng->error; }
 if(upng->state!=PNG_NEW) {return upng->error; }
 if(upng->source.size<29) {PNG_SET_ERROR(upng,RET_BADFORMAT);	return upng->error;	}
 if(upng->source.buffer[0]!=137||upng->source.buffer[1]!=80||upng->source.buffer[2]!=78||upng->source.buffer[3]!=71||upng->source.buffer[4]!=13||upng->source.buffer[5]!=10||upng->source.buffer[6]!=26||upng->source.buffer[7]!=10)
  {
  PNG_SET_ERROR(upng,RET_BADFORMAT);
  return upng->error;
  }
 if(PNG_MAKE_DWORD_PTR(upng->source.buffer+12)!=PNG_CHUNK_IHDR) { PNG_SET_ERROR(upng,RET_CORRUPTED);return upng->error; }
 upng->width=PNG_MAKE_DWORD_PTR(upng->source.buffer+16);
 upng->height=PNG_MAKE_DWORD_PTR(upng->source.buffer+20);
 upng->color_depth=upng->source.buffer[24];
 upng->color_type=upng->source.buffer[25];
 switch(upng->color_type)
  {
  case PNG_LUM: upng->components=1; break;
  case PNG_RGB: upng->components=3; break;
  case PNG_LUMA: upng->components=2; break;
  case PNG_RGBA: upng->components=4; break;
  default: upng->components=0;  break;
  }
 switch (upng->color_type)
  {
  case PNG_LUM:
  switch (upng->color_depth)
   {
   case 1:	upng->format=PNG_LUMINANCE1; break;
   case 2:	upng->format=PNG_LUMINANCE2; break;
   case 4:	upng->format=PNG_LUMINANCE4; break;
   case 8:	upng->format=PNG_LUMINANCE8; break;
   default:	upng->format=PNG_BADFORMAT; break;
   }
  break;
  case PNG_RGB:
  switch (upng->color_depth)
   {
   case 8:	upng->format=PNG_RGB8; break;
   case 16:	upng->format=PNG_RGB16; break;
   default:	upng->format=PNG_BADFORMAT; break;
   }
  break;
  case PNG_LUMA:
  switch (upng->color_depth)
   {
   case 1:   upng->format=PNG_LUMINANCE_ALPHA1; break;
   case 2:   upng->format=PNG_LUMINANCE_ALPHA2; break;
   case 4:   upng->format=PNG_LUMINANCE_ALPHA4; break;
   case 8:   upng->format=PNG_LUMINANCE_ALPHA8; break;
   default:  upng->format=PNG_BADFORMAT; break;
   }
  break;
  case PNG_RGBA:
  switch (upng->color_depth)
   {
   case 8:  upng->format=PNG_RGBA8; break;
   case 16: upng->format=PNG_RGBA16; break;
   default: upng->format=PNG_BADFORMAT; break;
   }
  break;
  default:
  upng->format=PNG_BADFORMAT;
  break;
  }
 if(upng->format==PNG_BADFORMAT) { PNG_SET_ERROR(upng,RET_BADFORMAT); return upng->error;	}
 if(upng->source.buffer[26]!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error;	}
 if(upng->source.buffer[27]!=0) { PNG_SET_ERROR(upng,RET_CORRUPTED); return upng->error;	}
 if(upng->source.buffer[28]!=0) { PNG_SET_ERROR(upng,RET_NOTSUPPORTED); return upng->error;	}
 upng->bpp=upng->color_depth*upng->components;
 upng->state=PNG_HEADER;
 return upng->error;
 }





 B aa_PngDecode                        (upng_t*upng)
 {
 BP chunk;
 BP compressed;
 BP inflated;
 H compressed_size=0,compressed_index=0;
 H inflated_size,length;
 BP data;
 B error;

 if(upng->error!=RET_YES) { return upng->error;	}
 aa_PngHeader(upng);
 if(upng->error!=RET_YES) { return upng->error; }
 if(upng->state!=PNG_HEADER) { return upng->error; }
 if(upng->buffer!=0) {	aaMemoryRelease(upng->buffer); upng->buffer=0; upng->size=0; }
  chunk=upng->source.buffer+33;
 while(chunk<upng->source.buffer+upng->source.size)
  {
  if((H)(chunk-upng->source.buffer+12)>upng->source.size) { PNG_SET_ERROR(upng,RET_CORRUPTED);return upng->error; }
  length=PNG_MAKE_DWORD_PTR(chunk);
  if(length>INT_MAX) {	PNG_SET_ERROR(upng,RET_CORRUPTED);	return upng->error;		}
  if((H)(chunk-upng->source.buffer+length+12)>upng->source.size) { PNG_SET_ERROR(upng,RET_CORRUPTED);	return upng->error;
  }
 data=chunk+8;
 if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IDAT) { compressed_size+=length; }
 else
 if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IEND) { break; }
 else
 if((((chunk)[4]&32)==0)) { PNG_SET_ERROR(upng,RET_NOTSUPPORTED);return upng->error;  }
 chunk+=PNG_MAKE_DWORD_PTR(chunk)+12;
 }
 if(aaMemoryAllocate((VP)&compressed,compressed_size)!=YES) { PNG_SET_ERROR(upng,RET_NOMEMORY); return upng->error; }
 chunk=upng->source.buffer+33;
 while(chunk<upng->source.buffer+upng->source.size)
  {
  length=PNG_MAKE_DWORD_PTR(chunk);
  data=chunk+8;
  if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IDAT) { aaMemoryCopy(compressed+compressed_index,length,data); compressed_index+=length; }
  else
  if(PNG_MAKE_DWORD_PTR((chunk)+4)==PNG_CHUNK_IEND) { break;}
  chunk+=PNG_MAKE_DWORD_PTR(chunk)+12;
  }
 inflated_size=((upng->width*(upng->height*upng->bpp+7))/8)+upng->height;
 if(aaMemoryAllocate((VP)&inflated,inflated_size)!=YES) { aaMemoryRelease(compressed);	PNG_SET_ERROR(upng,RET_NOMEMORY); return upng->error; }
 error=aa_PngUzInflate(upng,inflated,inflated_size,compressed,compressed_size);
 if(error!=RET_YES) { aaMemoryRelease(compressed); aaMemoryRelease(inflated);	return upng->error;	}
 aaMemoryRelease(compressed);
 upng->size=(upng->height*upng->width*upng->bpp+7)/8;
 if(aaMemoryAllocate((VP)&upng->buffer,upng->size)!=YES) { aaMemoryRelease(inflated); upng->size=0; PNG_SET_ERROR(upng,RET_NOMEMORY);	return upng->error;	}
 aa_PngPostProcessScanLines(upng,upng->buffer,inflated,upng);
 aaMemoryRelease(inflated);
 if(upng->error!=RET_YES) { aaMemoryRelease(upng->buffer);	upng->buffer=NULL;	upng->size=0;	}
 else                      { upng->state=PNG_DECODED;	}
 if(upng->source.owning!=0) { aaMemoryRelease(upng->source.buffer);	}
 upng->source.buffer=NULL;
 upng->source.size=0;
 upng->source.owning=0;
 return upng->error;
 }





 V aa_PngFree                          (upng_t*upng)
 {
 if(upng->buffer!=NULL) {aaMemoryRelease(upng->buffer);	}
 if(upng->source.owning!=0) { aaMemoryRelease(upng->source.buffer);	}
 upng->source.buffer=NULL;
 upng->source.size=0;
 upng->source.owning=0;
 aaMemoryRelease(upng);
 }



 upng_t*aa_PngNew                      (V)
 {
 upng_t*upng;
 if(aaMemoryAllocate((VP)&upng,sizeof(upng_t))!=YES) { return NULL;	}
 upng->buffer=NULL;
 upng->size=0;
 upng->width=upng->height=0;
 upng->color_type=PNG_RGBA;
 upng->color_depth=8;
 upng->format=PNG_RGBA8;
 upng->state=PNG_NEW;
 upng->error=RET_YES;
 upng->error_line=0;
 upng->source.buffer=NULL;
 upng->source.size=0;
 upng->source.owning=0;
 return upng;
 }


 upng_t*aa_PngNewFromBytes             (BP buffer,H size)
 {
 upng_t*upng;

 if((upng=aa_PngNew())==NULL) { return NULL; }
 upng->source.buffer=buffer;
 upng->source.size=size;
 upng->source.owning=0;
 aa_PngDecode(upng);
 if(upng->error!=RET_YES)
  {
  //aaDebugf("aerr %u %u",upng->error,upng->error_line);
  aa_PngFree(upng);
  return NULL;
  }
 aa_PngHeader(upng);
 if(upng->error!=RET_YES)
  {
  //aaDebugf("berr %u %u",upng->error,upng->error_line);
  aa_PngFree(upng);
  return NULL;
  }
 return upng;
 }



 upng_t*aa_PngNewFromFile              (CP filename)
 {
 upng_t* upng;
 BP buffer;
 B ret;
 _filestreamunit fsu;

 if((upng=aa_PngNew())==NULL) { return NULL; }
 if((ret=aaFileStreamCreate(&fsu.handle,filename,aa_FILECREATE_OPEN,3,3,0,0))!=RET_YES) { PNG_SET_ERROR(upng,RET_NOTFOUND); return upng; }
 aaFileStreamStatus(fsu.handle,&fsu.status);
 if(aaMemoryAllocate((VP)&buffer,(H)fsu.status.bytes)!=YES) { aaFileStreamDestroy(fsu.handle); PNG_SET_ERROR(upng,RET_NOMEMORY); return upng; }
 if((ret=aaFileStreamRead(fsu.handle,(H)fsu.status.bytes,buffer))!=RET_YES) { oops; }
 aaFileStreamDestroy(fsu.handle);
 upng->source.buffer=buffer;
 upng->source.size=(H)fsu.status.bytes;
 upng->source.owning=1;
 aa_PngDecode(upng);
 if(upng->error!=RET_YES)
  {
  //aaDebugf("c err %u %u",upng->error,upng->error_line);
  aa_PngFree(upng);
  return NULL;
  }
 aa_PngHeader(upng);
 if(upng->error!=RET_YES)
  {
  //aaDebugf("e err %u %u",upng->error,upng->error_line);
  aa_PngFree(upng);
  return NULL;
  }
 return upng;
 }



 B aa_PngFromImage                     (VP imgdata,N width,N height,N stride,VP outbuf,N maxout,HP outbytes)
 {
 BP sptr,dptr,idptr,idsptr,rs;
 H idsz,crc,Bpp;
 H i,line_size,val;
 Z x,y,psz;

 //if(width<=0||width>10000||height<=0||height>10000) {   psz=-1;    }
 //else { psz=sizeof(aa_png_header)+ (((N)width*4+6)*(N)height)+ 8+sizeof(aa_png_trailer); }
 psz=sizeof(aa_png_header)+(((N)width*4+6)*(N)height)+8+sizeof(aa_png_trailer);
 if(maxout<psz) { return RET_BOUNDS; }
 //if(imgdata==NULL||width<=0||width>10000||height<=0||height>10000 ||stride<width ||outbuf==NULL||maxout<psz)
  //{
  //return 0;
  //}
   Bpp=4;//(use_alpha ? 4 : 3);
   dptr=(BP)outbuf;
   for(i=0;i<sizeof(aa_png_header); i++) {    dptr[i]=aa_png_header[i];    }
   dptr[PNG_HEADER_OFFSET_WIDTH+0]=(width>>24)&F8; dptr[PNG_HEADER_OFFSET_WIDTH+1]=(width>>16)&F8;
   dptr[PNG_HEADER_OFFSET_WIDTH+2]=(width>> 8)&F8; dptr[PNG_HEADER_OFFSET_WIDTH+3]=(width>> 0)&F8;
   dptr[PNG_HEADER_OFFSET_HEIGHT+0]=(height>>24)&F8; dptr[PNG_HEADER_OFFSET_HEIGHT+1]=(height>>16)&F8;
   dptr[PNG_HEADER_OFFSET_HEIGHT+2]=(height>> 8)&F8; dptr[PNG_HEADER_OFFSET_HEIGHT+3]=(height>> 0)&F8;
   dptr[PNG_HEADER_OFFSET_FORMAT]=(6);// 2=no alpha
   val=F32;
   aaMemoryCrcGet(&dptr[PNG_HEADER_OFFSET_IHDR],PNG_HEADER_SIZE_IHDR,&val);
   dptr[PNG_HEADER_OFFSET_IHDR_CRC+0]=(val>>24)&F8; dptr[PNG_HEADER_OFFSET_IHDR_CRC+1]=(val>>16)&F8;
   dptr[PNG_HEADER_OFFSET_IHDR_CRC+2]=(val>> 8)&F8; dptr[PNG_HEADER_OFFSET_IHDR_CRC+3]=(val>> 0)&F8;
   idsptr=&dptr[PNG_HEADER_OFFSET_IDAT_SIZE];
   idptr=&dptr[PNG_HEADER_OFFSET_IDAT_DATA];
   dptr+=sizeof(aa_png_header);
   sptr=(BP)imgdata;
   crc=1;
   for(y=0;y<height;y++,sptr+=(stride-width)*4)
    {
    rs=dptr+5;
    line_size=1+width*Bpp;
    dptr[0]=(y==height-1)?0x01:0x00;
    dptr[1]=(line_size>>0)&F8;
    dptr[2]=(line_size>>8)&F8;
    dptr[3]=~dptr[1];
    dptr[4]=~dptr[2];
    dptr[5]=0;
    dptr+=6;
    for(x=0;x<width;x++,sptr+=4,dptr+=Bpp)
     {
     dptr[0]=sptr[2];
     dptr[1]=sptr[1];
     dptr[2]=sptr[0];
     dptr[3]=sptr[ 3];
     }
    aaMemoryAdlerCrcGet(rs,line_size,&crc);
    }
 idsz=(dptr+4)-idptr;
 idsptr[0]=(idsz>>24)&F8; idsptr[1]=(idsz>>16)&F8;
 idsptr[2]=(idsz>> 8)&F8; idsptr[3]=(idsz>> 0)&F8;
 dptr[0]=(crc>>24)&F8; dptr[1]=(crc>>16)&F8;
 dptr[2]=(crc>> 8)&F8; dptr[3]=(crc>> 0)&F8;
 val=F32;
 aaMemoryCrcGet(idptr-4,idsz+4,&val);
 dptr[4+0]=(val>>24)&F8; dptr[4+1]=(val>>16)&F8;
 dptr[4+2]=(val>> 8)&F8; dptr[4+3]=(val>> 0)&F8;
 dptr+=8;
 for(i=0;i<sizeof(aa_png_trailer); i++) {     dptr[i]=aa_png_trailer[i];    }
 dptr+=sizeof(aa_png_trailer);
 *outbytes=dptr-(BP)outbuf;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/

 B aa_JpegChunkNext                    (_jpegchunk*ic)
 {
 ic->x_pos+=16;
 if(ic->x_pos>=ic->width) {   ic->y_pos+=8;    ic->x_pos=0;  }
 return (ic->y_pos<ic->height);
 }


 V aa_JpegChunkCopyY1                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+ic->y_pos*ic->width);
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {  *destination=*pointer-128;   ++destination;      pointer+=2;    }
  base+=2*ic->width;
  }
 }


 V aa_JpegChunkCopyY2                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+8+ic->y_pos*ic->width);
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {  *destination=*pointer-128;    ++destination;      pointer+=2;    }
  base+=2*ic->width;
  }
 }


 V aa_JpegChunkCopyCr                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+ic->y_pos*ic->width)+3;
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {   *destination=*pointer-128;    ++destination;     pointer+=4;    }
  base+=2*ic->width;
  }
 }


 V aa_JpegChunkCopyCb                  (_jpegchunk*ic,IP destination)
 {
 B x,y;
 BP pointer=NULL;
 BP base=ic->data+2*(ic->x_pos+ic->y_pos*ic->width)+1;
 if(ic==NULL) { oof; }
 for(y=8;y;--y)
  {
  pointer=base;
  for(x=8;x;--x) {   *destination=*pointer-128;    ++destination;      pointer+=4;    }
  base+=2*ic->width;
  }
 }




 V aa_JpegAdd                          (_jpegbuf*buffer,Y bits,B length)
 {
 BP wp,rp;
 Z i;

 bits=bits<<(sizeof(bits)*8-length-(buffer->bit_size&0x07));
 wp=buffer->data+(buffer->bit_size>>3);
 rp=((BP)&bits)+sizeof(bits)-1;
 for(i=0;i<length+8;i+=8,++wp,--rp,*wp=0)
  {
  *wp|=*rp;
  if(*wp==0xff) { ++wp; buffer->bit_size+=8; *wp=0; }
  }
 buffer->bit_size+=length;
 }




 V aa_JpegAddAC                        (_jpegbuf*buffer,WP table,B run,I value)
 {
 B xlen;
 I xval;
 W uvalue=value<0 ? value-1 : value;
 xlen=0;
 xval=value;
 if(xval<0) { xval=-xval; }
 while(xval) {   xval>>= 1; xlen++; }
 B length=xlen;
 W code=table[length*16+run];

 if((code&0x000f)>11)
  {
  aa_JpegAdd(buffer,(code>>4)|(0x0f00<<((code&0x000f)-11)),(code&0x000f)+1);
  }
 else
  {
  aa_JpegAdd(buffer,code>>4,(code&0x000f)+1);
  }
 if(length!=0) {  aa_JpegAdd(buffer,uvalue&((1<<length)-1),length); }
 }




 V aa_JpegAddDC                        (_jpegbuf*buffer,WP table,I value)
 {
 B xlen;
 I xval;
 W uvalue=value<0 ? value-1 : value;
 xlen=0;
 xval=value;
 if(xval<0) { xval=-xval; }
 while(xval) {   xval>>= 1; xlen++; }
 B length=xlen;
 W code=table[length];
 aa_JpegAdd(buffer,code>>4,code&0x000f);
 if(length!=0) {  aa_JpegAdd(buffer,uvalue&((1<<length)-1),length); }
 }




 V aa_JpegEncode                       (_jpegctx*jpegctx,IP last_dc,WP dc_table,WP ac_table,IP block)
 {
 B run,i;
 W HUF_Y_AC[0xb0]={0x00c3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
                   0x0000,0x0000,0x0000,0x0000,0xff3b,0x0001,0x00a3,0x01b4,0x03a5,0x03b5,0x0786,
                   0x07b6,0x0f97,0x1f48,0x1f78,0x1f88,0x3f59,0x3f89,0x3fa9,0x7f6a,0xfedc,0x0011,
                   0x01c4,0x0f87,0x1f68,0x3f69,0x3f99,0xff2b,0xff5b,0xfecc,0xfe0d,0xfe1d,0xfc4e,
                   0xf8df,0xf9af,0xf9bf,0xfaef,0x0042,0x07a6,0x3f79,0x7f7a,0xfddd,0xfdfd,0xfc5e,
                   0xf8cf,0xf9ef,0xf91f,0xf92f,0xf93f,0xf99f,0xfaaf,0xfaff,0xfb0f,0x00b3,0x1f58,
                   0xff4b,0xfded,0xf8ff,0xf96f,0xf97f,0xf98f,0xfa3f,0xfa4f,0xfa7f,0xfa8f,0xfb1f,
                   0xfb2f,0xfb3f,0xfb4f,0x01a4,0x3f49,0xfdcd,0xf8ef,0xfa5f,0xfabf,0xfb5f,0xfb6f,
                   0xfb7f,0xfb8f,0xfb9f,0xfbaf,0xfbbf,0xfbcf,0xfbdf,0xfbef,0x0796,0x7f8a,0xf9df,
                   0xf94f,0xfa6f,0xfa9f,0xfbff,0xfc0f,0xfc1f,0xfc2f,0xfc3f,0xfc4f,0xfc5f,0xfc6f,
                   0xfc7f,0xfc8f,0x1f98,0xf95f,0xf90f,0xfc9f,0xfcaf,0xfcbf,0xfccf,0xfcdf,0xfcef,
                   0xfcff,0xfd0f,0xfd1f,0xfd2f,0xfd3f,0xfd4f,0xfd5f,0xf9cf,0xfa1f,0xfacf,0xfd6f,
                   0xfd7f,0xfd8f,0xfd9f,0xfdaf,0xfdbf,0xfdcf,0xfddf,0xfdef,0xfdff,0xfe0f,0xfe1f,
                   0xfe2f,0xf9ff,0xfa2f,0xfe3f,0xfe4f,0xfe5f,0xfe6f,0xfe7f,0xfe8f,0xfe9f,0xfeaf,
                   0xfebf,0xfecf,0xfedf,0xfeef,0xfeff,0xff0f,0xfa0f,0xfadf,0xff1f,0xff2f,0xff3f,
                   0xff4f,0xff5f,0xff6f,0xff7f,0xff8f,0xff9f,0xffaf,0xffbf,0xffcf,0xffdf,0xffef};

 aa_JpegAddDC(&jpegctx->buffy,dc_table,block[0]-*last_dc);
 *last_dc=block[0];
 for(i=1;i<64;++i)
  {
  run=0;
  while(i<64&&block[aa_math_scan_zigzag[i]]==0) {    ++i;     ++run;    }
  if(i==64) {  aa_JpegAddAC(&jpegctx->buffy,ac_table,0,0);     break;    }
  else      {  while(run>=16) {  aa_JpegAddAC(&jpegctx->buffy,ac_table,15,0);  run-=16;   } }
  aa_JpegAddAC(&jpegctx->buffy,HUF_Y_AC,run,block[aa_math_scan_zigzag[i]]);
  }
 }




 V aa_JpegQuantize                     (_jpegctx*jpegctx,IP block)
 {
 Z i;
 C mm;
 CP qm=(CP)jpegctx->quant;

 for(i=0;i<64;++i,++block,++qm)
  {
  mm=*qm;
  *block=2**block/mm;
  switch (*block&0x80000001)
   {
   case 0x80000001: *block=*block/2-1; break;
   case 0x00000001: *block=*block/2+1; break;
   default: *block/=2;
   }
  }
 }




 Z aa_JpegWrite                        (_jpegctx*p,BP destination,Z size)
 {
 Z bytes_written;
 I block[64];
 int to_copy;
 W HUF_Y_AC[0xb0]={0x00c3,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
                   0x0000,0x0000,0x0000,0x0000,0xff3b,0x0001,0x00a3,0x01b4,0x03a5,0x03b5,0x0786,
                   0x07b6,0x0f97,0x1f48,0x1f78,0x1f88,0x3f59,0x3f89,0x3fa9,0x7f6a,0xfedc,0x0011,
                   0x01c4,0x0f87,0x1f68,0x3f69,0x3f99,0xff2b,0xff5b,0xfecc,0xfe0d,0xfe1d,0xfc4e,
                   0xf8df,0xf9af,0xf9bf,0xfaef,0x0042,0x07a6,0x3f79,0x7f7a,0xfddd,0xfdfd,0xfc5e,
                   0xf8cf,0xf9ef,0xf91f,0xf92f,0xf93f,0xf99f,0xfaaf,0xfaff,0xfb0f,0x00b3,0x1f58,
                   0xff4b,0xfded,0xf8ff,0xf96f,0xf97f,0xf98f,0xfa3f,0xfa4f,0xfa7f,0xfa8f,0xfb1f,
                   0xfb2f,0xfb3f,0xfb4f,0x01a4,0x3f49,0xfdcd,0xf8ef,0xfa5f,0xfabf,0xfb5f,0xfb6f,
                   0xfb7f,0xfb8f,0xfb9f,0xfbaf,0xfbbf,0xfbcf,0xfbdf,0xfbef,0x0796,0x7f8a,0xf9df,
                   0xf94f,0xfa6f,0xfa9f,0xfbff,0xfc0f,0xfc1f,0xfc2f,0xfc3f,0xfc4f,0xfc5f,0xfc6f,
                   0xfc7f,0xfc8f,0x1f98,0xf95f,0xf90f,0xfc9f,0xfcaf,0xfcbf,0xfccf,0xfcdf,0xfcef,
                   0xfcff,0xfd0f,0xfd1f,0xfd2f,0xfd3f,0xfd4f,0xfd5f,0xf9cf,0xfa1f,0xfacf,0xfd6f,
                   0xfd7f,0xfd8f,0xfd9f,0xfdaf,0xfdbf,0xfdcf,0xfddf,0xfdef,0xfdff,0xfe0f,0xfe1f,
                   0xfe2f,0xf9ff,0xfa2f,0xfe3f,0xfe4f,0xfe5f,0xfe6f,0xfe7f,0xfe8f,0xfe9f,0xfeaf,
                   0xfebf,0xfecf,0xfedf,0xfeef,0xfeff,0xff0f,0xfa0f,0xfadf,0xff1f,0xff2f,0xff3f,
                   0xff4f,0xff5f,0xff6f,0xff7f,0xff8f,0xff9f,0xffaf,0xffbf,0xffcf,0xffdf,0xffef};
 W HUF_Y_DC[0x0c]={0x0063,0x0053,0x0033,0x0023,0x0003,0x0013,0x0043,0x00e4,0x01e5,0x03e6,0x07e7,0x0fe8};

 bytes_written=0;
 while(bytes_written<size-512) // B data[512];
  {
  if((p->buffy.bit_size>>3)>0)
   {
   to_copy=(p->buffy.bit_size>>3);
   aaMemoryCopy(destination,to_copy,p->buffy.data);
   p->buffy.data[0]=p->buffy.data[p->buffy.bit_size/8];
   p->buffy.bit_size&=0x07;
   destination+=to_copy;
   bytes_written+=to_copy;
   }
  else
   {
   if(aa_JpegChunkNext(&p->chunk))
    {
    aa_JpegChunkCopyY1(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_y1dc,HUF_Y_DC,HUF_Y_AC,block);
    aa_JpegChunkCopyY2(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_y1dc,HUF_Y_DC,HUF_Y_AC,block);
    aa_JpegChunkCopyCr(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_crdc,HUF_Y_DC,HUF_Y_AC,block);
    aa_JpegChunkCopyCb(&p->chunk,block);
    aaMathDct(block,YES,YES);
    aa_JpegQuantize(p,block);
    aa_JpegEncode(p,&p->prev_cbdc,HUF_Y_DC,HUF_Y_AC,block);
    p->blocks_n+=1;
    }
   else
    {
    p->x_pos+=p->chunk.width;
    if(p->x_pos>=p->img_w)  {  p->x_pos=0;   p->y_pos+=p->chunk.height; }
    if(p->y_pos>=p->img_h)
     {
     if(p->eoi) { break; }
     else
      {
      p->buffy.bit_size=((p->buffy.bit_size+15)/8)*8; p->buffy.data[p->buffy.bit_size/8]=0xff;
      p->buffy.bit_size=((p->buffy.bit_size+15)/8)*8; p->buffy.data[p->buffy.bit_size/8]=0xd9;
      p->buffy.bit_size=((p->buffy.bit_size+15)/8)*8; p->buffy.data[p->buffy.bit_size/8]=0xd9;
      p->eoi =1;
      }
     }
    else
     {
     break;
     }
    }
   }
  }
 return bytes_written;
 }








 B aa_JpegNew                          (_jpegctx*jpegctx)
 {
 if(jpegctx==NULL) { return RET_BADPARM; }
 aaMemoryFill(jpegctx,sizeof(_jpegctx),0);
 jpegctx->magic=aaHPP(aa_JpegNew);
 return RET_YES;
 }





 B aa_JpegDelete                       (_jpegctx*jpegctx)
 {
 if(jpegctx==NULL) { return RET_BADPARM; }
 if(jpegctx->magic!=aaHPP(aa_JpegNew)) { return RET_NOTINITIALIZED; }
 if(jpegctx->out.bytes) { aaMemoryUnitRelease(&jpegctx->out); }
 if(jpegctx->yuv.bytes) { aaMemoryUnitRelease(&jpegctx->yuv); }
 aaMemoryFill(jpegctx,sizeof(_jpegctx),0);
 return RET_YES;
 }



 B aa_JpegCompress                     (_jpegctx*jpegctx,H w,H h,VP img)
 {
 B ret;
 H ioff,ooff,bytes;
 H fo,bb,i;
 F r1,g1,b1,r2,g2,b2;
 F cb1,cb2,cr1,cr2;
 F ycbcr[2048*8]; // max img width=2048
 N xx,yy,zz,jj;
 BP imgrgb;
 B hdr_data[338]={
   255,216,255,224,0,16,0x4a,0x46,0x49,0x46,0,1,0,0,0,1,0,1,0,0,255,0xdb,0,0x43,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
   0,0,0,0,0,0,0,0,0,0,0,255,0xc0,0,17,8,0,0,0,0,3,1,33,0,2,17,0,3,17,0,255,0xc4,0,31,0,0,0,7,1,
   1,1,1,1,0,0,0,0,0,0,0,0,4,5,3,2,6,1,0,7,8,9,10,11,255,0xc4,0,0xb5,16,0,2,1,3,3,2,4,2,6,7,3,4,
   2,6,2,0x73,1,2,3,17,4,0,5,33,18,0x31,0x41,0x51,6,19,0x61,0x22,0x71,0x81,20,0x32,0x91,0xa1,7,21,
   0xb1,0x42,0x23,0xc1,0x52,0xd1,0xe1,0x33,22,0x62,0xf0,0x24,0x72,0x82,0xf1,0x25,0x43,0x34,0x53,
   0x92,0xa2,0xb2,0x63,0x73,0xc2,0x35,0x44,0x27,0x93,0xa3,0xb3,0x36,23,0x54,0x64,0x74,0xc3,0xd2,
   0xe2,8,0x26,0x83,9,10,24,25,0x84,0x94,0x45,0x46,0xa4,0xb4,0x56,0xd3,0x55,0x28,26,0xf2,0xe3,
   0xf3,0xc4,0xd4,0xe4,0xf4,0x65,0x75,0x85,0x95,0xa5,0xb5,0xc5,0xd5,0xe5,0xf5,0x66,0x76,0x86,0x96,
   0xa6,0xb6,0xc6,0xd6,0xe6,0xf6,0x37,0x47,0x57,0x67,0x77,0x87,0x97,0xa7,0xb7,0xc7,0xd7,0xe7,0xf7,
   0x38,0x48,0x58,0x68,0x78,0x88,0x98,0xa8,0xb8,0xc8,216,0xe8,0xf8,0x29,0x39,0x49,0x59,0x69,0x79,
   0x89,0x99,0xa9,0xb9,0xc9,0xd9,0xe9,0xf9,0x2a,0x3a,0x4a,0x5a,0x6a,0x7a,0x8a,0x9a,0xaa,0xba,0xca,
   0xda,0xea,0xfa,255,0xda,0,12,3,1,0,2,0,3,0,0,0x3f,0
   };

 if(jpegctx==NULL) { return RET_BADPARM; }
 if(jpegctx->magic!=aaHPP(aa_JpegNew)) { return RET_NOTINITIALIZED; }
 if(img==NULL) { return RET_BADPARM; }
 if(w==0||h==0) { return RET_BOUNDS; }
 if(w>=2000||h>=2000) { return RET_BOUNDS; }
 jpegctx->img_w=w;
 jpegctx->img_h=h;
 jpegctx->prev_y1dc=0;
 jpegctx->prev_y2dc=0;
 jpegctx->prev_crdc=0;
 jpegctx->prev_cbdc=0;
 jpegctx->x_pos=0;
 jpegctx->y_pos=0;
 jpegctx->eoi=NO;
 jpegctx->blocks_n=0;
 jpegctx->header.length=338;
 jpegctx->header.img_w_off=96;
 jpegctx->header.img_h_off=94;
 aaMemoryCopy(&jpegctx->header.data[0],jpegctx->header.length,&hdr_data[0]);
 for(i=0;i<64;i++)
  {
  #if 0
  if(i<48) { jpegctx->quant[i]=1;   }  else
  if(i<56) { jpegctx->quant[i]=2;   }  else
  if(i<64) { jpegctx->quant[i]=3;   }
  #endif
  jpegctx->quant[i]=1;
  }
 for(i=0;i<64;i++)  {  jpegctx->header.data[25+i]=jpegctx->quant[i];  }
 jpegctx->header.data[jpegctx->header.img_w_off+0]=(B)(jpegctx->img_w>>8);
 jpegctx->header.data[jpegctx->header.img_w_off+1]=(B)(jpegctx->img_w&0xff);
 jpegctx->header.data[jpegctx->header.img_h_off+0]=(B)(jpegctx->img_h>>8);
 jpegctx->header.data[jpegctx->header.img_h_off+1]=(B)(jpegctx->img_h&0xff);
 aaMemoryFill(&jpegctx->buffy,sizeof(_jpegbuf),0);
 jpegctx->out_len=0;
 bytes=((jpegctx->img_w*jpegctx->img_h)*3)+_32K;
 if(jpegctx->out.bytes<bytes)
  {
  if(jpegctx->out.bytes==0) { ret=aaMemoryUnitAllocate(&jpegctx->out,bytes); }
  else                     { ret=aaMemoryUnitReAllocate(&jpegctx->out,bytes); }
  if(ret!=RET_YES) { oops; }
  }
 bytes=((jpegctx->img_w*jpegctx->img_h)*2)+_16K;
 if(jpegctx->yuv.bytes<bytes)
  {
  if(jpegctx->yuv.bytes==0) { ret=aaMemoryUnitAllocate(&jpegctx->yuv,bytes); }
  else                      { ret=aaMemoryUnitReAllocate(&jpegctx->yuv,bytes); }
  if(ret!=RET_YES) { oops; }
  }
 ioff=ooff=0;
 imgrgb=(BP)img;
 zz=0;
 for(yy=0;yy<(N)jpegctx->img_h;yy++)
  {
  for(xx=0;xx<(N)jpegctx->img_w;xx+=2)
   {
   ioff=4*(xx+(yy*jpegctx->img_w));
   r1=imgrgb[ioff+2];
   g1=imgrgb[ioff+1];
   b1=imgrgb[ioff+0];
   r2=imgrgb[ioff+6];
   g2=imgrgb[ioff+5];
   b2=imgrgb[ioff+4];
   cb1=128.0-(0.168736*r1)-(0.331264*g1)+(0.5*b1);
   cb2=128.0-(0.168736*r2)-(0.331264*g2)+(0.5*b2);
   cr1=128.0+(0.5*r1)-(0.418688*g1)-(0.081312*b1);
   cr2=128.0+(0.5*r2)-(0.418688*g2)-(0.081312*b2);
   ycbcr[zz+0]=0.299*r1+0.587*g1+0.114*b1;
   ycbcr[zz+2]=0.299*r2+0.587*g2+0.114*b2;
   ycbcr[zz+3]=(cb1+cb2)/2;
   ycbcr[zz+1]=(cr1+cr2)/2;
   zz+=4;
   }
  if((yy&2))
   {
   for(jj=0;jj<zz;jj++) { jpegctx->yuv.mem[ooff++]=(B)ycbcr[jj];    }
   zz=0;
   }
  }
 fo=0;
 aaMemoryCopy(&jpegctx->out.mem[fo],jpegctx->header.length,jpegctx->header.data);
 fo+=jpegctx->header.length;

 jpegctx->chunk.data=jpegctx->yuv.mem;//_img;
 jpegctx->chunk.width=jpegctx->img_w;
 jpegctx->chunk.height=jpegctx->img_h;
 jpegctx->chunk.x_pos=-16;
 jpegctx->chunk.y_pos=0;
 bb=aa_JpegWrite(jpegctx,&jpegctx->out.mem[fo],jpegctx->out.bytes);
 fo+=bb;
 jpegctx->out_len=fo;
 return RET_YES;
 }






/*-----------------------------------------------------------------------*/



 B aa_CursorSystemStart                (V)
 {
 logg("aa_CursorSystemStart()");
 aa.cursor_system.hand_cursor_handle=CreateCursor(aa.core_system.this_instance,6,1,32,32,aa_cursorhand,&aa_cursorhand[32*4]);
 aaCursorSet(aa_CURSOR_Arrow);
 logg("");
 return RET_YES;
 }



 V aa_CursorSystemStop                 (V)
 {
 logg("aa_CursorSystemStop()");
 if(aa.cursor_system.hand_cursor_handle!=NULL)
  {
  DestroyCursor(aa.cursor_system.hand_cursor_handle);
  aa.cursor_system.hand_cursor_handle=NULL;
  }
 logg("");
 }



/*-----------------------------------------------------------------------*/



 B aa_AppBarSystemStart                (V)
 {
 logg("aa_AppBarSystemStart");
 logg("");
 return RET_YES;
 }




 V aa_AppBarSystemStop                 (V)
 {
 logg("aa_AppBarSystemStop");
 if(aa.appbar_system.state==YES)
  {
  aaAppBarSet(NO,0,0);
  }
 logg("");
 }



/*-----------------------------------------------------------------------*/


 B aa_ColorSystemStart                 (V)
 {
 _rgba p1;
 N i,r,g,b,n;
 _rgba ref;
// _rgba*pn;

 logg("aa_ColorSystemStart()");
 aaRgbaSet(&col_null,0,0,0,0);
 aaRgbaSet(&aa.color_system.shadow,0,0,0,128);
 aaRgbaSet(&col_black,0,0,0,255);
 aaRgbaSet(&col_white,255,255,255,255);
 aaRgbaSet(&ref,0,0,0,255);
 aaRgbaSet(&p1,255,255,255,255); aaRgbaGradientArray(&ref,&p1,32,&col_gray[0]);
 aaRgbaSet(&p1,255,0,0,255);     aaRgbaGradientArray(&ref,&p1,32,&col_red[0]);
 aaRgbaSet(&p1,0,255,0,255);     aaRgbaGradientArray(&ref,&p1,32,&col_green[0]);
 aaRgbaSet(&p1,0,0,255,255);     aaRgbaGradientArray(&ref,&p1,32,&col_blue[0]);
 aaRgbaSet(&p1,255,0,255,255);   aaRgbaGradientArray(&ref,&p1,32,&col_purple[0]);
 aaRgbaSet(&p1,255,255,0,255);    aaRgbaGradientArray(&ref,&p1,32,&col_yellow[0]);
 aaRgbaSet(&p1,0,255,255,255);   aaRgbaGradientArray(&ref,&p1,32,&col_cyan[0]);
 aaRgbaSet(&p1,242,95,45,255);   aaRgbaGradientArray(&ref,&p1,32,&col_orange[0]);
 aaRgbaSet(&p1,27,173,242,255);   aaRgbaGradientArray(&ref,&p1,32,&col_sky[0]);
 aaRgbaSetUsingHlsa(&p1,250,200,200,255); aaRgbaGradientArray(&col_red[4],&p1,32,&col_pastelred[0]);
 aaRgbaSetUsingHlsa(&p1, 80,200,250,255); aaRgbaGradientArray(&col_green[4],&p1,32,&col_pastelgreen[0]);
 aaRgbaSetUsingHlsa(&p1,150,200,250,255); aaRgbaGradientArray(&col_blue[4],&p1,32,&col_pastelblue[0]);
 aaRgbaSetUsingHlsa(&p1,200,200,150,255); aaRgbaGradientArray(&col_purple[4],&p1,32,&col_pastelpurple[0]);
 aaRgbaSetUsingHlsa(&p1, 50,200,200,255); aaRgbaGradientArray(&col_yellow[4],&p1,32,&col_pastelyellow[0]);
 aaRgbaSetUsingHlsa(&p1,120,210,230,255); aaRgbaGradientArray(&col_cyan[4],&p1,32,&col_pastelcyan[0]);
 aaRgbaSet(&p1,248,168,133,255);   aaRgbaGradientArray(&col_orange[4],&p1,32,&col_pastelorange[0]);
 aaRgbaSet(&p1,106,210,248,255);   aaRgbaGradientArray(&col_sky[4],&p1,32,&col_pastelsky[0]);
 for(r=0;r<6;r++)
  {
  for(g=0;g<6;g++)
   {
   for(b=0;b<6;b++)
    {
    i=(r+g*6+b*36);
    aaRgbaSet(&aa.color_system.half_pal[i],(B)(r*51),(B)(g*51),(B)(b*51),255);
    }
   }
  }
 n=0;
 for(i=0;i<32;i++) col_map[n++]=&col_gray[i];       // 0
 for(i=0;i<32;i++) col_map[n++]=&col_red[i];        // 32
 for(i=0;i<32;i++) col_map[n++]=&col_green[i];      // 64
 for(i=0;i<32;i++) col_map[n++]=&col_blue[i];       // 96
 for(i=0;i<32;i++) col_map[n++]=&col_purple[i];     // 128
 for(i=0;i<32;i++) col_map[n++]=&col_yellow[i];     // 160
 for(i=0;i<32;i++) col_map[n++]=&col_cyan[i];       // 192
 for(i=0;i<32;i++) col_map[n++]=&col_orange[i];     // 224
 for(i=0;i<32;i++) col_map[n++]=&col_sky[i];        // 256
 for(i=0;i<32;i++) col_map[n++]=&col_pastelred[i];  // 288
 for(i=0;i<32;i++) col_map[n++]=&col_pastelgreen[i]; // 320
 for(i=0;i<32;i++) col_map[n++]=&col_pastelblue[i];  // 352
 for(i=0;i<32;i++) col_map[n++]=&col_pastelpurple[i]; // 384
 for(i=0;i<32;i++) col_map[n++]=&col_pastelyellow[i]; // 416
 for(i=0;i<32;i++) col_map[n++]=&col_pastelcyan[i];   // 448
 for(i=0;i<32;i++) col_map[n++]=&col_pastelorange[i]; // 480
 for(i=0;i<32;i++) col_map[n++]=&col_pastelsky[i];    // 512
 for(i=n;i<576;i++) col_map[i]=&col_null;
 logg("");
 return RET_YES;
 }




 V aa_ColorSystemStop                  (V)
 {
 logg("aa_ColorSystemStop()");
 logg("");
 }


/*-----------------------------------------------------------------------*/




 B aa_GifSystemStart                   (V)
 {
 logg("aa_GifSystemStart()");
 aa_ObjectIdNew(&aa.gif_system.object_id);
 aa_ObjectDefine(aa.gif_system.object_id,sizeof(_aa_gifobject),300,8,aaGifDestroy,"Gif");
 logg("");
 return RET_YES;
 }




 V aa_GifSystemStop                    (V)
 {
 logg("aa_GifSystemStop()");
 aa_ObjectUndefine(aa.gif_system.object_id);
 logg("");
 }





 B aa_GifSystemReadBytes               (PP mem,H bytes,VP buf)
 {
 H rem;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 rem=gifp->file_bytes-gifp->file_offset;
 if(bytes>rem)
  {
  aaNote(0,"%i %i %i %i",rem,gifp->file_bytes,gifp->file_offset,bytes);
  return RET_BOUNDS;
  }
 aaMemoryCopy(buf,bytes,&gifp->file_mem[gifp->file_offset]);
 gifp->file_offset+=bytes;
 return RET_YES;
 }




 N aa_GifSystemBitSize                 (N value)
 {
 N i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 for(i=1;i<=8;i++) { if((1<<i)>=value) break;  }
 return(i);
 }




 B aa_GifSystemReadFrameInfo           (PP mem)
 {
 N i,bpp;
 B Buf[32],codesize;
 HP prefix;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(aa_GifSystemReadBytes(mem,2,&gifp->frame_cord.x)==RET_FAILED||aa_GifSystemReadBytes(mem,2,&gifp->frame_cord.y)==RET_FAILED
  ||aa_GifSystemReadBytes(mem,2,&gifp->frame_size.w)==RET_FAILED||aa_GifSystemReadBytes(mem,2,&gifp->frame_size.h)==RET_FAILED)
  {
  return RET_FAILED;
  }
 if(aa_GifSystemReadBytes(mem,1,Buf)!=RET_YES)  {  return RET_FAILED;  }
 bpp=(Buf[0]&0x07)+1;
 gifp->frame_interlaced=(B)(Buf[0]&0x40);
 gifp-> frame_use_local_color=NO;
 if(Buf[0]&0x80)
  {
  if((1<<bpp)!=(1<<aa_GifSystemBitSize(1<<bpp))) return RET_FAILED;
  gifp->local_color_count=(W)(1<<bpp);
  gifp->local_color_bits=(W)aa_GifSystemBitSize((1<<bpp));
  for(i=0;i<gifp->local_color_count;i++)
   {
   if(aa_GifSystemReadBytes(mem,3,Buf)!=RET_YES)  { return RET_FAILED; }
   aaRgbaSet(&gifp->local_color_pen[i],Buf[2],Buf[1],Buf[0],255);
   }
  gifp->frame_use_local_color=YES;
  }
 gifp->PixelCount=(long)gifp->frame_size.w*(long)gifp->frame_size.h;
 if(gifp->frame_cord.x<0||gifp->frame_cord.x>=(N)gifp->status.size.w) { return RET_FAILED; } // ningy added (N)
 if(gifp->frame_cord.y<0||gifp->frame_cord.y>=(N)gifp->status.size.h) { return RET_FAILED; } // ningy added (N)
 if(gifp->frame_size.w>gifp->status.size.w) { return RET_FAILED; }
 if(gifp->frame_size.h>gifp->status.size.h) { return RET_FAILED; }
 if(gifp->frame_cord.x+gifp->frame_size.w>gifp->status.size.w) { return RET_FAILED; }
 if(gifp->frame_cord.y+gifp->frame_size.h>gifp->status.size.h) { return RET_FAILED; }
 aa_GifSystemReadBytes(mem,1,&codesize);
 bpp=codesize;
 gifp->Buf[0]=0;
 gifp->bpp=bpp;
 gifp->clear_code=(1<<bpp);
 gifp->eof_code=gifp->clear_code+1;
 gifp->RunningCode=gifp->eof_code+1;
 gifp->RunningBits=bpp+1;
 gifp->MaxCode1=1<<gifp->RunningBits;
 gifp->stack_ptr=0;
 gifp->last_code=4098;
 gifp->CrntShiftState=0;
 gifp->CrntShiftDWord=0;
 prefix=gifp->Prefix;
 for(i=0;i<=4095;i++) {  prefix[i]=4098;  }
 return RET_YES;
 }




 B aa_GifSystemReadExtension           (PP mem,NP extension_code,BP*extension)
 {
 B buf;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_GifSystemReadBytes(mem,1,&buf)!=RET_YES)  {  return RET_FAILED;  }
 *extension_code=buf;
 return aa_GifSystemReadExtensionNext(mem,extension);
 }





 B aa_GifSystemReadExtensionNext       (PP mem,BP*extension)
 {
 B buf;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(aa_GifSystemReadBytes(mem,1,&buf)!=RET_YES) {  return RET_FAILED;  }
 if(buf>0)
  {
  *extension=gifp->Buf;
  (*extension)[0]=buf;
  if(aa_GifSystemReadBytes(mem,buf,&((*extension)[1]))!=RET_YES)  {  return RET_FAILED;  }
  }
 else {  *extension=NULL;  }
 return RET_YES;
 }





 B aa_GifSystemReadLine                (PP mem,BP line,N linelen)
 {
 BP dummy;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(!linelen) {  linelen=(I)gifp->frame_size.w;  }
 if((gifp->PixelCount-=linelen)>0xffff0000) {  return RET_FAILED; }
 if(aa_GifSystemDecompressLine(mem,line,linelen)==RET_YES)
  {
  if(gifp->PixelCount==0)
   {
   do { if(aa_GifSystemGetCodeNext(mem,&dummy)==RET_FAILED)  {  return RET_FAILED;   }   } while(dummy!=NULL);
   }
  return RET_YES;
  }
 return RET_FAILED;
 }






 B aa_GifSystemGetCodeNext             (PP mem,BP*codeblock)
 {
 B buf;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 if(aa_GifSystemReadBytes(mem,1,&buf)!=RET_YES) {  return RET_FAILED;  }

 if(buf>0)
  {
  *codeblock=gifp->Buf;
  (*codeblock)[0]=buf;
  if(aa_GifSystemReadBytes(mem,buf,&((*codeblock)[1]))!=RET_YES)  {  return RET_FAILED; }
  }
 else
  {
  *codeblock=NULL;
  gifp->Buf[0]=0;
  gifp->PixelCount=0;
  }
 return RET_YES;
 }





 B aa_GifSystemDecompressLine          (PP mem,BP line,N linelen)
 {
 N i,j,crnt_code,eof_code,clear_code,crnt_prefix,last_code,stack_ptr;
 BP stack,suffix;
 HP prefix;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 i=0;
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 stack_ptr=gifp->stack_ptr;
 prefix=gifp->Prefix;
 suffix=gifp->Suffix;
 stack=gifp->Stack;
 eof_code=gifp->eof_code;
 clear_code=gifp->clear_code;
 last_code=gifp->last_code;

 if(stack_ptr!=0)
  {
  while(stack_ptr!=0&&i<linelen)
   {
   if(line) line[i++]=stack[--stack_ptr];
   else { i++; --stack_ptr; }
   }
  }
 while(i<linelen)
  {
  if(aa_GifSystemDecompressInput(mem,&crnt_code)==RET_FAILED) {  return RET_FAILED; }
  if(crnt_code==eof_code)
   {
   if(i!=linelen-1||gifp->PixelCount!=0)  { return RET_FAILED; }
   i++;
   }
  else if(crnt_code==clear_code)
   {
   for(j=0;j<=4095;j++)  { prefix[j]=4098; }
   gifp->RunningCode=gifp->eof_code+1;
   gifp->RunningBits=gifp->bpp+1;
   gifp->MaxCode1=1<<gifp->RunningBits;
   last_code=gifp->last_code=4098;
   }
  else
   {
   if(crnt_code<clear_code)
    {
    if(line) { line[i++] =(B) crnt_code; }
    else     { i++; }
    }
   else
    {
    if(prefix[crnt_code]==4098)
     {
     if(crnt_code==(N)gifp->RunningCode - 2) // ningy added (N)
      {
      crnt_prefix=last_code;
      suffix[gifp->RunningCode - 2]=stack[stack_ptr++]=aa_GifSystemGetPrefixChar(prefix,last_code,clear_code);
      }
     else { return RET_FAILED; }
     }
    else
     {
     crnt_prefix=crnt_code;
     }
     j=0;
     while(j++<=4095&&crnt_prefix>clear_code&&crnt_prefix<=4095)
      {
      stack[stack_ptr++]=suffix[crnt_prefix];
      crnt_prefix=prefix[crnt_prefix];
      }
     if(j>=4095||crnt_prefix>4095) {  return RET_FAILED;  }
     stack[stack_ptr++]=(B)crnt_prefix;
     while(stack_ptr!=0&&i<linelen)
      {
      if(line) { line[i++]=stack[--stack_ptr]; }
      else     { i++; --stack_ptr; }
      }
     }
   if(last_code!=4098)
    {
    prefix[gifp->RunningCode - 2]=last_code;
    if(crnt_code==(N)gifp->RunningCode-2) { suffix[gifp->RunningCode-2]=aa_GifSystemGetPrefixChar(prefix,last_code,clear_code);  }// ningy added (N)
    else                                  { suffix[gifp->RunningCode-2]=aa_GifSystemGetPrefixChar(prefix,crnt_code,clear_code);  }
    }
   last_code=crnt_code;
   }
  }
 gifp->last_code=last_code;
 gifp->stack_ptr=stack_ptr;
 return RET_YES;
 }




 B aa_GifSystemGetPrefixChar           (HP prefix,N Code,N clear_code)
 {
 N i=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 while(Code>clear_code&&i++<=4095) Code=prefix[Code];
 return (B)Code;
 }





 B aa_GifSystemDecompressInput         (PP mem,NP Code)
 {
 B NextByte;
 _aa_gifobject*gifp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(gifp,_aa_gifobject*,*mem);
 while(gifp->CrntShiftState<gifp->RunningBits)
  {
  if(gifp->Buf[0]==0)
   {
   if(aa_GifSystemReadBytes(mem,1,gifp->Buf)!=RET_YES)   {  return RET_FAILED; }
   if(aa_GifSystemReadBytes(mem,gifp->Buf[0],&gifp->Buf[1])!=RET_YES) { return RET_FAILED; }
   NextByte=gifp->Buf[1];
   gifp->Buf[1]=2;
   gifp->Buf[0]--;
   }
  else
   {
   NextByte=gifp->Buf[gifp->Buf[1]++];
   gifp->Buf[0]--;
   }
  gifp->CrntShiftDWord|=((H)NextByte)<<gifp->CrntShiftState;
  gifp->CrntShiftState+=8;
  }
 *Code=gifp->CrntShiftDWord&aa_GifCodeMasks[gifp->RunningBits];
 gifp->CrntShiftDWord>>=gifp->RunningBits;
 gifp->CrntShiftState-=gifp->RunningBits;
 if(++gifp->RunningCode>gifp->MaxCode1&&gifp->RunningBits<12)
  {
  gifp->MaxCode1<<=1;
  gifp->RunningBits++;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

/*
//http://hackerthedude.blogspot.com.au/2009/10/keylogger-in-c.html
//-----------


*/






 __declspec(dllexport) K KeyEvent      (int nCode,WPARAM wParam,LPARAM lParam)
 {
 //H fla;
 LPARAM lp;
 HWND hwnd;
 H han,flag;
 KBDLLHOOKSTRUCT hooked=*((KBDLLHOOKSTRUCT*)lParam);


 if(nCode==HC_ACTION)
  {
  if(wParam==WM_KEYUP||wParam==WM_KEYDOWN||wParam==WM_SYSKEYUP||wParam==WM_SYSKEYDOWN)//||wParam==WM_SYSCHAR||wParam==WM_CHAR)
   {
   lp=0;
   lp=lp|(0x0000FFFF&0x00000001);
   lp=lp|(0x00FF0000&(hooked.scanCode<<16));
   lp=lp|(0x01000000&((hooked.flags&LLKHF_EXTENDED)<<23));
   lp=lp|(0x20000000&((hooked.flags&LLKHF_ALTDOWN)<<24));
   lp=lp|(0x80000000&((hooked.flags&LLKHF_UP)<<24));
   if(flag) {}
   if(han) {}
   if(hwnd) {}
///   if(aa_SurfaceSystemFindSurfaceByHwnd(0,0,GetFocus())!=RET_YES)
    {
    //aaDebugf("not surf");
    aa_InputSystemKeyEventProc(0,wParam,hooked.vkCode,lp,1);
    }
   }
  }
 return CallNextHookEx(aa.input_system.hKeyHook,nCode,wParam,lParam);
 }





 __declspec(dllexport) K MouseEvent      (int nCode,WPARAM wParam,LPARAM lParam)
 {
 //LPARAM lp;
 //HWND hwnd;
 //H han,flag;
 I delta;
 MSLLHOOKSTRUCT*hooked=(MSLLHOOKSTRUCT*)lParam;

 if(nCode==HC_ACTION)
  {
  if(wParam==WM_MOUSEWHEEL)
   {
   delta=HIWORD(hooked->mouseData);
   if(delta<0)    {    aa.input_system.wheel--;    }
   else
   if(delta>0)    {    aa.input_system.wheel++;    }
   }
  }
 return CallNextHookEx(aa.input_system.hMouseHook,nCode,wParam,lParam);
 }




 B aa_InputKeyLoggerStart              (V)
 {
 HINSTANCE hExe=GetModuleHandle(NULL);
 if(!hExe) hExe=LoadLibrary(NULL);
 if(!hExe) return RET_FAILED;
 aa.input_system.hKeyHook=SetWindowsHookEx(WH_KEYBOARD_LL,(HOOKPROC)KeyEvent,hExe,0);
 aa.input_system.hMouseHook=SetWindowsHookEx(WH_MOUSE_LL,(HOOKPROC)MouseEvent,hExe,0);
 //MsgLoop();
 //UnhookWindowsHookEx(hKeyHook);
 return RET_YES;
 }





/*
 V StartKeyLogger                      (V)
 {
 HANDLE hThread;
 DWORD dwThread;
 DWORD exThread;

 hThread = CreateThread(NULL,NULL,(LPTHREAD_START_ROUTINE)  KeyLogger, NULL, NULL, &dwThread);
 if(hThread==0) oof;
 //if(hThread) {   return WaitForSingleObject(hThread,INFINITE);   }
 ///else {        return 1;    }
 }
*/


 B aa_InputSystemStart                 (V)
 {
 H val,v;
 B state[256];

 logg("aa_InputSystemStart()");
 val=0;
 aa.input_system.keyboard_delay=aa.input_system.keyboard_speed=256;
 if(SystemParametersInfo(SPI_GETKEYBOARDDELAY,0,&val,0)!=0) { aa.input_system.keyboard_delay=((val+1)*256); }
 if(SystemParametersInfo(SPI_GETKEYBOARDSPEED,0,&val,0)!=0) { aa.input_system.keyboard_speed=(256-(val*7)); } // 256 is apx 1/4sec, so 1s,val=31 is apx 1/30secs 256-(val*7)
 aa.input_system.keyboard_delay*=0.8;
 aa.input_system.keyboard_speed*=1.2;
 aa.input_system.keyboard_layout=GetKeyboardLayout(0);
 if(GetKeyboardState(state)==0) { oof; }
 for(v=0;v<256;v++)   { state[v]=aaBitClr(state[v],0);  }
 ///for(v=0;v<256;v++)   { state[v]=aaBitClr(state[v],7);  }
 ///for(v=0;v<256;v++)   { state[v]=aaBitClr(state[v],7);  }
 ///aaMemoryFill(state,sizeof(state),0);
 if(SetKeyboardState(state)==0) { oof; oow; Boop; }
 for(v=0;v<256;v++)  {  aa.input_system.keyboard_scan_code[v]=(H)MapVirtualKeyEx(v,0,aa.input_system.keyboard_layout);  }
 aa.input_system.wheel=0;
 if(aa.input_system.tray_hwnd==NULL)
  {
  if((aa.input_system.tray_hwnd=FindWindow("Shell_TrayWnd",NULL))==NULL) { oof; }
  }
 aa.input_system.vsx=GetSystemMetrics(78);//now uses virtual screen , not SM_CXSCREEN);
 aa.input_system.vsy=GetSystemMetrics(79);//SM_CYSCREEN);
 aa.input_system.tray_cycle=0;
 logg("");
 return RET_YES;
 }






 V aa_InputSystemStop                  (V)
 {
 aa_InputSystemHookedKeyEngineStop();
 }




 B aa_InputSystemHookedKeyEngineStart  (V)
 {
 I k;
 HANDLE h;


 if(aa.input_system.ihke_que.handle==0)
  {
  //aaQueCreate(&aa.input_system.input_stream_que.handle);
  //aaQueStatus(aa.input_system.input_stream_que.handle,&aa.input_system.input_stream_que.status);
  h=0;
  aa.input_system.mutex_handle=h;
  aa.input_system.ihke_que.handle=1;
  aa.input_system.ihke_que_head=0;
  aa.input_system.ihke_que_tail=0;
  aa.input_system.ihke_events_waiting=0;
  //aa.input_system.speedy=aaMicrosecsRunning();
  aa.input_system.ihke_sequence=1;
  aa.input_system.sequence=1;
  k=GetKeyState(VK_CAPITAL); if(aaBitGet(k,0)) { aa.input_system.is_caps=YES; }
  k=GetKeyState(VK_NUMLOCK); if(aaBitGet(k,0)) { aa.input_system.is_numl=YES; }
  k=GetKeyState(VK_SCROLL);  if(aaBitGet(k,0)) { aa.input_system.is_scrl=YES; }
  aa_InputKeyLoggerStart();
  }
 return RET_YES;
 }







 B aa_InputSystemHookedKeyEngineStop   (V)
 {
 //if(aa.input_system.hHook) {  UnhookWindowsHookEx(aa.input_system.hHook); aa.input_system.hHook=0; }
 if(aa.input_system.mutex_handle!=0) {   CloseHandle(aa.input_system.mutex_handle); }
 #if 0
 if(aa.input_system.input_stream_que.handle!=0)
  {
  aaQueDestroy(aa.input_system.input_stream_que.handle);
  aa.input_system.input_stream_que.handle=0;
  }
  #endif
 if(aa.input_system.ihke_que.handle!=0)
  {
  //aaQueDestroy(aa.input_system.ihke_que.handle);
  aa.input_system.ihke_que.handle=0;
  }
 if(aa.input_system.vkcode!=NULL) {   aaMemoryRelease(aa.input_system.vkcode); }
 if(aa.input_system.memod.magic) { aaMemoryModuleRelease(&aa.input_system.memod); }
 //if(aa.input_system.vmvm.magic) {   aaVmDelete(&aa.input_system.vmvm); }
 return RET_YES;
 }




#if 0
 B aa_InputSystemThisGetProcAddress    (VP name,VP etc,BP type,PP ptr)
 {
 B ret=RET_YES;
 H index;
 VP pro;

 UNUSE(etc);
 UNUSE(type);
 aaLog(-777,"%s: %s",__func__,name);
 ret=aaVmProcFind(&aa.input_system.vmvm,name,&index,(VP)&pro,NULL);
 if(ret==RET_YES)  {  *ptr=pro;  return ret;  }
 aaNote(0,"coulnt find %s",name);
 return ret;
 }
#endif




 B aa_InputSystemCountVkeys            (V)
 {
 Z z;
 aa.input_system.vkey_used_count=aa.input_system.vkey_down_count=0;
 aa.input_system.vkey_held_count=aa.input_system.vkey_up_count=0;
 for(z=0;z<256;z++)
  {
  if(aa.input_system.vkey_state[z]!=0)  { aa.input_system.vkey_used_count++; }
  if(aa.input_system.vkey_state[z]==1)  { aa.input_system.vkey_down_count++; }
  if(aa.input_system.vkey_state[z]>=2)  { aa.input_system.vkey_held_count++; }
  if(aa.input_system.vkey_state[z]==-1) { aa.input_system.vkey_up_count++; }
  }
 return RET_YES;
 }




 V aaDebugHwnds                        (V)
 {
 HWND tw,aw,fw,fo;
 B titt[4][_1K];
 B clas[4][_1K];

 tw=GetTopWindow(NULL); aw=GetActiveWindow(); fw=GetFocus(); fo=GetForegroundWindow();
 aaDebugf("---------");
 if(tw==NULL||aw==NULL||fw==NULL||fo==NULL) aaDebugf("fuckfuck %x %x %x %x",tw,aw,fw,fo);
 if(tw!=NULL) {  aaHwndInfoGet(tw,0,0,0,clas[0],titt[0]); aaDebugf("top:0x%08x c:%s t:%s",tw,clas[0],titt[0]); }
 if(aw!=NULL) {  aaHwndInfoGet(aw,0,0,0,clas[1],titt[1]); aaDebugf("act:0x%08x c:%s t:%s",aw,clas[1],titt[1]); }
 if(fw!=NULL) {  aaHwndInfoGet(fw,0,0,0,clas[2],titt[2]); aaDebugf("foc:0x%08x c:%s t:%s",fw,clas[2],titt[2]); }
 if(fo!=NULL) {  aaHwndInfoGet(fo,0,0,0,clas[3],titt[3]); aaDebugf("for:0x%08x c:%s t:%s",fo,clas[3],titt[3]); }
 }






 B aa_InputSystemVkeyStateSet          (Z vkey,B cmd,B ismore)
 {
 B txt[_2K];

 //hooker
 if(cmd=='d') ///aa.input_system.is_left==YES)
  {
  if(aa.input_system.vkey_state[vkey]==0)  {   aa.input_system.vkey_state[vkey]=1;   }
  else
  if(aa.input_system.vkey_state[vkey]>=1)
   {
   if(aa.input_system.vkey_state[vkey]<126) {  aa.input_system.vkey_state[vkey]++;    }
   }
  else
   {
   aaDebugHwnds();
   aaStringNull(txt);
   aaStringAppendf(txt,"A.. ismore=%i vkey[%02x] state=%i\n",ismore,vkey,aa.input_system.vkey_state[vkey]);
   aa.input_system.vkey_state[vkey]=1;
   aaStringAppendf(txt,"*** down line=%i vkey=%02x state=%i waiting=%I64d\n",__LINE__,vkey,aa.input_system.vkey_state[vkey],aa.input_system.ihke_events_waiting);
   aaWinEventLog(2,0,123,8555,"%s %s %i\n%s",__FILE__,__func__,__LINE__,txt);
   aa_stats[9]++;
   }
  }
 else
 if(cmd=='u')
  {
  if(aa.input_system.vkey_state[vkey]>=1)  {   aa.input_system.vkey_state[vkey]=-1;   }
  else
  if(aa.input_system.vkey_state[vkey]==0)
   {
   return NO;
   }
  else
   {
   aaDebugHwnds();
   aaStringNull(txt);
   aaStringAppendf(txt,"C.. ismore=%i vkey[%02x] state=%i\n",ismore,vkey,aa.input_system.vkey_state[vkey]);
   aaStringAppendf(txt,"*** up line=%i state=%i vkey=%02x\n",__LINE__,aa.input_system.vkey_state[vkey],vkey);
   aaWinEventLog(2,0,123,8777,"%s %s %i\n%s",__FILE__,__func__,__LINE__,txt);
   aa_stats[9]++;
   }
  }
 else
  {
  oof;
  }
 return RET_YES;
 }






 structure
 {
 H msg;
 _aa_inputhookedkeyevent ihke;
 //KBDLLHOOKSTRUCT kbdHookStruct;
 //KBDLLHOOKSTRUCT*kbdHookStruct;
 W inBuffer[2];
 B keyboard_state[256];
 C key;
 I k;
 H xf;
 Z r;
 DWORD res;
 B isinjected;
 WPARAM wparam;
 LPARAM lparam;
 }
 _inputhookparms;





 B aa_InputSystemKeyEventProc          (HWND wnd,H msg,WPARAM wparm,LPARAM lparm,B extflag)
 {
 S _inputhookparms ihppstat;
 S _inputhookparms*ihpp=NULL;
 N virtCode=wparm;
 N scanCode=HIWORD(lparm)&0xff;


 UNUSE(wnd);
 if(aa.input_system.mutex_handle!=0)
  {
  DWORD res;
  if((res=WaitForSingleObject(aa.input_system.mutex_handle,INFINITE))==WAIT_FAILED) {  oow; oof; return RET_FAILED; }
  if(res==WAIT_TIMEOUT)   { oof; }
  if(res==WAIT_ABANDONED) { oof; }
  if(res!=WAIT_OBJECT_0)  { oof; oow; oof; }
  }


 #if 0
 if(aaMemoryAllocate((VP)&ihpp,sizeof(_inputhookparms))!=YES) { oof; }
 aaMemoryNameSet(ihpp,"inphookparms");
 #else
 ihpp=&ihppstat;
 #endif

 // B fcetc[_2K]; sprintf(fcetc,"%s %i",__func__,sizeof(_inputhookparms)); OutputDebugString(fcetc);
 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 ihpp->msg=msg;
 ihpp->wparam=wparm;
 ihpp->lparam=lparm;
// ihpp->kbdHookStruct=(KBDLLHOOKSTRUCT*)lParam;
 ihpp->isinjected=NO;
 aaMemoryFill(&ihpp->ihke,sizeof(_aa_inputhookedkeyevent),0);
 ihpp->ihke.is_ext=extflag;
 ihpp->ihke.is_injected=NO;
 ihpp->ihke.sequence=aa.input_system.ihke_sequence;
 ihpp->ihke.microsecs=aaMicrosecsRunning();
 ihpp->ihke.skey_code=scanCode;
 ihpp->ihke.vkey_code=virtCode;
 //-------------
 if(ihpp->msg==WM_SYSKEYDOWN||ihpp->msg==WM_SYSKEYUP) {  ihpp->ihke.is_sys=YES;  }
 if(ihpp->msg==WM_KEYDOWN||ihpp->msg==WM_SYSKEYDOWN)  {  ihpp->ihke.msg='d'; } else
 if(ihpp->msg==WM_KEYUP||ihpp->msg==WM_SYSKEYUP)      {  ihpp->ihke.msg='u'; }
 else  {  oof;  }
 //if(ihpp->ihke.is_sys==YES&&aaBitGet(ihpp->kbdHookStruct->flags,5)==NO) { oof; } else
 //if(ihpp->ihke.is_sys==NO&&aaBitGet(ihpp->kbdHookStruct->flags,5)==YES) { oof; }
 //-----------------
 if(GetKeyboardState(ihpp->keyboard_state)==0) { oof; }
  ihpp->k=GetKeyState(VK_CAPITAL); if(aaBitGet(ihpp->k,0)) ihpp->ihke.is_caps=YES;
  ihpp->k=GetKeyState(VK_NUMLOCK); if(aaBitGet(ihpp->k,0)) ihpp->ihke.is_numl=YES;
  ihpp->k=GetKeyState(VK_SCROLL);  if(aaBitGet(ihpp->k,0)) ihpp->ihke.is_scrl=YES;
  ihpp->k=GetKeyState(VK_SHIFT);    if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_shift=YES;
  ihpp->k=GetKeyState(VK_CONTROL);  if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_ctrl=YES;
  ihpp->k=GetKeyState(VK_MENU);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_alt=YES;
  ihpp->k=GetKeyState(VK_LWIN);     if(aaBitGet(ihpp->k,15)) ihpp->ihke.is_win=YES;
 //-----------------
 ihpp->xf=MapVirtualKeyEx(ihpp->ihke.vkey_code,2,aa.input_system.keyboard_layout);
 if(aaBitGet(ihpp->xf,31)) { oof; }
 ihpp->ihke.xf=(B)LOWORD(ihpp->xf);
 if(ihpp->ihke.xf==0) { ihpp->ihke.xf=ihpp->ihke.vkey_code; }
 ///------------------------------------------------------------
 if(ihpp->ihke.msg=='d'||ihpp->ihke.msg=='u')
  {
  if(ihpp->ihke.is_sys==YES)   {   }
  else
   {
   ihpp->r=ToAscii(ihpp->ihke.vkey_code,ihpp->ihke.skey_code,ihpp->keyboard_state,ihpp->inBuffer,0);
   if(ihpp->r==0)    {    }
   else
   if(ihpp->r==1)
    {
    ihpp->key=(C)ihpp->inBuffer[0];
    ihpp->ihke.akey_code=ihpp->key;
    }
   else              {  oof;  }
   }
  }
 else { oof;  }
 ///-----------
 if(ihpp->ihke.msg!=0)
  {
  aa.input_system.ihke_sequence++;
  aaMemoryCopy(&aa.input_system.ihke_que_array[aa.input_system.ihke_que_head],sizeof(_aa_inputhookedkeyevent),&ihpp->ihke);
  aa.input_system.ihke_que_head++;
  aa.input_system.ihke_que_head%=aa_INPUT_IHKE_QUEUE_SIZE;
  aa.input_system.ihke_events_waiting++;
  aa.input_system.ihke_events_total++;
  //aaDebugf("%I64u",aa.input_system.ihke_events_waiting);
  if((aa.input_system.ihke_events_waiting+10)>=aa_INPUT_IHKE_QUEUE_SIZE) oof;
//  aaDebugf("%I64u",aa.input_system.ihke_events_waiting);
  }


 if(ihpp!=&ihppstat)
  {
  aaMemoryRelease(ihpp);
  ihpp=NULL;
  }


 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 if(aa.input_system.mutex_handle!=0)
  {
  if(!ReleaseMutex(aa.input_system.mutex_handle)) { oow; }
  }

 return RET_YES;
 }









 B aa_InputSystemHookedKeyProcess      (_aa_inputhookedkeyevent*aaihke)
 {
 B ret;
 _aa_inputhookedkeyevent ihke;

 if(aaihke==NULL) { oof; }
 if(aa.input_system.ihke_events_waiting==0) { return RET_NOTREADY; }
 aaMemoryCopy(&ihke,sizeof(_aa_inputhookedkeyevent),&aa.input_system.ihke_que_array[aa.input_system.ihke_que_tail]);
 ret=RET_FAILED;
 if(ihke.msg=='d')   { ret=aa_InputSystemVkeyStateSet((Z)ihke.vkey_code,'d',NO);   } else
 if(ihke.msg=='u')   { ret=aa_InputSystemVkeyStateSet((Z)ihke.vkey_code,'u',NO);   }
 if(ret==RET_FAILED) { oops; }
 if(ret==RET_NO)
  {
  aa.input_system.ihke_que_tail++;
  aa.input_system.ihke_que_tail%=aa_INPUT_IHKE_QUEUE_SIZE;
  aa.input_system.ihke_events_waiting--;
  return RET_NOTREADY;
  }
 aa_InputSystemCountVkeys();
 ///------------------------------------------------------------
 aa.input_system.is_caps=ihke.is_caps;
 aa.input_system.is_numl=ihke.is_numl;
 aa.input_system.is_scrl=ihke.is_scrl;
 aa.input_system.is_shift=ihke.is_shift;
 aa.input_system.is_ctrl=ihke.is_ctrl;
 aa.input_system.is_alt=ihke.is_alt;
 aa.input_system.is_win=ihke.is_win;
 aaMemoryCopy(&ihke,sizeof(_aa_inputhookedkeyevent),&aa.input_system.ihke_que_array[aa.input_system.ihke_que_tail]);
 aa.input_system.ihke_que_tail++;
 aa.input_system.ihke_que_tail%=aa_INPUT_IHKE_QUEUE_SIZE;
 aaMemoryCopy(aaihke,sizeof(_aa_inputhookedkeyevent),&ihke);
 aa.input_system.ihke_events_waiting--;
 return RET_YES;
 }





 B aa_InputStateGet                    (_inputstate*inputstate,B dokeys,B domouse)
 {
 B ret;
 Z z;
 H sh;
 _aa_surfaceobject*surp;
 _aa_inputhookedkeyevent ihke;
 Q ms;
 I k;
 POINT pt;
 POINT xpt;
// DWORD res;
 _surfacespot*sspot;
 _cord rcd;
 H spid,smoff,go;
 HWND actvhwnd,fochwnd,forghwnd;//,tophwnd;
 HWND pointhwnd;


 if(aa.input_system.ihke_que.handle==0)  {  aa_InputSystemHookedKeyEngineStart();    }
 if(inputstate==NULL) { return RET_BADPARM; }

 inputstate->is_ok=NO;
 //cit00: aaMemoryFill(inputstate,sizeof(_inputstate),0);
 dokeys&=1; domouse&=1;
 //if(mcsdelay==0) { mcsdelay=1; }

#if 0
 if(aa.input_system.mutex_handle!=0)
  {
  aa_last_line_executed=__LINE__;
  if((res=WaitForSingleObject(aa.input_system.mutex_handle,0))==WAIT_FAILED)  {  oow; oof; return RET_FAILED; }
  if(res==WAIT_TIMEOUT) { return RET_NOTREADY; }
  if(res==WAIT_ABANDONED)  { oof; }
  if(res!=WAIT_OBJECT_0)  { oof; oow; oof; }
  }
 #endif

// return RET_NOTREADY;
 ms=aaMicrosecsRunning();

 #if 0
 if(mcsdelay!=0)
  {

  if(((ms-aa.input_system.speedy)<(mcsdelay))&&aa.input_system.ihke_events_waiting==0)
   {
   #if 0
   if(aa.input_system.mutex_handle!=0)
    {
    if(!ReleaseMutex(aa.input_system.mutex_handle)) { oow; }
    }
    #endif
   return RET_NOTREADY;
   }
   aaDebugf("etto %I64d %I64d",aaMsRunning(),aa.input_system.ihke_events_waiting);

  }

#endif

 //aaDebugf("%s:%u",__func__,__LINE__);
 //aaDebugf("%.4f",(ms-aa.input_system.speedy)/1000.0);

 #if 1 // remove fill inputstate to zero, testing if is_ok is enough
 aaMemoryFill(inputstate,sizeof(_inputstate),0); // cit00: moved here
 #endif

 inputstate->is_ok=YES;
// aa.input_system.speedy=ms;
 aaMemoryFill(&ihke,sizeof(ihke),0);
///aa_last_line_executed=__LINE__;
// these following 3 getkeystate calls were getasynckeystate calls
 k=GetKeyState(VK_LBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_left=YES;  } else { aa.input_system.is_left=NO;  }
 k=GetKeyState(VK_MBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_mid=YES;   } else { aa.input_system.is_mid=NO;   }
 k=GetKeyState(VK_RBUTTON); if(aaBitGet(k,15)) { aa.input_system.is_right=YES; } else { aa.input_system.is_right=NO; }

 /**===============================================================*/
 inputstate->spot_cord.x=inputstate->spot_cord.y=0;
 inputstate->spot_index=-1;
 inputstate->spot_id=0;
 inputstate->spot_type=0;
 inputstate->spot_ptr=NULL;
 inputstate->microsecs=ms;
 inputstate->seq=aa.input_system.sequence;
 aa.input_system.sequence++;

 aaHwndGroupGet(&actvhwnd,&fochwnd,&forghwnd);//&tophwnd);


 GetCursorPos(&pt);
 ///WinPointToCord(&pt,&inputstate->over_cord);
 pointhwnd=WindowFromPoint(pt);
 if(pointhwnd==NULL) { }//oow; }
 inputstate->cord.x=pt.x;
 inputstate->cord.y=pt.y;
 inputstate->over_hwnd=pointhwnd;
 inputstate->focus_hwnd=forghwnd;

 ///==============================================
  if(inputstate->focus_hwnd!=NULL)
   {
   if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,(VP)&surp,inputstate->focus_hwnd)==YES)
    {
    surp->status.is_focus=YES;

    if(surp->status.is_focus!=YES)
     {
     go=0;
     while(1)
      {
      SetFocus(inputstate->focus_hwnd);
      aaYieldRaw();
      aaSurfaceStatus(sh,0);
      if(surp->status.is_focus) { break; }
      go++;
      aaSleep(0);
      }
     if(go!=0)
      {
      //aaDebugf("#%i  go=%i",__LINE__,go);
      }
     }

    inputstate->is_focus_surface=YES;
    inputstate->focus_handle=sh;
    aaSurfaceVisualCordToCord(sh,&inputstate->cord,&inputstate->focus_cord);
    }
   else
    {
    WinPointCopy(&xpt,&pt);
    ScreenToClient(inputstate->focus_hwnd,&xpt);
    WinPointToCord(&xpt,&inputstate->focus_cord);
    }
   }
 ///==============================================
  if(inputstate->over_hwnd!=NULL)
   {
   if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,(VP)&surp,inputstate->over_hwnd)==YES)
    {
    inputstate->is_over_surface=YES;
    inputstate->over_handle=sh;
    aaSurfaceVisualCordToCord(sh,&inputstate->cord,&inputstate->over_cord);
    }
   else
    {
    WinPointToCord(&pt,&inputstate->over_cord);
    }
   }
 ///=============================================

   if(inputstate->is_focus_surface)
    {
    if(aa_SurfaceSystemFindSurfaceByHwnd(&sh,(VP)&surp,inputstate->focus_hwnd)!=YES) { oof; }
    if(surp->status.spot_order_ok!=YES)
     {
     aa_SurfaceSortSpots((VP)&surp);
     if(surp->status.spot_order_ok!=YES)  { oof; }
     }
    if(surp->status.spot_count>0)
     {
     rcd.x=inputstate->focus_cord.x-surp->status.spot_depth_rect.x;
     rcd.y=inputstate->focus_cord.y-surp->status.spot_depth_rect.y;
     if(rcd.x>=0&&rcd.y>=0&&rcd.x<(N)surp->status.spot_depth_rect.w&&rcd.y<(N)surp->status.spot_depth_rect.h)
      {
      smoff=(rcd.y*surp->status.spot_depth_rect.w)+rcd.x;
      spid=surp->status.spot_id_map[smoff];
      if(spid!=0)
       {
       if((ret=aaSurfaceSpotFindById(surp->status.self_handle,spid,&sspot))!=YES)
        {
        aaNote(0,"%s %i %s, spid=%i",__func__,__LINE__,ret_string[ret],spid);
        }

       if(aaRectIsValid(&sspot->rect)==YES)
        {
        if(aaCordIsWithinRect(&inputstate->focus_cord,&sspot->rect)==RET_YES)
         {
         inputstate->spot_index=sspot->index;
         inputstate->spot_id=sspot->id;
         inputstate->spot_type=sspot->type;
         aaRectCopy(&inputstate->spot_rect,&sspot->rect);
         inputstate->spot_ptr=sspot;
         }
        }
       }
      }
     }
    }


 //===============================================================
 if(inputstate->spot_index!=-1)
  {
  aaCordSet(&inputstate->spot_cord,inputstate->focus_cord.x-sspot->rect.x,inputstate->focus_cord.y-sspot->rect.y);
  }
 inputstate->wheel=aa.input_system.wheel;
 if(aa.input_system.ihke_events_waiting!=0)
  {
  ret=aa_InputSystemHookedKeyProcess(&ihke);
  if(ret!=YES&&ret!=RET_NOTREADY) { oops; }
  if(ret==RET_YES)
   {
   //aaDebugf("%x %x %c",ihke.akey_code,ihke.vkey_code,ihke.msg);
   if(ihke.msg=='d'||ihke.msg=='u')
    {
    inputstate->key_microsecs=ihke.microsecs;
    inputstate->key_seq=ihke.sequence;
    inputstate->key_msg=ihke.msg;
    inputstate->key_sys=ihke.is_sys;
    inputstate->skey=ihke.skey_code;
    inputstate->vkey=ihke.vkey_code;
    inputstate->akey=ihke.akey_code;
    inputstate->key_inj=ihke.is_injected;
    inputstate->xkey=ihke.xf; // i moved it here
    }
   else
    {
    ///aaDebugf("aa_Istate ihke neither");
    }
   }
  }
 inputstate->is_caps=aa.input_system.is_caps;
 inputstate->is_numl=aa.input_system.is_numl;
 inputstate->is_scrl=aa.input_system.is_scrl;
 inputstate->is_shift=aa.input_system.is_shift;
 inputstate->is_ctrl=aa.input_system.is_ctrl;
 inputstate->is_alt=aa.input_system.is_alt;
 inputstate->is_win=aa.input_system.is_win;
 inputstate->is_left=aa.input_system.is_left;
 inputstate->is_mid=aa.input_system.is_mid;
 inputstate->is_right=aa.input_system.is_right;

 z=VK_LBUTTON;
 if(aa.input_system.is_left==YES)      {  aa_InputSystemVkeyStateSet(z,'d',NO);  } else
 if(aa.input_system.vkey_state[z]>=1)  {  aa_InputSystemVkeyStateSet(z,'u',NO);  }

 z=VK_MBUTTON;
 if(aa.input_system.is_mid==YES)       {   aa_InputSystemVkeyStateSet(z,'d',NO);  } else
 if(aa.input_system.vkey_state[z]>=1)  {   aa_InputSystemVkeyStateSet(z,'u',NO);  }

 z=VK_RBUTTON;
 if(aa.input_system.is_right==YES)     {   aa_InputSystemVkeyStateSet(z,'d',NO);  } else
 if(aa.input_system.vkey_state[z]>=1)  {   aa_InputSystemVkeyStateSet(z,'u',NO);  }

 aa_InputSystemCountVkeys();
 inputstate->vkey_used_count=aa.input_system.vkey_used_count;
 inputstate->vkey_down_count=aa.input_system.vkey_down_count;
 inputstate->vkey_held_count=aa.input_system.vkey_held_count;
 inputstate->vkey_up_count=aa.input_system.vkey_up_count;
 for(z=0;z<256;z++)  {  inputstate->vkey_state[z]=aa.input_system.vkey_state[z];  }

 for(z=0;z<256;z++)
  {
  if(aa.input_system.vkey_state[z]==-1)  {  aa.input_system.vkey_state[z]=0;   }
  }

 aa_InputSystemCountVkeys();
 inputstate->events_waiting=aa.input_system.ihke_events_waiting;

///---------------------
#if 0
 if(aa.input_system.mutex_handle!=0)
  {
  if(!ReleaseMutex(aa.input_system.mutex_handle)) { oow; }
  }
  #endif

 return RET_YES;
 }





///=====================================================



/*-----------------------------------------------------------------------*/





 B aa_AudioSystemStart                 (V)
 {
 logg("aa_AudioSystemStart()");
 aa_ObjectIdNew(&aa.audio_system.object_id);
 aa_ObjectDefine(aa.audio_system.object_id,sizeof(_aa_audioobject),10,4,aaAudioDestroy,"Audio");
 logg("");
 return RET_YES;
 }





 V aa_AudioSystemStop                  (V)
 {
 logg("aa_AudioSystemStop()");
 aa_ObjectUndefine(aa.audio_system.object_id);
 logg("");
 }







 B aa_AudioSystemModeVerify            (_audiomode*audiomode)
 {
 B m;
 H r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL)  {  return RET_BADPARM;  }
 audiomode->bps=0;
 audiomode->mode=0;
 if(audiomode->frequency== 8000) { m=0; } else
 if(audiomode->frequency==11025) { m=4; } else
 if(audiomode->frequency==16000) { m=8; } else
 if(audiomode->frequency==22050) { m=12; } else
 if(audiomode->frequency==24000) { m=16; } else
 if(audiomode->frequency==32000) { m=20; } else
 if(audiomode->frequency==44100) { m=24; } else
 if(audiomode->frequency==48000) { m=28; }
 else                              {  return RET_FAILED;  }
 m++;
 r=audiomode->frequency;
 if(audiomode->bits==8)                      { m+=(B)0; } else
 if(audiomode->bits==16||audiomode->bits==0) { m+=(B)2; r<<=1; }
 else                                        {   return RET_FAILED;  }
 if(audiomode->channels==1)  { m+=(B)0; r<<=1; } else
 if(audiomode->channels==2)  { m+=(B)1; }
 else                        {  return RET_FAILED;  }
 if((m-1)%4==0) { audiomode->bps=1; } else
 if((m-1)%4==1) { audiomode->bps=2; } else
 if((m-1)%4==2) { audiomode->bps=2; } else { audiomode->bps=4; }
 audiomode->mode=m;
 audiomode->rate=r;
 return RET_YES;
 }





 K aa_AudioSystemOutProc               (HWAVEOUT h,UINT msg,H data,H p1,H p2)
 {
 B ret;
 WAVEHDR*p;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(h);
 UNUSE(p2);
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,data,(VP)&audp,NULL))!=RET_YES) { oof; Boop; return ret; }
 switch(msg)
  {
  case WOM_OPEN:
  audp->is_openreceived=YES;
  break;

  case WOM_DONE:
  aaCast(p,WAVEHDR*,p1);
  if(!(p->dwFlags&WHDR_DONE))
   {
   //aaDebugf("p->dwflags&DONE failed");
   }
  if(!(p->dwFlags&WHDR_PREPARED)) {  }
  break;

  default:
  break;
  }
 return 0;
 }




 K aa_AudioSystemInProc                (HWAVEOUT h,UINT msg,H data,H p1,H p2)
 {
 B ret;
 WAVEHDR*p;
 _aa_audioobject*audp;

 D gain,avg;
 W abss;
 H s,samples,sk;
 IP ip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(h);
 UNUSE(p2);
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,data,(VP)&audp,NULL))!=RET_YES) { oof; Boop; return ret; }
 switch(msg)
  {
  case WIM_OPEN:
  audp->is_openreceived=YES;
  break;

  case WIM_DATA:
  aaCast(p,WAVEHDR*,p1);
  if(p->dwBytesRecorded==0) {  break; }

  // DECIBEL DETECT
  samples=p->dwBytesRecorded/audp->status.mode.bps;
  if((ret=aaQueWrite(audp->que_handle,p->dwBytesRecorded,&p->lpData[0]))!=RET_YES)   {   aaNote(0,"oops=%i line=%i",ret,__LINE__);   }
   #if 1
   aaCast(ip,IP,&p->lpData[0]);
   avg=0.0;
   sk=10;
   for(s=0;s<samples;s+=sk)
    {
    abss=(W)aaNumAbs(ip[s]);
    abss=(W)aaNumClamp(abss,1,32767);
    gain=log10((D)abss/32767.0);
    avg=avg+gain;
    }
   gain=(D)avg/((D)samples/(D)sk);
   audp->status.decibels=pow(10.0,gain);
   #endif
//zoro
aaQueStatus(audp->que_handle,&audp->que_status);
  break;

  default:
  break;
  }
 return 0;
 }








 B aa_AudioSystemUpdateSamplePosition  (PP mem)
 {
 _aa_audioobject*audp;
 MMTIME mmt;
 D d1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaMemoryFill(&mmt,sizeof(mmt),0);
 mmt.wType=TIME_SAMPLES;
 if(audp->status.is_record==YES)
  {
  if(waveInGetPosition((HWAVEIN)audp->handle,&mmt,sizeof(MMTIME))!=MMSYSERR_NOERROR) { oof; oow; Boop; }
  }
 else
  {
  if(waveOutGetPosition((HWAVEOUT)audp->handle,&mmt,sizeof(MMTIME))!=MMSYSERR_NOERROR) { oof; oow; Boop; }
  }
 if(mmt.wType==TIME_SAMPLES)
  {
  d1=(D)(mmt.u.sample);
  d1/=(audp->status.div);
  audp->status.mcs=(Q)d1;
  }
 else  {  oof;  Boop;   }
 audp->status.sample_position=mmt.u.sample;
 if(audp->status.is_record==NO)
  {
  audp->status.samples_surplus=audp->status.samples_written-audp->status.sample_position;
  }
 else
  {
  audp->status.samples_surplus=audp->status.sample_position-audp->status.samples_written;
  }
 return RET_YES;
 }





 B aa_AudioSystemProcessQues           (PP mem)
 {
 B ret;
 MMRESULT mr;
 WAVEHDR*p;
 H q,s,el;//,todo;
 _aa_audioobject*audp;
// IP left,right;
 S H last_ms_known=NO;
 S H last_ms;
 D gain,avg;
 W abss;
 H samples,sk;
 IP ip;
 N val;
 IP left;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);

 audp->cycle++;

 if(last_ms_known==NO)
  {
  last_ms=aa.core_system.aamain_elapsed;
  last_ms_known=YES;
  }

 if(audp->status.mixer_device!=0)
  {
  aaTimerPrimitive(aa.core_system.aamain_elapsed,last_ms,&el);
  if(el>=50)
   {
   aa_AudioSystemGetVolume((VP)&audp,audp->ctrl_master_volume,&val);
   aaCast(left,IP,&val);
   audp->status.volume=(W)left[0];
   aa_AudioSystemGetMute((VP)&audp,audp->ctrl_master_mute,&val);
   audp->status.is_mute=(B)val;
   last_ms=aa.core_system.aamain_elapsed;
   }
  }

 /// RECORD
 if(audp->status.is_record==YES)//&& audp->status.is_paused==NO)
  {
  for(q=0;q<audp->status.maxblocks;q++)
   {
   aaCast(p,WAVEHDR*,&audp->wave_hdr[q]);
   if(p->dwFlags&WHDR_DONE&&!(p->dwFlags&WHDR_INQUEUE)&&p->dwFlags&WHDR_PREPARED)
    {
    mr=waveInAddBuffer(audp->handle,p,sizeof(WAVEHDR));
    if(mr!=MMSYSERR_NOERROR&&mr!=WAVERR_STILLPLAYING)     {      aaNote(0,"waveinaddbuffer error, mr=%i",mr);      }
    }
   }
  }
else
 if(audp->status.is_record==NO)
  {
  aaQueStatus(audp->que_handle,&audp->que_status);
  if(audp->que_status.bytes>=(audp->status.blocksize*audp->status.mode.bps*1))
   {

   for(q=0;q<audp->status.maxblocks;q++)
    {
    aaCast(p,WAVEHDR*,&audp->wave_hdr[q]);
    if(!(p->dwFlags&WHDR_INQUEUE)&&p->dwFlags&WHDR_PREPARED)
     {
     if((ret=aaQueRead(audp->que_handle,(audp->status.blocksize*audp->status.mode.bps),p->lpData))!=RET_YES) { oops; }
     #if 1
     // DECIBEL DETECT
     samples=audp->status.blocksize;
     aaCast(ip,IP,&p->lpData[0]);
     avg=0.0;
     sk=10;
     for(s=0;s<samples;s+=sk)
      {
      abss=(W)aaNumAbs(ip[s]);
      abss=(W)aaNumClamp(abss,1,32767);
      gain=log10((D)abss/32767.0);
      avg=avg+gain;
      }
     gain=(D)avg/((D)samples/(D)sk);
     audp->status.decibels=pow(10.0,gain);
//   todo=audp->status.blocksize;
     #endif
     if((mr=waveOutWrite((HWAVEOUT)audp->handle,p,sizeof(WAVEHDR)))!=MMSYSERR_NOERROR)       {       aaNote(0,"Waveoutwriteerror %i audp=%i",mr,audp->handle);       }
     //aaQueStatus(audp->que_handle,&audp->que_status);
     //if(audp->que_status.bytes<(audp->status.blocksize*audp->status.mode.bps)) { break; }
     break;
     }
    }
   if(q!=0) { aaQueStatus(audp->que_handle,&audp->que_status); }


   }
  }

 return RET_YES;
 }







 D aa_AudioSystemAtan2                 (D x,D y)
 {
 D signx;
 if(x>0.) signx=1.;
 else signx=-1.;
 if(x==0.) return 0.;
 if(y==0.) return signx*aaPi/2.;
 return atan2(x,y);
 }





 V aa_AudioSystemFFT                   (FP fftbuffer,N framesize,N sign)
 {
 F wr,wi,arg,*p1,*p2,temp;
 F tr,ti,ur,ui,*p1r,*p1i,*p2r,*p2i;
 N i,bitm,j,le,le2,k;

 for(i=2;i<2*framesize-2;i+=2)
  {
  for(bitm=2,j=0;bitm<2*framesize;bitm<<=1)
   {
   if(i&bitm) j++;
   j<<=1;
   }
  if(i<j)
   {
   p1=fftbuffer+i;
   p2=fftbuffer+j;
   temp=*p1;
   *(p1++)=*p2;
   *(p2++)=temp;
   temp=*p1;
   *p1=*p2;
   *p2=temp;
   }
  }
 for(k=0,le=2; k<(long)(log(framesize)/log(2.)+.5); k++)
  {
  le<<=1;
  le2=le>>1;
  ur=1.0;
  ui=0.0;
  arg=aaPi/(le2>>1);
  wr=cos(arg);
  wi=sign*sin(arg);
  for(j=0;j<le2;j+=2)
   {
   p1r=fftbuffer+j;
   p1i=p1r+1;
   p2r=p1r+le2; p2i=p2r+1;
   for(i=j;i<2*framesize;i+=le)
    {
    tr=*p2r*ur-*p2i*ui;
    ti=*p2r*ui+*p2i*ur;
    *p2r=*p1r-tr;
    *p2i=*p1i-ti;
    *p1r+=tr;
    *p1i+=ti;
    p1r+=le;
    p1i+=le;
    p2r+=le;
    p2i+=le;
    }
   tr=ur*wr-ui*wi;
   ui=ur*wi+ui*wr;
   ur=tr;
   }
  }
 }



 B aa_AudioSystemGetVolume             (PP mem,H ctrlid,NP vol)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(MIXERCONTROLDETAILS *)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_UNSIGNED)*mxdets->cChannels;
 mxdets->paDetails=vol;
 mmr=mixerGetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }





 B aa_AudioSystemSetVolume             (PP mem,H ctrlid,NP vol)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(LPMIXERCONTROLDETAILS)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_UNSIGNED)*mxdets->cChannels;
 mxdets->paDetails=vol;
 mmr=mixerSetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }





 B aa_AudioSystemGetMute               (PP mem,H ctrlid,NP mute)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(LPMIXERCONTROLDETAILS)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN)*mxdets->cChannels;
 mxdets->paDetails=mute;
 mmr=mixerGetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_GETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }




 B aa_AudioSystemSetMute               (PP mem,H ctrlid,NP mute)
 {
 B dat[_4K];
 BP bp;
 MMRESULT mmr;
 MIXERCONTROLDETAILS *mxdets;
 _aa_audioobject*audp;
 HMIXER Mixer;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 mxdets=(LPMIXERCONTROLDETAILS)bp;
 mxdets->cbStruct=sizeof(MIXERCONTROLDETAILS);
 mxdets->dwControlID=ctrlid;
 #if defined(_MSC_VER)||(__GNUC__)
 mxdets->cMultipleItems=0;
 #else
 #if __BORLANDC__ >= 0x0551
 mxdets->cMultipleItems=0;
 #else
 mxdets->u.cMultipleItems=0;
 #endif
 #endif
 mxdets->cChannels=1;
 mxdets->cbDetails=sizeof(MIXERCONTROLDETAILS_BOOLEAN);
 mxdets->paDetails=mute;
 mmr=mixerSetControlDetails((HMIXEROBJ)Mixer,mxdets,MIXER_SETCONTROLDETAILSF_VALUE|MIXER_OBJECTF_MIXER);
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }




 B aa_AudioSystemGetLineControls       (PP mem,MIXERLINE*mxline,H source,H dest,HP volctrl,HP mutectrl)
 {
 MMRESULT mmr;//=MMSYSERR_NOERROR;
 UINT ct;
 MIXERLINECONTROLS mxctls;
// Z temptype;
 B dat[_4K];
 BP bp;
 _aa_audioobject*audp;
 HMIXER Mixer;

 if(mem==NULL) { return RET_BADPARM; }
 aaCast(audp,_aa_audioobject*,*mem);
 aaCast(bp,BP,dat);
 Mixer=audp->status.mixer_device;
 aaMemoryFill(mxline,sizeof(MIXERLINE),0);
 mxline->cbStruct=sizeof(MIXERLINE);
 mxline->dwDestination=dest;
 mxline->dwSource=source;
 if((N)source==-1)  {  mxline->dwSource=0;  mmr=mixerGetLineInfo((HMIXEROBJ)Mixer,mxline,MIXER_OBJECTF_MIXER|MIXER_GETLINEINFOF_DESTINATION);  }
 else               {  mmr=mixerGetLineInfo((HMIXEROBJ)Mixer,mxline,MIXER_OBJECTF_MIXER|MIXER_GETLINEINFOF_SOURCE);  }
 if(mmr!=MMSYSERR_NOERROR) {}
 mxctls.cbStruct=sizeof(MIXERLINECONTROLS);
 mxctls.dwLineID=mxline->dwLineID;
 mxctls.cControls=mxline->cControls;
 mxctls.cbmxctrl=sizeof(MIXERCONTROL);
 mxctls.pamxctrl=(LPMIXERCONTROL)bp;
 mmr =mixerGetLineControls((HMIXEROBJ)Mixer,&mxctls,MIXER_OBJECTF_MIXER|MIXER_GETLINECONTROLSF_ALL);
 if(mmr==MMSYSERR_NOERROR)
  {
  for(ct=0;ct<mxctls.cControls;ct++)
   {
//   temptype=MIXERCONTROL_CONTROLTYPE_VOLUME;
   if(mxctls.pamxctrl[ct].dwControlType==MIXERCONTROL_CONTROLTYPE_VOLUME)    {    *volctrl=mxctls.pamxctrl[ct].dwControlID;    }
   else
   if(mxctls.pamxctrl[ct].dwControlType==MIXERCONTROL_CONTROLTYPE_MUTE)      {    *mutectrl=mxctls.pamxctrl[ct].dwControlID;    }
   }
  }
 mxctls.pamxctrl=NULL;
 if(mmr!=MMSYSERR_NOERROR) { return RET_FAILED; }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aa_VidCapSystemStart                (V)
 {
 logg("aa_VidCapSystemStart()");
 aa_ObjectIdNew(&aa.vidcap_system.object_id);
 aa_ObjectDefine(aa.vidcap_system.object_id,sizeof(_aa_vidcapobject),10,2,aaVidCapDestroy,"VidCap");
 logg("");
 // shut those stupid vfw warnings ups

 if(ICDecompressEx!=ICDecompressEx) {}
 if(ICDecompressExBegin!=ICDecompressExBegin) {}
 if(ICDecompressExQuery!=ICDecompressExQuery) {}
 if(ICSetStatusProc!=ICSetStatusProc) {}
 #ifndef __GNUC__
 if(dwICValue!=dwICValue) {}
 #endif
 if(ICDrawSuggestFormat!=ICDrawSuggestFormat) {}
 return RET_YES;
 }






 V aa_VidCapSystemStop                 (V)
 {
 logg("aa_VidCapSystemStop()");
 aa_ObjectUndefine(aa.vidcap_system.object_id);
 logg("");
 }






 H aa_VidCapThread                     (VP parm)
 {
 B ret;
 MSG msg;
 _aa_vidcapobject*vdcp;
 //_aa_threadobject*thrp;
 BOOL bl;
 aa_CAPDRIVERCAPS caps;
 _threadstatus thread_status;
 H thread_status_cycle;
 C txt[_1K];
 HP hp;
 _threadunit tu;

 H handle;

 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 hp=(HP)parm;
 //aaNote(0,"%x %x",&hp[0],&hp[1]);
 //aaNote(0,"%x %x",hp[0],hp[1]);
 tu.handle=(H)&hp[0];
 if((ret=aaThreadStatus(tu.handle,&tu.status))!=RET_YES) { oops; }

 handle=tu.status.data;//(H)&hp[1];
 //aaNote(0,"%x %x",hp[0],hp[1]);
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=YES) { oops; }
 // aaCast(thrp,_aa_threadobject*,parm);
 //if(aa_ObjectCheck(aa.vidcap_system.object_id,thrp->data,(VP)&vdcp,NULL)!=RET_YES) oof;
 aaStringCopyf(txt,"CapWin%i",vdcp->device_id);//status.id);
 if((vdcp->hwnd=capCreateCaptureWindow(txt,WS_POPUP|WS_DISABLED,0,0,1,1,0,0))==NULL) { oof; oow; Boop; Boop; Boop;  }
 //logg("VidCapThread is calling aa_vidCapSetCallbacks(YES)");
 aa_VidCapSetCallbacks((VP)&vdcp,YES);
 //logg("VidCapThread about to connect");
 if(capDriverConnect(vdcp->hwnd,vdcp->device_id)==FALSE)
  {
  vdcp->is_connect_failed=YES;
  aa_VidCapSetCallbacks((VP)&vdcp,NO);
  }
 else
  {
  //aaDebugf("aa_vidCapThread... capDriverConnect(%i) SUCCESS",vdcp->device_id);
  if(capDriverGetCaps(vdcp->hwnd,&caps,sizeof(caps))==FALSE) { oof; oow; }
  if(caps.fHasDlgVideoSource)  vdcp->status.has_sourcebox=YES;
  if(caps.fHasDlgVideoFormat)  vdcp->has_format=YES;
  if(caps.fHasDlgVideoDisplay) vdcp->has_display=YES;
  }
 //aaDebugf("Signaling vidcap event");
 if(vdcp->is_connect_failed)
  {
  vdcp->status.is_connected=NO;
  //aaDebugf("Destroying cap window (hwnd=%i)",vdcp->hwnd);
  if(DestroyWindow(vdcp->hwnd)==0) { oof; oow; Boop; }
 vdcp->hwnd=NULL;
 //aaDebugf("Vidcap (%i) thread fin",vdcp->device_id);
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 ExitThread(RET_YES);
 return(RET_YES);
 }
 if(aa_EventSignal(&vdcp->connect_event)!=YES) { oof; Boop; }
 thread_status_cycle=0;
// BUG,"index=%i",vdcp->status.id);
 while(1)
  {
//  if(vdcp->is_connect_failed) { oof; break; }
  //aa_DIAG("aa_VidCapThread");

  #if USE_VIDCAP_CRITICAL_SECTION == 1
  aaThreadLock(thrp->self_handle,YES);
  #endif
  if(PeekMessage(&msg,0,0,0,PM_NOREMOVE))
   {
   bl=GetMessage(&msg,0,0,0);
   if(bl==0) {   break; }
   else
   if(bl==-1) { oof; }
   else
   if(bl!=0)
    {
    TranslateMessage(&msg); ///////////// nov 22 2006 i removed this too see if it would cause problems
    DispatchMessage(&msg);
    switch(msg.message)
     {
     case WM_QUIT:
     //aaDebugf("VidCapProc: Window %i vidcaphwnd=%i got WM_QUIT",msg.hwnd,vdcp->hwnd);
//     BUG,"wm_quit of vidcap");
     break;

     case WM_USER_VIDCAP_SOURCE:
     //aaDebugf("sourcebox open");
     // we should make these events, or put them in critcal sections
     vdcp->is_sourcebox_message_received=YES;
     if(capDlgVideoSource(vdcp->hwnd)==FALSE)
      {
      //aaDebugf("err func %s line %i",__func__,__LINE__);
      }
     ///aaDebugf("sourcebox close hwnd=%x",vdcp->hwnd);
//     vdcp->status.is_sourcebox_show=NO;
     vdcp->is_sourcebox_closed=YES;
     break;

     default:
     break;
     }
    }
   }
  if((thread_status_cycle%aa_VIDCAP_THREAD_STATUS_CYCLE)==0)
   {
   if((ret=aaThreadStatus(vdcp->thread_handle,&thread_status))!=YES)
    {
    oops;
    //aaDebugf("threadstatus=%i",ret);
    Boop;
    }
   #if USE_VIDCAP_CRITICAL_SECTION == 1
   aaThreadUnLock(thrp->self_handle);
   #endif
   if(thread_status.is_exiting==YES)   { oof;   break;   }
   }
  thread_status_cycle++;
  aaSleep(aa_VIDCAP_THREAD_SLEEP); // was just sleep
  }
// BUG,"finio %i",vdcp->status.id);
 //aaDebugf("Clearing callbacks");
 aa_VidCapSetCallbacks((VP)&vdcp,NO);
 //aaDebugf("callbacks cleared");
 if(vdcp->is_connect_failed!=YES)
  {
  //aaDebugf("disconnecting capture (hwnd=%i)",vdcp->hwnd);
  if(capDriverDisconnect(vdcp->hwnd)==FALSE)
   {
   //aaDebugf("Capdisconnect failed");
   }
  }
 vdcp->status.is_connected=NO;
 //aaDebugf("Destroying cap window (hwnd=%i)",vdcp->hwnd);
 if(DestroyWindow(vdcp->hwnd)==0) { oof; oow; Boop; }
 vdcp->hwnd=NULL;
/// log(Vidcap (%i) thread fin",vdcp->device_id);

 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 ExitThread(RET_YES);
// return(RET_YES);
 }





 B aa_VidCapSetCallbacks               (PP mem,B state)
 {
 _aa_vidcapobject*vdcp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  {  return RET_BADPARM;  }
 aaCast(vdcp,_aa_vidcapobject*,*mem);
 if(vdcp==NULL) {  return RET_BADPARM;  }

 //aaDebugf("aa_VidCapSetCallBacks being set to %s",aaBoolString(state));
 if(state==YES)
  {
  if(capSetCallbackOnError(vdcp->hwnd,aa_VidCapErrorProc)==FALSE) { oof; oow; Boop; }
  if(capSetCallbackOnCapControl(vdcp->hwnd,aa_VidCapControlProc)==FALSE) { oof; oow; Boop; }
  if(capSetCallbackOnStatus(vdcp->hwnd,aa_VidCapStatusProc)==FALSE) { oof;  oow; Boop;  }
  if(capSetCallbackOnVideoStream(vdcp->hwnd,aa_VidCapVideoProc)==FALSE) { oof; oow; Boop; }
  if(capSetCallbackOnFrame(vdcp->hwnd,aa_VidCapPreviewProc)==FALSE) { oof; oow; Boop; }
  logg("vidcap callbacks set");
  }
 else
  {
  capSetCallbackOnError(vdcp->hwnd,NULL);
  capSetCallbackOnCapControl(vdcp->hwnd,NULL);
  capSetCallbackOnStatus(vdcp->hwnd,NULL);
  capSetCallbackOnVideoStream(vdcp->hwnd,NULL);
  capSetCallbackOnFrame(vdcp->hwnd,NULL);
  //aaDebugf("vidcap callbacks cleared");
  }
 return RET_YES;
 }





 B aa_VidCapFindByCaptureHwnd          (HP handle,PP mem,HWND wnd)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 _aa_vidcapobject*vdcp;
 H base,h,instance_stride;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 id=aa.vidcap_system.object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_FAILED; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 for(h=0;h<aa.object_system.object[id].instance_slots;h++)
  {
  aaCast(oih,_aa_objectinstanceheader*,bp);
  if(oih->in_use==YES)
   {
   bp+=sizeof(_aa_objectinstanceheader);
   aaCast(vdcp,_aa_vidcapobject*,bp);
   if(vdcp->hwnd==wnd)
    {
    if(handle) { *handle=base+h; }
    if(mem)    { *mem=bp; }
    return RET_YES;
    }
   bp-=sizeof(_aa_objectinstanceheader);
   }
  bp+=instance_stride;
  }
 return RET_NOTFOUND;
 }




 K aa_VidCapErrorProc                  (HWND wnd,N errorid,LPSTR errortxt)
 {
 _aa_vidcapobject*vdcp;
 H vidcap_handle;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 logg("aa_VidCapErrorProc **");
 UNUSE(errortxt);
 if(aa_VidCapFindByCaptureHwnd(&vidcap_handle,(VP)&vdcp,wnd)!=RET_YES)
  {
  oof;
  Boop;
  return FALSE;
  }
 if(errorid==0)
  {
  vdcp->error_code=0;
  return TRUE;
  }
 vdcp->error_count++;
 vdcp->error_code=errorid;
 //aaDebugf("Error#%i: (%i) %s",vdcp->error_count,vdcp->error_code,errortxt);
 return TRUE;
 }





 K aa_VidCapControlProc                (HWND wnd,N state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(wnd);
 switch(state)
  {
  default:
  //aaDebugf("state=%i",state);
  break;

  case aa_CONTROLCALLBACK_PREROLL: // called just before capture begins
  //aaDebugf("ControlProc: Pre-Roll");
  break;
  case aa_CONTROLCALLBACK_CAPTURING: // called during capture
  break;
  }
 return TRUE; // return FALSE to abort at anytime
 }



 K aa_VidCapStatusProc                 (HWND wnd,N id,LPCSTR str)
 {
 _aa_vidcapobject*vdcp;
 H vidcap_handle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 UNUSE(str);
 if(aa_VidCapFindByCaptureHwnd(&vidcap_handle,(VP)&vdcp,wnd)!=RET_YES)
  {
  oof;
  Boop;
  return FALSE;
  }
 switch(id)
  {
  case aa_IDS_CAP_BEGIN:
  //aaDebugf("CapStatusProc: Begin");
  break;
  case aa_IDS_CAP_END:
  vdcp->is_abort_complete=YES;
  //aaDebugf("CapStatusProc: End");
  break;
  default:
  break;
  }
 return TRUE;
 }




 // during preview mode
 K aa_VidCapPreviewProc                (HWND wnd,aa_VIDEOHDR* lpvhdr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_VidCapProcessFrame(wnd,lpvhdr)==RET_NO)
  {
  return FALSE;
  }
 return TRUE;
 }




 // during streaming mode
 K aa_VidCapVideoProc                  (HWND wnd,aa_VIDEOHDR* lpvhdr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_VidCapProcessFrame(wnd,lpvhdr)==RET_NO)
  {
  return FALSE;
  }
 return TRUE;
 }





 B aa_VidCapProcessFrame               (HWND wnd,aa_VIDEOHDR* lpvhdr)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 H vidcap_handle;
 H dwSize;
 BITMAPINFO bmi;
 B type;
 BP bp;
 H s_offset;
 H d_offset;
 _rgba*p4;
 _aa_pen24*p3;
 _aa_pen16*p2;
 N x,y;
 BP yl_ptr;
 BP yr_ptr;
 BP yb_ptr;
 HP shp,dhp;
 N rr,gg,bb,YY,UU,VV;
 H wshift;
 H WID,HIT;
 N XXX,YYY;
 H divs,mods;
 /////

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_VidCapFindByCaptureHwnd(&vidcap_handle,(VP)&vdcp,wnd)!=RET_YES)
  {
  oof;
  //aaDebugf("wnd=%i ...",wnd);
  Boop;
  return RET_NO;
  }

 if(vdcp->status.is_connected!=YES)  {  return RET_NO;  }
 if(vdcp->status.is_ready!=YES)  {  return RET_NO;  }
 if(vdcp->is_frame_waiting==YES)
  {
  vdcp->status.frames_dropped++;
  return RET_NO;
  }
 if(vdcp->status.frame_number==0)
  {
  vdcp->status.ms_start=aaMsRunning();
  }
 vdcp->status.frame_number++;

 vdcp->status.fps=(D)aaMsRunning()-(D)vdcp->status.ms_start;
 vdcp->status.fps=vdcp->status.fps/1000.0;
 vdcp->status.fps=(D)vdcp->status.frame_number/vdcp->status.fps;


 dwSize=capGetVideoFormatSize(wnd);
 if(dwSize==0||dwSize>_1K)
  {
  //aaDebugf("vid frame format size=%i",dwSize);
  //logg("Bad=%i",vdcp->frames_bad);
  vdcp->frames_bad++;
  return RET_NO;
  }
 if(capGetVideoFormat(wnd,&bmi,dwSize)==FALSE)
  {
  //logg("vid frame format get failure");
  //aaDebugf("GetVidFormat Bad=%i",vdcp->frames_bad);
  vdcp->frames_bad++;
  return RET_NO;
  }
 if(vdcp->status.size.w!=(H)bmi.bmiHeader.biWidth||vdcp->status.size.h!=(H)bmi.bmiHeader.biHeight) // ningy added (H)
  {
  //logg("vid frame has changed sizes");
  //aaDebugf("VidChange Bad=%i",vdcp->frames_bad);
  vdcp->frames_bad++;
  return RET_NO;
  }
// log(OIII %i",__LINE__);
  // look in c:\arcvhies\codeccode\mashvidcap for 420 conversion routines
 switch (bmi.bmiHeader.biCompression)
  {
  case BI_RGB:       type=1; break; // RGB
  case BI_RLE8:      type=0; break; // RLE8
  case BI_BITFIELDS: type=0; break; // BITFIELDS
  case VAL_I420:       type=4; break; // I420
  case VAL_IYUV:       type=4; break; // I420
  #if aa_VIDCAP_ALLOW_YUY2==YES
  case VAL_YUY2:       type=5; break; // YUY2
  #endif

  case VAL_YUYV:       type=0; break;
  case VAL_V422:       type=0; break;
  case VAL_UYVY:       type=0; break;
  case VAL_YV12:       type=0; break;
  case 0x20424944:   type=0; break; // uncompressed, full frames
  case 0x64697663:   type=0; break; // cinepak by supermac
  case 0x32335649:   type=0; break; // Intel indeo video r3.2
  case 0x6376736d:   type=0; break; // ms video 1
  case 0x656c726c:   type=0; break; // Rle
  default:           type=0; break;
  }
 if(vdcp->frame_buf_bytes<(vdcp->status.size.w*vdcp->status.size.h*4))
  {
  //aaDebugf("renaje videp frame %i, %i",vdcp->frame_buf_bytes,(vdcp->status.size.w*vdcp->status.size.h*4));
  if(vdcp->status.surface_handle!=0)
   {
   if((ret=aaSurfaceDestroy(vdcp->status.surface_handle))!=RET_YES) { oops; }
   vdcp->status.surface_handle=0;
   aaMemoryFill(&vdcp->status.surface_status,sizeof(_surfacestatus),0);
   }
  bp=vdcp->frame_buf;
  dwSize=vdcp->status.size.w*(vdcp->status.size.h+2)*4;
  if((ret=aa_MemoryReAllocate((VP)&bp,dwSize))!=RET_YES) { oops; }
  vdcp->frame_buf=bp;
  vdcp->frame_buf_bytes=dwSize;
  }
 if(vdcp->status.surface_handle==0)
  {
  //aaLog(-1,"aa");
  //aaDebugf("Creating vidcap surface");
//  aaLog(-1,"create iv");
  if((ret=aaSurfaceMake(&vdcp->status.surface_handle,&vdcp->status.size,vdcp->frame_buf))!=RET_YES) oops;
//  aaSurfaceVisualize(vdcp->status.surface_handle);
  aaSurfaceFlipSet(vdcp->status.surface_handle,0,1);
  aaSurfaceStatus(vdcp->status.surface_handle,&vdcp->status.surface_status);
  //aaDebugf("surface made %i %i",vdcp->status.size.w,vdcp->status.size.h);
  }
 aaSurfaceStatus(vdcp->status.surface_handle,&vdcp->status.surface_status);
 if(vdcp->status.surface_status.size.w!=vdcp->status.size.w||vdcp->status.surface_status.size.h!=vdcp->status.size.h)
  {
  //aaDebugf("remcreate iv");
  //aaDebugf("Remaking vidcap surface");
  if((ret=aaSurfaceReMake(vdcp->status.surface_handle,&vdcp->status.size,vdcp->frame_buf))!=RET_YES) oops;
  aaSurfaceStatus(vdcp->status.surface_handle,&vdcp->status.surface_status);
  //aaDebugf("surface re-made %i %i",vdcp->status.size.w,vdcp->status.size.h);
  }
  XXX=0;
  YYY=0;
  WID=vdcp->status.size.w;
  HIT=vdcp->status.size.h;
// if(vdcp->profiler.magic==0) { aaTimerProfilerInit(&vdcp->profiler,1); }
// aaTimerProfilerUpdate(&vdcp->profiler,1);
// aaTimerProfilerElapsed(&vdcp->tikmicro,&vdcp->status.frame_micro);
 switch(type)
  {
  case 1:
  if(vdcp->status.bits==15||vdcp->status.bits==16)
   {
   bp=lpvhdr->lpData;
   aaCast(p2,_aa_pen16*,bp);
   for(y=0;y<(N)HIT;y++) // ningy added (N)
    {
    s_offset=((y+YYY)*vdcp->status.size.w)+XXX;
    d_offset=(y*WID);
    for(x=0;x<(N)WID;x++)// ningy added (N)
     {
     vdcp->status.surface_status.mem[d_offset].r=(B)(p2[s_offset].r<<3);
     vdcp->status.surface_status.mem[d_offset].g=(B)(p2[s_offset].g<<3);
     vdcp->status.surface_status.mem[d_offset].b=(B)(p2[s_offset].b<<3);
     s_offset++;
     d_offset++;
     }
    }
   }
  else
  if(vdcp->status.bits==24)
   {
   bp=lpvhdr->lpData;
   aaCast(p3,_aa_pen24*,bp);
   divs=WID/16;
   mods=WID%16;
   for(y=0;y<(N)HIT;y++)// ningy added (N)
    {
    s_offset=((y+YYY)*vdcp->status.size.w)+XXX;
    d_offset=(y*WID);
    #if 0
    for(x=0;x<(N)WID;x++)// ningy added (N)
     {
     aaCast(p4,_rgba*,&p3[s_offset]);
     vdcp->status.surface_status.mem[d_offset]=*p4;
     s_offset++;
     d_offset++;
     }
    #endif
//    aaCast(p4,_rgba*,&p3[s_offset+0]);
    for(x=0;x<(N)divs;x++)// ningy added (N)
     {
     aaCast(dhp,HP,&vdcp->status.surface_status.mem[d_offset]);
     aaCast(shp,HP,&p3[s_offset+0]);  dhp[0]=*shp;
     aaCast(shp,HP,&p3[s_offset+1]);  dhp[1]=*shp;
     aaCast(shp,HP,&p3[s_offset+2]);  dhp[2]=*shp;
     aaCast(shp,HP,&p3[s_offset+3]);  dhp[3]=*shp;
     aaCast(shp,HP,&p3[s_offset+4]);  dhp[4]=*shp;
     aaCast(shp,HP,&p3[s_offset+5]);  dhp[5]=*shp;
     aaCast(shp,HP,&p3[s_offset+6]);  dhp[6]=*shp;
     aaCast(shp,HP,&p3[s_offset+7]);  dhp[7]=*shp;
     aaCast(shp,HP,&p3[s_offset+8]);  dhp[8]=*shp;
     aaCast(shp,HP,&p3[s_offset+9]);  dhp[9]=*shp;
     aaCast(shp,HP,&p3[s_offset+10]);  dhp[10]=*shp;
     aaCast(shp,HP,&p3[s_offset+11]);  dhp[11]=*shp;
     aaCast(shp,HP,&p3[s_offset+12]);  dhp[12]=*shp;
     aaCast(shp,HP,&p3[s_offset+13]);  dhp[13]=*shp;
     aaCast(shp,HP,&p3[s_offset+14]);  dhp[14]=*shp;
     aaCast(shp,HP,&p3[s_offset+15]);  dhp[15]=*shp;
     s_offset+=16;
     d_offset+=16;
     }
    for(x=0;x<(N)mods;x++)// ningy added (N)
     {
     aaCast(p4,_rgba*,&p3[s_offset]);
     vdcp->status.surface_status.mem[d_offset]=*p4;
     s_offset++;     d_offset++;
     }
    }
   }
  else
  if(vdcp->status.bits==32)
   {
   bp=lpvhdr->lpData;
   aaCast(p4,_rgba*,bp);
   for(y=0;y<(N)HIT;y++)// ningy added (N)
    {
    s_offset=((y+YYY)*vdcp->status.size.w)+XXX;
    d_offset=(y*WID);
    for(x=0;x<(N)WID;x++) // ningy added (N)
     {
     vdcp->status.surface_status.mem[d_offset]=p4[s_offset];
     s_offset++;
     d_offset++;
     }
    }
   }
  vdcp->is_frame_waiting=YES;
  vdcp->status.is_frameready=YES;
  ///aaDebugf("type=%i ",type);
  return RET_YES;

  case 4:
  bp=lpvhdr->lpData;
  aaCast(yl_ptr,BP,bp);
  aaCast(yr_ptr,BP,&yl_ptr[(vdcp->status.size.w*vdcp->status.size.h)]);
  aaCast(yb_ptr,BP,&yr_ptr[(vdcp->status.size.w>>1)*(vdcp->status.size.h>>1)]);

  yl_ptr+=((YYY*(vdcp->status.size.w))+(XXX));
  yr_ptr+=(((YYY>>1)*(vdcp->status.size.w>>1))+(XXX>>1));
  yb_ptr+=(((YYY>>1)*(vdcp->status.size.w>>1))+(XXX>>1));
 #if 1
// qprofgo(0);
//  aaTimerProfilerInit(&pro,1);
  /////////////////////////////////////////////////
  wshift=vdcp->status.size.w>>1;
  d_offset=(HIT-1)*WID;


   for(y=0;y<(N)HIT;y++)// ningy added (N)
    {
    aaCast(dhp,HP,&vdcp->status.surface_status.mem[d_offset]);
    for(x=0;x<(N)WID;x+=2)// ningy added (N)
     {
     UU=(yr_ptr[(x>>1)])-128;
     VV=(yb_ptr[(x>>1)])-128;
     YY=(yl_ptr[x+0]-16)*76284;
     bb=(YY         +132252*VV)>>16;
     gg=(YY- 53281*UU-25625*VV)>>16;
     rr=(YY+104595*UU)>>16;
     bb=aaNumClamp(bb,0,255);
     gg=aaNumClamp(gg,0,255);
     rr=aaNumClamp(rr,0,255);
     dhp[x+0]=(0xff000000)+(bb<<16)+(gg<<8)+rr;
     YY=(yl_ptr[x+1]-16)*76284;
     bb=(YY         +132252*VV)>>16;
     gg=(YY- 53281*UU-25625*VV)>>16;
     rr=(YY+104595*UU)>>16;
     bb=aaNumClamp(bb,0,255);
     gg=aaNumClamp(gg,0,255);
     rr=aaNumClamp(rr,0,255);
     dhp[x+1]=(0xff000000)+(bb<<16)+(gg<<8)+rr;
     }
    d_offset-=WID;
    yl_ptr+=(vdcp->status.size.w);
    if((y&1)==1) { yr_ptr+=wshift;  yb_ptr+=wshift;   }
    }

// qproflog(0);
 #endif
  /////////////////////////////////////////////////
//  aaTimerProfilerUpdate(&pro,1);  tot=tot+(1.0/pro.elapsed);  totc++;  if(totc==50)  {  tot=tot/50.0;   aaLog(-1,"%.4f",tot);   tot=0;   totc=0;   }
  vdcp->is_frame_waiting=YES;
  vdcp->status.is_frameready=YES;
  //aaDebugf("type=%i ",type);
  return RET_YES;


#if aa_VIDCAP_ALLOW_YUY2==YES
  case 5:
  bp=lpvhdr->lpData;
  aaCast(yl_ptr,BP,&bp[0]);
  aaCast(yr_ptr,BP,&bp[1]);
  aaCast(yb_ptr,BP,&bp[3]);
  /////////////////////////////////////////////////
  d_offset=(HIT-1)*WID;
   for(y=0;y<(N)HIT;y++)// ningy added (N)
    {
    aaCast(dhp,HP,&vdcp->status.surface_status.mem[d_offset]);
    for(x=0;x<(N)WID;x+=1)// ningy added (N)
     {
     UU=(yr_ptr[0])-128;
     VV=(yb_ptr[0])-128;
     YY=(yl_ptr[0]-16)*76284;
     bb=(YY         +132252*VV)>>16;
     gg=(YY- 53281*UU-25625*VV)>>16;
     rr=(YY+104595*UU)>>16;
     bb=aaNumClamp(bb,0,255);
     gg=aaNumClamp(gg,0,255);
     rr=aaNumClamp(rr,0,255);
     dhp[x]=(255<<24)+(bb<<16)+(gg<<8)+rr;
     yl_ptr+=2;
     if((x&1)==1)      {      yr_ptr+=4;      yb_ptr+=4;      }
     }
    d_offset-=WID;
    }
  /////////////////////////////////////////////////
  vdcp->is_frame_waiting=YES;
  vdcp->status.is_frameready=YES;
  ///aaDebugf("type=%i ",type);
  return RET_YES;

#endif

 default:
 //aaDebugf("type=%i ",type);
 break;
  }

// log(What %i",vdcp->frames_bad);
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
 vdcp->frames_bad++;
 return RET_NO;
 }





 B aa_VidCapAbort                      (PP mem)
 {
 _aa_vidcapobject*vdcp;
 H go;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL)  {  return RET_BADPARM;  }
 aaCast(vdcp,_aa_vidcapobject*,*mem);
 if(vdcp==NULL) {  return RET_BADPARM;  }
 vdcp->is_abort_complete=NO;

 //aaDebugf("#%i %I64u ",__LINE__,aaMsRunning());


 if(capCaptureAbort(vdcp->hwnd)==FALSE)
  {
  //aaDebugf("capture abort failure");
  return RET_FAILED;
  }

/*
 if(capCaptureStop(vdcp->hwnd)==FALSE)
  {
  aaDebugf("capture abort failure");
  return RET_FAILED;
  }
  */

 //aaDebugf("#%i %I64u ",__LINE__,aaMsRunning());
 go=0;
 while(1)
  {
//boffin  aa_CoreSystemLoop();
  //aaYieldRaw();
  //aaYield(-1);
  if(vdcp->is_abort_complete==YES) { break; } //aaDebugf("abort after %i",go); break; }
  aaSleep(1);
  go++;
  if(go>=3200)
   {
   ///aaDebugf("aa_VidCapAbort didnt complete");
   break;
   }
  }
//  vdcp->is_abort_complete=YES;
 //aaDebugf("#%i %I64u ",__LINE__,aaMsRunning());
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aa_FileStreamSystemStart            (V)
 {
 logg("aa_FileStreamSystemStart()");
 aa_ObjectIdNew(&aa.filestream_system.object_id);
 aa_ObjectDefine(aa.filestream_system.object_id,sizeof(_aa_filestreamobject),_8K,256,aaFileStreamDestroy,"FileStream");
 logg("");
 return RET_YES;
 }




 V aa_FileStreamSystemStop             (V)
 {
 logg("aa_FileStreamSystemStop()");
 aa_ObjectUndefine(aa.filestream_system.object_id);
 logg("");
 }




#if 0

 B aa_FileStreamCacheSlotFind          (PP mem,Q offset,Q bytes,HP slot)
 {
 B ret;
 _aa_filestreamobject*fsop;
 Q start,end;
 H i;

 aaCast(fsop,_aa_filestreamobject*,*mem);
 if(bytes==0) { oof; }
 start=offset;
 end=start+(bytes-1);
 for(i=0;i<fsop->cache_slots;i++)
  {
  if(fsop->cache[i].length==0) { continue; }
  }
 return RET_YES;
 }










 B aa_FileStreamCacheAdd               (PP mem,Q offset,Q bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsop;

 aaCast(fsop,_aa_filestreamobject*,*mem);

 UNUSE(ret);

 return RET_YES;
 }
#endif



 B aa_FileStreamCacheManage            (PP mem)
 {
 B ret;
 _aa_filestreamobject*fsop;

 aaCast(fsop,_aa_filestreamobject*,*mem);
 UNUSE(fsop);
 UNUSE(ret);
 return RET_YES;
 }




 B aa_FileStreamCacheRead              (PP mem,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsop;

 aaCast(fsop,_aa_filestreamobject*,*mem);
 UNUSE(fsop);
 UNUSE(bytes);
 UNUSE(data);
// aaDebugf("%s %I64u %u",__func__,fsop->status.offset,bytes);

 UNUSE(ret);

 return RET_YES;
 }



 B aa_FileStreamCacheWrite             (PP mem,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsop;

 aaCast(fsop,_aa_filestreamobject*,*mem);
 UNUSE(fsop);
 UNUSE(bytes);
 UNUSE(data);
 //aaDebugf("%s %I64u %u",__func__,fsop->status.offset,bytes);
 UNUSE(ret);

 return RET_YES;
 }


/*-----------------------------------------------------------------------*/



 B aa_FileBoxSystemStart               (V)
 {
 logg("aa_FileBoxSystemStart()");
 logg("");
 return RET_YES;
 }


 V aa_FileBoxSystemStop                (V)
 {
 logg("aa_FileBoxSystemStop()");
 aaFileBoxClose();
 logg("");
 }



//of.nFileExtension


 H WINAPI aa_FileBoxProc               (LPVOID pa)
 {
 B ret;
 H z,tl,sl,fl;
 B thefilter[_2K];
 //OPENFILENAME of;
 BOOL res;
 _aa_fileboxsystem*df;
 H dipa_toggle;
 H dipa_count;
 B ascii;
 B failure_flag;
 //B thestr[_8K];

 aaCast(df,_aa_fileboxsystem*,pa);
 if(df!=&aa.filebox_system) { oof; }//&hicall.file_box) xxx;
 aaMemoryFill(&aa.filebox_system.of,sizeof(aa.filebox_system.of),0);
 aaStringLen(aa.filebox_system.filter,&sl);

 tl=fl=0;
 dipa_toggle=0;
 dipa_count=0;
 failure_flag=NO;

 for(z=0;z<sl;z++)
  {
  ascii=aa.filebox_system.filter[z];
  if(ascii!='|')   {   thefilter[fl++]=ascii; thefilter[fl]=NULL_CHAR;  tl++; }
  else
   {
   if(tl==0)  {  failure_flag=1; break; }
   dipa_toggle++;
   thefilter[fl++]=NULL_CHAR;
   dipa_toggle^=1;
   tl=0;
   }
  }


 if(failure_flag==NO)
  {
  if(dipa_toggle==1&&tl==0)   {   failure_flag=2;   }
  else
  if(dipa_toggle==1&&tl!=0)   {  }
  else
  if(dipa_toggle==0)
   {
   if(dipa_count>=2&&aaNumIsNotMod(dipa_count,2)) {}
   else                                           { failure_flag=3; }
   }
  }

 //if(failure_flag) { aaDebugf("*** FAILURE ***"); }
 //else             { aaDebugf("*** success ***"); }
 //if(failure_flag) { aa.filebox_system.is_failure=YES; }

 // although I am checking for errors more carefully now, the function works even on failure,
 // due to the additional error correction I have added, specifically fixing the end of string
 // double nulls.

 thefilter[fl++]=NULL_CHAR;
 thefilter[fl++]=NULL_CHAR;
 thefilter[fl++]=NULL_CHAR;

 ///aaStringFromArrayHex(thestr,1,fl,32,YES,thefilter); aaDebugf("%s",thestr);


 if(aa.filebox_system.initial_file[0]!=NULL_CHAR)
  {
  aaStringCopy(aa.filebox_system.selection,aa.filebox_system.initial_file);
  }
 aa.filebox_system.of.lStructSize=sizeof(aa.filebox_system.of);
 aa.filebox_system.of.hwndOwner=aa.filebox_system.parent_hwnd;//NULL;
 aa.filebox_system.of.hInstance=aa.core_system.this_instance;//hicall.instance;//_pvInstance;
 aa.filebox_system.of.lpstrFilter=(CP)thefilter;
 aa.filebox_system.of.lpstrCustomFilter=NULL;
 aa.filebox_system.of.nMaxCustFilter=0;
 aa.filebox_system.of.nFilterIndex=1;
 aa.filebox_system.of.lpstrFile=(CP)aa.filebox_system.selection;
 if((ret=aaMemoryBytesGet(aa.filebox_system.selection,&aa.filebox_system.of.nMaxFile))!=YES) { oops; }
 aa.filebox_system.of.lpstrFileTitle=NULL;
 aa.filebox_system.of.nMaxFileTitle=0;
 if(aa.filebox_system.initial_dir[0]!=0) { aa.filebox_system.of.lpstrInitialDir=(CP)aa.filebox_system.initial_dir; }
 aa.filebox_system.of.lpstrTitle=(CP)aa.filebox_system.caption;
 aa.filebox_system.of.nFileOffset=0;
 aa.filebox_system.of.nFileExtension=0;
 aa.filebox_system.of.lpstrDefExt=NULL;
 aa.filebox_system.of.lCustData=0;
 aa.filebox_system.of.lpfnHook=NULL;
 aa.filebox_system.of.lpTemplateName=NULL;
 //aaDebugf("maxfile=%i",aa.filebox_system.of.nMaxFile);
 // both has|OFN_HIDEREADONLY
 if(aa.filebox_system.max_files>1)
  {
  aa.filebox_system.of.Flags=OFN_ALLOWMULTISELECT|OFN_EXPLORER;
  }
 else
  {
  aa.filebox_system.of.Flags=OFN_EXPLORER;
  }
 res=aa.core_system.GetOpenFileName(&aa.filebox_system.of);
 if(res==FALSE)
  {
  aa.filebox_system.is_cancelled=YES;
  //oow; aaNote(0,"%s:%i returned false",__func__,__LINE__); }
 //if(res==0) { oof;}
  }
 ExitThread((H)res);
// return 0;
 }


/*-----------------------------------------------------------------------*/

 B aa_FolderBoxSystemStart             (V)
 {
 logg("aa_FolderBoxSystemStart()");
 logg("");
 return RET_YES;
 }


 V aa_FolderBoxSystemStop              (V)
 {
 logg("aa_FolderBoxSystemStop()");
 aaFolderBoxClose();
 logg("");
 }



 Z CALLBACK aa_FolderBoxCallback       (HWND hwnd,UINT uMsg,LPARAM lp,LPARAM pData)
 {
 B path[_1K];
 UNUSE(lp);
 switch(uMsg)
  {
  case BFFM_INITIALIZED:
  if(aa.folderbox_system.dialog_hwnd==0) { aa.folderbox_system.dialog_hwnd=hwnd; }
  aaStringCopyf(path,"%s",pData);
  aaStringReplaceChar(path,0,FSLASH_CHAR,BSLASH_CHAR);
  SendMessage(hwnd,BFFM_SETSELECTION,TRUE,(LPARAM)path);
  break;
  }
 return 0;
 }




 H WINAPI aa_FolderBoxProc             (LPVOID pa)
 {
 _aa_folderboxsystem*df;

 aaCast(df,_aa_folderboxsystem*,pa);
 if(df!=&aa.folderbox_system) { oof; }//&hicall.file_box) xxx;
 aa.folderbox_system.pidl=SHBrowseForFolder(&aa.folderbox_system.bi);
 ExitThread(1);
 }

/*-----------------------------------------------------------------------*/

 B aa_DirSystemStart                   (V)
 {
 logg("aa_DirSystemStart()");
 aa_ObjectIdNew(&aa.dir_system.object_id);
 aa_ObjectDefine(aa.dir_system.object_id,sizeof(_aa_dirobject),_2K,16,aaDirClose,"Dir");
 logg("");
 return RET_YES;
 }



 V aa_DirSystemStop                    (V)
 {
 logg("aa_DirSystemStop()");
 aa_ObjectUndefine(aa.dir_system.object_id);
 logg("");
 }


/*-----------------------------------------------------------------------*/



 B aa_DirWalkerSystemStart                   (V)
 {
 //aaLog(-555,"%s",__func__);
 aa_ObjectIdNew(&aa.dirwalker_system.object_id);
 aa_ObjectDefine(aa.dirwalker_system.object_id,sizeof(_aa_dirwalkerobject),_2K,16,aaDirWalkerDestroy,"Dirwalk");
 return RET_YES;
 }



 V aa_DirWalkerSystemStop              (V)
 {
 //aaLog(-555,"%s",__func__);
 aa_ObjectUndefine(aa.dirwalker_system.object_id);
 }


/*-----------------------------------------------------------------------*/

 B aa_CpuMonitorSystemStart            (V)
 {
 logg("aa_CpuMonitorSystemStart()");
 aa.core_system.GetSystemTimes(&aa.cpumonitor_system.prev_idle_time.dword,&aa.cpumonitor_system.prev_kernel_time.dword,&aa.cpumonitor_system.prev_user_time.dword);
 logg("");
 return RET_YES;
 }




 V aa_CpuMonitorSystemStop             (V)
 {
 logg("aa_CpuMonitorSystemStop()");
 aa.cpumonitor_system.is_started=NO;
 }



/*-----------------------------------------------------------------------*/

 B aa_DigestSystemStart                (V)
 {
 logg("aa_DigestSystemStart()");
 aa_ObjectIdNew(&aa.digest_system.object_id);
 aa_ObjectDefine(aa.digest_system.object_id,sizeof(_aa_digestobject),_4K,32,aaDigestDestroy,"Digest");
 logg("");
 return RET_YES;
 }



 V aa_DigestSystemStop                 (V)
 {
 logg("aa_DigestSystemStop()");
 aa_ObjectUndefine(aa.digest_system.object_id);
 logg("");
 }




 V aa_DigestSystemCompress             (PP mem,HP block)
 {
 _aa_digestobject*digp;
 H raa,rbb,rcc,rdd,ree;
 H paa,pbb,pcc,pdd,pee;
 H pab,pac,pad;
 H a,b,c,d,e;
 HP cwp;
 H j;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(digp,_aa_digestobject*,*mem);
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
    paa= digp->status.digest[0];
    pab=digp->status.digest[1];
    pac=digp->status.digest[2];
    pad=digp->status.digest[3];
    for(j=0;j<16;j++) digp->correct_words[j]=block[j];
    cwp=digp->correct_words;
   // memcpy( digp->correct_words,block,64 );

    // Round 1.
    aaMD5OP1 (paa,pab,pac,pad,7,0xd76aa478);
    aaMD5OP1 (pad,paa,pab,pac,12,0xe8c7b756);
    aaMD5OP1 (pac,pad,paa,pab,17,0x242070db);
    aaMD5OP1 (pab,pac,pad,paa,22,0xc1bdceee);
    aaMD5OP1 (paa,pab,pac,pad,7,0xf57c0faf);
    aaMD5OP1 (pad,paa,pab,pac,12,0x4787c62a);
    aaMD5OP1 (pac,pad,paa,pab,17,0xa8304613);
    aaMD5OP1 (pab,pac,pad,paa,22,0xfd469501);
    aaMD5OP1 (paa,pab,pac,pad,7,0x698098d8);
    aaMD5OP1 (pad,paa,pab,pac,12,0x8b44f7af);
    aaMD5OP1 (pac,pad,paa,pab,17,0xffff5bb1);
    aaMD5OP1 (pab,pac,pad,paa,22,0x895cd7be);
    aaMD5OP1 (paa,pab,pac,pad,7,0x6b901122);
    aaMD5OP1 (pad,paa,pab,pac,12,0xfd987193);
    aaMD5OP1 (pac,pad,paa,pab,17,0xa679438e);
    aaMD5OP1 (pab,pac,pad,paa,22,0x49b40821);
    if(cwp) {} // prevent warning
    // Round 2.
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,1,5,0xf61e2562);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,6,9,0xc040b340);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,11,14,0x265e5a51);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,0,20,0xe9b6c7aa);
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,5,5,0xd62f105d);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,10,9,0x02441453);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,15,14,0xd8a1e681);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,4,20,0xe7d3fbc8);
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,9,5,0x21e1cde6);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,14,9,0xc33707d6);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,3,14,0xf4d50d87);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,8,20,0x455a14ed);
    aaMD5OP2 (aaMD5FG,paa,pab,pac,pad,13,5,0xa9e3e905);
    aaMD5OP2 (aaMD5FG,pad,paa,pab,pac,2,9,0xfcefa3f8);
    aaMD5OP2 (aaMD5FG,pac,pad,paa,pab,7,14,0x676f02d9);
    aaMD5OP2 (aaMD5FG,pab,pac,pad,paa,12,20,0x8d2a4c8a);
    // Round 3.
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,5,4,0xfffa3942);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,8,11,0x8771f681);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,11,16,0x6d9d6122);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,14,23,0xfde5380c);
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,1,4,0xa4beea44);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,4,11,0x4bdecfa9);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,7,16,0xf6bb4b60);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,10,23,0xbebfbc70);
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,13,4,0x289b7ec6);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,0,11,0xeaa127fa);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,3,16,0xd4ef3085);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,6,23,0x04881d05);
    aaMD5OP2 (aaMD5FH,paa,pab,pac,pad,9,4,0xd9d4d039);
    aaMD5OP2 (aaMD5FH,pad,paa,pab,pac,12,11,0xe6db99e5);
    aaMD5OP2 (aaMD5FH,pac,pad,paa,pab,15,16,0x1fa27cf8);
    aaMD5OP2 (aaMD5FH,pab,pac,pad,paa,2,23,0xc4ac5665);
    // Round 4.
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,0,6,0xf4292244);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,7,10,0x432aff97);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,14,15,0xab9423a7);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,5,21,0xfc93a039);
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,12,6,0x655b59c3);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,3,10,0x8f0ccc92);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,10,15,0xffeff47d);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,1,21,0x85845dd1);
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,8,6,0x6fa87e4f);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,15,10,0xfe2ce6e0);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,6,15,0xa3014314);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,13,21,0x4e0811a1);
    aaMD5OP2 (aaMD5FI,paa,pab,pac,pad,4,6,0xf7537e82);
    aaMD5OP2 (aaMD5FI,pad,paa,pab,pac,11,10,0xbd3af235);
    aaMD5OP2 (aaMD5FI,pac,pad,paa,pab,2,15,0x2ad7d2bb);
    aaMD5OP2 (aaMD5FI,pab,pac,pad,paa,9,21,0xeb86d391);
    // Put checksum in context given as argument.
    digp->status.digest[0]+=paa;
    digp->status.digest[1]+=pab;
    digp->status.digest[2]+=pac;
    digp->status.digest[3]+=pad;
 }
else
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  raa=digp->status.digest[0];
  rbb=digp->status.digest[1];
  rcc=digp->status.digest[2];
  rdd=digp->status.digest[3];
  ree=digp->status.digest[4];
  paa=raa; pbb=rbb; pcc=rcc; pdd=rdd; pee=ree;

  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[ 0],11);
  aaRipemdFF(ree,raa,rbb,rcc,rdd,block[ 1],14);
  aaRipemdFF(rdd,ree,raa,rbb,rcc,block[ 2],15);
  aaRipemdFF(rcc,rdd,ree,raa,rbb,block[ 3],12);
  aaRipemdFF(rbb,rcc,rdd,ree,raa,block[ 4],5);
  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[ 5],8);
  aaRipemdFF(ree,raa,rbb,rcc,rdd,block[ 6],7);
  aaRipemdFF(rdd,ree,raa,rbb,rcc,block[ 7],9);
  aaRipemdFF(rcc,rdd,ree,raa,rbb,block[ 8],11);
  aaRipemdFF(rbb,rcc,rdd,ree,raa,block[ 9],13);
  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[10],14);
  aaRipemdFF(ree,raa,rbb,rcc,rdd,block[11],15);
  aaRipemdFF(rdd,ree,raa,rbb,rcc,block[12],6);
  aaRipemdFF(rcc,rdd,ree,raa,rbb,block[13],7);
  aaRipemdFF(rbb,rcc,rdd,ree,raa,block[14],9);
  aaRipemdFF(raa,rbb,rcc,rdd,ree,block[15],8);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 7],7);
  aaRipemdGG(rdd,ree,raa,rbb,rcc,block[ 4],6);
  aaRipemdGG(rcc,rdd,ree,raa,rbb,block[13],8);
  aaRipemdGG(rbb,rcc,rdd,ree,raa,block[ 1],13);
  aaRipemdGG(raa,rbb,rcc,rdd,ree,block[10],11);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 6],9);
  aaRipemdGG(rdd,ree,raa,rbb,rcc,block[15],7);
  aaRipemdGG(rcc,rdd,ree,raa,rbb,block[ 3],15);
  aaRipemdGG(rbb,rcc,rdd,ree,raa,block[12],7);
  aaRipemdGG(raa,rbb,rcc,rdd,ree,block[ 0],12);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 9],15);
  aaRipemdGG(rdd,ree,raa,rbb,rcc,block[ 5],9);
  aaRipemdGG(rcc,rdd,ree,raa,rbb,block[ 2],11);
  aaRipemdGG(rbb,rcc,rdd,ree,raa,block[14],7);
  aaRipemdGG(raa,rbb,rcc,rdd,ree,block[11],13);
  aaRipemdGG(ree,raa,rbb,rcc,rdd,block[ 8],12);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[ 3],11);
  aaRipemdHH(rcc,rdd,ree,raa,rbb,block[10],13);
  aaRipemdHH(rbb,rcc,rdd,ree,raa,block[14],6);
  aaRipemdHH(raa,rbb,rcc,rdd,ree,block[ 4],7);
  aaRipemdHH(ree,raa,rbb,rcc,rdd,block[ 9],14);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[15],9);
  aaRipemdHH(rcc,rdd,ree,raa,rbb,block[ 8],13);
  aaRipemdHH(rbb,rcc,rdd,ree,raa,block[ 1],15);
  aaRipemdHH(raa,rbb,rcc,rdd,ree,block[ 2],14);
  aaRipemdHH(ree,raa,rbb,rcc,rdd,block[ 7],8);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[ 0],13);
  aaRipemdHH(rcc,rdd,ree,raa,rbb,block[ 6],6);
  aaRipemdHH(rbb,rcc,rdd,ree,raa,block[13],5);
  aaRipemdHH(raa,rbb,rcc,rdd,ree,block[11],12);
  aaRipemdHH(ree,raa,rbb,rcc,rdd,block[ 5],7);
  aaRipemdHH(rdd,ree,raa,rbb,rcc,block[12],5);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 1],11);
  aaRipemdII(rbb,rcc,rdd,ree,raa,block[ 9],12);
  aaRipemdII(raa,rbb,rcc,rdd,ree,block[11],14);
  aaRipemdII(ree,raa,rbb,rcc,rdd,block[10],15);
  aaRipemdII(rdd,ree,raa,rbb,rcc,block[ 0],14);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 8],15);
  aaRipemdII(rbb,rcc,rdd,ree,raa,block[12],9);
  aaRipemdII(raa,rbb,rcc,rdd,ree,block[ 4],8);
  aaRipemdII(ree,raa,rbb,rcc,rdd,block[13],9);
  aaRipemdII(rdd,ree,raa,rbb,rcc,block[ 3],14);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 7],5);
  aaRipemdII(rbb,rcc,rdd,ree,raa,block[15],6);
  aaRipemdII(raa,rbb,rcc,rdd,ree,block[14],8);
  aaRipemdII(ree,raa,rbb,rcc,rdd,block[ 5],6);
  aaRipemdII(rdd,ree,raa,rbb,rcc,block[ 6],5);
  aaRipemdII(rcc,rdd,ree,raa,rbb,block[ 2],12);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[ 4],9);
  aaRipemdJJ(raa,rbb,rcc,rdd,ree,block[ 0],15);
  aaRipemdJJ(ree,raa,rbb,rcc,rdd,block[ 5],5);
  aaRipemdJJ(rdd,ree,raa,rbb,rcc,block[ 9],11);
  aaRipemdJJ(rcc,rdd,ree,raa,rbb,block[ 7],6);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[12],8);
  aaRipemdJJ(raa,rbb,rcc,rdd,ree,block[ 2],13);
  aaRipemdJJ(ree,raa,rbb,rcc,rdd,block[10],12);
  aaRipemdJJ(rdd,ree,raa,rbb,rcc,block[14],5);
  aaRipemdJJ(rcc,rdd,ree,raa,rbb,block[ 1],12);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[ 3],13);
  aaRipemdJJ(raa,rbb,rcc,rdd,ree,block[ 8],14);
  aaRipemdJJ(ree,raa,rbb,rcc,rdd,block[11],11);
  aaRipemdJJ(rdd,ree,raa,rbb,rcc,block[ 6],8);
  aaRipemdJJ(rcc,rdd,ree,raa,rbb,block[15],5);
  aaRipemdJJ(rbb,rcc,rdd,ree,raa,block[13],6);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[ 5],8);
  aaRipemdJJJ(pee,paa,pbb,pcc,pdd,block[14],9);
  aaRipemdJJJ(pdd,pee,paa,pbb,pcc,block[ 7],9);
  aaRipemdJJJ(pcc,pdd,pee,paa,pbb,block[ 0],11);
  aaRipemdJJJ(pbb,pcc,pdd,pee,paa,block[ 9],13);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[ 2],15);
  aaRipemdJJJ(pee,paa,pbb,pcc,pdd,block[11],15);
  aaRipemdJJJ(pdd,pee,paa,pbb,pcc,block[ 4],5);
  aaRipemdJJJ(pcc,pdd,pee,paa,pbb,block[13],7);
  aaRipemdJJJ(pbb,pcc,pdd,pee,paa,block[ 6],7);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[15],8);
  aaRipemdJJJ(pee,paa,pbb,pcc,pdd,block[ 8],11);
  aaRipemdJJJ(pdd,pee,paa,pbb,pcc,block[ 1],14);
  aaRipemdJJJ(pcc,pdd,pee,paa,pbb,block[10],14);
  aaRipemdJJJ(pbb,pcc,pdd,pee,paa,block[ 3],12);
  aaRipemdJJJ(paa,pbb,pcc,pdd,pee,block[12],6);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[ 6],9);
  aaRipemdIII(pdd,pee,paa,pbb,pcc,block[11],13);
  aaRipemdIII(pcc,pdd,pee,paa,pbb,block[ 3],15);
  aaRipemdIII(pbb,pcc,pdd,pee,paa,block[ 7],7);
  aaRipemdIII(paa,pbb,pcc,pdd,pee,block[ 0],12);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[13],8);
  aaRipemdIII(pdd,pee,paa,pbb,pcc,block[ 5],9);
  aaRipemdIII(pcc,pdd,pee,paa,pbb,block[10],11);
  aaRipemdIII(pbb,pcc,pdd,pee,paa,block[14],7);
  aaRipemdIII(paa,pbb,pcc,pdd,pee,block[15],7);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[ 8],12);
  aaRipemdIII(pdd,pee,paa,pbb,pcc,block[12],7);
  aaRipemdIII(pcc,pdd,pee,paa,pbb,block[ 4],6);
  aaRipemdIII(pbb,pcc,pdd,pee,paa,block[ 9],15);
  aaRipemdIII(paa,pbb,pcc,pdd,pee,block[ 1],13);
  aaRipemdIII(pee,paa,pbb,pcc,pdd,block[ 2],11);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[15],9);
  aaRipemdHHH(pcc,pdd,pee,paa,pbb,block[ 5],7);
  aaRipemdHHH(pbb,pcc,pdd,pee,paa,block[ 1],15);
  aaRipemdHHH(paa,pbb,pcc,pdd,pee,block[ 3],11);
  aaRipemdHHH(pee,paa,pbb,pcc,pdd,block[ 7],8);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[14],6);
  aaRipemdHHH(pcc,pdd,pee,paa,pbb,block[ 6],6);
  aaRipemdHHH(pbb,pcc,pdd,pee,paa,block[ 9],14);
  aaRipemdHHH(paa,pbb,pcc,pdd,pee,block[11],12);
  aaRipemdHHH(pee,paa,pbb,pcc,pdd,block[ 8],13);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[12],5);
  aaRipemdHHH(pcc,pdd,pee,paa,pbb,block[ 2],14);
  aaRipemdHHH(pbb,pcc,pdd,pee,paa,block[10],13);
  aaRipemdHHH(paa,pbb,pcc,pdd,pee,block[ 0],13);
  aaRipemdHHH(pee,paa,pbb,pcc,pdd,block[ 4],7);
  aaRipemdHHH(pdd,pee,paa,pbb,pcc,block[13],5);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[ 8],15);
  aaRipemdGGG(pbb,pcc,pdd,pee,paa,block[ 6],5);
  aaRipemdGGG(paa,pbb,pcc,pdd,pee,block[ 4],8);
  aaRipemdGGG(pee,paa,pbb,pcc,pdd,block[ 1],11);
  aaRipemdGGG(pdd,pee,paa,pbb,pcc,block[ 3],14);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[11],14);
  aaRipemdGGG(pbb,pcc,pdd,pee,paa,block[15],6);
  aaRipemdGGG(paa,pbb,pcc,pdd,pee,block[ 0],14);
  aaRipemdGGG(pee,paa,pbb,pcc,pdd,block[ 5],6);
  aaRipemdGGG(pdd,pee,paa,pbb,pcc,block[12],9);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[ 2],12);
  aaRipemdGGG(pbb,pcc,pdd,pee,paa,block[13],9);
  aaRipemdGGG(paa,pbb,pcc,pdd,pee,block[ 9],12);
  aaRipemdGGG(pee,paa,pbb,pcc,pdd,block[ 7],5);
  aaRipemdGGG(pdd,pee,paa,pbb,pcc,block[10],15);
  aaRipemdGGG(pcc,pdd,pee,paa,pbb,block[14],8);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[12] ,8);
  aaRipemdFFF(paa,pbb,pcc,pdd,pee,block[15] ,5);
  aaRipemdFFF(pee,paa,pbb,pcc,pdd,block[10] ,12);
  aaRipemdFFF(pdd,pee,paa,pbb,pcc,block[ 4] ,9);
  aaRipemdFFF(pcc,pdd,pee,paa,pbb,block[ 1] ,12);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[ 5] ,5);
  aaRipemdFFF(paa,pbb,pcc,pdd,pee,block[ 8] ,14);
  aaRipemdFFF(pee,paa,pbb,pcc,pdd,block[ 7] ,6);
  aaRipemdFFF(pdd,pee,paa,pbb,pcc,block[ 6] ,8);
  aaRipemdFFF(pcc,pdd,pee,paa,pbb,block[ 2] ,13);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[13] ,6);
  aaRipemdFFF(paa,pbb,pcc,pdd,pee,block[14] ,5);
  aaRipemdFFF(pee,paa,pbb,pcc,pdd,block[ 0] ,15);
  aaRipemdFFF(pdd,pee,paa,pbb,pcc,block[ 3] ,13);
  aaRipemdFFF(pcc,pdd,pee,paa,pbb,block[ 9] ,11);
  aaRipemdFFF(pbb,pcc,pdd,pee,paa,block[11] ,11);
  pdd+=rcc+digp->status.digest[1];
  digp->status.digest[1]=digp->status.digest[2]+rdd+pee;
  digp->status.digest[2]=digp->status.digest[3]+ree+paa;
  digp->status.digest[3]=digp->status.digest[4]+raa+pbb;
  digp->status.digest[4]=digp->status.digest[0]+rbb+pcc;
  digp->status.digest[0]=pdd;
  }
else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  B workspace[64];
  T union { B c[64]; H l[16]; } CHAR64LONG16;
  CHAR64LONG16 *zblock=(CHAR64LONG16 *)workspace;
  aaMemoryCopy(zblock,64,block);//buffer);
  a=digp->status.digest[0];
  b=digp->status.digest[1];
  c=digp->status.digest[2];
  d=digp->status.digest[3];
  e=digp->status.digest[4];
    aaSHA1R0(a,b,c,d,e,0); aaSHA1R0(e,a,b,c,d,1); aaSHA1R0(d,e,a,b,c,2); aaSHA1R0(c,d,e,a,b,3);
    aaSHA1R0(b,c,d,e,a,4); aaSHA1R0(a,b,c,d,e,5); aaSHA1R0(e,a,b,c,d,6); aaSHA1R0(d,e,a,b,c,7);
    aaSHA1R0(c,d,e,a,b,8); aaSHA1R0(b,c,d,e,a,9); aaSHA1R0(a,b,c,d,e,10); aaSHA1R0(e,a,b,c,d,11);
    aaSHA1R0(d,e,a,b,c,12); aaSHA1R0(c,d,e,a,b,13); aaSHA1R0(b,c,d,e,a,14); aaSHA1R0(a,b,c,d,e,15);
    aaSHA1R1(e,a,b,c,d,16); aaSHA1R1(d,e,a,b,c,17); aaSHA1R1(c,d,e,a,b,18); aaSHA1R1(b,c,d,e,a,19);
    aaSHA1R2(a,b,c,d,e,20); aaSHA1R2(e,a,b,c,d,21); aaSHA1R2(d,e,a,b,c,22); aaSHA1R2(c,d,e,a,b,23);
    aaSHA1R2(b,c,d,e,a,24); aaSHA1R2(a,b,c,d,e,25); aaSHA1R2(e,a,b,c,d,26); aaSHA1R2(d,e,a,b,c,27);
    aaSHA1R2(c,d,e,a,b,28); aaSHA1R2(b,c,d,e,a,29); aaSHA1R2(a,b,c,d,e,30); aaSHA1R2(e,a,b,c,d,31);
    aaSHA1R2(d,e,a,b,c,32); aaSHA1R2(c,d,e,a,b,33); aaSHA1R2(b,c,d,e,a,34); aaSHA1R2(a,b,c,d,e,35);
    aaSHA1R2(e,a,b,c,d,36); aaSHA1R2(d,e,a,b,c,37); aaSHA1R2(c,d,e,a,b,38); aaSHA1R2(b,c,d,e,a,39);
    aaSHA1R3(a,b,c,d,e,40); aaSHA1R3(e,a,b,c,d,41); aaSHA1R3(d,e,a,b,c,42); aaSHA1R3(c,d,e,a,b,43);
    aaSHA1R3(b,c,d,e,a,44); aaSHA1R3(a,b,c,d,e,45); aaSHA1R3(e,a,b,c,d,46); aaSHA1R3(d,e,a,b,c,47);
    aaSHA1R3(c,d,e,a,b,48); aaSHA1R3(b,c,d,e,a,49); aaSHA1R3(a,b,c,d,e,50); aaSHA1R3(e,a,b,c,d,51);
    aaSHA1R3(d,e,a,b,c,52); aaSHA1R3(c,d,e,a,b,53); aaSHA1R3(b,c,d,e,a,54); aaSHA1R3(a,b,c,d,e,55);
    aaSHA1R3(e,a,b,c,d,56); aaSHA1R3(d,e,a,b,c,57); aaSHA1R3(c,d,e,a,b,58); aaSHA1R3(b,c,d,e,a,59);
    aaSHA1R4(a,b,c,d,e,60); aaSHA1R4(e,a,b,c,d,61); aaSHA1R4(d,e,a,b,c,62); aaSHA1R4(c,d,e,a,b,63);
    aaSHA1R4(b,c,d,e,a,64); aaSHA1R4(a,b,c,d,e,65); aaSHA1R4(e,a,b,c,d,66); aaSHA1R4(d,e,a,b,c,67);
    aaSHA1R4(c,d,e,a,b,68); aaSHA1R4(b,c,d,e,a,69); aaSHA1R4(a,b,c,d,e,70); aaSHA1R4(e,a,b,c,d,71);
    aaSHA1R4(d,e,a,b,c,72); aaSHA1R4(c,d,e,a,b,73); aaSHA1R4(b,c,d,e,a,74); aaSHA1R4(a,b,c,d,e,75);
    aaSHA1R4(e,a,b,c,d,76); aaSHA1R4(d,e,a,b,c,77); aaSHA1R4(c,d,e,a,b,78); aaSHA1R4(b,c,d,e,a,79);
 // Add the working vars back into context.state[]
  digp->status.digest[0]+=a;
  digp->status.digest[1]+=b;
  digp->status.digest[2]+=c;
  digp->status.digest[3]+=d;
  digp->status.digest[4]+=e;
  }
 }





 V aa_DigestSystemMd5                  (_aa_digestobject*digp,BP inbuf,H inlen)
 {
 if(digp->count==64)  {  aa_DigestSystemCompress((VP)&digp,(HP)digp->block);  }
 if(!inbuf)return;
 if(digp->count)
  {
  for(;inlen&&digp->count<64;inlen--)  digp->block[digp->count++]=*inbuf++;
  aa_DigestSystemMd5(digp,NULL,0);
  if(!inlen) return;
  }
 while(inlen>=64)
  {
  aa_DigestSystemCompress((VP)&digp,(HP)inbuf);
  digp->count=0;
  digp->counter++;
  inlen-=64;
  inbuf+=64;
  }
 for(;inlen&&digp->count<64;inlen--) digp->block[digp->count++]=*inbuf++;
 }





 V aa_DigestSystemSha256Transform      (_aa_digestobject*digp)
 {
 H a,b,c,d,e,f,g,h,T1,T2,i,j;
 H WW[16];
 a=digp->status.digest[0];
 b=digp->status.digest[1];
 c=digp->status.digest[2];
 d=digp->status.digest[3];
 e=digp->status.digest[4];
 f=digp->status.digest[5];
 g=digp->status.digest[6];
 h=digp->status.digest[7];
 for(i=0;i<16;i++)
  {
  WW[i]=((digp->block[(i<<2)+3])|(digp->block[(i<<2)+2]<<8)|(digp->block[(i<<2)+1]<< 16)|(digp->block[i<<2]<<24));
  }
 for(j=0;j<64;j++)
  {
  T1=h+aa_DigestSha2Sigma1(e)+aa_DigestSha2choice(e,f,g)+aa_DigestSha2K256[j];
  if(j<16) T1+=WW[j];
  else     T1+=aa_DigestSha2expand(WW,j);
  T2=aa_DigestSha2Sigma0(a)+aa_DigestSha2majority(a,b,c);
  h=g;
  g=f;
  f=e;
  e=aa_DigestSha2safeAdd(d,T1);
  d=c;
  c=b;
  b=a;
  a=aa_DigestSha2safeAdd(T1,T2);
  }
 digp->status.digest[0]+=a;
 digp->status.digest[1]+=b;
 digp->status.digest[2]+=c;
 digp->status.digest[3]+=d;
 digp->status.digest[4]+=e;
 digp->status.digest[5]+=f;
 digp->status.digest[6]+=g;
 digp->status.digest[7]+=h;
 }



 H aa_DigestSha2rotateRight            (H n,H x)
 {
 return((x>>n)|(x<<(32-n)));
 }

 H aa_DigestSha2choice                 (H x,H y,H z)
 {
 return((x&y)^(~x&z));
 }

 H aa_DigestSha2majority               (H x,H y,H z)
 {
 return((x&y)^(x&z)^(y&z));
 }

 H aa_DigestSha2Sigma0                 (H x)
 {
 return(aa_DigestSha2rotateRight(2,x)^aa_DigestSha2rotateRight(13,x)^aa_DigestSha2rotateRight(22,x));
 }

 H aa_DigestSha2Sigma1                 (H x)
 {
 return(aa_DigestSha2rotateRight(6,x)^aa_DigestSha2rotateRight(11,x)^aa_DigestSha2rotateRight(25,x));
 }

 H aa_DigestSha2sigma0                 (H x)
 {
 return(aa_DigestSha2rotateRight(7,x)^aa_DigestSha2rotateRight(18,x)^(x>>3));
 }

 H aa_DigestSha2sigma1                 (H x)
 {
 return(aa_DigestSha2rotateRight(17,x)^aa_DigestSha2rotateRight(19,x)^(x>>10));
 }

 H aa_DigestSha2expand                 (HP WX,H j)
 {
 return(WX[j&0x0f]+=aa_DigestSha2sigma1(WX[(j+14)&0x0f])+WX[(j+9)&0x0f]+aa_DigestSha2sigma0(WX[(j+1)&0x0f]));
 }


 H aa_DigestSha2safeAdd                (H x,H y)
 {
 H lsw=(x&0xffff)+(y&0xffff);
 H msw=(x>>16)+(y>>16)+(lsw>>16);
 return (msw<<16)|(lsw&0xffff);
 }



/*-----------------------------------------------------------------------*/

 B aa_CryptoSystemStart                (V)
 {
 logg("aa_CryptoSystemStart()");
 aa_ObjectIdNew(&aa.crypto_system.object_id);
 aa_ObjectDefine(aa.crypto_system.object_id,sizeof(_aa_cryptoobject),_8K,32,aaCryptoDestroy,"Crypto");
 logg("");
 return RET_YES;
 }


 V aa_CryptoSystemStop                 (V)
 {
 logg("aa_CryptoSystemStop()");
 aa_ObjectUndefine(aa.crypto_system.object_id);
 logg("");
 }



 V aa_CryptoSystemProcess              (H SK[32],B key[8])
 {
 Z i;
 H XX,YY,TT;

 (XX)=((H)(key)[(0)]<<24)|((H)(key)[(0)+1]<<16)|((H)(key)[(0)+2]<<8)|((H)(key)[(0)+3]);
 (YY)=((H)(key)[(4)]<<24)|((H)(key)[(4)+1]<<16)|((H)(key)[(4)+2]<<8)|((H)(key)[(4)+3]);
 TT=((YY>>4)^XX)&0x0F0F0F0F;  XX^=TT; YY^=(TT<<4);
 TT=((YY)^XX)&0x10101010;  XX^=TT; YY^=(TT);
 XX= (aa_crypto_des_LHs[(XX)&0xF]<<3)|(aa_crypto_des_LHs[(XX>>8)&0xF]<<2)
       |(aa_crypto_des_LHs[(XX>>16)&0xF]<<1)|(aa_crypto_des_LHs[(XX>>24)&0xF])
       |(aa_crypto_des_LHs[(XX>>5)&0xF]<<7)|(aa_crypto_des_LHs[(XX>>13)&0xF]<<6)
       |(aa_crypto_des_LHs[(XX>>21)&0xF]<<5)|(aa_crypto_des_LHs[(XX>>29)&0xF]<<4);
    YY=(aa_crypto_des_RHs[(YY>>1)&0xF]<<3)|(aa_crypto_des_RHs[(YY>>9)&0xF]<<2)
       |(aa_crypto_des_RHs[(YY>>17)&0xF]<<1)|(aa_crypto_des_RHs[(YY>>25)&0xF])
       |(aa_crypto_des_RHs[(YY>>4)&0xF]<<7)|(aa_crypto_des_RHs[(YY>>12)&0xF]<<6)
       |(aa_crypto_des_RHs[(YY>>20)&0xF]<<5)|(aa_crypto_des_RHs[(YY>>28)&0xF]<<4);
 XX&=0x0FFFFFFF;
 YY&=0x0FFFFFFF;
 for(i=0;i<16;i++)
  {
  if(i<2||i==8||i==15)
   {
   XX=((XX<<1)|(XX>>27))&0x0FFFFFFF;
   YY=((YY<<1)|(YY>>27))&0x0FFFFFFF;
   }
  else
   {
   XX=((XX<<2)|(XX>>26))&0x0FFFFFFF;
   YY=((YY<<2)|(YY>>26))&0x0FFFFFFF;
   }
        *SK++= ((XX<<4)&0x24000000)|((XX<<28)&0x10000000)
               |((XX<<14)&0x08000000)|((XX<<18)&0x02080000)
               |((XX<<6)&0x01000000)|((XX<<9)&0x00200000)
               |((XX>>1)&0x00100000)|((XX<<10)&0x00040000)
               |((XX<<2)&0x00020000)|((XX>>10)&0x00010000)
               |((YY>>13)&0x00002000)|((YY>>4)&0x00001000)
               |((YY<<6)&0x00000800)|((YY>>1)&0x00000400)
               |((YY>>14)&0x00000200)|((YY)&0x00000100)
               |((YY>>5)&0x00000020)|((YY>>10)&0x00000010)
               |((YY>>3)&0x00000008)|((YY>>18)&0x00000004)
               |((YY>>26)&0x00000002)|((YY>>24)&0x00000001);

        *SK++= ((XX<<15)&0x20000000)|((XX<<17)&0x10000000)
               |((XX<<10)&0x08000000)|((XX<<22)&0x04000000)
               |((XX>>2)&0x02000000)|((XX<<1)&0x01000000)
               |((XX<<16)&0x00200000)|((XX<<11)&0x00100000)
               |((XX<<3)&0x00080000)|((XX>>6)&0x00040000)
               |((XX<<15)&0x00020000)|((XX>>4)&0x00010000)
               |((YY>>2)&0x00002000)|((YY<<8)&0x00001000)
               |((YY>>14)&0x00000808)|((YY>>9)&0x00000400)
               |((YY)&0x00000200)|((YY<<7)&0x00000100)
               |((YY>>7)&0x00000020)|((YY>>3)&0x00000011)
               |((YY<<2)&0x00000004)|((YY>>21)&0x00000002);
  }
 }

/*-----------------------------------------------------------------------*/

 B aa_JsonSystemStart                  (V)
 {
 logg("aa_JsonSystemStart()");
 aa_ObjectIdNew(&aa.json_system.object_id);
 aa_ObjectDefine(aa.json_system.object_id,sizeof(_aa_jsonobject),_8K,64,aaJsonDestroy,"Json");
 logg("");
 return RET_YES;
 }


 B aa_JsonSystemStop                   (V)
 {
 logg("aa_JsonSystemStop()");
 aa_ObjectUndefine(aa.json_system.object_id);
 logg("");
 return RET_YES;
 }



 B aa_JsonSystemExtendMemory           (PP mem,H by)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(jsonp,_aa_jsonobject*,*mem);
 if(by==0) { return RET_YES; }
 if(jsonp->bytes_allocated==0)
  {
  //aaLog(-777,"_alloc %i",by);
  if((ret=aa_MemoryAllocate((VP)&jsonp->status.mem,by,"JsonMem",NO))!=RET_YES) { oops; return ret; }
  }
 else
  {
  //aaLog(-777,"realloc %i by %i to %i",jsonp->bytes_allocated,by,jsonp->bytes_allocated+by);
  by+=jsonp->bytes_allocated;
  if((ret=aa_MemoryReAllocate((VP)&jsonp->status.mem,by))!=RET_YES) { oops;  return ret; }
  }
 jsonp->bytes_allocated=by;
 jsonp->bytes_left=jsonp->bytes_allocated-jsonp->status.mem_bytes;
 return RET_YES;
 }




 B aa_JsonSystemDecoderType            (PP mem,B type,H off,H bytes,VP data)
 {
 _aa_jsonobject*jsonp;
 //B txt[_16K];
 H left,count,len;
 H rl,ad;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 UNUSE(data);
 aaCast(jsonp,_aa_jsonobject*,*mem);
 //if(bytes>_32K) aaLog(-777,"zzz typ=%i %i",type,bytes);
 while(1)
  {
  left=jsonp->lines_allocated-jsonp->status.lines;
  if(left>5) { break; }
  ad=(jsonp->lines_allocated/2)+(jsonp->lines_allocated+50);
  count=sizeof(_jsonline)*(ad);//jsonp->status.lines+10);
  if(jsonp->status.line==NULL)
   {
   if(aaMemoryAllocate((VP)&jsonp->status.line,count)!=YES) oof;
   jsonp->lines_allocated=ad;
   break;
   }
  if(aaMemoryBytesGet(jsonp->status.line,&len)!=YES) oof;
  if((len+(sizeof(_jsonline)*5))>=count) { break; }
  aaMemoryReAllocate((VP)&jsonp->status.line,sizeof(_jsonline)*ad);///(jsonp->lines_allocated+20));//status.lines+20));
   //BUG,"la=%i %i",jsonp->lines_allocated,jsonp->lines_allocated+ad);
  jsonp->lines_allocated=ad;//(jsonp->lines_allocated);
  break;
  }
 rl=jsonp->status.lines;
 if(type==JSON_TYPE_OBJOPEN||type==JSON_TYPE_ARRAYOPEN) { jsonp->depth++; }
 jsonp->status.line[rl].is_keyobj=NO;
 jsonp->status.line[rl].is_keyarray=NO;
 jsonp->status.line[rl].is_keyvalue=NO;
 jsonp->status.line[rl].depth=jsonp->depth;
 jsonp->status.line[rl].open_line=-1;
 jsonp->status.line[rl].close_line=-1;
 jsonp->status.line[rl].parent_line=-1;
 jsonp->status.line[rl].num_elements=-1;
 jsonp->status.line[rl].element_index=-1;
 jsonp->status.line[rl].next_element=-1;
 jsonp->status.line[rl].prev_element=-1;
 jsonp->status.line[rl].bytes=bytes;
 jsonp->status.line[rl].type=type;
 jsonp->status.line[rl].off=off;
 jsonp->status.line[rl].len=bytes;
 jsonp->status.line[rl].val_int=0;
 jsonp->status.line[rl].val_float=0;
 jsonp->status.line[rl].val_bool=' ';
 if(type==JSON_TYPE_INT)
  {
  aaStringToNumber(&jsonp->status.mem[off],len,0,0,&jsonp->status.line[rl].val_int,0);
  }
 else
 if(type==JSON_TYPE_FLOAT)
  {
  aaStringToDouble(&jsonp->status.mem[off],0,&jsonp->status.line[rl].val_float);
  }
 else
 if(type==JSON_TYPE_FALSE)
  {
  jsonp->status.line[rl].val_bool='f';
  }
 else
 if(type==JSON_TYPE_TRUE)
  {
  jsonp->status.line[rl].val_bool='t';
  }
 else
 if(type==JSON_TYPE_NULL)
  {
  jsonp->status.line[rl].val_bool='N';
  }
 else
 if(type==6)
  {
  oof;
  jsonp->status.line[rl-1].type=JSON_TYPE_KEY;
  return RET_YES;
  }
 if(type==JSON_TYPE_OBJCLOSE||type==JSON_TYPE_ARRAYCLOSE) { jsonp->depth--; }
 jsonp->status.lines=rl+1;
 return RET_YES;
 }





 B aa_jsonSystemDecode                 (PP mem)
 {
 _aa_jsonobject*jsonp;
 B ret;
 H sl,i,j,left,off,len,t,cnt;
 B txt[_32K+_8K];
 Z depth;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 aaCast(jsonp,_aa_jsonobject*,*mem);
 switch(jsonp->dec_stage)
  {
  case 0:
  jsonp->dec_stage=300;
  break;

  case 300:
  if((ret=aaParserSeekToVisibleChar(&jsonp->pa,YES))!=YES)
   {
   jsonp->dec_stage=552;
   //jsonp->status.is_decoded=NO;
   break;
   }
  if(jsonp->pa.ch=='{')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_OBJOPEN,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch=='[')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_ARRAYOPEN,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch=='}')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_OBJCLOSE,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch==']')
   {
   aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_ARRAYCLOSE,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch==DQUOTE_CHAR)
   {
   aaParserCopy(&jsonp->pb,&jsonp->pa,NO);
   aaParserSeek(&jsonp->pa,1);
   while(1)
    {
    if(jsonp->pa.bp[0]==BSLASH_CHAR&&jsonp->pa.bp[1]==DQUOTE_CHAR) { aaParserSeek(&jsonp->pa,2); continue; }
    if(jsonp->pa.bp[0]!=DQUOTE_CHAR)  { aaParserSeek(&jsonp->pa,1);  continue; }
    sl=(jsonp->pa.offset-jsonp->pb.offset)+1;
    //if(sl>_32K) aaLog(-777,"%i",sl);
    aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_STRING,jsonp->pb.offset,sl,jsonp->pb.bp);//txt);//jsonp->pa.bp);
    aaParserSeek(&jsonp->pa,1);
    break;
    }
   break;
   }
  if(jsonp->pa.ch==':')
   {
   if(jsonp->status.line[jsonp->status.lines-1].type!=JSON_TYPE_STRING) { oof; }
   jsonp->status.line[jsonp->status.lines-1].type=JSON_TYPE_KEY;
   //aa_JsonSystemDecoderType((VP)&jsonp,6,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  if(jsonp->pa.ch==',')
   {
   //aa_JsonSystemDecoderType((VP)&jsonp,7,jsonp->pa.offset,1,jsonp->pa.bp);
   aaParserSeek(&jsonp->pa,1);
   break;
   }
  aaParserCopy(&jsonp->pb,&jsonp->pa,NO);
  aaParserSeek(&jsonp->pa,1);
  while(1)
   {
   if(aaCharIsVisible(jsonp->pa.bp[0])==NO||(jsonp->pa.bp[0]==','||jsonp->pa.bp[0]=='}'||jsonp->pa.bp[0]==']'))
    {
    //if(jsonp->pa.bp[0]==',') oof;
    sl=(jsonp->pa.offset-jsonp->pb.offset);
    if(sl==1&&(jsonp->pb.bp[0]=='}'||jsonp->pb.bp[0]==']'||jsonp->pb.bp[0]=='{'||jsonp->pb.bp[0]=='['))
     {
     aaParserCopy(&jsonp->pa,&jsonp->pb,NO);
     break;
     }
    aaStringNCopy(txt,jsonp->pb.bp,sl,YES);
    if(aaCharIsVisible(txt[0])==NO&&sl==1) { break; }
    if(aaStringIsNumerical(txt,0,1,0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_INT,jsonp->pb.offset,sl,txt); break; }
    if(aaStringIsNumerical(txt,1,1,0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_FLOAT,jsonp->pb.offset,sl,txt); break; }
    if(aaStringICompare(txt,"false",0)==YES) { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_FALSE,jsonp->pb.offset,sl,txt); break; }
    if(aaStringICompare(txt,"true",0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_TRUE,jsonp->pb.offset,sl,txt); break; }
    if(aaStringICompare(txt,"null",0)==YES)  { aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_NULL,jsonp->pb.offset,sl,txt); break; }
    aa_JsonSystemDecoderType((VP)&jsonp,JSON_TYPE_UNKNOWN,jsonp->pb.offset,sl,txt);
    break;
    }
   aaParserSeek(&jsonp->pa,1);
   }
  break;

  case 552:
  i=0;
  while(i<jsonp->status.lines)
   {
   left=jsonp->status.lines-i;
   if(left==0) { break; }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY||jsonp->status.line[i+0].type==JSON_TYPE_STRING)
    {
    jsonp->status.line[i+0].off++;
    jsonp->status.line[i+0].len-=2;
    }
   off=jsonp->status.line[i+0].off;
   len=jsonp->status.line[i+0].len;
   if(len==0) { i++; continue; }
   jsonp->status.line[i+0].hash=0;
   aaStringHashGet(&jsonp->status.mem[off],len,&jsonp->status.line[i+0].hash,YES);
   i++;
   }
  jsonp->dec_stage=560;
  break;

  case 560:
  ///
  i=0;
  while(i<jsonp->status.lines)
   {
   if(jsonp->status.line[i+0].type==JSON_TYPE_OBJOPEN) { t=JSON_TYPE_OBJCLOSE; } else
   if(jsonp->status.line[i+0].type==JSON_TYPE_ARRAYOPEN) { t=JSON_TYPE_ARRAYCLOSE; } else { i++; continue; }
   depth=jsonp->status.line[i+0].depth;
   for(j=i;j<jsonp->status.lines;j++)
    {
    if(jsonp->status.line[j+0].type!=t) { continue; }
    if(jsonp->status.line[j+0].depth!=depth) { continue; }
    jsonp->status.line[i+0].close_line=j;
    break;
    }
   i++;
   }
  i=jsonp->status.lines-1;
  while(i!=F32)
   {
   if(jsonp->status.line[i+0].type==JSON_TYPE_OBJCLOSE) { t=JSON_TYPE_OBJOPEN; } else
   if(jsonp->status.line[i+0].type==JSON_TYPE_ARRAYCLOSE) { t=JSON_TYPE_ARRAYOPEN; } else { i--; continue; }
   depth=jsonp->status.line[i+0].depth;
   for(j=i;j!=F32;j--)
    {
    if(jsonp->status.line[j+0].type!=t) { continue; }
    if(jsonp->status.line[j+0].depth!=depth) { continue; }
    jsonp->status.line[i+0].open_line=j;
    break;
    }
   i--;
   }
  //
  jsonp->dec_stage=580;
  break;

  case 580:
  i=0;
  while(i<jsonp->status.lines)
   {
   left=jsonp->status.lines-i;
   if(left==0) { break; }
   jsonp->status.line[i+0].is_keyobj=NO;
   jsonp->status.line[i+0].is_keyarray=NO;
   jsonp->status.line[i+0].is_keyvalue=NO;
   if(left<2) { i++; continue; }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY&&jsonp->status.line[i+1].type==JSON_TYPE_ARRAYOPEN)
    {

    if((jsonp->status.line[i+0].depth+1)!=jsonp->status.line[i+1].depth) oof;
    jsonp->status.line[i+0].is_keyarray=YES;
    i+=2;
    continue;
    }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY&&jsonp->status.line[i+1].type==JSON_TYPE_OBJOPEN)
    {
    //if(jsonp->status.line[i+0].depth!=jsonp->status.line[i+1].depth) oof;

    if((jsonp->status.line[i+0].depth+1)!=jsonp->status.line[i+1].depth) oof;
    jsonp->status.line[i+0].is_keyobj=YES;
    i+=2;
    continue;
    }
   if(jsonp->status.line[i+0].type==JSON_TYPE_KEY&&jsonp->status.line[i+1].type>=JSON_TYPE_STRING)
    {
    //if(jsonp->status.line[i+0].depth!=jsonp->status.line[i+1].depth) oof;

    if((jsonp->status.line[i+0].depth)!=jsonp->status.line[i+1].depth) oof;
    jsonp->status.line[i+0].is_keyvalue=YES;
    i+=2;
    continue;
    }
   i++;
   continue;
   }
  jsonp->dec_stage=582;
  break;

  case 582:
  i=0;
  while(i<jsonp->status.lines)
   {
   if(jsonp->status.line[i+0].type!=JSON_TYPE_ARRAYOPEN) {  i++; continue; }
   depth=jsonp->status.line[i+0].depth;
   cnt=0;
//   BUG,"i=%i close=%i",i,jsonp->status.line[i+0].close_line);
   for(j=i;j<(H)jsonp->status.line[i+0].close_line;j++)
    {
    if(j==i) { continue; }
    //if(jsonp->status.line[j+0].type==JSON_TYPE_ARRAYCLOSE) { continue; }
    //if(jsonp->status.line[j+0].type==JSON_TYPE_OBJCLOSE) { continue; }
    if(jsonp->status.line[j+0].type==JSON_TYPE_OBJOPEN||jsonp->status.line[j+0].type==JSON_TYPE_ARRAYOPEN)
     {
     if(jsonp->status.line[j+0].depth!=(depth+1)) { continue; }
     jsonp->status.line[j+0].parent_line=i;
     }
    else
    if(jsonp->status.line[j+0].type>=JSON_TYPE_STRING)
     {
     if(jsonp->status.line[j+0].depth!=(depth)) { continue; }
     jsonp->status.line[j+0].parent_line=i;
     }
    else
     {
     continue;
     }
    //BUG,"%i %i %i %i",i,j,jsonp->status.line[j+0].depth,depth);
    cnt++;
    //break;
    }
   //BUG,"line %i cnt %i",i,cnt);
   jsonp->status.line[i+0].num_elements=cnt;
   i++;
   }
  jsonp->dec_stage=584;
  break;

  case 584:
  i=0;
  while(i<jsonp->status.lines)
   {
   if(jsonp->status.line[i+0].num_elements==-1) {  i++; continue; }
   cnt=0;
   t=i;
   j=i+1;
   for(;j<(H)jsonp->status.line[i+0].close_line;j++)
    {
    if(jsonp->status.line[j+0].parent_line!=(Z)i) {  continue; }
    jsonp->status.line[j+0].element_index=cnt;
    jsonp->status.line[t+0].next_element=j;
    if(cnt!=0) { jsonp->status.line[j+0].prev_element=t; }
    t=j;
    cnt++;
    }
   i++;
   }
  jsonp->dec_stage=590;
  break;


  case 590:
  jsonp->dec_stage=600;
  break;

  case 600:
  jsonp->status.is_decoding=NO;
  jsonp->status.decode_success=YES;
  jsonp->status.decode_failure=NO;
  break;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aa_ClassSystemStart                 (V)
 {
 logg("aa_ClassSystemStart()");
 logg("");
 return RET_YES;
 }



 V aa_ClassSystemStop                  (V)
 {
 N i;

 logg("aa_ClassSystemStop()");
 for(i=127;i>-1;i--)
  {
  aaClassDestroy((B)i);
//boffin  aa_CoreSystemLoop();
  }
 logg("");
 }




/*-----------------------------------------------------------------------*/



 B aa_SettingsSystemStart              (V)
 {
 HKEY sub;
 HKEY subb;
 H disp;

 logg("aa_SettingsSystemStart()");
 logg("");

 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software",0L,KEY_ALL_ACCESS|0x100,&sub)!=ERROR_SUCCESS)
  {
  return RET_FAILED;
  }
 if(RegCreateKeyEx(sub,aa_SETTINGS_ROOT,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp)!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  return RET_FAILED;
  }
 RegCloseKey(subb);
 RegCloseKey(sub);
 return RET_YES;
 }




 V aa_SettingsSystemStop               (V)
 {
 logg("aa_SettingsSystemStop()");
 logg("");
 if(aa.settings_system.enum_key!=0)
  {
  aaSettingsEnumStop();
  }
 }



/*-----------------------------------------------------------------------*/




 B aa_ClipBoardSystemStart             (V)
 {
 logg("aa_ClipBoardSystemStart()");
 logg("");
 return RET_YES;
 }




 V aa_ClipBoardSystemStop              (V)
 {
 logg("aa_ClipBoardSystemStop()");
 logg("");
 }


/*-----------------------------------------------------------------------*/




 B aa_IpcSystemStart                   (V)
 {
 logg("aa_IpcSystemStart()");
 aa_ObjectIdNew(&aa.ipc_system.object_id);
 aa_ObjectDefine(aa.ipc_system.object_id,sizeof(_aa_ipcobject),_2K,10,aaIpcDestroy,"Ipc");
 logg("");
 return RET_YES;
 }




 V aa_IpcSystemStop                    (V)
 {
 logg("aa_IpcSystemStop()");
 aa_ObjectUndefine(aa.ipc_system.object_id);
 logg("");
 }


/*-----------------------------------------------------------------------*/

 B aa_DesktopSystemStart               (V)
 {
 logg("aa_DesktopSystemStart()");
 aa_ObjectIdNew(&aa.desktop_system.object_id);
 aa_ObjectDefine(aa.desktop_system.object_id,sizeof(_aa_desktopobject),1000,4,aaDesktopDestroy,"Desktop");
 logg("");
 return RET_YES;
 }



 V aa_DesktopSystemStop                (V)
 {
 logg("aa_DesktopSystemStop()");
 aa_ObjectUndefine(aa.desktop_system.object_id);
 logg("");
 }



/*-----------------------------------------------------------------------*/


 B aaStringNull                        (VP str)
 {
 CP d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(d,CP,str);
 *d=NULL_CHAR;
 return RET_YES;
 }




 B aaStringIsNull                      (VP str)
 {
 CP d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(d,CP,str);
 if(*d!=NULL_CHAR) { return RET_NO; }
 return RET_YES;
 }



 B aaStringIsEmpty                     (VP str,B onlybool)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(onlybool==YES&&str==NULL) { return RET_YES; }
 if(onlybool!=YES&&str==NULL) { return RET_BADPARM; }
 bp=(BP)str;
 if(bp[0]!=NULL_CHAR) { return RET_NO; }
 return RET_YES;
 }



 B aaStringCopy                        (VP dst,VP src)
 {
 register CP s;
 register CP d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 aaCast(d,CP,dst);
 if(src==NULL)
  {
  *d=NULL_CHAR;
  return RET_YES;
  }
 aaCast(s,CP,src);
 while(1)
  {
  *d=*s;
  if(*s==NULL_CHAR) break;
  d++;
  s++;
  }
 return RET_YES;
 }






 B aaStringNCopy                       (VP dst,VP src,H chars,B appendnull)
 {
 register CP s;
 register CP d;
 register C ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(src==NULL) { return RET_BADPARM; }
 if(dst==NULL) { return RET_BADPARM; }
// if(chars==0)  { aaStringLen(src,&chars); }
 if(chars==0)
  {
  if(appendnull)   {   aaCast(d,CP,dst);   *d=NULL_CHAR;   }
  return RET_YES;
  }
 aaCast(s,CP,src);
 aaCast(d,CP,dst);
 while(1)
  {
  ch=*s;
  *d =ch;
  if(ch==NULL_CHAR) { break; }
  //if(ch!=NULL_CHAR) s++;
  s++;
  d++;
  chars--;
  if(chars==0) break;
  }
 if(appendnull&&ch!=NULL_CHAR) { *d=NULL_CHAR; }
 return RET_YES;
 }





 B aaStringCopyLen                     (VP dst,VP src,HP chars)
 {
 CP s,d;
 H sl;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 if(dst==NULL) { return RET_BADPARM; }
 aaCast(d,CP,dst);
 if(src==NULL)
  {
  *d=NULL_CHAR;
  return RET_YES;
  }
 aaCast(s,CP,src);
 sl=0;
 while(1)
  {
  *d=*s;
  if(*s==NULL_CHAR) break;
  d++;
  s++;
  sl++;
  }
 if(chars) { *chars=sl; }
 return RET_YES;
 }






 B aaStringLen                         (VP str,HP chars)
 {
 register CP s;
 register H count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(str==NULL) { return RET_BADPARM; }
 aaCast(s,CP,str);
 count=0;
 while(1)
  {
  if(*s==NULL_CHAR) break;
  s++;
  count++;
  }
 *chars=count;
 return RET_YES;
 }




 B aaStringNLen                        (VP str,H maxchars,HP chars)
 {
 CP s;
 H count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(str==NULL) { return RET_BADPARM; }
 if(maxchars==0) { return RET_NOTFOUND; }
 aaCast(s,CP,str);
 count=0;
 while(1)
  {
  if(*s==NULL_CHAR) break;
  s++;
  count++;
  if(count>=maxchars) { return RET_NOTFOUND; }
  }
 *chars=count;
 return RET_YES;
 }




 B aaStringLenSet                      (VP str,H chars)
 {
 CP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 oof;
 if(str==NULL) { return RET_BADPARM; }
 aaCast(s,CP,str);
 s[chars]=NULL_CHAR;
 return RET_YES;
 }




 B aaStringFill                        (VP str,H chars,B ascii,B appendnull)
 {
 register CP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(s,CP,str);
 if(chars==0) { aaStringLen(str,&chars);  }
 if(chars!=0) { aaMemoryFill(s,chars,ascii);  }
 if(appendnull==YES) { s[chars]=NULL_CHAR; }
 return RET_YES;
 }





 B aaStringAppend                      (VP dst,VP src)
 {
 B ret;
 CP s,d;
 H dest_len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(dst,&dest_len))!=RET_YES)  {  return ret;  }
 aaCast(d,CP,dst);
 if(src==NULL)  {  d+=dest_len;  *d=NULL_CHAR;  return RET_YES;  }
 aaCast(s,CP,src);
 d+=dest_len;
 while(1)
  {
  *d=*s;
  if(*s==NULL_CHAR) break;
  d++;
  s++;
  }
 return RET_YES;
 }








 B aaStringAppendChar                  (VP str,B ch)
 {
 B ret;
 BP d;
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(str,&len))!=RET_YES)  {  return ret;  }
 aaCast(d,BP,str);
 //if(len>0) { len--; }
 d[len]=ch;
 d[len+1]=NULL_CHAR;
 return RET_YES;
 }



 B aaStringAppendChars                 (VP str,B ch,H count,B appendnull)
 {
 BP bp;
 H i,sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 bp=(BP)str;
 aaStringLen(str,&sl);
 for(i=0;i<count;i++)  {  bp[sl++]=ch;  }
 if(appendnull)  {  bp[sl]=NULL_CHAR;  }
 return RET_YES;
 }





 B aaStringVSprintf                    (VP dst,VP fmt,va_list arglist)
 {
 BP bp;
 BP fm;
 B ch;
 _size*v_size;
 _cord*v_cord;
 _rect*v_rect;
 _rgba*v_rgba;
 _yuva*v_yuva;
 _hlsa*v_hlsa;
 C v_c;
 D v_d;
 Z v_i;
 H v_u;
 Q v_q;
 CP v_str;
 H sl;
 H i;
 C txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,dst);
 aaCast(fm,BP,fmt);
 *bp=NULL_CHAR;

 while(1)
  {
  ch=*fm; fm++;
  if(ch==0) { break; }
  if(ch!='%') {  *bp=ch;  bp++;  continue;   }
  ch=*fm; fm++;
  if(ch==0) { break; }
  if(ch=='c'&&*fm=='d')
   {
   fm++;
   if((v_cord=va_arg(arglist,_cord*))==NULL) { break; }
   wsprintf(txt,"%i,%i",v_cord->x,v_cord->y);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='s'&&*fm=='z')
   {
   fm++;
   if((v_size=va_arg(arglist,_size*))==NULL) { break; }
   wsprintf(txt,"%i,%i",v_size->w,v_size->h);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='r'&&*fm=='c')
   {
   fm++;
   if((v_rect=va_arg(arglist,_rect*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_rect->x,v_rect->y,v_rect->w,v_rect->h);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='p'&&*fm=='n')
   {
   fm++;
   if((v_rgba=va_arg(arglist,_rgba*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_rgba->r,v_rgba->g,v_rgba->b,v_rgba->a);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='y'&&*fm=='u')
   {
   fm++;
   if((v_yuva=va_arg(arglist,_yuva*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_yuva->y,v_yuva->u,v_yuva->v,v_yuva->a);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='h'&&*fm=='l')
   {
   fm++;
   if((v_hlsa=va_arg(arglist,_hlsa*))==NULL) { break; }
   wsprintf(txt,"%i,%i,%i,%i",v_hlsa->h,v_hlsa->l,v_hlsa->s,v_hlsa->a);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  if(ch=='I'&&*fm=='P')
   {
   fm++;
   v_u=va_arg(arglist,H);
   aaNetIpToString(v_u,txt);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   continue;
   }
  switch(ch)
   {
   default:
   break;

   case 'i':
   case 'd':
   v_i=va_arg(arglist,Z);
   sprintf(txt,"%i",v_i);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;

   case 'u':
   v_u=(H)va_arg(arglist,H);
   sprintf(txt,"%u",(Z)v_u);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;

   case 'c':
   v_c=(C)va_arg(arglist,Z);
   sprintf(txt,"%c",v_c);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;

  case 'q':
   v_q=(Q)va_arg(arglist,Q);
   sprintf(txt,"%I64u",v_q);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;


   case 'f':
   v_d=va_arg(arglist,double);
   sprintf(txt,"%f",v_d);
   aaStringLen(txt,&sl);
   for(i=0;i<sl;i++) {  *bp=txt[i];  bp++;     }
   break;


   case 's':
   v_str=va_arg(arglist,CP);
   if(v_str!=NULL)
    {
    aaStringLen(v_str,&sl);
    for(i=0;i<sl;i++)
     {
     *bp=v_str[i];
     bp++;
     }
    }
   break;
   }
  }
 *bp=NULL_CHAR;
 return RET_YES;
 }






 B aaStringNCopyf                      (VP dst,H maxchars,VP fmt,...)
 {
 B ret;
 va_list argptr;
 BP tmp=NULL_POINTR;
 B temp[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES) {   if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrNCopyf))!=RET_YES) { return ret; }   }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(maxchars>=_64K) { aaNote(0,"line=%i\nmaxchars=%i",__LINE__,maxchars);  }
 tmp[maxchars]=NULL_CHAR;
 return(aaStringCopy(dst,tmp));
 }






 B aaStringCopyf                       (VP dst,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B temp[_64K];
 BP tmp=NULL_POINTR;

 ///OutputDebugString("func=aaStringCOpyf");
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrCopyf))!=RET_YES)  { return ret;   }
  }
 else
  {
  aaCast(tmp,BP,temp);
  }

 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 return(aaStringCopy(dst,tmp));
 }




 B aaStringCopyfLen                    (VP dst,HP chars,VP fmt,...)
 {
 B ret;
 va_list argptr;
 H sl;
 BP tmp=NULL_POINTR;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES) { if((ret=aa_MemoryTemp((VP)&tmp,_256K-100,aa_MEMORYTEMP_StrCopyfLen))!=RET_YES) {  return ret; }  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 ret=aaStringCopy(dst,tmp);
 if(chars) { aaStringLen(dst,&sl); *chars=sl; }
 return ret;
 }




 B aaStringAppendf                     (VP dst,VP fmt,...)
 {
 va_list argptr;
 B ret;
 BP tmp=NULL_POINTR;
 B temp[_64K];

 ///OutputDebugString("func=aaStringAppendf");
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.is_ready==YES)
  {
  ///OutputDebugString("doing tmp");
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrAppendf))!=RET_YES) { oops; return ret; }
  ///OutputDebugString("end doing tmp");
  }
 else
  {
  ///OutputDebugString("aaStringAppendf=aa.is_ready=NO");
  aaCast(tmp,BP,temp);
  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)   {  return RET_BADPARM;  }
 return(aaStringAppend(dst,tmp));
 }





 B aaStringAppendfLen                  (VP dst,HP chars,VP fmt,...)
 {
 B ret;
 va_list argptr;
 H sl;
 B temp[_64K];
 BP tmp=NULL_POINTR;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K-300,aa_MEMORYTEMP_StrCopyf))!=RET_YES) {  return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if(dst==NULL)  {  return RET_BADPARM;  }
 ret=aaStringAppend(dst,tmp);
 if(chars) { aaStringLen(dst,&sl); *chars=sl; }
 return ret;
 }




 B aaStringSpacedAppendf               (VP dst,VP fmt,...)
 {
 va_list argptr;
 B str[_32K];
 H dl,sl;
 BP dp,sp;
 B dch,sch;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dst==NULL) { return RET_BADPARM; }
 aaFmt(fmt,argptr,str);
 sp=(BP)str; aaStringLen(sp,&sl);
 dp=(BP)dst; aaStringLen(dp,&dl);
 dch=NULL_CHAR; if(dl!=0) { dch=dp[dl-1];  }
 sch=NULL_CHAR; if(sl!=0) { sch=sp[0];     }
 if(dl!=0&&sl!=0)
  {
  if(dch!=SPACE_CHAR&&sch!=SPACE_CHAR)
   {
   aaStringAppendChar(dp,SPACE_CHAR);
   }
  }
 aaStringAppendf(dp,"%s",str);
 return RET_YES;
 }





/*e.g
aaStringAppendCopyf(txt,0,"%-25s ","aa_stage=%u",aa_stage);
*/


 B aaStringAppendCopyf                 (VP dst,HP chars,VP afmt,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B temp[_64K];
 BP tmp=NULL_POINTR;
 H sl,tl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) { *chars=0; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_StrAppendCopyf))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 aaStringLen(tmp,&tl);
 if(dst==NULL)  {  return RET_BADPARM;  }
 if(chars)  {  aaStringLen(dst,&sl);  *chars=sl;  }
 ret=aaStringAppendf(dst,afmt,tmp);
 if(chars)  {  aaStringLen(dst,&sl);  *chars=sl;    }
 return ret;
 }





 B aaStringConcat                      (VP str,...)
 {
 BP bp;
 B txt[_16K];
 va_list ap;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,str);
 if(str==NULL) {  va_end(ap); return RET_BADPARM; }
 aaStringNull(txt);
 while(1)
  {
  if((bp=va_arg(ap,BP))==NULL) { break; }
  aaStringAppendf(txt,"%s",bp);
  }
 va_end(ap);
 aaStringAppendf(str,"%s",txt);
 return RET_YES;
 }





 B aaStringCopyx                       (VP dst,VP fmt,...)
 {
 va_list ap;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,fmt);
 aaStringVSprintf(dst,fmt,ap);
 va_end(ap);
 return RET_YES;
 }




 B aaStringCompare                     (VP dst,VP src,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  c1=*s1;
  c2=*s2;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaStringICompare                    (VP dst,VP src,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(1)
  {
  c1=*s1;
  c2=*s2;
  if(c1>='A'&&c1<='Z') c1+=(B)32;
  if(c2>='A'&&c2<='Z') c2+=(B)32;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }





 B aaStringNCompare                    (VP dst,VP src,H chars,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(dst,&chars); }
 else
 if(chars==F32) { aaStringLen(src,&chars); }
 if(chars==0)  { if(dif) { *dif=0; }  return RET_YES;  }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(chars-->0)
  {
  c1=*s1;
  c2=*s2;
  if(c1!=c2)
   {
   if(dif) { *dif=(N)(c1-c2);   }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }








 B aaStringNICompare                   (VP dst,VP src,H chars,NP dif)
 {
 register BP s1;
 register BP s2;
 register B c1;
 register B c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dif!=NULL) { *dif=-1; }
 if(dst==NULL) { return RET_BADPARM; }
 if(src==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(dst,&chars); }
 else
 if(chars==F32) { aaStringLen(src,&chars); }
 if(chars==0) {  if(dif) { *dif=0; }  return RET_YES;  }
 aaCast(s1,BP,dst);
 aaCast(s2,BP,src);
 while(chars-->0)
  {
  c1=*s1;
  c2=*s2;
  if(c1>='A'&&c1<='Z')  c1+=(B)32;
  if(c2>='A'&&c2<='Z')  c2+=(B)32;
  if(c1!=c2)
   {
   if(dif)  { *dif=(I)(c1-c2); }
   return RET_NO;
   }
  if(c1==NULL_CHAR)   {   break;   }
  s1++;
  s2++;
  }
 if(dif) { *dif=0; }
 return RET_YES;
 }







 B aaStringUpper                       (VP str,H chars,VP ostr)
 {
 register BP s;
 register BP d;
 register H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str);  }
 for(i=0;i<chars;i++)
  {
  if(s[i]>='a'&&s[i]<='z') { d[i]=(B)(s[i]-32); }
  else
  if(s!=d) { d[i]=(B)s[i]; }
  }
 d[i]=NULL_CHAR;
 return RET_YES;
 }






 B aaStringLower                       (VP str,H chars,VP ostr)
 {
 register BP s;
 register BP d;
 register H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else       { aaCast(d,BP,str);  }
 for(i=0;i<chars;i++)
  {
  if(s[i]>='A'&&s[i]<='Z') { d[i]=(B)(s[i]+32); }
  else                     { d[i]=(B)s[i]; }
  }
 d[i]=NULL_CHAR;
 return RET_YES;
 }







 B aaStringReverse                     (VP str,H chars,VP ostr,B appendnull)
 {
 BP s,tmp=NULL_POINTR;
 H i,o;
 B ret,overwrite;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 aaCast(tmp,BP,temp);
 if(ostr)  {  overwrite=NO;  }
 else        {  overwrite=YES; }
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrReverse))!=RET_YES) { oops; return ret; }
  }
 i=chars-1;
 o=0;
 while(1)
  {
  tmp[o]=s[i];
  if(i==0) { break; }
  o++;
  i--;
  }
 if(appendnull)      {  tmp[o+1]=NULL_CHAR;  }
 if(overwrite==YES)  {  aaStringCopy(str,tmp); }
 else                  {  aaStringCopy(ostr,tmp);  }
 return RET_YES;
 }




 B aaStringInsertChar                  (VP str,H chars,H pos,C ch)
 {
 register CP s;
 register H left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==F32)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 left=chars-pos;
 if(left==0)
  {
  aaCast(s,CP,str);
  s[chars]=ch;
  s[chars+1]=NULL_CHAR;
  }
 else
  {
  aaCast(s,CP,str);
  aaMemoryCopy(&s[pos+1],left,&s[pos]);
  s[pos]=ch;
  s[chars+1]=NULL_CHAR;
  }
 return RET_YES;
 }





 B aaStringInsertChars                 (VP str,H chars,H pos,C ch,H inscount)
 {
 register CP s;
 register H left,d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==F32)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 if(inscount==0) { return RET_YES; }
 for(d=0;d<inscount;d++)
  {
  left=chars-pos;
  if(left==0)
   {
   aaCast(s,CP,str);
   s[chars]=ch;
   s[chars+1]=NULL_CHAR;
   }
  else
   {
   aaCast(s,CP,str);
   aaMemoryCopy(&s[pos+1],left,&s[pos]);
   s[pos]=ch;
   s[chars+1]=NULL_CHAR;
   }
  chars++;
  }
 return RET_YES;
 }






 B aaStringDeleteChar                  (VP str,H chars,H pos)
 {
 register CP s;
 register H left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==F32)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 left=chars-pos;
 if(left==0)
  {
  if(chars==0) { return RET_YES; }
  aaCast(s,CP,str);
  s[chars-1]=NULL_CHAR;
  }
 else
  {
///  log(chars %i  left  %i poa=%i",chars,left,pos);
  aaCast(s,CP,str);
  aaMemoryCopy(&s[pos],left,&s[pos+1]);
  s[chars-1]=NULL_CHAR;
  }
 return RET_YES;
 }





 B aaStringDeleteChars                 (VP str,H chars,H pos,H delcount)
 {
 register CP s;
 register H left,d;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(pos==F32)   { pos=chars; }
 if(pos>chars)  { return RET_BOUNDS; }
 if(delcount==0) { return RET_YES; }
 if(pos==chars) // added mar 08 ashod
  {
  aaCast(s,CP,str);
  s[chars-delcount]=NULL_CHAR;
  return RET_YES;
  }

 for(d=0;d<delcount;d++)
  {
  left=chars-pos;
  if(left==0)
   {
   if(chars==0) { return RET_YES; }
   aaCast(s,CP,str);
   s[chars-1]=NULL_CHAR;
   }
  else
   {
 ///  log(chars %i  left  %i poa=%i",chars,left,pos);
   aaCast(s,CP,str);
   aaMemoryCopy(&s[pos],left,&s[pos+1]);
   s[chars-1]=NULL_CHAR;
   }
  }
 return RET_YES;
 }




 B aaStringDeleteCharsTillChar         (VP str,H chars,B ch,B incch,HP len)
 {
 B ret;
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 incch&=1;
 if(len) { *len=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0)
  {
  if(ch==NULL_CHAR) return RET_YES;
  return RET_NOTFOUND;
  }
 aaCast(bp,BP,str);
 ret=aaStringFindChar(bp,chars,&off,ch,YES,0,YES);
 if(ret==RET_NOTFOUND)
  {
  if(len) { aaStringLen(str,len); }
  return RET_NOTFOUND;
  }
 if(incch==YES)
  {
  if((ret=aaStringDeleteChars(bp,chars,0,off+1))!=RET_YES) { oops; }
  }
 else
  {
  if(off>0)
   {
   if((ret=aaStringDeleteChars(bp,chars,0,off+0))!=RET_YES) { oops; }
   }
  }
 if(len) { aaStringLen(str,len); }
 return RET_YES;
 }




 B aaStringCharGet                     (VP str,H chars,N pos,BP ch)
 {
 H off;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ch) { *ch=NULL_CHAR; }
 if(str==NULL)  {  return RET_BADPARM;  }
 if(ch==NULL)  {  return RET_BADPARM;  }
 if(chars==0)   {  aaStringLen(str,&chars);  }
 if(pos>=0) { off=(H)pos; }
 else       { off=(H)aaNumAbs(pos); off=chars-off; }
 if(off>=chars) { return RET_BOUNDS; }
 aaCast(bp,BP,str);
 *ch=bp[off];
 return RET_YES;
 }



 B aaStringCharSet                     (VP str,H chars,N pos,B ch)
 {
 H off;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)  {  return RET_BADPARM;  }
// if(ch==NULL)  {  return RET_BADPARM;  }
 if(chars==0)   {  aaStringLen(str,&chars);  }
 if(pos>=0) { off=(H)pos; }
 else       { off=(H)aaNumAbs(pos); off=chars-off; }
 if(off>=chars) {  return RET_BOUNDS; }
 aaCast(bp,BP,str);
 bp[off]=ch;
 return RET_YES;
 }




 B aaStringCharUpper                   (VP str,H chars,N pos)
 {
 B ret;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringCharGet(str,chars,pos,&ascii))!=YES) { return ret; }
 if(aaCharIsAlphaLo(ascii)!=YES) { return RET_YES; }
 ascii-=32;
 return(aaStringCharSet(str,chars,pos,ascii));
 }



 B aaStringCharLower                   (VP str,H chars,N pos)
 {
 B ret;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringCharGet(str,chars,pos,&ascii))!=YES) { return ret; }
 if(aaCharIsAlphaHi(ascii)!=YES) { return RET_YES; }
 ascii+=32;
 return(aaStringCharSet(str,chars,pos,ascii));
 }



 B aaStringLastCharGet                 (VP str,H chars,BP ch)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaStringCharGet(str,chars,-1,ch));
 }





 B aaStringLastCharSet                 (VP str,H chars,B ch,B appendnull)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)   {  aaStringLen(str,&chars);  }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 s[chars-1]=ch;
 if(appendnull) { s[chars]=NULL_CHAR; }
 return RET_YES;
 }




 B aaStringIsLastChar                  (VP str,H chars,B ch)
 {
 B ret;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringCharGet(str,chars,-1,&ascii))!=YES) { return ret; }
 if(ascii!=ch) { return RET_NO; }
 return RET_YES;
 }



 B aaStringLastCharNonVisibleRemove    (VP str,H chars)
 {
 BP bp;
 B ascii;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(bp,BP,str);
 off=chars;
 while(1)
  {
  if(chars==0) { break; }
  ascii=bp[off];
 /// if(ascii==NULL_CHAR) { break;  }
  if(aaCharIsVisible(ascii)==YES) { bp[off+1]=NULL_CHAR; break; }
  //aaStringLastCharGet(str,chars,&ascii);
 // if(ascii==NULL_CHAR) { break; }
 // if(aaCharIsVisible(ascii)==YES) { break; }
  //aaStringLastCharSet(str,chars,NULL_CHAR,YES);
  bp[off]=NULL_CHAR;
  if(off==0) { break; }
  off--;
  chars--;
  }
 return RET_YES;
 }


 B aaStringFirstCharNonVisibleRemove   (VP str,H chars)
 {
 BP bp;
 B ascii;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(bp,BP,str);
 off=0;
 while(1)
  {
  if(chars==0) { break; }
  ascii=bp[off];
 /// if(ascii==NULL_CHAR) { break;  }
  if(aaCharIsVisible(ascii)==YES) { break; } //bp[off+1]=NULL_CHAR; break; }
  //aaStringLastCharGet(str,chars,&ascii);
 // if(ascii==NULL_CHAR) { break; }
 // if(aaCharIsVisible(ascii)==YES) { break; }
  //aaStringLastCharSet(str,chars,NULL_CHAR,YES);
  //bp[off]=NULL_CHAR;
  //if(off==0) { break; }
  off++;
  chars--;
  }
 if(off!=0)
  {
  aaStringDeleteChars(str,0,0,off);
  }
 return RET_YES;
 }



 B aaStringInsertString                (VP str,H chars,H pos,VP istr,H ichars)
 {
// N todo;
 BP bp;
 BP sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ichars==0) { aaStringLen(istr,&ichars); }
 if(chars==0) { aaStringLen(str,&chars); }
 aaCast(bp,BP,istr);
 aaCast(sp,BP,str);
 if(ichars==0) { return RET_YES; }
 if(pos>chars) { return RET_BOUNDS; }
// todo=chars-ichars;
 UNUSE(bp);
// if(todo>0)
  {
  aaMemoryCopy(&sp[pos+ichars],chars-pos,&sp[pos]);
  aaMemoryCopy(&sp[pos],ichars,istr);
  sp[pos+chars+ichars]=NULL_CHAR;
  }
 return RET_YES;
 }





 B aaStringInsertStringf               (VP str,H chars,H pos,B appendnull,VP fmt,...)
 {
 B ret;
 va_list ap;
 B txt[_64K];
 H sl;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,ap,txt);
 aaStringLen(txt,&sl);

 if(chars==0) { aaStringLen(str,&chars);}
 //else         { chars=sl; }

 if(appendnull==YES) { sl++; }
 ret=aaStringInsertString(str,chars,pos,txt,sl);
 if(ret==RET_YES)
  {
  bp=(BP)str;
  bp[chars+sl]=NULL_CHAR;
  }
 return ret;
 }






 B aaStringIsString                    (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 //ret=RET_NO;
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=NO; break; }
  aaStringLen(s,&dsl);
  if(ssl==dsl)
   {
   aaStringNCompare(str,s,dsl,&dif);
   if(dif==0)
    {
    ret=YES;
    *which=w;
    break;
    }
   }
  w++;
  }
 va_end(ap);
// if(*which==-1) { return RET_NO; }
 return ret;
 }





 B aaStringIsIString                   (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which!=NULL) { *which=-1; }
 //*which=-1;
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=RET_NO; break; }
  aaStringLen(s,&dsl);
  if(ssl==dsl)
   {
   if((ret=aaStringNICompare(str,s,dsl,&dif))==RET_YES)
    {
    if(which) { *which=w; }
    break;
    }
   }
  w++;
  }
 va_end(ap);
// if(*which==-1) { return RET_NO; }
 return ret;
 }





 B aaStringIsStringPartial             (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=NO; break; }
  aaStringLen(s,&dsl);
  if(ssl>=dsl)
   {
   aaStringNCompare(str,s,dsl,&dif);
   if(dif==0)
    {
    ret=YES;
    *which=w;
    break;
    }
   }
  w++;
  }
 va_end(ap);
 return ret;
 }







 B aaStringIsIStringPartial            (VP str,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl;
 N w,dif;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { ret=RET_NO; break; }
  aaStringLen(s,&dsl);
  if(ssl>=dsl)
   {
   if((ret=aaStringNICompare(str,s,dsl,&dif))==RET_YES)
    {
    *which=w;
    break;
    }
   }
  w++;
  }
 va_end(ap);
 return ret;
 }




 B aaStringIsNumerical                 (VP str,B allowfloat,B allowsign,H chars)
 {
 BP s;
 H i,dotcount=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(s,BP,str);
 for(i=0;i<chars;i++)
  {
  if(s[i]=='.'&&allowfloat==YES&&dotcount==0) { dotcount=1; continue; }
  if((s[i]=='+'||s[i]=='-')&&allowsign==YES&&i==0) { continue; }
  if(s[i]<'0'||s[i]>'9') { return RET_NO; }
  }
 return RET_YES;
 }



 B aaStringIsDeliminated               (VP str,H chars,WP type,BP mode)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mode) { *mode=0; }
 if(type!=NULL) { *type=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 aaCast(s,BP,str);
 if(s[chars]==NULL_CHAR)
  {
  if(mode) { *mode=aa_STRINGMODE_NULL; }
  }
 if(chars==0)
  {
  return RET_NO;
  }
 if(s[chars-1]==LF_CHAR)
  {
  if(chars>=2&&s[chars-2]==CR_CHAR)
   {
   if(mode) { *mode=aa_STRINGMODE_CRLF; }
   if(type) { *type=0x0d0a;  }
   return RET_YES;
   }
   if(mode) { *mode=aa_STRINGMODE_LF; }
  if(type) { *type=0x0a; }
  return RET_YES;
  }
 if(s[chars-1]==CR_CHAR)
  {
  if(chars>=2&&s[chars-2]==LF_CHAR)
   {
   if(type) { *type=0x0a0d; }
  if(mode) { *mode=aa_STRINGMODE_LFCR; }
   return RET_YES;
   }
  if(mode) { *mode=aa_STRINGMODE_CR; }
  if(type) { *type=0x0d; }
  return RET_YES;
  }
 return RET_NO;
 }




 B aaStringCountNumbers                (VP str,H chars,HP count,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if(s[i]>='0'&&s[i]<='9') { c++; }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountHex                    (VP str,H chars,HP count,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]>='0'&&s[i]<='9')||(s[i]>='a'&&s[i]<='f')||(s[i]>='A'&&s[i]<='F'))
   {
   c++;
   }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountAlpha                  (VP str,H chars,HP count,B upper,B lower,B underscore,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]>='a'&&s[i]<='z')&&lower)   {   c++;   }
  else
  if((s[i]>='A'&&s[i]<='Z')&&upper)   {   c++;   }
  else
  if((s[i]=='_')&&underscore) {    c++;   }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountAlphaNum               (VP str,H chars,HP count,B upper,B lower,B underscore,B numerical,B consecutive)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]>='a'&&s[i]<='z')&&lower)   {   c++;   }
  else
  if((s[i]>='A'&&s[i]<='Z')&&upper)   {   c++;   }
  else
  if((s[i]=='_')&&underscore) {    c++;   }
  else
  if((s[i]>='0'&&s[i]<='9')&&numerical) { c++; }
  else
   {
   if(consecutive==YES) { break; }
   }
  }
 *count=c;
 return RET_YES;
 }



 B aaStringCountVisibleChars           (VP str,H chars,HP count,B logic,B consecutive,B fwd)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(count==NULL) { return RET_BADPARM; }
 fwd&=1;
 logic&=1;
 //if(fwd!=YES) oof;
 *count=0;
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 if(fwd==YES)
  {
  for(i=0;i<chars;i++)
   {
   if(logic==YES&&aaCharIsVisible(s[i])==YES)   {   c++;   }
   else
   if(logic==NO&&aaCharIsVisible(s[i])!=YES)   {   c++;   }
   else
    {
    if(consecutive==YES) { break; }
    }
   }
  }
 else
  {
  for(i=0;i<chars;i++)
   {
   if(logic==YES&&aaCharIsVisible(s[chars-i-1])==YES)   {   c++;   }
   else
   if(logic==NO&&aaCharIsVisible(s[chars-i-1])!=YES)   {   c++;   }
   else
    {
    if(consecutive==YES) { break; }
    }
   }
  }

 *count=c;
 return RET_YES;
 }




 B aaStringIsPrintable                 (VP str,H chars)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(s,BP,str);
 while(1)
  {
  if(aaCharIsPrintable(*s)!=YES) { return RET_NO; }
  chars--;
  if(chars==0) { break; }
  s++;
  }
 return RET_YES;
 }





 B aaStringCountPrintable              (VP str,H chars,HP count)
 {
 BP s;
 H c=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count) { *count=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(s,BP,str);
 while(1)
  {
  if(aaCharIsPrintable(*s)==YES) { c++; }
  chars--;
  if(chars==0) { break; }
  s++;
  }
 if(count) { *count=c; }
 return RET_YES;
 }








 B aaStringToDouble                    (VP str,H chars,DP dub)
 {
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dub) *dub=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 *dub=atof((CP)s);
 return RET_YES;
 }





 B aaStringToNumber                    (VP str,H chars,HP loh,HP hih,GP gv,QP qv)
 {
 BP s;
 D v,h;
 H ch;
 N isneg;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(loh!=NULL) { *loh=0; }
 if(hih!=NULL) { *hih=0; }
 if(gv!=NULL) { *gv=0; }
 if(qv!=NULL) { *qv=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(gv==NULL&&qv==NULL&&loh==NULL&&hih==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 v=0;
 isneg=0;
 while(1)
  {
  if(*s=='-')
   {
   if(isneg) { break; }
   isneg=1;
   }
  else
   {
   ch=*s-'0';
   if(ch>9) { break; }
   v=v*(D)10;
   v=v+(D)ch;
   }
  chars--;
  if(chars==0) { break; }
  s++;
  }
 if(isneg) { v=-v; }
 if(gv)  {  *gv=(G)v;  }
 if(qv)  {  *qv=(Q)v;  }
 if(hih)
  {
  if(aa.math_system.four_billion==0.0) oof;
  h=v/(D)aa.math_system.four_billion;
  *hih=(H)h;
  }
 if(loh) { *loh=(H)v; }
 return RET_YES;
 }




 B aaStringHexToNumber                 (VP str,H chars,HP loh,HP hih,GP gv,QP qv)
 {
 BP s;
 //D v,h;
 G val;
 H ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(loh!=NULL) { *loh=0; }
 if(hih!=NULL) { *hih=0; }
 if(gv!=NULL) { *gv=0; }
 if(qv!=NULL) { *qv=0; }

 if(str==NULL) { return RET_BADPARM; }
 //if(loh==NULL&&hih==NULL) { oof; return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(chars>=3)
  {
  if(s[0]=='0'&&(s[1]=='x'||s[1]=='X')&&aaCharIsHex(s[2]))  { s+=2;   chars-=2;   }
  }
 val=0;
 while(1)
  {
  ch=*s;
  if(ch>='A'&&ch<='F') { ch=ch-'A'; ch=ch+10; }  else
  if(ch>='a'&&ch<='f') { ch=ch-'a'; ch=ch+10; }  else
  if(ch>='0'&&ch<='9') { ch=ch-'0';           }  else { break; }
  val=val*(G)16;
  val=val+(G)ch;
  chars--;
  if(chars==0) { break; }
  s++;
  }
 if(gv)  {  *gv=(G)val;  }
 if(qv)  {  *qv=(Q)val;  }
 if(loh) { *loh=(H)val; }
 val=val>>16;
 if(hih) {  *hih=(H)val;  }
 return RET_YES;
 }


 /*
 aaStringFromBinary(str,0,32,4,1,&em);
 aaDebugf("       0    4    8   12   16   20   24   28   " );
 aaDebugf("       +----+----+----+----+----+----+----+---" );
 aaDebugf("bits:  %s",str);
 */


 B aaStringFromBinary                  (VP str,H from,H nbits,H gbits,B dir,VP mem)
 {
 BP sp,mp;
 H bb,o,by,bi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 sp=(BP)str;
 mp=(BP)mem;
 //if(nbits==0) { nbits=1; }
 for(bb=0;bb<nbits;bb++)
  {
  //o=bb;
  if(dir==1) { o=(bb); }
  else       { o=nbits-bb-1; }
  //aaDebugf("o=%i-%i-1=%i",nbits,bb,o);
  o+=from;
  by=o/8;
  bi=o%8;
  //aaDebugf("by=%i bi=%i",by,bi);
  if(aaBitGet(mp[by],bi)) *sp='1'; else *sp='0';
  sp++;
  if(gbits!=0&&((bb+1)%gbits)==0)
   {
   *sp=SPACE_CHAR;
   sp++;
   }
  }
 *sp=NULL_CHAR;
 return RET_YES;
 }








 B aaStringCountChars                  (VP str,H chars,HP count,B ch,B consecutive,B logic)
 {
 H i,c;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 c=0;
 for(i=0;i<chars;i++)
  {
  if((s[i]!=ch&&logic==YES)||(s[i]==ch&&logic==NO))
   {
   if(consecutive==YES) { break; }
   }
  else
   {
   c++;
   }
  }
 *count=c;
 return RET_YES;
 }





 // if H chars==0&&B ch==NULL_CHAR, then it fails for some reason,, i.e to find null char with unknown string len doesnt work

 B aaStringFindChar                    (VP str,H chars,HP pos,B ch,B logic,H number,B fwd)
 {
 BP ptr;
 H s,f;
 _parser p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
// if(pos==NULL) { return RET_BADPARM; }
 //*pos=F32;
 if(pos!=NULL) { *pos=F32; }
 if(str==NULL) { return RET_BADPARM;  }
 if(chars==0)  { aaStringLen(str,&chars);  }
 if(chars==0)  { return RET_NOTFOUND;  }
 f=0;
 if(fwd==YES)
  {
  aaCast(ptr,BP,str);
  s=0;
  while(1)
   {
   if((*ptr==ch&&logic)||(*ptr!=ch&&!logic))
    {
    if(f==number)     {   if(pos) { *pos=s; }   return RET_YES;     }
    f++;
    }
   chars--;
   if(chars==0) { break; }
   ptr++;
   s++;
   }
  return RET_NOTFOUND;
  }
 else
  {
  aaParserInit(&p,str,chars);
  if(p.length==0) { return RET_NOTFOUND; }
  aaParserSeek(&p,p.length-1); // seek to last char ( one before null char )
  while(1)
   {
   if((*p.bp==ch&&logic)||(*p.bp!=ch&&!logic))
    {
    if(f==number) {  if(pos) { *pos=p.offset; } /*(p.length-1)-p.offset; */ return RET_YES;  }
    f++;
    }
   if(p.is_start==YES) { break; }
   aaParserSeek(&p,-1);
   }
  }
 return RET_NOTFOUND;
 }




 B aaStringFindCharList                (VP str,H chars,HP pos,VP chlist,B logic,H number,B fwd)
 {
 BP ptr;
 H s,f,i,sl;
 _parser p;
 B match;
 BP chl;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
// if(pos==NULL) { return RET_BADPARM; }
 //*pos=F32;
 if(pos!=NULL) { *pos=F32; }
 if(chlist==NULL) { return RET_BADPARM; }
 aaStringLen(chlist,&sl);
 if(sl==0) { return RET_BADPARM; }
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 f=0;
 aaCast(chl,BP,chlist);
 if(fwd==YES)
  {
  aaCast(ptr,BP,str);
  s=0;
  while(1)
   {
   match=NO;
   if(logic)
    {
    for(i=0;i<sl;i++)     {     if(*ptr==chl[i]) { match=YES; break; }     }
    }
   else
    {
    for(i=0;i<sl;i++)     {     if(*ptr==chl[i]) { break; } }
    if(i==sl) { match=YES;  }
    }
   if(match)
    {
    if(f==number)     {   if(pos) {   *pos=s; }   return RET_YES;     }
    f++;
    }
   chars--;
   if(chars==0) { break; }
   ptr++;
   s++;
   }
  return RET_NOTFOUND;
  }
 else
  {
  aaParserInit(&p,str,chars);
  if(p.length==0) { return RET_NOTFOUND; }
  aaParserSeek(&p,p.length-1); // seek to last char ( one before null char )
  while(1)
   {
   match=NO;
   if(logic)
    {
    for(i=0;i<sl;i++)     {     if(*p.bp==chl[i]) { match=YES; break; }     }
    }
   else
    {
    for(i=0;i<sl;i++)     {     if(*p.bp==chl[i]) { break; }}
    if(i==sl) { match=YES;  }
    }
   if(match)
    {
    if(f==number) {  if(pos) { *pos=p.offset; } /*(p.length-1)-p.offset; */ return RET_YES;  }
    f++;
    }
   if(p.is_start==YES) { break; }
   aaParserSeek(&p,-1);
   }
  }
 return RET_NOTFOUND;
 }





 B aaStringFindFirstAlpha              (VP str,H chars,HP pos,B logic)
 {
 BP ptr;
 H s;
 B ascii;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos==NULL) { return RET_BADPARM; }
 *pos=F32;
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 aaCast(ptr,BP,str);
 s=0;
 while(1)
  {
  ascii=*ptr;
  if((aaCharIsAlpha(ascii)&&logic)||(((!aaCharIsAlpha(ascii))&&!logic)))
  //if((( (*ptr>='a'&&*ptr<='a')||(*ptr>='A'&&*ptr<='Z'))&&logic)||((*ptr<'0'||*ptr>'9')&&!logic) )
   {
   *pos=s;
   return RET_YES;
   }
  chars--;
  if(chars==0) break;
  ptr++;
  s++;
  }
 return RET_NOTFOUND;
 }





 B aaStringFindFirstNumber             (VP str,H chars,HP pos,B logic)
 {
 BP ptr;
 H s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos==NULL) { return RET_BADPARM; }
 *pos=F32;
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 aaCast(ptr,BP,str);
 s=0;
 while(1)
  {
  if(((*ptr>='0'&&*ptr<='9')&&logic)||((*ptr<'0'||*ptr>'9')&&!logic))
   {
   *pos=s;
   return RET_YES;
   }
  chars--;
  if(chars==0) break;
  ptr++;
  s++;
  }
 return RET_NOTFOUND;
 }




 B aaStringFindCharVisible             (VP str,H chars,HP pos,B logic,H number,B fwd)
 {
 BP ptr;
 H s,f;
 _parser p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pos!=NULL) { *pos=F32; }
 if(str==NULL)  {  return RET_BADPARM;  }
 if(chars==0)  {  aaStringLen(str,&chars);  }
 if(chars==0)  {  return RET_NOTFOUND;  }
 f=0;
 if(fwd==YES)
  {
  aaCast(ptr,BP,str);
  s=0;
  while(1)
   {
   if((aaCharIsVisible(*ptr)&&logic)||(!aaCharIsVisible(*ptr)&&!logic))
    {
    if(f==number)     {   if(pos) {   *pos=s; }   return RET_YES;     }
    f++;
    }
   chars--;
   if(chars==0) { break; }
   ptr++;
   s++;
   }
  return RET_NOTFOUND;
  }
 else
  {
  aaParserInit(&p,str,chars);
  if(p.length==0) { return RET_NOTFOUND; }
  aaParserSeek(&p,p.length-1); // seek to last char ( one before null char )
  while(1)
   {
   if((aaCharIsVisible(*p.bp)&&logic)||(!aaCharIsVisible(*p.bp)&&!logic))
    {
    if(f==number) {  if(pos) { *pos=p.offset; } /*(p.length-1)-p.offset; */ return RET_YES;  }
    f++;
    }
   if(p.is_start==YES) { break; }
   aaParserSeek(&p,-1);
   }
  }
 return RET_NOTFOUND;
 }




 B aaStringReplaceChar                 (VP str,H chars,B fromch,B toch)
 {
 BP s;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 if(fromch==toch) { return RET_YES; }
 aaCast(s,BP,str);
 for(i=0;i<chars;i++)
  {
  if(s[i]==fromch) { s[i]=toch; }
  }
 return RET_YES;
 }




 B aaStringReplaceString               (VP str,H chars,VP fstr,H fchars,VP tstr,H tchars,B iscasesensitive,VP ostr)
 {
 BP ob;
 B buf[_8K];
 _parser pa;
 H ok,o;
 B ib[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(ostr!=NULL&&ostr!=str) { aaStringNull(ostr); }
 ob=(BP)buf;
 if(chars==0)  { aaStringLen(str,&chars); }
 if(chars==0)   {  return RET_NOTFOUND;  } //return RET_YES; }
 if(fstr==NULL) { return RET_BADPARM; }
 if(fchars==0)  {  aaStringLen(fstr,&fchars); }
 if(fchars==0)   { return RET_NOTFOUND;  } // return RET_YES; }
 if(tstr==NULL) { return RET_BADPARM; }
 if(tchars==0)  {  aaStringLen(tstr,&tchars); }
 if(tchars==0)   {  return RET_BADPARM;  } //return RET_YES; }
 aaStringNCopy(ob,str,chars,YES);
 aaStringNCopy(ib,str,chars,YES);
 ok=0;
 aaParserInit(&pa,ob,chars);
 o=pa.offset;
 while(1)
  {
  if(pa.is_end) break;
  if(aaParserSeekToString(&pa,fstr,iscasesensitive,YES,PARSERFLAG_SAFE)!=YES) break;
  if(fchars==tchars)
   {
   aaStringNCopy(&ob[pa.offset],tstr,tchars,NO);
   o=pa.offset+tchars;
   ok=1;
   }
  else
  if(tchars>fchars)
   {
   aaStringInsertChars(ob,0,pa.offset,32,tchars-fchars);
   aaStringNCopy(&ob[pa.offset],tstr,tchars,NO);
   o=pa.offset+(tchars);
   ok=2;
   }
  else
  if(fchars>tchars)
   {
   aaStringDeleteChars(ob,0,pa.offset,fchars-tchars);
   aaStringNCopy(&ob[pa.offset],tstr,tchars,NO);
   o=pa.offset+(tchars);
   ok=3;
   }
  else oof;
  if(ok==0) oof;
  aaStringLen(ob,&chars);
  aaParserInit(&pa,ob,chars);
  aaParserOffsetSet(&pa,o);
  }
 if(ostr==NULL) { aaStringCopyf(str,"%s",ob); }
 else           { aaStringCopyf(ostr,"%s",ob); }
 if(ok) { return RET_YES; }
 return RET_NOTFOUND;
 }



 B aaStringFindFirstString             (VP str,H chars,VP fstr,H fchars,HP pos)
 {
 BP s,d;
 H i,c,p;
 B sch,dch,mch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(pos==NULL) { return RET_BADPARM; }
 //*pos=F32;
 if(pos) *pos=F32;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)  { aaStringLen(str,&chars); }
 if(fstr==NULL) { return RET_BADPARM; }
 if(fchars==0)  {  aaStringLen(fstr,&fchars); }
 if(fchars==0)   { return RET_NO; }// if(*pos==F32) { return RET_NO; } return RET_YES; }
 if(fchars>chars) { return RET_NO; } // if(*pos==F32) { return RET_NO; } return RET_YES; }
 aaCast(s,BP,str);
 aaCast(d,BP,fstr);
 i=c=0;
 p=F32;
 mch=d[0];
 while(1)
  {
  sch=s[i];
  dch=d[c];
  if(sch==dch)   {  if(c==0) { p=i; }   c++;   }
  else           {  if(sch==mch) { p=i; c=1;  }  else {  c=0; p=F32; }  } // june2013
  if(c==fchars)  { if(pos) *pos=p; return RET_YES; }
  i++;
  if(i==chars) { break; }
  }
 return RET_NO;
// if(*pos==F32) {  return RET_NO; }
// return RET_YES;
 }





 B aaStringFindFirstIString            (VP str,H chars,VP fstr,H fchars,HP pos)
 {
 BP s,d;
 H i,c,p;
 B sch,dch,mch;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(pos==NULL) { return RET_BADPARM; }
 //*pos=F32;
 if(pos) *pos=F32;
 if(str==NULL)  { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(fstr==NULL)   { return RET_BADPARM; }
 if(fchars==0)    { aaStringLen(fstr,&fchars); }
 if(fchars==0)    { return RET_NO; }// if(*pos==F32) { return RET_NO; } return RET_YES; }
 if(fchars>chars) { return RET_NO; } // if(*pos==F32) { return RET_NO; } return RET_YES; }
 aaCast(s,BP,str);
 aaCast(d,BP,fstr);
 i=c=0;
 p=F32;
 mch=d[0];
 if(mch>='A'&&mch<='Z') { mch+=(B)32; }
 while(1)
  {
  sch=s[i];
  dch=d[c];
  if(sch>='A'&&sch<='Z') { sch+=(B)32; }
  if(dch>='A'&&dch<='Z') { dch+=(B)32; }
  if(sch==dch)   {  if(c==0) { p=i; }   c++;   }
  else
   {
   if(sch==mch) { p=i; c=1;  }
   else         { c=0; p=F32; }
   }
  ///else             {  c=0; p=F32;  } june2013
  if(c==fchars)  { if(pos) *pos=p; return RET_YES; }
  i++;
  if(i==chars) { break; }
  }
 return RET_NO;
// if(*pos==F32) {  return RET_NO; }
// return RET_YES;
 }





 B aaStringCleanup                     (VP str,H chars,B ignorequoted,HP newlen)
 {
 B ret;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(newlen) { *newlen=chars; }
 sl=chars;
 while(1)
  {
  if((ret=aaStringRemoveSpaces(str,sl,YES,YES))!=YES) { oops; }
  aaStringLen(str,&sl);
  if(sl==0) { break; }
  if((ret=aaStringRemoveMultipleSpaces(str,sl,ignorequoted))!=YES) { oops; }
  aaStringLen(str,&sl);
  break;
  }
 if(newlen) {  *newlen=sl; }
 return RET_YES;
 }




 B aaStringRemoveMultipleSpaces        (VP str,H chars,B ignorequoted)
 {
 B ret,prev_char;
 B cur_char;
 BP tmp=NULL_POINTR;
 B in_quote;
 H i,o;
 BP sp;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,chars+_1K,aa_MEMORYTEMP_StrMultSpaces))!=RET_YES) { return ret; }
  }
 aaStringNull(tmp);
 aaCast(sp,BP,str);
 prev_char=NULL_CHAR;
 in_quote=NO;
 i=o=0;
 while(1)
  {
  if(i>=chars) { break; }
  cur_char=sp[i];
  if(cur_char==NULL_CHAR)       { break; }
  if(cur_char==DQUOTE_CHAR)     { in_quote^=1;  }
  else
  if(cur_char==SPACE_CHAR&&(in_quote==NO||ignorequoted==NO))
   {
   if(prev_char==SPACE_CHAR) {  i++; continue; }
   }
  tmp[o++]=cur_char;
  tmp[o]=NULL_CHAR;
  prev_char=cur_char;
  i++;
  }
 aaMemoryCopy(str,o+1,tmp);
 return RET_YES;
 }





 B aaStringRemoveSpaces                (VP str,H chars,B removeleading,B removetrailing)
 {
 B ch;
 BP bp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 if(removetrailing==YES)
  {
  while(1)
   {
   if(aaStringLastCharGet(str,chars,&ch)!=RET_YES) { break; }
   if(ch!=SPACE_CHAR) { break; }
   aaStringDeleteChar(str,chars,chars);
   aaStringLen(str,&chars);
   }
  }
 if(removeleading==YES)
  {
  while(1)
   {
   aaCast(bp,BP,str);
   if(bp[0]!=SPACE_CHAR) { break; }
   aaStringDeleteChar(bp,chars,0);
   aaStringLen(str,&chars);
   }
  }
 return RET_YES;
 }




 B aaStringRemoveChars                 (VP str,H chars,B ch)
 {
 BP bp;
 H off;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(bp,BP,str);
 off=0;
 while(1)
  {
  if(bp[off]!=ch)   {   off++;   }
  else   {   aaStringDeleteChar(bp,0,off);   chars--;   }
  if(off>=chars) { /* bp[off]=NULL_CHAR;*/ break; }
  }
 return RET_YES;
 }




 B aaStringDespace                     (VP str,H chars)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringLen(str,&chars);
 if(chars==0) { return RET_YES; }
 aaStringReplaceChar(str,chars,HTAB_CHAR,SPACE_CHAR);
 aaStringRemoveSpaces(str,chars,YES,YES);
 aaStringRemoveMultipleSpaces(str,chars,YES);
 return RET_YES;
 }




 B aaStringFindFirstIStrings           (VP str,H chars,HP pos,HP len,NP which,...)
 {
 va_list ap;
 CP s;
 H ssl,dsl[128];
 H off[128];
 N j,w;
 N smallest_index;
 N smallest_offset;
 //B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)  { aaStringLen(str,&chars); }

 va_start(ap,which);
 w=0;
 aaStringLen(str,&ssl);
 while(1)
  {
  s=va_arg(ap,CP);
  if(s==NULL) { break; }//ret=RET_NO; break; }
  aaStringLen(s,&dsl[w]);
  if(aaStringFindFirstIString(str,chars,s,dsl[w],&off[w])!=RET_YES) { off[w]=F32; }
  w++;
  }
 va_end(ap);

 smallest_index=-1;
 smallest_offset=1000000000;
 for(j=0;j<w;j++)
  {
  if(off[j]==F32) { continue; }
  if(off[j]<(H)smallest_offset) { smallest_index=j; smallest_offset=off[j]; continue; }
  }
 if(smallest_index==-1) { return RET_NO; }
 if(which) { *which=smallest_index; }
 if(pos)   { *pos=off[smallest_index]; }
 if(len)   { *len=dsl[smallest_index]; }
 return RET_YES;
 }




 B aaStringIsQuoted                    (VP str,H chars,BP qchar)
 {
 BP bp;
 B qc;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(qchar) *qchar=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 qc=0;
 if(bp[0]==DQUOTE_CHAR||bp[0]==QUOTE_CHAR)  { qc=bp[0]; }
 if(qc)   {  if(qchar) *qchar=qc;  }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]==qc) { return RET_YES; }
 return RET_NO;
 }


 B aaStringIsBraced                    (VP str,H chars)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[0]!='{') { return RET_NO; }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]=='}') { return RET_YES; }
 return RET_NO;
 }



 B aaStringIsBracketed                 (VP str,H chars)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[0]!='[') { return RET_NO; }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]==']') { return RET_YES; }
 return RET_NO;
 }


 B aaStringIsParenthesized             (VP str,H chars)
 {
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[0]!='(') { return RET_NO; }
 if(chars<2) { return RET_NO; }
 if(bp[chars-1]==')') { return RET_YES; }
 return RET_NO;
 }



 B aaStringQuotify                     (VP str,H chars,B qchar)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 //if(qchar!=DQUOTE_CHAR&&qchar!=QUOTE_CHAR) { return RET_BADPARM; }
 if(qchar==0) { return RET_BADPARM; }
 if(chars==0)
  {
  aaStringCopyf(str,"%c%c",qchar,qchar);
  return RET_YES;
  }
 aaStringInsertChar(str,chars,0,qchar);
 aaStringAppendChar(str,qchar);
 return RET_YES;
 }



// math random get gets 4 bytes at a time, - THIS is why, stringrandomSet is 4x
// slower than aaMemoryRandomSet -- because I only utilize 1 random character
// at a time
 B aaStringRandomSet                   (VP str,H chars,B alphalo,B alphahi,B numerical,B appendnull)
 {
 register BP bp;
 register BP vp;
 B val,ch;
 H ra,z;
 BP rp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { return RET_FAILED; }
 if(alphalo!=YES&&alphahi!=YES&&numerical!=YES) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 while(1)
  {
  if(chars==0) { break; }
  if(chars>=4)
   {
   ra=aaMathTwisterInt32(&aa.math_system.twister);
   vp=(BP)&ra;
   for(z=0;z<4;z++)
    {
    ch=vp[z];
    if(alphahi==YES&&ra%3==0)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;      }  else
    if(alphalo==YES&&ra%3==1)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
    if(numerical==YES&&ra%3==2) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;      }
    else
     {
     if(alphahi==YES)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;      }  else
     if(alphalo==YES)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
     if(numerical==YES) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;      }  else oof;
     }
    }
   chars-=4;
   continue;
   }


  //aa_MathRandomGet(&val,1);
  ra=aaMathTwisterInt32(&aa.math_system.twister);
  rp=(BP)&ra;
  val=rp[0];
  ch=val;//rp[0];

  //ch=val;
  if(alphahi==YES&&val%3==0)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;     }  else
  if(alphalo==YES&&val%3==1)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
  if(numerical==YES&&val%3==2) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;     }
  else
   {
   if(alphahi==YES)   {    ch%=(B)26;   ch+=(B)'A';   *bp++=ch;      }  else
   if(alphalo==YES)   {    ch%=(B)26;   ch+=(B)'a';   *bp++=ch;      }  else
   if(numerical==YES) {    ch%=(B)10;   ch+=(B)'0';   *bp++=ch;      }  else oof;
   }
  chars--;

  }
 if(appendnull)
  {
  *bp=NULL_CHAR;
  }
 return RET_YES;
 }






 B aaStringHashGet                     (VP str,H chars,HP hash,B iscasesensitive)
 {
 BP tmp=NULL_POINTR;
 BP ptr;
 B loctmp[_8K];
 B temp[_8K];
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(iscasesensitive==NO)
  {
  if(chars<sizeof(loctmp))
   {
   aaStringLower(str,chars,loctmp);
   aaCast(ptr,BP,loctmp);
   }
  else
   {
   aaCast(tmp,BP,temp);
   if(aa.is_ready==YES)
    {
    if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrHash))!=RET_YES) { return ret; }
    }
   else { oof; }
   aaStringLower(str,chars,tmp);
   aaCast(ptr,BP,tmp);
   }
  }
 else
  {
  aaCast(ptr,BP,str);
  }
 return(aaMemoryHashGet(ptr,chars,hash));
 }



 B aaStringHashIsTrue                  (VP str,H chars,H hash,B iscasesensitive)
 {
 B ret;
 H xh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 xh=0;
 if((ret=aaStringHashGet(str,chars,&xh,iscasesensitive))!=YES) { return ret; }
 if(xh!=hash) { return RET_NO; }
 return RET_YES;
 }



 B aaStringHashBothGet                 (VP str,H chars,HP hash,HP hashi)
 {
 B ret;
 H xh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash)
  {
  xh=0;
  if((ret=aaStringHashGet(str,chars,&xh,YES))!=YES) { return ret; }
  *hash=xh;
  }
 if(hashi)
  {
  xh=0;
  if((ret=aaStringHashGet(str,chars,&xh,NO))!=YES) { return ret; }
  *hashi=xh;
  }
 return RET_YES;
 }





 B aaStringGuid                        (VP str,B appendnull)
 {
 H i,v;
 FILETIME ft;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 GetSystemTimeAsFileTime(&ft);
 aaStringCopyf(bp,"%08lx",ft.dwLowDateTime);
 aaStringRandomSet(&bp[9],27,YES,NO,YES,appendnull);
 bp[8]='-';  bp[13]='-';
 bp[18]='-'; bp[23]='-';
 for(i=0;i<36;i++)
  {
  if(bp[i]>='g'&&bp[i]<='z')
   {
   aaMemoryRandomDwordSet(&v,0,15);
   if(v<10) {         bp[i]=(B)('0'+v); }
   else     {         bp[i]=(B)('a'+(v-10)); }
   }
  }
 return RET_YES;
 }




 B aaStringIsGuid                      (VP str)
 {
 H sl,count;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringLen(str,&sl);
 if(sl!=36) { return RET_NO; }
 aaCast(bp,BP,str);
 if(bp[8]!='-') { return RET_NO; }
 if(bp[13]!='-') { return RET_NO; }
 if(bp[18]!='-') { return RET_NO; }
 if(bp[23]!='-') { return RET_NO; }
 aaStringCountHex(&bp[0],8,&count,YES);
 if(count!=8) {  return RET_NO; }
 aaStringCountHex(&bp[14],4,&count,YES);
 if(count!=4) {  return RET_NO; }
 aaStringCountHex(&bp[19],4,&count,YES);
 if(count!=4) {  return RET_NO; }
 aaStringCountHex(&bp[24],12,&count,YES);
 if(count!=12) {  return RET_NO; }
 return RET_YES;
 }





 B aaStringFromWideString              (VP str,WCHAR*wstr)
 {
 WCHAR*wp;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 bp[0]=NULL_CHAR;
 if(wstr==NULL) { return RET_BADPARM; }
 aaCast(wp,WCHAR*,wstr);
 while(1)
  {
  *bp=(B)((*wp)&F8);
  if(*bp==0) { break; }
  bp++;
  wp++;
  }
 return RET_YES;
 }




 B aaStringToWideString                (VP str,WCHAR*wstr)
 {
 WCHAR*wp;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(wstr==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,str);
 aaCast(wp,WCHAR*,wstr);
 while(1)
  {
  *wp=(WCHAR)*bp;
  if(*bp==0) { break; }
  bp++;
  wp++;
  }
 return RET_YES;
 }




 B aaStringPathSanitize                 (VP str,H chars,VP ostr)
 {
 register BP s;
 register BP d;
 register H i;
 B last_char;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str);  }
 last_char=NULL_CHAR;
 for(i=0;i<chars;i++)
  {
  if(s[i]==NULL_CHAR) { break; }
  if(s[i]==BSLASH_CHAR) { d[i]=FSLASH_CHAR; }
  else                  { d[i]=(B)s[i]; }
  last_char=d[i];
  }
 if(last_char==FSLASH_CHAR)  { i--; }
 d[i]=NULL_CHAR;
 return RET_YES;
 }





 B aaStringRot13                       (VP str,H chars,VP ostr)
 {
 B u[]="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 B l[]="abcdefghijklmnopqrstuvwxyz";
 BP s,d;
 B ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str); }
 while(1)
  {
  ch=*s;
  if(ch>='A'&&ch<='Z') { ch-=(B)'A'; ch+=(B)13; ch%=(B)26; ch=u[ch]; }
  else
  if(ch>='a'&&ch<='z') { ch-=(B)'a'; ch+=(B)13; ch%=(B)26; ch=l[ch]; }
  *d=ch;
  chars--;
  if(chars==0) { d++; *d=NULL_CHAR; break; }
  d++;
  s++;
  }
 return RET_YES;
 }



 B aaStringTranspose                   (VP str,H chars,N amnt,VP ostr)
 {
 BP s,d;
 N ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else     { aaCast(d,BP,str); }
 while(1)
  {
  ch=*s;
  ch+=amnt;
  *d=(B)ch;
  chars--;
  if(chars==0) { d++; *d=NULL_CHAR; break; }
  d++;
  s++;
  }
 return RET_YES;
 }





 B aaStringFromDword                   (VP str,H val)
 {
 BP bp;
 BP sp;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,&val);
 aaCast(sp,BP,str);
 sp[0]=bp[0];
 sp[1]=bp[1];
 sp[2]=bp[2];
 sp[3]=bp[3];
 sp[4]=NULL_CHAR;
 for(i=0;i<4;i++)
  {
  if(sp[i]<SPACE_CHAR) { sp[i]=SPACE_CHAR; }
  else
  if(sp[i]>127)        { sp[i]=SPACE_CHAR; }
  }
 return RET_YES;
 }







 B aaStringFromArrayHex                (VP str,H sizet,H count,H cols,B dooffs,B doascii,VP mem)
 {
 H i,j;
 BP dp;
 BP bpi;
 WP wpi;
 HP hpi;
// QP qpi;
 B ascii;
 B txt[_32K];
 H brk;
 B freshline=YES;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(mem==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_YES; }
 if(sizet!=0&&sizet!=1&&sizet!=2&&sizet!=4&&sizet!=8) { return RET_BADPARM; }

 aaCast(dp,BP,str);
 aaCast(bpi,BP,mem);
 aaCast(wpi,WP,mem);
 aaCast(hpi,HP,mem);
 //aaCast(qpi,QP,mem);
 if(cols<1) { cols=1; }
 else
 if(cols>64) { cols=64; }

 brk=cols;
 j=0;
 if(sizet==0)
  {
  for(i=0;i<count;i++)
   {
   if(aaCharIsVisible(bpi[i])==YES) { aaStringAppendf(dp,"%c  ",bpi[i]); }
   else                             { aaStringAppendf(dp,"_  "); }
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if((i%brk==(brk-1)))     { aaStringAppendf(dp,"\r\n"); }
   }
  }
 else
 if(sizet==1)
  {
  for(i=0;i<count;i++)
   {
   if(freshline)
    {
    if(dooffs) { aaStringAppendf(dp,"%04x: ",i); }
    freshline=NO;
    }
   aaStringAppendf(dp,"%02X ",bpi[i]);
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)) { txt[j]=ascii;  }   else    if(ascii==32)              { txt[j]=ascii;  }   else    { txt[j]='.'; }
    j++;
    txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii)
     {
     aaStringAppendf(dp,"   ");
     aaStringAppendf(dp,"%s",txt);
     j=0;
     }
    aaStringAppendf(dp,"\r\n");
    freshline=YES;
    }
   }
  if(doascii&&j!=0)
   {
   for(i=j;i<(brk);i++)
    {
    aaStringAppendf(dp,"   ");
    if((i%8)==7)
     {
     //aaStringAppendf(dp,"####");
     aaStringAppendf(dp," ");
     }
    }
   aaStringAppendf(dp,"   ");
   aaStringAppendf(dp,"%s",txt);
   }
  }
 else
 if(sizet==2)
  {
  for(i=0;i<count;i++)
   {
   aaStringAppendf(dp,"%04X ",wpi[i]);
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)) { txt[j]=ascii;  }   else    if(ascii==32) { txt[j]=ascii;  }   else    { txt[j]='.'; }  j++; txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii) { aaStringAppendf(dp,"%s",txt);  j=0; }
    aaStringAppendf(dp,"\r\n");
    //aaStringLastCharSet(dp,0,CR_CHAR,NO); aaStringLastCharSet(dp,0,LF_CHAR,NO); }
    }
   }
  }
 else
 if(sizet==4)
  {
  for(i=0;i<count;i++)
   {
   aaStringAppendf(dp,"%08LX ",hpi[i]);
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)) { txt[j]=ascii;  }   else    if(ascii==32) { txt[j]=ascii;  }   else    { txt[j]='.'; }  j++; txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii) { aaStringAppendf(dp,"%s",txt);  j=0; }
    aaStringAppendf(dp,"\r\n");
    //aaStringLastCharSet(dp,0,CR_CHAR,NO); aaStringLastCharSet(dp,0,LF_CHAR,NO);
    }
   }
  }
 else
 if(sizet==8)
  {
  for(i=0;i<count;i++)
   {
   //ashod aaStringAppendf(dp,"%08LX%08LX ",qpi[i].lo,qpi[i].hi);
   if((i%8)==7) { aaStringAppendf(dp," "); }
   if(doascii)
    {
    ascii=bpi[i];
    if(aaCharIsVisible(ascii)) { txt[j]=ascii;  }   else    if(ascii==32) { txt[j]=ascii;  }   else    { txt[j]='.'; }  j++; txt[j]=NULL_CHAR;
    }
   if((i%brk==(brk-1)))
    {
    if(doascii) { aaStringAppendf(dp,"%s",txt);  j=0; }
    aaStringAppendf(dp,"\r\n");
    //aaStringLastCharSet(dp,0,CR_CHAR,NO); aaStringLastCharSet(dp,0,LF_CHAR,NO);
    }
   }
  }
 return RET_YES;
 }






 B aaStringHexDump                     (VP str,H sizet,H count,H cols,B dooffs,B doascii,VP buf,VP fmt,...)
 {
 BP bp;
 H todo,left,off;
 H bound;
 B txt[_16K];
 va_list argptr;
 B temp[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,temp);
 if(buf==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(count==0) { aaStringLen(buf,&count); }
 if(count>(_32K-32)) { oof; }
 aaCast(bp,BP,buf);
 off=0;
 left=count;
 if(aaStringIsNull(temp)==NO) { aaStringAppendf(str,"%s\r\n",temp); }
 aaStringNull(txt);
 while(1)
  {
  if(left==0) { break; }
  bound=aaNumRoof(left,cols);
  todo=aaNumRoof(left,bound);
  aaStringFromArrayHex(txt,sizet,todo,cols,NO,doascii,&bp[off]);
  aaStringLastCharNonVisibleRemove(txt,0);
  //aaStringAppendf(str,"                     ");
  if(dooffs)   {   aaStringAppendf(str,"%05u: ",off);   }
  else         {   }
  aaStringAppendf(str,"%s",txt);
  //BUG,"%s",txt);
  left-=todo;
  if(left!=0) { aaStringAppendf(str,"\r\n"); }
  if(sizet==0) { off+=(todo*1); }
  else         { off+=(todo*sizet); }
  }
 return RET_YES;
 }





 B aaStringSplit                       (VP str,H chars,H pos,B incsplit,VP str1,VP str2)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(str1==NULL&&str2==NULL)
  {
  aaCast(bp,BP,str);
  if(incsplit) {   bp[pos+1]=NULL_CHAR; }
  else         {    bp[pos]=NULL_CHAR; }
  return RET_YES;
  }
 if(str1)
  {
  if(incsplit) {  aaStringNCopy(str1,str,pos+1,YES); }
  else         {  aaStringNCopy(str1,str,pos,YES); }
  }
 if(str2)
  {
  aaCast(bp,BP,str);
  if(incsplit) { aaStringCopy(str2,&bp[pos]); }
  else         { aaStringCopy(str2,&bp[pos+1]);  }
  }
 return RET_YES;
 }



 B aaStringSplitChar                   (VP str,H chars,B ch,B incsplit,B logic,H number,B fwd,VP str1,VP str2)
 {
 B ret;
 H pos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if((ret=aaStringFindChar(str,chars,&pos,ch,logic,number,fwd))!=YES) { return ret;  }
 return(aaStringSplit(str,chars,pos,incsplit,str1,str2));
 }





 B aaStringExplode                     (VP str,H chars,_stringexplode*explode,B dch)
 {
 B ret;
 H i,count,off,pos,cando,mx;
 BP tmp=NULL_POINTR;
// B state;//,ch;
 B temp[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(explode==NULL) { return RET_BADPARM; }
 aaMemoryFill(explode,sizeof(_stringexplode),0);
 if(str==NULL) { return RET_BADPARM; }
 if(dch==0) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 mx=sizeof(explode->off)/sizeof(explode->off[0]);
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrExplode))!=RET_YES) { return ret; }
  }
 aaStringNCopy(tmp,str,chars,YES);
 aaStringRemoveSpaces(tmp,0,YES,YES);
 aaStringRemoveMultipleSpaces(tmp,0,NO);
 aaStringLen(tmp,&chars);
 aaStringCountChars(tmp,0,&count,dch,NO,YES);
 count++;
 count=aaNumRoof(count,mx);
 off=0;
 for(i=0;i<count;i++)
  {
  aaStringFindChar(&tmp[off],0,&pos,dch,YES,0,YES);
  explode->off[i]=off;
  if(pos==F32) { aaStringLen(&tmp[off],&pos); }
  cando=pos;
  explode->len[i]=cando;
  if(explode->len[i]>1&&tmp[off]=='-'&&(tmp[off+1]>='0'&&tmp[off+1]<='9'))
   {
   if(aaStringIsNumerical(&tmp[off+1],0,0,cando-1)==YES)
    {
    aaStringToNumber(&tmp[off+1],cando-1,&explode->value[explode->count],0,0,0);
    explode->type[explode->count]=2;
    }
   }
 else
  if(explode->len[i]>1&&tmp[off]=='+'&&(tmp[off+1]>='0'&&tmp[off+1]<='9'))
   {
   if(aaStringIsNumerical(&tmp[off+1],0,0,cando-1)==YES)
    {
    aaStringToNumber(&tmp[off+1],cando-1,&explode->value[explode->count],0,0,0);
    explode->type[explode->count]=1;
    }
   }
  else
  if(explode->type[explode->count]==0)
   {
   if(aaStringIsNumerical(&tmp[off],0,0,cando)==YES)
    {
    aaStringToNumber(&tmp[off],cando,&explode->value[explode->count],0,0,0);
    explode->type[explode->count]=1;
    }
   }
  explode->count++;
  if(pos==F32) { break; }
  off+=(pos);  aaStringFindChar(&tmp[off],0,&pos,dch,NO,0,YES);
  off+=(pos);  //aaStringRemoveSpaces(token->string[i],0,YES,YES);
  }
 explode->off[i]=off+1;
 return RET_YES;
 }






 B aaStringExplodeTokenGet             (VP str,H index,_stringexplode*explode,VP token)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(token==NULL) { return RET_BADPARM; }
 aaStringNull(token);
 if(explode==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(index>=explode->count) { return RET_BOUNDS; }
 aaCast(bp,BP,str);
 if((index+1)==explode->count)
  {
//  H sl;  aaStringLen(str,&sl);
//  aaNote(0,".. %i %i %i",explode->off[index],explode->len[index],sl);
  aaStringNCopy(token,&bp[explode->off[index]],explode->len[index]+1,YES); // added by ashod ??
  }
 else
  {
  aaStringNCopy(token,&bp[explode->off[index]],explode->len[index],YES);
  }
 return RET_YES;
 }






 B aaStringExplodePtrGet               (VP str,H index,_stringexplode*explode,PP token)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(token==NULL) { return RET_BADPARM; }
 *token=NULL;
 if(explode==NULL) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(index>=explode->count) { return RET_BOUNDS; }
 aaCast(bp,BP,str);
 *token=&bp[explode->off[index]];
 return RET_YES;
 }




 B aaStringEncode                      (VP str,H chars,VP ostr,B appendnull,VP ignorecharlist)
 {
 BP dp;
 BP sp;
 N lo,hi;
 H i,j,k;
 B ch=0;
 B ret;
 BP il;
 BP tmp=NULL_POINTR;
 H icl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrEncode))!=RET_YES) {oops; }
 if(ostr==NULL||ostr==str) { aaCast(dp,BP,tmp); }
 else                      { aaCast(dp,BP,ostr); }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { dp[0]=NULL_CHAR; return RET_YES; }
 aaStringLen(ignorecharlist,&icl);
 il=(BP)ignorecharlist;

 aaCast(sp,BP,str);
 j=0;
 for(i=0;i<chars;i++)
  {
  ch=sp[i];
  if(aaCharIsAlphaNum(ch)==YES||ch=='_')//||ch==FSLASH_CHAR)
   {
   dp[j]=ch; j++;
   continue;
   }
  for(k=0;k<icl;k++)
   {
   if(ch==il[k]) {  break;   }
   }
  if(k!=icl&&icl!=0)
   {
   dp[j]=ch; j++;
   continue;
   }
  dp[j]='%'; j++;
  hi=(ch/16);
  lo=(ch%16);
  if(hi<10) { hi='0'+hi; }
  else      { hi='A'+(hi-10); }
  if(lo<10) { lo='0'+lo; }
  else      { lo='A'+(lo-10); }
  dp[j]=(B)hi; j++;
  dp[j]=(B)lo; j++;
  if(ch==NULL_CHAR) { break; }
  }
 if(appendnull&&ch!=NULL_CHAR) { dp[j]=NULL_CHAR; j++; }
 if(dp==tmp)
  {
  if(ostr==NULL) { aaMemoryCopy(str,j,tmp); }
  else           { aaMemoryCopy(ostr,j,tmp); }
  }
 return RET_YES;
 }




 B aa_StringDecode                      (VP str,H chars,VP ostr,B appendnull)
 {
 B ret;
 BP dp;
 BP sp;
 BP tmp;
 N lo,hi;
 H i,j;
 B ch=0;
 B usingtemp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_StrDecode))!=RET_YES) {oops; }
 if(ostr==NULL||ostr==str) { aaCast(dp,BP,tmp); usingtemp=YES; }
 else                      { aaCast(dp,BP,ostr); usingtemp=NO; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { dp[0]=NULL_CHAR; return RET_YES; }
 aaCast(sp,BP,str);
 j=0;
 for(i=0;i<chars;i++)
  {
  ch=*sp;
  if(ch==0x25)
   {
   if(aaCharIsHex(sp[1])&&aaCharIsHex(sp[2]))
    {
    sp++;
    hi=sp[0];
    lo=sp[1];
    if('0'<=hi&&hi<='9') { hi-='0'; }    else
    if('a'<=hi&&hi<='f') { hi-=('a'-10); }    else
    if('A'<=hi&&hi<='F') { hi-=('A'-10); }
    if('0'<=lo&&lo<='9') { lo-='0'; }    else
    if('a'<=lo&&lo<='f') { lo-=('a'-10); }    else
    if('A'<=lo&&lo<='F') { lo-=('A'-10); }
    *dp=(B)(lo+(16*hi));
    dp++;
    sp+=2;
    j++;
    }
   else
    {
    *dp=ch;
    dp++;
    sp++;
    j++;
    }
   }
  else { *dp=ch; dp++; sp++;  j++; }
  if(ch==NULL_CHAR) { break; }
  }
 if(appendnull&&ch!=NULL_CHAR) { *dp=NULL_CHAR; j++; }
 if(usingtemp==YES)//dp==tmp)
  {
  if(ostr==NULL) { aaMemoryCopy(str,j,tmp); }
  else           { aaMemoryCopy(ostr,j,tmp); }
  }
 return RET_YES;
 }





 B aaStringDecode                      (VP str,H chars,VP ostr,B fully,B appendnull)
 {
 B ret;
// pos;
// N dif;
//.B prev_str[_64K];
 BP tmpa,tmpb;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 fully&=1;
 if((ret=aa_MemoryTemp((VP)&tmpa,_512K,aa_MEMORYTEMP_StringDecodeA))!=RET_YES) {oops; }
 if((ret=aa_MemoryTemp((VP)&tmpb,_512K,aa_MEMORYTEMP_StringDecodeB))!=RET_YES) {oops; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0)
  {
  if(appendnull)
   {
   if(ostr!=NULL)  {    bp=(BP)ostr;    bp[0]=NULL_CHAR;    }
   }
  return RET_YES;
  }
 aaStringNCopy(tmpa,str,chars,YES);

 //if(fully) { aaStringCopy(prev_str,str); }
 while(1)
  {
  if((ret=aa_StringDecode(tmpa,chars,tmpb,appendnull))!=RET_YES) { return ret; }
  if(fully!=YES) { break; }
  if(aaStringCompare(tmpa,tmpb,0)==YES) { break; }

  aaStringCopy(tmpa,tmpb);
  }
 if(ostr) { aaStringCopy(ostr,tmpb); }
 else     { aaStringCopy(str,tmpa); }
 return RET_YES;
 }


/*
static const htmlentity_t ent[] =
{
	{ "lt",     "<" },	{ "gt",     ">" },	{ "amp",    "&" },	{ "apos",   "'" },
	{ "quot",   "\"" },	{ "aacute", "" },	{ "eacute", "" },	{ "iacute", "" },
	{ "oacute", "" },	{ "uacute", "" },	{ "agrave", "" },	{ "egrave", "" },
	{ "igrave", "" },	{ "ograve", "" },	{ "ugrave", "" },	{ "acirc",  "" },
	{ "ecirc",  "" },	{ "icirc",  "" },	{ "ocirc",  "" },	{ "ucirc",  "" },
	{ "auml",   "" },	{ "euml",   "" },	{ "iuml",   "" },	{ "ouml",   "" },
	{ "uuml",   "" },	{ "nbsp",   " " },	{ "",        ""  }
};

*/


 B aaStringEntityToPseudoEnglish       (VP str,H chars,VP ostr)
 {
 BP s,d;
 H val,num,i;
 B ok,ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(s,BP,str);
 if(ostr) { aaCast(d,BP,ostr); }
 else       { aaCast(d,BP,str);  }
 while(1)
  {
  if(*s==NULL_CHAR)   {   *d=NULL_CHAR;   break;   }
  while(1)
   {
   ok=YES;
   if(chars==0) { break; }
   if(s[0]!='&'||s[1]!='#'||s[2]!='x') { break; }
   if(chars<2) { break; }
   aaStringCountHex(&s[3],chars,&val,YES);
   if(val==0)  {  break; }
   if(s[3+val]!=';') { break; }
   aaStringHexToNumber(&s[3],val,&num,0,NULL,NULL);
     switch(num)
      {
      default:  //BUG,"ato=%x %u **************** %s",ato,ato,txt);
      ascii=2; break; //was STX

      case 1489:   case 1500:   case 1496:   case 1512:   case 1493:    case 1497:     case 1505:      case 1507: ascii=''; break;

      case 37041: case 20896:   case 23431: ascii='i'; break;
      case 65533: ascii='i'; break;
      //
      case 216: ascii='O'; break;
      case 222: ascii='D'; break;
      case 322: ascii='l'; break;
      case 324: ascii='n'; break;
      case 351: ascii='s'; break;
      case 382: ascii='z'; break;
      case 231: ascii='c'; break;
      case 241: ascii='n'; break;
      case 248: ascii='o'; break;
      case 250: ascii='u'; break;
      case 263: ascii='c'; break;
      ///
      case 224: case 225:      case 226:      case 227:  case 228:   case 229: ascii='a'; break;
      case 192: case 193:      case 194:      case 195:  case 196: ascii='A'; break;
      ///
      case 232: case 233:      case 234:      case 235:  ascii='e'; break;
      case 200: case 201:      case 202:      case 203:  ascii='E'; break;
      ////
      case 236: case 237:      case 238:      case 239:  ascii='i'; break;
      case 204: case 205:      case 206:      case 207:  ascii='I'; break;
      ///
      case 242: case 243:      case 244:      case 245:  case 246: ascii='o'; break;
      case 210: case 211:      case 212:      case 213:  case 214: ascii='O'; break;
      ///
      case 249: case 253:      case 251:      case 252: ascii='u'; break;
      case 217: case 221:      case 219:      case 220: ascii='O'; break;
      ///
      case 255: ascii='y'; break;
      case 159: ascii='Y'; break;
      }
   *d=ascii;
   s+=(3+val+1);
   chars-=(3+val+1);
   d++;
   ok=NO;
   break;
   }
  if(ok==YES) { for(i=0;i<1;i++) { *d=*s; s++; d++; chars--; } continue; }
  }
 return RET_YES;
 }



 B aaStringLineCountGet                (VP str,H chars,HP lines)
 {
 H ln,mode,j;
 B cch,nch;
 _parser pa;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lines) { *lines=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaParserInit(&pa,str,chars);
 ln=0;
 for(;;)
  {
  j=mode=0;
  do
   {
   if((pa.offset+j)>=pa.length) { break; }
   cch=pa.bp[j];
   if(cch<=CR_CHAR)
    {
    if(cch==NULL_CHAR) { mode=0; break; }
    if(cch==CR_CHAR||cch==LF_CHAR)
     {
     nch=pa.bp[j+1];
     mode=2;
     if(cch==CR_CHAR&&nch==LF_CHAR) {   break; }
     if(cch==LF_CHAR&&nch==CR_CHAR) {   break; }
     mode=1;
     break;
     }
    }
   j++;
   }
  while(1);
  if(mode==0) {  break; }
  ln++;
  aaParserSeek(&pa,j+mode);
  }
 if(lines) { *lines=ln; }
 return RET_YES;
 }









 B aaStringLineCountGetToMemory        (VP str,H chars,HP lines,H maxinfolines,PP lineoff,PP linechars)
 {
 B ret;
 H ln,mode,j;
 B cch,nch;
 _parser pa;
 H add,slots,left;//,as;
 HP lnof,lnch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lines) { *lines=0; }
 if(lineoff) { *lineoff=0; }
 if(linechars) { *linechars=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaParserInit(&pa,str,chars);
 add=_4K;
 slots=0;
 lnof=lnch=NULL;
 if(lineoff)    {  if((ret=aaMemoryAllocate((VP)&lnof,(slots+add)*sizeof(H)))!=YES) { oops; }  }
 if(linechars)  {  if((ret=aaMemoryAllocate((VP)&lnch,(slots+add)*sizeof(H)))!=YES) { oops; }  }
 aaMemoryNameSet(lnof,"lnof");
 aaMemoryNameSet(lnch,"lnch");
 slots+=add;
 ln=0;
// as=0;
 for(;;)
  {
  j=mode=0;
  do
   {
   if((pa.offset+j)>=pa.length) { break; }
   cch=pa.bp[j];
   if(cch<=CR_CHAR)
    {
    if(cch==NULL_CHAR) {  mode=0; break; }
    if(cch==CR_CHAR||cch==LF_CHAR)
     {
     nch=pa.bp[j+1];
     mode=2;
     if(cch==CR_CHAR&&nch==LF_CHAR) {   break; }
     if(cch==LF_CHAR&&nch==CR_CHAR) {   break; }
     mode=1;
     break;
     }
    }
   j++;
   }
  while(1);
  if(mode==0) {  break; }
  left=slots-ln;
 if(ln<maxinfolines)
  {
  if(lineoff||linechars)
   {
   if(left<(add/10))
    {
//    as++;
    if(lineoff)     {     if((ret=aaMemoryReAllocate((VP)&lnof,(slots+(add))*sizeof(H)))!=YES) { oops; }     }
    if(linechars)   {     if((ret=aaMemoryReAllocate((VP)&lnch,(slots+(add))*sizeof(H)))!=YES) { oops; }     }
    slots+=(add);
    }
   if(lineoff) { lnof[ln]=pa.offset; } //hp=(HP)&lineoff[ln]; *hp=pa.offset; }
   if(linechars) { lnch[ln]=j; } //hp=(HP)&linechars[ln]; *hp=j; }
   }
  }
  ln++;
  aaParserSeek(&pa,j+mode);
  }
 if(lines) { *lines=ln; }
 if(ln!=0)
  {
  if(lineoff) { *lineoff=lnof; }
  if(linechars) { *linechars=lnch; }
  }
//  BUG,"as=%i",as);
 return RET_YES;
 }









 B aaStringLineCountGetToBuffer        (VP str,H chars,HP lines,H maxinfolines,HP lineoff,HP linechars)
 {
 _parser pa;
 H mode,j,l;
 B cch,nch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lines) { *lines=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaParserInit(&pa,str,chars);
 l=0;
 for(;;)
  {
  j=mode=0;
  do
   {
   if((pa.offset+j)>=pa.length) { break; }
   cch=pa.bp[j];
   if(cch<=CR_CHAR)
    {
    if(cch==NULL_CHAR) {  mode=0; break; }
    if(cch==CR_CHAR||cch==LF_CHAR)
     {
     nch=pa.bp[j+1];
     mode=2;
     if(cch==CR_CHAR&&nch==LF_CHAR) {   break; }
     if(cch==LF_CHAR&&nch==CR_CHAR) {   break; }
     mode=1;
     break;
     }
    }
   j++;
   }
  while(1);
  if(mode==0) {  break; }
  if(l<maxinfolines)
   {
   if(lineoff) { lineoff[l]=pa.offset; }
   if(linechars) { linechars[l]=j; }
   }
  // o[l]=pa.offset; c[l]=j;
  l++;
  aaParserSeek(&pa,j+mode);
  }
 if(lines) { *lines=l; }
 return RET_YES;
 }






 B aaStringLineGet                     (VP str,H chars,HP strchars,HP modechars,HP totchars,BP mode)
 {
 //B ret;
 B m;
 H mc,i;
 H pos;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(modechars) { *modechars=0; }
 if(strchars) { *strchars=0; }
 if(totchars) { *totchars=0; }
 if(mode) { *mode=0; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 bp=(BP)str;
 for(i=0;i<chars;i++)
  {
  if(bp[i]==CR_CHAR||bp[i]==LF_CHAR) { break; }
  }
 if(i==chars)
  {
  if(mode) { *mode=aa_STRINGMODE_NULL; }
  if(strchars) { *strchars=chars;  }
  if(totchars) { *totchars=chars;  }
  if(modechars) { *modechars=0; }
  return RET_YES;
  }
 pos=i;

  #if 0
 if((ret=aaStringFindCharList(str,chars,&pos,"\r\n",YES,0,YES))!=YES)
  {
  if(mode) { *mode=aa_STRINGMODE_NULL; }
  if(strchars) { *strchars=chars;  }
  if(totchars) { *totchars=chars;  }
  if(modechars) { *modechars=0; }
  return RET_YES;
  }
  #endif
 bp=(BP)str;
 m=0;
 mc=0;
 if(bp[pos+0]==CR_CHAR&&bp[pos+1]==LF_CHAR) { m=aa_STRINGMODE_CRLF; }  else
 if(bp[pos+0]==LF_CHAR&&bp[pos+1]==CR_CHAR) { m=aa_STRINGMODE_LFCR; }  else
 if(bp[pos+0]==CR_CHAR)                     { m=aa_STRINGMODE_CR;   }  else
 if(bp[pos+0]==LF_CHAR)                     { m=aa_STRINGMODE_LF;   }
 if(m==aa_STRINGMODE_LFCR||m==aa_STRINGMODE_CRLF) { mc=2; }  else
 if(m==aa_STRINGMODE_CR||m==aa_STRINGMODE_LF)     { mc=1; }
 if(m!=0&&mc!=0)
  {
  if(strchars) { *strchars=pos; }
  if(totchars) { *totchars=pos+mc; }
  }
 if(mode) { *mode=m; }
 if(modechars) { *modechars=mc; }
 return RET_YES;
 }


#if 0

 B aaStringLineGet                     (VP str,H chars,HP strchars,HP modechars,HP totchars,BP mode)
 {
 _parser pa;
 B m;
 H mc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(modechars) { *modechars=0; }
 if(strchars) { *strchars=0; }
 if(totchars) { *totchars=0; }
 if(mode) { *mode=0; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaParserInit(&pa,str,chars);
 m=0;
 while(1)
  {
  if(pa.is_end) { break; }
  if(pa.ch==CR_CHAR&&pa.bp[1]==LF_CHAR) { m=aa_STRINGMODE_CRLF; break; }
  if(pa.ch==CR_CHAR) { m=aa_STRINGMODE_CR; break; }
  if(pa.ch==LF_CHAR) { m=aa_STRINGMODE_LF; break; }
  aaParserSeek(&pa,1);
  }
 if(mode) { *mode=m; }
 if(strchars) {  *strchars=pa.offset; }
 mc=0;
 if(modechars||totchars)
  {
  if(m==aa_STRINGMODE_CRLF) { mc=2; } else
  if(m==aa_STRINGMODE_CR) { mc=1; } else
  if(m==aa_STRINGMODE_LF) { mc=1; }
  if(modechars) { *modechars=mc; }
  if(totchars) { *totchars=pa.offset+mc; }
  }
 return RET_YES;
 }

#endif


 B aaStringMatchCount                  (VP str,H chars,VP fstr,H fchars,B iscasesensitive,HP count,B logic)
 {
 BP s,d;
 H c;
 B sch,dch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0)  { aaStringLen(str,&chars); }
 if(fstr==NULL) { return RET_BADPARM; }
 if(fchars==0)  {  aaStringLen(fstr,&fchars); }
// if(fchars==0)   {  if(*pos==F32) { return RET_NO; } return RET_YES; }
// if(fchars>chars) {  if(*pos==F32) { return RET_NO; } return RET_YES; }
 aaCast(s,BP,str);
 aaCast(d,BP,fstr);
 c=0;
// p=F32;
 while(1)
  {
  if(c>=chars) { break; }
  if(c>=fchars) { break; }
  sch=s[c];
  dch=d[c];
//  BUG,"%c %c",sch,dch);
  if(iscasesensitive==NO)
   {
   if(sch>='A'&&sch<='Z') { sch+=(B)32; }
   if(dch>='A'&&dch<='Z') { dch+=(B)32; }
   }
  if((sch!=dch&&logic==YES)||(sch==dch&&logic==NO))   {   break;   }
  c++;
  }
 *count=c;
 return RET_YES;
 }


 B aaStringLengthModeAdjust            (B mode,H chars,B addflag,HP adjustedchars)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(adjustedchars==NULL) { return RET_BADPARM; }
 *adjustedchars=chars;
 if(addflag)
  {
  if(mode==aa_STRINGMODE_CR||mode==aa_STRINGMODE_LF) { chars=chars+1; }
  else
  if(mode==aa_STRINGMODE_CRLF||mode==aa_STRINGMODE_LFCR) { chars=chars+2; }
  else
  if(mode==aa_STRINGMODE_NULL) { chars=chars+0;  }
  else { return RET_FAILED; }
  }
 else
  {
  if(mode==aa_STRINGMODE_CR||mode==aa_STRINGMODE_LF) { chars=chars-1; }
  else
  if(mode==aa_STRINGMODE_CRLF||mode==aa_STRINGMODE_LFCR) { chars=chars-2; }
  else
  if(mode==aa_STRINGMODE_NULL) { chars=chars-0;  }
  else { return RET_FAILED; }
  }
 *adjustedchars=chars;
 return RET_YES;
 }



 B aaStringToker                       (VP str,H chars,_stringtoker*toker,B dohash,B dobuf)
 {
 _parser pa,pb;
 B ascii;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(toker==NULL) { return RET_BADPARM; }
 toker->count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTREADY; }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  if(pa.is_end) { break; }
  if(toker->count>=32) { break; }
  if(aaParserSeekToVisibleChar(&pa,YES)!=YES) { break; }
  aaParserCopy(&pb,&pa,NO);
  ascii=pa.ch;
  if(ascii==QUOTE_CHAR||ascii==DQUOTE_CHAR)
   {
   aaParserSeek(&pb,1);
   aaParserSeekToChar(&pb,ascii,YES,YES);
   aaParserSeek(&pb,1);
   }
  else
   {
   for(i=0;i<pb.to_end;i++)
    {
    if(aaCharIsVisible(pb.bp[i])==NO) { break; }
    ascii=pa.bp[i];
    if(ascii==QUOTE_CHAR||ascii==DQUOTE_CHAR)     {     break;     }
    }
   aaParserSeek(&pb,i);
   }
  toker->sl[toker->count]=pb.offset-pa.offset;
  if(toker->sl[toker->count]==0||toker->sl[toker->count]>=_1K) { return RET_CORRUPTED; }
  toker->off[toker->count]=pa.offset;
  toker->ptr[toker->count]=(BP)pa.bp;
  if(dobuf) { aaStringNCopy(toker->buf[toker->count],pa.bp,toker->sl[toker->count],YES); }
  toker->hashs[toker->count]=toker->hashi[toker->count]=0;
  if(aaBitGet(dohash,0)) { aaStringHashGet(toker->buf[toker->count],toker->sl[toker->count],&toker->hashs[toker->count],YES); }
  if(aaBitGet(dohash,1)) { aaStringHashGet(toker->buf[toker->count],toker->sl[toker->count],&toker->hashi[toker->count],NO); }
  toker->count++;
  aaParserCopy(&pa,&pb,NO);
  }
 if(toker->count==0) { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaStringTokerMini                   (VP str,H chars,_stringtokermini*tokermini)
 {
 _parser pa,pb;
 B ascii;
 H i;
 B buf[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tokermini==NULL) { return RET_BADPARM; }
 tokermini->count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTREADY; }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  if(pa.is_end) { break; }
  if(tokermini->count>=64) { break; }
  if(aaParserSeekToVisibleChar(&pa,YES)!=YES) { break; }
  aaParserCopy(&pb,&pa,NO);
  ascii=pa.ch;
  if(ascii==QUOTE_CHAR||ascii==DQUOTE_CHAR)
   {
   aaParserSeek(&pb,1);
   aaParserSeekToChar(&pb,ascii,YES,YES);
   aaParserSeek(&pb,1);
   }
  else
   {
   for(i=0;i<pb.to_end;i++)
    {
    if(aaCharIsVisible(pb.bp[i])==NO) { break; }
    ascii=pa.bp[i];
    if(ascii==QUOTE_CHAR||ascii==DQUOTE_CHAR)     {     break;     }
    }
   aaParserSeek(&pb,i);
   }
  tokermini->sl[tokermini->count]=pb.offset-pa.offset;
  if(tokermini->sl[tokermini->count]==0||tokermini->sl[tokermini->count]>=_1K) { return RET_CORRUPTED; }
  tokermini->off[tokermini->count]=pa.offset;
  tokermini->ptr[tokermini->count]=(BP)pa.bp;
  tokermini->hashs[tokermini->count]=tokermini->hashi[tokermini->count]=0;
  aaStringNCopy(buf,pa.bp,tokermini->sl[tokermini->count],YES);
  aaStringHashGet(buf,tokermini->sl[tokermini->count],&tokermini->hashs[tokermini->count],YES);
  aaStringHashGet(buf,tokermini->sl[tokermini->count],&tokermini->hashi[tokermini->count],NO);
  tokermini->count++;
  aaParserCopy(&pa,&pb,NO);
  }
 if(tokermini->count==0) { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaStringTokerMiniStringGet          (VP str,H index,H maxchars,_stringtokermini*tokermini)
 {
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(index>=aaElementCount(tokermini->ptr)) { return RET_BOUNDS; }
 if(tokermini==NULL) { return RET_BADPARM; }
 if(index>=tokermini->count) { return RET_BOUNDS; }
 todo=tokermini->sl[index];
 todo=aaNumRoof(todo,maxchars-1);
 if(todo==0) { return RET_YES; }
 aaStringNCopy(str,tokermini->ptr[index],todo,YES);
 return RET_YES;
 }


 B aaStringTokerMaxiStringGet          (VP str,H index,H maxchars,_stringtokermaxi*tokermaxi)
 {
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(index>=aaElementCount(tokermaxi->ptr)) { return RET_BOUNDS; }
 if(tokermaxi==NULL) { return RET_BADPARM; }
 if(index>=tokermaxi->count) { return RET_BOUNDS; }
 todo=tokermaxi->sl[index];
 todo=aaNumRoof(todo,maxchars-1);
 if(todo==0) { return RET_YES; }
 aaStringNCopy(str,tokermaxi->ptr[index],todo,YES);
 return RET_YES;
 }





 B aaStringTokerMaxi                   (VP str,H chars,_stringtokermaxi*tokermaxi)
 {
 _parser pa,pb;
 B ascii;
 H i;
 B buf[_64K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tokermaxi==NULL) { return RET_BADPARM; }
 tokermaxi->count=0;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTREADY; }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  if(pa.is_end) { break; }
  if(tokermaxi->count>=256) { break; }
  if(aaParserSeekToVisibleChar(&pa,YES)!=YES) { break; }
  aaParserCopy(&pb,&pa,NO);
  ascii=pa.ch;
  if(ascii==QUOTE_CHAR||ascii==DQUOTE_CHAR)
   {
   aaParserSeek(&pb,1);
   aaParserSeekToChar(&pb,ascii,YES,YES);
   aaParserSeek(&pb,1);
   }
  else
   {
   for(i=0;i<pb.to_end;i++)
    {
    if(aaCharIsVisible(pb.bp[i])==NO) { break; }
    ascii=pa.bp[i];
    if(ascii==QUOTE_CHAR||ascii==DQUOTE_CHAR)     {     break;     }
    }
   aaParserSeek(&pb,i);
   }
  tokermaxi->sl[tokermaxi->count]=pb.offset-pa.offset;
  if(tokermaxi->sl[tokermaxi->count]==0||tokermaxi->sl[tokermaxi->count]>=_1K) { return RET_CORRUPTED; }
  tokermaxi->off[tokermaxi->count]=pa.offset;
  tokermaxi->ptr[tokermaxi->count]=(BP)pa.bp;
  tokermaxi->hashs[tokermaxi->count]=tokermaxi->hashi[tokermaxi->count]=0;
  aaStringNCopy(buf,pa.bp,tokermaxi->sl[tokermaxi->count],YES);
  aaStringHashGet(buf,tokermaxi->sl[tokermaxi->count],&tokermaxi->hashs[tokermaxi->count],YES);
  aaStringHashGet(buf,tokermaxi->sl[tokermaxi->count],&tokermaxi->hashi[tokermaxi->count],NO);
  tokermaxi->count++;
  aaParserCopy(&pa,&pb,NO);
  }
 if(tokermaxi->count==0) { return RET_NOTREADY; }
 return RET_YES;

 }



 B aaStringUnicodeToClosestEnglish     (VP str,H chars,VP ostr)
 {
 B output[_64K];
 H off,wro,hex,changes,unknowns,j;
 BP sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(output);
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { if(ostr) aaStringNull(ostr); return RET_YES; }
 sp=(BP)str;
 off=wro=changes=unknowns=0;
 while(1)
  {
  if((chars-off)<6) { for(j=off;j<chars;j++) { output[wro]=sp[j]; wro++;  }  off=j;   }
  if(off>=chars)    { break; }
  if(sp[off]!=BSLASH_CHAR) { output[wro]=sp[off]; wro++; off++; continue; }
  if(sp[off+1]!='u')       { output[wro]=sp[off]; wro++; off++; continue; }
  hex=0;

  if(sp[off+2]>='0'&&sp[off+2]<='9') { hex+=(sp[off+2]-'0')*4096;      }   else
  if(sp[off+2]>='a'&&sp[off+2]<='f') { hex+=((sp[off+2]-'a')+10)*4096; }   else
  if(sp[off+2]>='A'&&sp[off+2]<='F') { hex+=((sp[off+2]-'A')+10)*4096; }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }

  if(sp[off+3]>='0'&&sp[off+3]<='9') { hex+=(sp[off+3]-'0')*256;      }   else
  if(sp[off+3]>='a'&&sp[off+3]<='f') { hex+=((sp[off+3]-'a')+10)*256; }   else
  if(sp[off+3]>='A'&&sp[off+3]<='F') { hex+=((sp[off+3]-'A')+10)*256; }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }

  if(sp[off+4]>='0'&&sp[off+4]<='9') { hex+=(sp[off+4]-'0')*16;      }   else
  if(sp[off+4]>='a'&&sp[off+4]<='f') { hex+=((sp[off+4]-'a')+10)*16; }   else
  if(sp[off+4]>='A'&&sp[off+4]<='F') { hex+=((sp[off+4]-'A')+10)*16; }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }

  if(sp[off+5]>='0'&&sp[off+5]<='9') { hex+=(sp[off+5]-'0');        }   else
  if(sp[off+5]>='a'&&sp[off+5]<='f') { hex+=((sp[off+5]-'a')+10);   }   else
  if(sp[off+5]>='A'&&sp[off+5]<='F') { hex+=((sp[off+5]-'A')+10);   }   else
                                     { output[wro]=sp[off]; wro++; off++; continue; }

//  if(hex<=0x7f)                      { output[wro++]=(B)hex; changes++; off+=6; continue; }

  if(hex>=0x391&&hex<=0x03dc)
   {
   if(hex>=0x0391&&hex<=0x0391)                 { output[wro++]='A'; changes++; off+=6; continue; } // greek
   if(hex>=0x0392&&hex<=0x0392)                 { output[wro++]='B'; changes++; off+=6; continue; } // greek
   if(hex>=0x0395&&hex<=0x0395)                 { output[wro++]='E'; changes++; off+=6; continue; } // greek
   if(hex>=0x0397&&hex<=0x0397)                 { output[wro++]='H'; changes++; off+=6; continue; } // greek
   if(hex>=0x0399&&hex<=0x0399)                 { output[wro++]='I'; changes++; off+=6; continue; } // greek
   if(hex>=0x039a&&hex<=0x039a)                 { output[wro++]='K'; changes++; off+=6; continue; } // greek
   if(hex>=0x039c&&hex<=0x039c)                 { output[wro++]='M'; changes++; off+=6; continue; } // greek
   if(hex>=0x039d&&hex<=0x039d)                 { output[wro++]='N'; changes++; off+=6; continue; } // greek
   if(hex>=0x039F&&hex<=0x039F)                 { output[wro++]='O'; changes++; off+=6; continue; } // greek
   if(hex>=0x03a1&&hex<=0x03a1)                 { output[wro++]='P'; changes++; off+=6; continue; } // greek
   if(hex>=0x03a3&&hex<=0x03a3)                 { output[wro++]='E'; changes++; off+=6; continue; } // greek
   if(hex>=0x03a4&&hex<=0x03a4)                 { output[wro++]='T'; changes++; off+=6; continue; } // greek
   if(hex>=0x03a5&&hex<=0x03a5)                 { output[wro++]='Y'; changes++; off+=6; continue; } // greek
   if(hex>=0x03d2&&hex<=0x03d2)                 { output[wro++]='Y'; changes++; off+=6; continue; } // greek
   if(hex>=0x03a7&&hex<=0x03a7)                 { output[wro++]='X'; changes++; off+=6; continue; } // greek
   if(hex>=0x03ad&&hex<=0x03ad)                 { output[wro++]='e'; changes++; off+=6; continue; } // greek
   if(hex>=0x03af&&hex<=0x03af)                 { output[wro++]='c'; changes++; off+=6; continue; } // greek
   if(hex>=0x03b1&&hex<=0x03b1)                 { output[wro++]='a'; changes++; off+=6; continue; } // greek
   if(hex>=0x03b2&&hex<=0x03b2)                 { output[wro++]='b'; changes++; off+=6; continue; } // greek
   if(hex>=0x03b5&&hex<=0x03b5)                 { output[wro++]='e'; changes++; off+=6; continue; } // greek
   if(hex>=0x03b8&&hex<=0x03b8)                 { output[wro++]='o'; changes++; off+=6; continue; } // greek
   if(hex>=0x03b9&&hex<=0x03b9)                 { output[wro++]='i'; changes++; off+=6; continue; } // greek
   if(hex>=0x03ba&&hex<=0x03ba)                 { output[wro++]='k'; changes++; off+=6; continue; } // greek
   if(hex>=0x03bc&&hex<=0x03bc)                 { output[wro++]='u'; changes++; off+=6; continue; } // greek
   if(hex>=0x03bd&&hex<=0x03bd)                 { output[wro++]='v'; changes++; off+=6; continue; } // greek
   if(hex>=0x03bf&&hex<=0x03bf)                 { output[wro++]='o'; changes++; off+=6; continue; } // greek
   if(hex>=0x03c0&&hex<=0x03c0)                 { output[wro++]='n'; changes++; off+=6; continue; } // greek
   if(hex>=0x03c1&&hex<=0x03c1)                 { output[wro++]='p'; changes++; off+=6; continue; } // greek
   if(hex>=0x03c2&&hex<=0x03c2)                 { output[wro++]='c'; changes++; off+=6; continue; } // greek
   if(hex>=0x03c3&&hex<=0x03c3)                 { output[wro++]='o'; changes++; off+=6; continue; } // greek
   if(hex>=0x03c4&&hex<=0x03c4)                 { output[wro++]='t'; changes++; off+=6; continue; } // greek
   if(hex>=0x03c7&&hex<=0x03c7)                 { output[wro++]='x'; changes++; off+=6; continue; } // greek
   if(hex>=0x03c9&&hex<=0x03c9)                 { output[wro++]='w'; changes++; off+=6; continue; } // greek
   if(hex>=0x03cc&&hex<=0x03cc)                 { output[wro++]='o'; changes++; off+=6; continue; } // greek
   if(hex>=0x03cd&&hex<=0x03cd)                 { output[wro++]='v'; changes++; off+=6; continue; } // greek
   ///BUG,"greek.hex=%04x",hex);
   ///BUG,"if(hex>=0x%04x&&hex<=0x%04x)                 { output[wro++]='x'; changes++; off+=6; continue; } // greek",hex,hex);
   }

  if(hex>=0x0061&&hex<=0x02af)
   {
   if(hex>=0x00bf&&hex<=0x00bf)                 { output[wro++]='?'; changes++; off+=6; continue; }
   if(hex>=0x00e0&&hex<=0x00e5)                 { output[wro++]='a'; changes++; off+=6; continue; }
   if(hex>=0x00e8&&hex<=0x00eb)                 { output[wro++]='e'; changes++; off+=6; continue; }
   if(hex>=0x00ec&&hex<=0x00ef)                 { output[wro++]='i'; changes++; off+=6; continue; }
   if(hex>=0x00f2&&hex<=0x00f8)                 { output[wro++]='o'; changes++; off+=6; continue; }
   if(hex>=0x00f9&&hex<=0x00fc)                 { output[wro++]='u'; changes++; off+=6; continue; }
   if(hex==0x0101||hex==0x0103||hex==0x0105)    { output[wro++]='a'; changes++; off+=6; continue; }
   if(hex>=0x015b&&hex<=0x0161)                 { output[wro++]='s'; changes++; off+=6; continue; }

   ////BUG,"if(hex>=0x%04x&&hex<=0x%04x)                 { output[wro++]='x'; changes++; off+=6; continue; } // other",hex,hex);
   }




  if(hex>=0x00c0&&hex<=0x00c6)                 { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x0100||hex==0x0102||hex==0x0104)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x0410||hex==0x04d0||hex==0x04d2)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x01cd||hex==0x01de||hex==0x0200)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex==0x0202||hex==0x0226||hex==0x023a)    { output[wro++]='A'; changes++; off+=6; continue; }
  if(hex>=0xC380&&hex<=0xc385)                 { output[wro++]='A'; changes++; off+=6; continue; }




  if(hex>=0x00E0&&hex<=0x00E6)                 { output[wro++]='a'; changes++; off+=6; continue; }
  if(hex==0x0101||hex==0x0104||hex==0x0105)    { output[wro++]='a'; changes++; off+=6; continue; }
  if(hex==0x00aa)                              { output[wro++]='a'; changes++; off+=6; continue; }

  if(hex>=0x00d2&&hex<=0x00d8)                 { output[wro++]='O'; changes++; off+=6; continue; }
  if(hex==0x014c||hex==0x014e||hex==0x0150)    { output[wro++]='O'; changes++; off+=6; continue; }
  if(hex>=0xc392&&hex<=0xc396)                 { output[wro++]='O'; changes++; off+=6; continue; }
  if(hex>=0x00f2&&hex<=0x00f6)                 { output[wro++]='o'; changes++; off+=6; continue; }
  if(hex==0x00f8||hex==0x014d||hex==0x014f)    { output[wro++]='o'; changes++; off+=6; continue; }
  if(hex==0x0151)                              { output[wro++]='o'; changes++; off+=6; continue; }
  if(hex>=0xc3b2&&hex<=0xc3b6)                 { output[wro++]='o'; changes++; off+=6; continue; }

  if(hex>=0x00c8&&hex<=0x00cb)                 { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex==0x0112||hex==0x0114||hex==0x0116)    { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex==0x0118||hex==0x011a||hex==0x04ec)    { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex>=0xC388&&hex<=0xc38b)                 { output[wro++]='E'; changes++; off+=6; continue; }
  if(hex>=0xC3a8&&hex<=0xc3ab)                 { output[wro++]='e'; changes++; off+=6; continue; }
  if(hex>=0x00e8&&hex<=0x00eb)                 { output[wro++]='e'; changes++; off+=6; continue; }
  if(hex==0x0113||hex==0x0115||hex==0x0117)    { output[wro++]='e'; changes++; off+=6; continue; }
  if(hex==0x0119||hex==0x011b||hex==0x04ed)    { output[wro++]='e'; changes++; off+=6; continue; }

  if(hex==0x00c7||hex==0x0106||hex==0x0108)    { output[wro++]='C'; changes++; off+=6; continue; }
  if(hex==0x010a||hex==0x010c)                 { output[wro++]='C'; changes++; off+=6; continue; }
  if(hex==0x00E7||hex==0x0107||hex==0x0109)    { output[wro++]='c'; changes++; off+=6; continue; }
  if(hex==0x010b||hex==0x010d)                 { output[wro++]='c'; changes++; off+=6; continue; }

  if(hex>=0x00cc&&hex<=0x00cf)                 { output[wro++]='I'; changes++; off+=6; continue; }
  if(hex==0x0128||hex==0x012a||hex==0x012c)    { output[wro++]='I'; changes++; off+=6; continue; }
  if(hex==0x012e||hex==0x0130)                 { output[wro++]='I'; changes++; off+=6; continue; }
  if(hex>=0x00ec&&hex<=0x00ef)                 { output[wro++]='i'; changes++; off+=6; continue; }
  if(hex==0x0129||hex==0x012b||hex==0x012d)    { output[wro++]='i'; changes++; off+=6; continue; }
  if(hex==0x012f||hex==0x0131)                 { output[wro++]='i'; changes++; off+=6; continue; }

  if(hex>=0x00d9&&hex<=0x00dc)                 { output[wro++]='U'; changes++; off+=6; continue; }
  if(hex==0x0168||hex==0x016a||hex==0x016c)    { output[wro++]='U'; changes++; off+=6; continue; }
  if(hex==0x016e||hex==0x0170||hex==0x0172)    { output[wro++]='U'; changes++; off+=6; continue; }

  if(hex>=0x00f9&&hex<=0x00fc)                 { output[wro++]='u'; changes++; off+=6; continue; }
  if(hex==0x0169||hex==0x016b||hex==0x016d)    { output[wro++]='u'; changes++; off+=6; continue; }
  if(hex==0x016f||hex==0x0171||hex==0x0173)    { output[wro++]='u'; changes++; off+=6; continue; }

  if(hex>=0x2010&&hex<=0x2015)                 { output[wro++]='-'; changes++; off+=6; continue; }
  if(hex>=0x2018&&hex<=0x201b)                 { output[wro++]=QUOTE_CHAR; changes++; off+=6; continue; }
  if(hex>=0x201c&&hex<=0x201f)                 { output[wro++]=DQUOTE_CHAR; changes++; off+=6; continue; }

  if(1) /// add parm, B allowexpand
   {
   if(hex==0x00a2) {  output[wro++]='c';  output[wro++]='e'; output[wro++]='n'; output[wro++]='t'; output[wro++]='s'; changes++;  off+=6;  continue;  }
   if(hex==0x00a9) {  output[wro++]='(';  output[wro++]='c'; output[wro++]=')'; changes++;  off+=6;  continue;  }
   if(hex==0x20ac) {  output[wro++]='(';  output[wro++]='$'; output[wro++]='e'; output[wro++]=')';  changes++;  off+=6;  continue;  }
   if(hex==0x2122) {  output[wro++]='(';  output[wro++]='t'; output[wro++]='m'; output[wro++]=')';  changes++;  off+=6;  continue; }
   break;
   }

  if(hex>=0x009d&&hex<=0xff)      //                        { changes++; off+=6; continue; } // operating system char
   {
   if(hex>=0x00a0)                              { output[wro++]=' '; changes++; off+=6; continue; }
   if(hex>=0x00a1)                              { output[wro++]='!'; changes++; off+=6; continue; }
   if(hex>=0x00a6)                              { output[wro++]='|'; changes++; off+=6; continue; }
   if(hex>=0x00ad)                              { output[wro++]='-'; changes++; off+=6; continue; }
   if(hex>=0x00b4)                              { output[wro++]='`'; changes++; off+=6; continue; }
   if(hex>=0x00b4)                              { output[wro++]='u'; changes++; off+=6; continue; }
   if(hex>=0x00b7)                              { output[wro++]='-'; changes++; off+=6; continue; }
   if(hex>=0x00b8)                              { output[wro++]=','; changes++; off+=6; continue; }
   if(hex>=0x00bf)                              { output[wro++]='?'; changes++; off+=6; continue; }
   }

//BUG,"hex=%x",hex);

  aaLog(-1,"BAD u%04x",hex);
  oof;

  output[wro++]='#';
  off+=6;
  changes++;
  unknowns++;
  }
 output[wro]=NULL_CHAR;
 if(changes==0&&ostr==str) { return RET_NOTFOUND; }
 if(changes==0&&ostr!=str&&ostr!=NULL) { aaStringNCopy(ostr,str,chars,YES); return RET_NOTFOUND;   }
 if(changes==0&&ostr==NULL)  {  return RET_NOTFOUND;   }
 if(ostr) { aaStringNCopy(ostr,output,wro,YES); }
 else     { aaStringNCopy(str,output,wro,YES); }
 if(unknowns) { return RET_NOTSUPPORTED; }
 return RET_YES;
 }





 B aaStringContract                    (VP str,H chars,N amnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars<2) { return RET_FAILED; }
 if(amnt==0) { return RET_YES; }
 if(amnt<0) { return RET_NOTSUPPORTED; }
 while(1)
  {
  if(chars<2) { break; }
  if(amnt==0) { break; }
  aaStringDeleteChars(str,chars,0,1);
  chars--;
  aaStringLastCharSet(str,chars,0,1);
  chars--;
  amnt--;
  }
 return RET_YES;
 }





///=====================================================



 B aaStringUtfLen                      (VP str,H chars,HP uchars)
 {
 H count=0;
 H done;
 BP s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uchars==NULL) { return RET_BADPARM; }
 *uchars=0;
 if(str==NULL) { return RET_BADPARM; }


 //if(chars==0) { aaStringLen(str,&chars); }
 //if(chars==0) { return RET_YES; }

 done=0;
 aaCast(s,BP,str);
 for(; *s; ++s)
  {
  if(chars==0||chars<done)
   {
   if((*s&0xC0)!=0x80)
    {
    ++count;
    done++;
    }
   }
  }

 if(uchars) { *uchars=count; }
 return RET_YES;
 }


 B aaStringUtfPosGet                   (VP str,H uchrs,H pos,HP off)
 {
 H o=0;
 BP s;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(off==NULL) { return RET_BADPARM; }
 *off=0;
 if(str==NULL) { return RET_BADPARM; }
 if(uchrs==0) { aaStringUtfLen(str,0,&uchrs); }
 if(uchrs==0) { return RET_YES; }
 if(pos==F32) { pos=uchrs-1; }
 if(pos>=uchrs) { return RET_BOUNDS; }
 aaCast(s,BP,str);
 ++pos;
 while(1)
  {
  if((*s&0xC0)!=0x80) { --pos; }
  if(pos==0) break;
  s++;
  o++;
  }
 *off=o;
 return RET_YES;
 }






 B aaStringUtfTypeGet                  (VP str,H chars,HP type)
 {
 H i,t;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type) { *type=0; }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 aaCast(bp,BP,str);
 t=0;
 for(i=0;i<chars;i++)
  {
  if(bp[i]<0x80) { continue; }
  if(bp[i]>=0x80&&bp[i]<=0xbf) { t=1; break; }
  if(bp[i]>=0xc0&&bp[i]<=0xc1) { t=2; break; }
  if(bp[i]>=0xc2&&bp[i]<=0xdf) { t=3; break; }
  if(bp[i]>=0xe0&&bp[i]<=0xef) { t=4; break; }
  if(bp[i]>=0xf0&&bp[i]<=0xf4) { t=5; break; }
  t=F32;
  break;
  }
 if(type) { *type=t; }
 return RET_YES;
 }



 B aaStringToUtf8                      (VP str,H chars,HP ochars,H maxochars,VP ostr)
 {
 H x,y,len,c,cs;
 BP in,out;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsNull(str)!=NO) { return RET_BADPARM; }
 if(str==NULL) { return RET_BADPARM; }
 if(ostr==NULL) { return RET_BADPARM; }
 aaStringNull(ostr);
 if(chars==0) { aaStringLen(str,&chars); }
 if(ochars) { *ochars=0; }
 aaCast(in,BP,str);
 aaCast(out,BP,ostr);
 for(x=len=0;x<chars;x++)
  {
  c=in[x];
  if(c>0x1FFFF)   { return RET_FAILED; }
  if(c<= 0x7F)    { cs=1;   } else
  if(c<= 0x7FF)   { cs=2;   } else
  if(c<= 0xFFFF)  { cs=3;   } else { cs=4; }
  len+=cs;
  }
 if(len<128)        { y=2+len;   } else
 if(len<256)        { y=3+len;   } else
 if(len<65536UL)    { y=4+len;   } else
 if(len<16777216UL) { y=5+len;   } else   {  return RET_FAILED;   }
 if(y>maxochars)    { if(ochars) *ochars=len;  return RET_BOUNDS;   }
 x=0;
 out[x++]=0x0C;
 if(len<128)        { out[x++]=(B)len;                                                    }
 else
 if(len<256)        { out[x++]=0x81;  out[x++]=(B)len;                                    }
 else
 if(len<65536UL)    { out[x++]=0x82;  out[x++]=(B)((len>>8)&255);  out[x++]=(B)(len&255); }
 else
 if(len<16777216UL) { out[x++]=0x83;  out[x++]=(B)((len>>16)&255); out[x++]=(B)((len>>8)&255);   out[x++]=(B)(len&255);  }
 else               { return RET_FAILED;   }
 for(y=0;y<chars;y++)
  {
  c=in[y];
  if(c>0x1FFFF)   { return RET_FAILED; }
  if(c<= 0x7F)    { cs=1;   } else
  if(c<= 0x7FF)   { cs=2;   } else
  if(c<= 0xFFFF)  { cs=3;   } else { cs=4; }
  switch(cs)
   {
   case 1: out[x++]=(B)in[y]; break;
   case 2: out[x++]=0xC0|((in[y]>>6)&0x1F);  out[x++]=0x80|(in[y]&0x3F); break;
   case 3: out[x++]=0xE0|((in[y]>>12)&0x0F); out[x++]=0x80|((in[y]>>6)&0x3F); out[x++]=0x80|(in[y]&0x3F); break;
   case 4: out[x++]=0xF0|((in[y]>>18)&0x07); out[x++]=0x80|((in[y]>>12)&0x3F); out[x++]=0x80|((in[y]>>6)&0x3F); out[x++]=0x80|(in[y]&0x3F); break;
   }
  }
 if(ochars) *ochars=x;
 return RET_YES;
 }




///=====================================================


 B aaStringTokenGet                    (VP str,H chars,B ch,H ti,HP toff,HP tchars,VP tok)
 {
 BP s;
 H i,from,off,pos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(toff)   { *toff=F32; }
 if(tchars) { *tchars=0; }
 if(tok)    { aaStringNull(tok); }
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NOTFOUND; }
 aaCast(s,BP,str);
 i=from=0;
 while(1)
  {
  if(chars==0) { return RET_NOTFOUND; }
  if(aaStringFindChar(&s[from],chars,&off,ch,NO,0,YES)!=RET_YES) { return RET_NOTFOUND; }
  from+=off;
  chars-=off;
  if(aaStringFindChar(&s[from],chars,&pos,ch,YES,0,YES)!=RET_YES)
   {
   if(i==ti) { pos=chars; }
   else      { return RET_NOTFOUND; }
   }
  if(i==ti)
   {
   if(tok) { aaStringNCopy(tok,&s[from],pos,YES); }
   if(toff) { *toff=from; }
   if(tchars) { *tchars=pos; }
   break;
   }
  from+=pos;
  chars-=pos;
  i++;
  }
 return RET_YES;
 }





 B aaStringFix                         (VP str)
 {
 H sl,pos,i,hex;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringLen(str,&sl);
 aaCast(bp,BP,str);
 while(1)
  {
  if(aaStringFindFirstIString(bp,0,"&amp;",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,5);  bp[pos]='&'; continue;
   }
  if(aaStringFindFirstIString(bp,0,"&lt;",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,3);  bp[pos]='<'; continue;
   }
  if(aaStringFindFirstIString(bp,0,"&gt;",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,3);  bp[pos]='>'; continue;
   }
  if(aaStringFindFirstIString(bp,0,"\\\"",0,&pos)==YES)
   {
   aaStringDeleteChars(bp,0,pos,1);  bp[pos]='\"'; continue;
   }
  break;
  }
 i=0;
 while(1)
  {
  if(aaStringFindChar(bp,0,&pos,'&',YES,i,YES)!=YES) { break; }
  if(aaCharIsHex(bp[pos+1])!=YES) { i++; continue; }
  if(aaCharIsHex(bp[pos+2])!=YES) { i++; continue; }
  if(bp[pos+3]!=';') { i++; continue; }
  if(aaStringToNumber(&bp[pos+1],2,&hex,0,0,0)!=YES) { oof; }
  aaStringDeleteChars(bp,0,pos,3);
  bp[pos]=(B)hex;
  i=0;
  }
 i=0;
 while(1)
  {
  if(aaStringFindChar(bp,0,&pos,'&',YES,i,YES)!=YES) { break; }
  if(bp[pos+1]!='#')              { i++; continue; }
  if(aaCharIsHex(bp[pos+2])!=YES) { i++; continue; }
  if(aaCharIsHex(bp[pos+3])!=YES) { i++; continue; }
  if(bp[pos+4]!=';') { i++; continue; }
  if(aaStringHexToNumber(&bp[pos+2],2,&hex,0,NULL,NULL)!=YES) { oof; }
  aaStringDeleteChars(bp,0,pos,4);
  bp[pos]=(B)hex;
  i=0;
  }
 i=0;
 while(1)
  {
  if(aaStringFindChar(bp,0,&pos,BSLASH_CHAR,YES,i,YES)!=YES) { break; }
  if(bp[pos+1]==QUOTE_CHAR)  {   aaStringDeleteChars(bp,0,pos,1);   i=0; continue; }
  if(bp[pos+1]==DQUOTE_CHAR)  {   aaStringDeleteChars(bp,0,pos,1);   i=0; continue; }
  if(bp[pos+1]=='n')  {   aaStringDeleteChars(bp,0,pos,1); bp[pos]=' ';  i=0; continue; }
  if(bp[pos+1]=='r')  {   aaStringDeleteChars(bp,0,pos,1); bp[pos]=' '; i=0; continue; }
  //break;
  i++;
  }
 aaStringCopyf(str,"%s",bp);
 return RET_YES;
 }




 B aaStringWildCompare                 (VP str,H chars,VP wildcard)
 {
 CP cp,mp;
 CP string;
 CP wild;
 H done;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(wildcard==NULL) { return RET_BADPARM; }
 if(chars==0)   { aaStringLen(str,&chars); }
 if(chars==0) { return RET_NO; }
 done=0;
 cp=NULL;
 mp=NULL;
 string=(CP)str;
 wild=(CP)wildcard;
 while((*string)&&(*wild!='*'))
  {
  if((*wild!=*string)&&(*wild!='?')) { return RET_NO; }
  wild++;
  string++;
  }
 while(*string)
  {
  if(*wild=='*')
   {
   if(!*++wild) { return RET_YES; }
   mp=wild;
   cp=string+1;
   }
  else
  if((*wild==*string)||(*wild=='?'))
   {
   wild++;
   string++;
   }
  else
   {
   wild=mp;
   string=cp++;
   }
  }
 while(*wild=='*')
  {
  wild++;
  }
 if(*wild) { return RET_NO; }
 UNUSE(done);
 return RET_YES;
 }


 B aaStringStartsWithContains          (VP str,H chars,VP sstr,H schars,B isand,VP contains,...)
 {
 B ret;
 BP bp;
 H found,count;
 va_list ap;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 va_start(ap,contains);
 if(str==NULL) {  va_end(ap); return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { va_end(ap); return RET_NO; }
 if(sstr)
  {
  if(aaStringNICompare(str,sstr,schars,0)!=YES) { va_end(ap); return RET_NO; }
  }
 //aaDebugf("cok [%s] [%s]",str,sstr);
 found=0;
 count=0;
 bp=contains;
 while(1)
  {
  if(bp==NULL) { break; }
  ret=aaStringFindFirstIString(str,chars,bp,0,0);
 // aaDebugf("count=%i found=%i ret=%s bp=[%s] [%s]",count,found,arets,bp,str);
  if(ret==YES) {found++; }
  count++;
  bp=va_arg(ap,BP);
  }
 va_end(ap);
 if(isand)
  {
  if(count==0) { return RET_NO; }
  if(found!=count) { return RET_NO; }
  return RET_YES;
  }
 //if(count==0) { return RET_NO; }
 if(found==0&&count!=0) { return RET_NO; }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 VP aaf                                (VP buf,H off,VP fmt,...)
 {
 B ret;
 BP tmp;
 BP bp;
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fmt==NULL) { return NULL; }
 bp=(BP)buf;
 if(buf==NULL)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_256K,aa_MEMORYTEMP_aaf))!=RET_YES)
   {
   oops;
   return NULL;
   }
  bp=(BP)tmp;
  }
 aaFmt(fmt,argptr,&bp[off]);
 return &bp[off];
 }



/*-----------------------------------------------------------------------*/


 B aaBase64Encode                      (VP mem,H bytes,VP str,HP chars)
 {
 B ret;
 BP sp,mp;
 H i,soff,moff;
 B input[3];
 B output[4];
 BP tmp=NULL_POINTR;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if(chars) { *chars=0; }
 if(bytes==0) { aaStringLen(mem,&bytes); }
 if(str==mem)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,bytes+_32K,aa_MEMORYTEMP_Base64))!=RET_YES) {oops; }
  aaCast(sp,BP,tmp);
  aaCast(mp,BP,mem);
  }
 else
  {
  aaCast(sp,BP,str);
  aaCast(mp,BP,mem);
  }
 soff=moff=0;
 while(2<bytes)
  {
  input[0]=mp[moff]; moff++;
  input[1]=mp[moff]; moff++;
  input[2]=mp[moff]; moff++;
  bytes-=3;
  output[0]=(B)(input[0]>>2);
  output[1]=(B)(((input[0]&0x03)<<4)+(input[1]>>4));
  output[2]=(B)(((input[1]&0x0f)<<2)+(input[2]>>6));
  output[3]=(B)(input[2]&0x3f);
  sp[soff]=aa_Base64Char[output[0]]; soff++;
  sp[soff]=aa_Base64Char[output[1]]; soff++;
  sp[soff]=aa_Base64Char[output[2]]; soff++;
  sp[soff]=aa_Base64Char[output[3]]; soff++;
  }
 if(bytes!=0)
  {
  input[0]=input[1]=input[2]=NULL_CHAR;
  for(i=0;i<bytes;i++)  {  input[i]=mp[moff]; moff++;  }
  output[0]=(B)(input[0]>>2);
  output[1]=(B)(((input[0]&0x03)<<4)+(input[1]>>4));
  output[2]=(B)(((input[1]&0x0f)<<2)+(input[2]>>6));
  sp[soff]=aa_Base64Char[output[0]]; soff++;
  sp[soff]=aa_Base64Char[output[1]]; soff++;
  if(bytes==1) { sp[soff]=EQUAL_CHAR; soff++; }
  else         { sp[soff]=aa_Base64Char[output[2]]; soff++; }
  sp[soff]=EQUAL_CHAR; soff++;
  }
 sp[soff]=NULL_CHAR;
 if(chars) { *chars=soff; }
 if(str==mem)
  {
  aaMemoryCopy(str,soff,tmp);
  aaCast(sp,BP,str);
  sp[soff]=NULL_CHAR;
  }
 return RET_YES;
 }






 B aaBase64Decode                      (VP str,H chars,VP mem,HP bytes)
 {
 B ret;
 BP sp,mp,tmp=NULL_POINTR;
 B ch=0,bb;
 H i,stage,soff,moff;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes) { *bytes=0; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(str==mem)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,chars+_32K,aa_MEMORYTEMP_Base64))!=RET_YES) {oops; }
  aaCast(sp,BP,str);
  aaCast(mp,BP,tmp);
  }
 else
  {
  aaCast(sp,BP,str);
  aaCast(mp,BP,mem);
  }
 //aaCast(sp,BP,str);
 //aaCast(mp,BP,mem);
 soff=moff=stage=0;
 while(soff!=chars)
  {
  ch=sp[soff];
  soff++;
  if(ch==NULL_CHAR)  { break; }
  if(ch==SPACE_CHAR) { continue; }
  if(ch==LF_CHAR) { continue; }
  if(ch==CR_CHAR) { continue; }
  if(ch==EQUAL_CHAR) { break; }
  if(aaStringFindChar(aa_Base64Char,64,&i,ch,YES,0,YES)!=YES) { aaNote(0,"b7a %i %c",ch,ch); return RET_CORRUPTED; }
  bb=(B)(i);
  switch(stage)
   {
   case 0:  mp[moff]=(B)(bb<<2);   stage=1;   break;
   case 1:  mp[moff]|=(B)(bb>>4);  mp[moff+1]=(B)(((bb)&0x0f)<<4); moff++;   stage=2;   break;
   case 2:  mp[moff]|=(B)(bb>>2);  mp[moff+1]=(B)(((bb)&0x03)<<6); moff++;   stage=3;   break;
   case 3:  mp[moff]|=(B)(bb);     moff++;   stage=0;   break;
   default: break;
   }
  }
 if(stage!=0&&ch!=EQUAL_CHAR) { oof; return RET_CORRUPTED; }
 mp[moff]=NULL_CHAR;
 if(bytes) { *bytes=moff; }
 if(str==mem)
  {
  aaMemoryCopy(mem,moff,tmp);
  aaCast(sp,BP,mem);
  sp[moff]=NULL_CHAR;
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaGuidInit                          (_guid*guid,VP node)
 {
 B ret;
 B nod[6];
 ULARGE_INTEGER time;
 S W seq=0;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(guid==NULL) { return RET_BADPARM; }
 GetSystemTimeAsFileTime((FILETIME *)&time);
 time.QuadPart+=(Q)(1000*1000*10)*(Q)(60*60*24)*(Q)(17+30+31+365*18+5); // # of days
 if(node) { aaMemoryCopy(nod,6,node); }
 else     { aaMemoryRandomSet(nod,6); }
 ret=aaGuidSet(guid,seq,time.QuadPart,nod);
 seq++;
 return ret;
 }




 B aaGuidSet                           (_guid*guid,W cseq,Q tstamp,VP node)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(guid==NULL) { return RET_BADPARM; }
 guid->time_low=(H)(tstamp&0xFFFFFFFF);
 guid->time_mid=(W)((tstamp>>32)&0xFFFF);
 guid->time_hi_and_version=(W)((tstamp>>48)&0x0FFF);
 guid->time_hi_and_version|=(1<<12);
 guid->clock_seq_low=cseq&0xFF;
 guid->clock_seq_hi_and_reserved=(cseq&0x3F00)>>8;
 guid->clock_seq_hi_and_reserved|=0x80;
 if(node) { aaMemoryCopy(guid->node,6,node); }
 else     { aaMemoryRandomSet(guid->node,6); }
 return RET_YES;
 }




 B aaGuidToString                      (_guid*guid,VP str)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringCopyf(str,"%8.8x-%4.4x-%4.4x-%2.2x%2.2x-%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x",guid->time_low,guid->time_mid,
    guid->time_hi_and_version,guid->clock_seq_hi_and_reserved,guid->clock_seq_low,
    guid->node[0],guid->node[1],guid->node[2],guid->node[3],guid->node[4],guid->node[5]);
 return RET_YES;
 }








/*-----------------------------------------------------------------------*/



 B aaParserInit                        (_parser*parser,VP string,H chars)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(string==NULL) { return RET_BADPARM; }
 parser->string=string;
 if(chars==0) { aaStringLen(string,&chars); }
 parser->magic=aa_PARSE_MAGIC;
 parser->length=chars;
 parser->offset=0;
 parser->to_end=parser->length;
 aaCast(parser->bp,BP,parser->string);
 parser->ch=parser->bp[0];
 parser->is_start=YES;
 parser->stack_len=0;
 if(parser->length==0) { parser->is_end=YES; }
 else                  { parser->is_end=NO; }
 return RET_YES;
 }




 B aaParserCopy                        (_parser*parser,_parser*sparser,B reset)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(sparser==NULL) { return RET_BADPARM; }
 if(sparser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(sparser->string==NULL) { return RET_BADPARM; }
 if(sparser->offset>sparser->length) { return RET_FAILED; }
 if(sparser->to_end>sparser->length) { return RET_FAILED; }
 if(reset) { if((ret=aaParserInit(parser,sparser->bp,sparser->to_end))!=RET_YES) { return ret; } return RET_YES; }
 aaMemoryCopy(parser,sizeof(_parser),sparser);
 return RET_YES;
 }




 B aaParserSeek                        (_parser*parser,N amnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if(amnt==0) { return RET_YES; }
 if(amnt<0)
  {
  amnt=aaNumAbs(amnt);
  if((H)amnt>parser->offset) { amnt=parser->offset; }
  parser->bp-=amnt;
  parser->offset-=amnt;
  parser->to_end+=amnt;
  }
 else
 if(amnt>0)
  {
  if((H)amnt>parser->to_end) { amnt=parser->to_end; }
  parser->bp+=amnt;
  parser->offset+=amnt;
  parser->to_end-=amnt;
  }
 if(parser->offset==0) { parser->is_start=YES; }
 else                    { parser->is_start=NO; }
 if(parser->to_end==0) { parser->is_end=YES; }
 else                  { parser->is_end=NO; }
 parser->ch=parser->bp[0];
 return RET_YES;
 }





 B aaParserOffsetSet                   (_parser*parser,H offset)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
// if(parser->to_end>parser->length) { return RET_FAILED; }
 if(offset==F32)
  {
  parser->bp+=parser->to_end;
  parser->offset+=parser->to_end;
  parser->to_end=0;
  parser->ch=parser->bp[0];
  if(parser->offset==0) { parser->is_start=YES; } else { parser->is_start=NO; }
  if(parser->to_end==0) { parser->is_end=YES; } else { parser->is_end=NO; }
  return RET_YES;
  }
/// if(offset>parser->length) { return RET_BOUNDS; }
// if(offset>parser->to_end) { return RET_BOUNDS; }
 parser->offset=offset;
 parser->to_end=parser->length-parser->offset;
 aaCast(parser->bp,BP,parser->string);
 parser->bp+=offset;
 parser->ch=parser->bp[0];
 if(parser->offset==0) { parser->is_start=YES; } else { parser->is_start=NO; }
 if(parser->to_end==0) { parser->is_end=YES; } else { parser->is_end=NO; }
 return RET_YES;
 }






 B aaParserDeleteChars                 (_parser*parser,H amnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if(amnt>parser->to_end) { return RET_BOUNDS; }
 if(amnt==0) { return RET_YES; }
 aaStringDeleteChars(parser->bp,parser->to_end,0,amnt);
 parser->to_end-=amnt;
 parser->length-=amnt;
 if(parser->offset==0) { parser->is_start=YES; }
 else                  { parser->is_start=NO; }
 if(parser->to_end==0) { parser->is_end=YES; }
 else                  { parser->is_end=NO; }
 parser->ch=parser->bp[0];
 return RET_YES;
 }





 B aaParserReset                       (_parser*parser)
 {
 B ret;
 _parser p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if((ret=aaParserInit(&p,parser->string,parser->length))!=RET_YES) { return ret; }
 return(aaParserCopy(parser,&p,NO));
 }





 B aaParserSeekToChar                  (_parser*parser,B ch,B logic,B fwd)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if(fwd)
  {
  while(1)
   {
   if(parser->is_end) { break; }
   if(logic==YES&&parser->ch==ch) { return RET_YES; }
   if(logic!=YES&&parser->ch!=ch) { return RET_YES; }
   aaParserSeek(parser,1);
   }
  }
 else
  {
  while(1)
   {
   //if(parser->is_start) { break; }
   if(logic==YES&&parser->ch==ch) { return RET_YES; }
   if(logic!=YES&&parser->ch!=ch) { return RET_YES; }
   if(parser->is_start) { break; }
   aaParserSeek(parser,-1);
   }
  }
 return RET_NOTFOUND;
 }






 B aaParserSeekToCharList              (_parser*parser,VP chlist,B logic)
 {
 H i,sl;
 BP bp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(chlist==NULL) { return RET_BADPARM; }
 aaStringLen(chlist,&sl);
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 aaCast(bp,BP,chlist);
 while(1)
  {
  if(parser->is_end) { break; }
  if(logic==YES)   {   for(i=0;i<sl;i++) {   if(parser->ch==bp[i]) { return RET_YES; }    }   }
  else
   {
   for(i=0;i<sl;i++)  {    if(parser->ch==bp[i]) { break; }      }
   if(i==sl) { return RET_YES; }
   }
  aaParserSeek(parser,1);
  }
 return RET_NOTFOUND;
 }




 B aaParserSeekToNumber                (_parser*parser,B logic)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 while(1)
  {
  if(parser->is_end) { break; }
  if(logic==YES&&aaCharIsNum(parser->ch)==YES) { return RET_YES; }
  if(logic!=YES&&aaCharIsNum(parser->ch)!=YES) { return RET_YES; }
  if(parser->is_end) { break; }
  aaParserSeek(parser,1);
  }
 return RET_NOTFOUND;
 }






 B aaParserSeekToVisibleChar           (_parser*parser,B logic)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->string==NULL) { return RET_BADPARM; }
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 while(1)
  {
//  if(parser->is_end) { break; }
  if(logic==YES&&aaCharIsVisible(parser->ch)==YES) { return RET_YES; }
  if(logic!=YES&&aaCharIsVisible(parser->ch)!=YES) { return RET_YES; }
  if(parser->is_end) { break; }
  aaParserSeek(parser,1);
  }
 return RET_NOTFOUND;
 }







 B aaParserSeekToString                (_parser*parser,VP string,B cs,B logic,B flags)
 {
 H i,sl,oldoff;
 BP bp;
 B as,bs;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(string==NULL) { return RET_BADPARM; }
 aaStringLen(string,&sl);
 if(parser->offset>parser->length) { return RET_FAILED; }
 if(parser->to_end>parser->length) { return RET_FAILED; }
 if((parser->offset+sl)>parser->length) { return RET_NOTFOUND; }
 if(sl>parser->to_end) {  return RET_NOTFOUND; }
 if(aaBitGet(flags,2))
  {
  if(parser->stack_len>=aaElementCount(parser->stack_buf)) { return RET_BOUNDS; }
  }
 oldoff=parser->offset;
 aaCast(bp,BP,string);
 while(1)
  {
  if(parser->is_end) { break; }
  if(sl>parser->to_end) { break; }
  if(logic==YES)
   {
   for(i=0;i<sl;i++)
    {
    as=bp[i];
    bs=parser->bp[i];
    if(!cs) { if(as>='A'&&as<='Z') { as+=32; } if(bs>='A'&&bs<='Z') { bs+=32; } }
    if(as!=bs)
     {
     parser->bp+=(i+1);
     parser->offset+=(i+1);
     parser->to_end-=(i+1);
     if(parser->offset==0) { parser->is_start=YES; } else   { parser->is_start=NO; }
     if(parser->to_end==0) { parser->is_end=YES; } else  { parser->is_end=NO; }
     parser->ch=parser->bp[0];
     break;
     }
    }
   if(i!=sl) { continue; }
   if(aaBitGet(flags,1))  {   aaParserSeek(parser,sl);   }//flags&aa_PARSERSEEKFLAG_PAST)
   if(aaBitGet(flags,2))  {   aaParserStackPush(parser);   }//flags&aa_PARSERSEEKFLAG_PUSH)
   return RET_YES;
   }
  else
   {
   for(i=0;i<sl;i++)
    {
    as=bp[i];
    bs=parser->bp[i];
    if(!cs) { if(as>='A'&&as<='Z') { as+=32; } if(bs>='A'&&bs<='Z') { bs+=32; } }
    if(as==bs)     {     aaParserSeek(parser,i+1);   break;     }
    }
   if(i!=sl) { continue; }
   if(aaBitGet(flags,1))  { aaParserSeek(parser,sl);    }//if(flags&aa_PARSERSEEKFLAG_PAST)
   if(aaBitGet(flags,2))  {   aaParserStackPush(parser);   }//flags&aa_PARSERSEEKFLAG_PUSH)
   return RET_YES;
   }
  parser->bp+=1;
  parser->offset+=1;
  parser->to_end-=1;
  if(parser->offset==0) { parser->is_start=YES; }
  else                  { parser->is_start=NO; }
  if(parser->to_end==0) { parser->is_end=YES; }
  else                  { parser->is_end=NO; }
  parser->ch=parser->bp[0];
  }
 if(aaBitGet(flags,0)) { aaParserOffsetSet(parser,oldoff);  } //flags&aa_PARSERSEEKFLAG_SAFE)
 return RET_NOTFOUND;
 }



 B aaParserSeekToStringf               (_parser*parser,B cs,B logic,B flags,VP fmt,...)
 {
 va_list argptr;
 B str[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 return(aaParserSeekToString(parser,str,cs,logic,flags));
 }






 B aaParserStringCopy                  (_parser*parser,VP buf,H chars,B appendnull)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(buf==NULL) { return RET_BADPARM; }
 if(chars>parser->to_end) { return RET_BOUNDS; }
 if(chars==0)
  {
  if(appendnull) { aaStringNull(buf); }
  }
 else
  {
  aaStringNCopy(buf,parser->bp,chars,appendnull);
  }
 return RET_YES;
 }




 B aaParserStackPush                   (_parser*parser)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len>=aaElementCount(parser->stack_buf)) { return RET_BOUNDS; }
 parser->stack_buf[parser->stack_len]=parser->offset;
 parser->stack_len++;
 return RET_YES;
 }



 B aaParserStackPop                    (_parser*parser)
 {
 H off;
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 off=parser->stack_buf[parser->stack_len-1];
 if((ret=aaParserOffsetSet(parser,off))!=YES) { return ret; }
 parser->stack_len--;
 return RET_YES;
 }




 B aaParserStackPeek                   (_parser*parser,H index,HP offset)
 {
 H off;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 if(index>=parser->stack_len) { return RET_BOUNDS; }
 off=parser->stack_buf[index];
 if(offset) { *offset=off; }
 return RET_YES;
 }



 B aaParserStackDiscard                (_parser*parser)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 parser->stack_len--;
 return RET_YES;
 }



 B aaParserStackString                 (_parser*parser,HP chars,H maxchars,VP buf,B appendnull)
 {
 B ret;
 H coff,poff,sl;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(parser==NULL) { return RET_BADPARM; }
 if(parser->magic!=aa_PARSE_MAGIC) { return RET_NOTSTARTED; }
 if(parser->stack_len==0) { return RET_BOUNDS; }
 coff=parser->offset;
 if((ret=aaParserStackPeek(parser,parser->stack_len-1,&poff))!=YES) { return ret; }
 sl=coff-poff;
 if(chars) { *chars=sl; }
 if(buf==NULL) { return RET_BADPARM; }
 if(appendnull) { aaStringNull(buf); }

 if(sl>maxchars)
  {
  if(sl>0) { aaStringNCopy(buf,&parser->string[poff],sl,appendnull); }
  return RET_BOUNDS;
  }
 if(sl>0) { aaStringNCopy(buf,&parser->string[poff],sl,appendnull); }
 aaParserStackDiscard(parser);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaCordNull                          (_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)  { return RET_BADPARM; }
 cord->x=0;
 cord->y=0;
 return RET_YES;
 }



 B aaCordSet                           (_cord*cord,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)  { return RET_BADPARM; }
 cord->x=x;
 cord->y=y;
 return RET_YES;
 }



 B aaCordGet                           (_cord*cord,NP x,NP y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(x) { *x=cord->x; }
 if(y) { *y=cord->y; }
 return RET_YES;
 }




 B aaCordCopy                          (_cord*cord,_cord*scord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)  { return RET_BADPARM; }
 if(scord==NULL)  { return RET_BADPARM; }
 cord->x=scord->x;
 cord->y=scord->y;
 return RET_YES;
 }





 B aaCordAdjust                        (_cord*cord,N xa,N ya)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 cord->x+=xa;
 cord->y+=ya;
 return RET_YES;
 }





 B aaCordsAdjust                       (_cord*cord1,_cord*cord2,N x1a,N y1a,N x2a,N y2a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL&&cord2==NULL) { return RET_BADPARM; }
 if(cord1!=NULL) { aaCordAdjust(cord1,x1a,y1a); }
 if(cord2!=NULL) { aaCordAdjust(cord2,x2a,y2a); }
 return RET_YES;
 }




 B aaCordEqualsCord                    (_cord*cord,_cord*cord2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 if(cord2==NULL)   { return RET_BADPARM; }
 if(cord->x!=cord2->x) return RET_NO;
 if(cord->y!=cord2->y) return RET_NO;
 return RET_YES;
 }





 B aaCordSubtract                      (_cord*cord,_cord*cord2,_cord*rescord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 if(cord2==NULL)   { return RET_BADPARM; }
 return(aaCordSet(rescord,(cord->x-cord2->x),(cord->y-cord2->y)));
 }





 B aaCordAdd                           (_cord*cord,_cord*cord2,_cord*rescord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL)    { return RET_BADPARM; }
 if(cord2==NULL)   { return RET_BADPARM; }
 return(aaCordSet(rescord,(cord->x+cord2->x),(cord->y+cord2->y)));
 }




 B aaCordIsWithinRect                  (_cord*cord,_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(rect==NULL) { return RET_BADPARM; }
 if(rect->w==0) { return RET_FAILED; }
 if(rect->h==0) { return RET_FAILED; }
 if(cord->x<rect->x) return RET_NO;
 if(cord->y<rect->y) return RET_NO;
 if(cord->x>=(N)(rect->x+rect->w)) return RET_NO; // ningy added (N)
 if(cord->y>=(N)(rect->y+rect->h)) return RET_NO; // ningy added (N)
 return RET_YES;
 }






 B aaCordIsWithinRects                 (_cord*cord,_rect*rect,H count,HP which)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(rect==NULL) { return RET_BADPARM; }
 if(which==NULL) { return RET_BADPARM; }
 *which=F32;
 if(count==0) { return RET_BADPARM; }
 for(i=0;i<count;i++)
  {
  if(rect[i].w==0) { return RET_FAILED; }
  if(rect[i].h==0) { return RET_FAILED; }
  if(cord->x<rect[i].x) continue;
  if(cord->y<rect[i].y) continue;
  if(cord->x>=(N)(rect[i].x+rect[i].w)) continue;// ningy added (N)
  if(cord->y>=(N)(rect[i].y+rect[i].h)) continue; // ningy added (N)
  *which=i;
  return RET_YES;
  }
 return RET_NO;
 }





 B aaCordsSet                          (_cord*cord1,_cord*cord2,N x1,N y1,N x2,N y2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL) { return RET_BADPARM; }
 if(cord2==NULL) { return RET_BADPARM; }
 aaCordSet(cord1,x1,y1);
 return(aaCordSet(cord2,x2,y2));
 }




 B aaCordsToRect                       (_cord*cord1,_cord*cord2,_rect*rect)
 {
// B ret;
 N n;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL) { return RET_BADPARM; }
 if(cord2==NULL) { return RET_BADPARM; }
 if(rect!=NULL)
  {
  n=cord2->x-cord1->x;
  if(n>=0) { rect->x=cord1->x; rect->w=n; }
  else     { rect->x=cord2->x; rect->w=cord1->x-cord2->x; }
  n=cord2->y-cord1->y;
  if(n>=0) { rect->y=cord1->y; rect->h=n; }
  else     { rect->y=cord2->y; rect->h=cord1->y-cord2->y; }
  rect->w++;
  rect->h++;
  }
 return RET_YES;
 }




 B aaCordIsZero                        (_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(cord->x==0&&cord->y==0) { return RET_YES; }
 return RET_NO;
 }



 B aaCordCopyFromRect                  (_cord*cord,_rect*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(srect==NULL)  { return RET_BADPARM; }
 cord->x=srect->x;
 cord->y=srect->y;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaSizeNull                          (_size*size)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)   { return RET_BADPARM; }
 size->w=0;
 size->h=0;
 return RET_YES;
 }


 B aaSizeSet                           (_size*size,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)   { return RET_BADPARM; }
 size->w=w;
 size->h=h;
 return RET_YES;
 }



 B aaSizeGet                           (_size*size,HP wid,HP hit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 if(wid) { *wid=size->w; }
 if(hit) { *hit=size->h; }
 return RET_YES;
 }


 B aaSizeCopy                          (_size*size,_size*ssize)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)  { return RET_BADPARM; }
 if(ssize==NULL)  { return RET_BADPARM; }
 size->w=ssize->w;
 size->h=ssize->h;
 return RET_YES;
 }




 B aaSizeAdjust                        (_size*size,N wa,N ha)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 size->w+=wa;
 size->h+=ha;
 return RET_YES;
 }




 B aaSizeEqualsSize                    (_size*size,_size*size2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL)    { return RET_BADPARM; }
 if(size2==NULL)   { return RET_BADPARM; }
 if(size->w!=size2->w) return RET_NO;
 if(size->h!=size2->h) return RET_NO;
 return RET_YES;
 }




 B aaSizeToRect                        (_size*size,_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 return(aaRectSet(rect,0,0,size->w,size->h));
 }



 B aaSizeIsValid                       (_size*size)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 if((N)size->w<=0) { return RET_NO; }
 if((N)size->h<=0) { return RET_NO; }
 return RET_YES;
 }



 B aaSizeCordCenterGet                 (_size*size,_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 if(cord==NULL) { return RET_BADPARM; }
 cord->x=size->w/2;
 cord->y=size->h/2;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aaRectNull                          (_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x=0;
 rect->y=0;
 rect->w=0;
 rect->h=0;
 return RET_YES;
 }




 B aaRectIsEmpty                       (_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect->w==0&&rect->h==0) { return RET_YES; }
 return RET_NO;
 }




 B aaRectSet                           (_rect*rect,N x,N y,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x=x;
 rect->y=y;
 rect->w=w;
 rect->h=h;
 return RET_YES;
 }




 B aaRectGet                           (_rect*rect,NP x,NP y,HP wid,HP hit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(x) { *x=rect->x; }
 if(y) { *y=rect->y; }
 if(wid) { *wid=rect->w; }
 if(hit) { *hit=rect->h; }
 return RET_YES;
 }






 B aaRectCopy                          (_rect*rect,_rect*srect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(srect==NULL) { return RET_BADPARM; }
 rect->x=srect->x;
 rect->y=srect->y;
 rect->w=srect->w;
 rect->h=srect->h;
 return RET_YES;
 }





 B aaRectAdjust                        (_rect*rect,N xa,N ya,N wa,N ha)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x+=xa;
 rect->y+=ya;
 rect->w+=wa;
 rect->h+=ha;
 return RET_YES;
 }





 B aaRectCordSet                       (_rect*rect,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->x=x;
 rect->y=y;
 return RET_YES;
 }





 B aaRectSizeSet                       (_rect*rect,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 rect->w=w;
 rect->h=h;
 return RET_YES;
 }



 B aaRectEqualsRect                    (_rect*rect,_rect*rect2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL)    { return RET_BADPARM; }
 if(rect2==NULL)   { return RET_BADPARM; }
 if(rect->x!=rect2->x) return RET_NO;
 if(rect->y!=rect2->y) return RET_NO;
 if(rect->w!=rect2->w) return RET_NO;
 if(rect->h!=rect2->h) return RET_NO;
 return RET_YES;
 }





 B aaRectIntersect                     (_rect*rect,_rect*rect2,_rect*resrect)
 {
 BOOL bl;
 RECT rr1,rr2,rr3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect2==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 WinRectFromRect(&rr1,rect);
 WinRectFromRect(&rr2,rect2);
 bl=IntersectRect(&rr3,&rr1,&rr2);
 resrect->x=rr3.left;
 resrect->y=rr3.top;
 resrect->w=rr3.right-rr3.left;
 resrect->h=rr3.bottom-rr3.top;
 if(bl==0) { return RET_NO; }
 return RET_YES;
 }



 B aaRectIsInsideRect                  (_rect*rect,_rect*rect2)
 {
 N r1x1,r1y1,r1y2,r1x2;
 N r2x1,r2y1,r2y2,r2x2;

 r1x1=(rect->x);             r1y1=(rect->y);
 r1x2=(rect->x+rect->w)-1;   r1y2=(rect->y+rect->h)-1;
 r2x1=(rect2->x);            r2y1=(rect2->y);
 r2x2=(rect2->x+rect2->w)-1; r2y2=(rect2->y+rect2->h)-1;
 if((r1x1>=r2x1)&&(r1x2<=r2x2))
  {
  if((r1y1>=r2y1)&&(r1y2<=r2y2))  {   return RET_YES;   }
  }
 return RET_NO;
 }



 B aaRectIsOutsideRect                 (_rect*rect,_rect*rect2)
 {
 N r1x1,r1y1,r1y2,r1x2;
 N r2x1,r2y1,r2y2,r2x2;

 r1x1=(rect->x);             r1y1=(rect->y);
 r1x2=(rect->x+rect->w)-1;   r1y2=(rect->y+rect->h)-1;
 r2x1=(rect2->x);            r2y1=(rect2->y);
 r2x2=(rect2->x+rect2->w)-1; r2y2=(rect2->y+rect2->h)-1;
 if((r1x1<r2x1)&&(r1x2>r2x2))
  {
  if((r1y1<r2y1)&&(r1y2>r2y2)) {  return RET_YES;   }
  }
 return RET_NO;
 }




 B aaRectIsOverlappingRect             (_rect*rect,_rect*rect2)
 {
 N r1x1,r1y1,r1y2,r1x2;
 N r2x1,r2y1,r2y2,r2x2;
 B hol,vol;

 r1x1=(rect->x);             r1y1=(rect->y);
 r1x2=(rect->x+rect->w)-1;   r1y2=(rect->y+rect->h)-1;
 r2x1=(rect2->x);            r2y1=(rect2->y);
 r2x2=(rect2->x+rect2->w)-1; r2y2=(rect2->y+rect2->h)-1;
 hol=((r1x1<r2x2)&&(r1x2>r2x1));
 vol=((r1y1>r2y2)&&(r1y2<r2y1));
 if(hol||vol) { return RET_YES; }
 return RET_NO;
 }



 B aaRectAdd                           (_rect*rect,_rect*rect2,_rect*resrect)
 {
 RECT rr1,rr2,rr3;
 _rect ro;
 _cord ca1,ca2;
 _cord cb1,cb2;
 _cord cd1,cd2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect2==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 WinRectFromRect(&rr1,rect);
 WinRectFromRect(&rr2,rect2);

 aaRectToCords(rect,&ca1,&ca2);
 aaRectToCords(rect2,&cb1,&cb2);
 cd1.x=aaNumMin(ca1.x,cb1.x);
 cd2.x=aaNumMax(ca2.x,cb2.x);
 cd1.y=aaNumMin(ca1.y,cb1.y);
 cd2.y=aaNumMax(ca2.y,cb2.y);
 aaRectSet(resrect,cd1.x,cd1.y,(cd2.x-cd1.x)+1,(cd2.y-cd1.y)+1);

 UnionRect(&rr3,&rr1,&rr2);
 ro.x=rr3.left;
 ro.y=rr3.top;
 ro.w=rr3.right-rr3.left;
 ro.h=rr3.bottom-rr3.top;

// aaDebugf("ro=%i,%i,%i,%i resrect=%i,%i,%i,%i ",aaRectParts(ro),resrect->x,resrect->y,resrect->w,resrect->h);
 if(ro.x!=resrect->x||ro.y!=resrect->y||ro.w!=resrect->w||ro.h!=resrect->h)
  {
  aaRectCopy(resrect,rect2);
  //aaDebugf("dd");
  //oof;
  }
 return RET_YES;
 }




 B aaRectSubtract                      (_rect*rect,_rect*rect2,_rect*resrect)
 {
 RECT rr1,rr2,rr3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(rect2==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 WinRectFromRect(&rr1,rect);
 WinRectFromRect(&rr2,rect2);
 SubtractRect(&rr3,&rr1,&rr2);
 resrect->x=rr3.left;
 resrect->y=rr3.top;
 resrect->w=rr3.right-rr3.left;
 resrect->h=rr3.bottom-rr3.top;
 return RET_YES;
 }





 B aaRectToCords                       (_rect*rect,_cord*cord1,_cord*cord2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(cord1!=NULL) { aaCordSet(cord1,rect->x,rect->y); }
 if(cord2!=NULL) { aaCordSet(cord2,(rect->x+rect->w)-1,(rect->y+rect->h)-1); }
 return RET_YES;
 }



 B aaRectToSize                        (_rect*rect,_size*size)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 return(aaSizeSet(size,rect->w,rect->h));
 }




 B aaRectIsValid                       (_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if((N)rect->w<=0) { return RET_NO; }
 if((N)rect->h<=0) { return RET_NO; }
 return RET_YES;
 }





 B aaRectCordCenterGet                 (_rect*rect,_cord*cord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 return(aaCordSet(cord,rect->x+(rect->w/2),rect->y+(rect->h/2)));
 }



 B aaRectExpand                        (_rect*rect,N wamnt,N hamnt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(wamnt!=0)  {  rect->x=rect->x-wamnt;  rect->w=rect->w+(wamnt*2);  }
 if(hamnt!=0)  {  rect->y=rect->y-hamnt;  rect->h=rect->h+(hamnt*2);  }
 return RET_YES;
 }



 B aaRectToCornerCords                 (_rect*rect,_cord*cord1,_cord*cord2,_cord*cord3,_cord*cord4)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(cord1) { cord1->x=rect->x; cord1->y=rect->y; }
 if(cord2) { cord2->x=(rect->x+rect->w)-1; cord2->y=rect->y; }
 if(cord3) { cord3->x=(rect->x+rect->w)-1; cord3->y=(rect->y+rect->h)-1; }
 if(cord4) { cord4->x=rect->x; cord4->y=(rect->y+rect->h)-1; }
 return RET_YES;
 }



 B aaRectToSideCords                   (_rect*rect,_cord*cord1,_cord*cord2,_cord*cord3,_cord*cord4)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(cord1) { cord1->x=(rect->x+(rect->w/2))-1; cord1->y=rect->y; }
 if(cord2) { cord2->x=(rect->x+rect->w)-1; cord2->y=(rect->y+(rect->h/2))-1; }
 if(cord3) { cord3->x=(rect->x+(rect->w/2))-1; cord3->y=(rect->y+rect->h)-1; }
 if(cord4) { cord4->x=(rect->x); cord4->y=(rect->y+(rect->h/2))-1; }
 return RET_YES;
 }



 B aaRectAlignRect                     (_rect*rect,_rect*rect2,B ha,B va,_rect*resrect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect2==NULL) { return RET_BADPARM; }
 if(rect==NULL) { return RET_BADPARM; }
 if(resrect==NULL) { return RET_BADPARM; }
 resrect->w=rect->w;
 resrect->h=rect->h;
 switch(ha)
  {
  default:
  case aa_ALIGN_NONE:   resrect->x=rect->x;  break;
  case aa_ALIGN_LEFT:   resrect->x=rect2->x+rect->x;  break;
  case aa_ALIGN_MIDDLE: resrect->x=(rect2->w/2)-(rect->w/2);  break;
  case aa_ALIGN_RIGHT:  resrect->x=(rect2->x+rect2->w)-(rect->w)-(rect->x);  break;
  }
 switch(va)
  {
  default:
  case aa_ALIGN_NONE:   resrect->y=rect->y;  break;
  case aa_ALIGN_TOP:   resrect->y=rect2->y+rect->y;  break;
  case aa_ALIGN_MIDDLE: resrect->y=(rect2->h/2)-(rect->h/2);  break;
  case aa_ALIGN_BOTTOM:  resrect->y=(rect2->y+rect2->h)-(rect->h)-(rect->y);  break;
  }
 return RET_YES;
 }




 B aaRectFromWinRect                   (_rect*rect,RECT*winrect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(WinRectToRect(winrect,rect));
 }







/*-----------------------------------------------------------------------*/


 B aaGridToCord                        (_rect*rect,_cord*g1,_cord*c1)
 {
 D xs,ys;
 _cord cd1;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 //if(xd) { *xd=xs; }
 //if(yd) { *yd=ys; }
 if(g1==NULL) { return RET_BADPARM; }
 if(c1==NULL) { return RET_BADPARM; }
 cd1.x=(g1->x*xs);
 cd1.y=(g1->y*ys);
 cd1.x+=rect->x;
 cd1.y+=rect->y;
 aaCordCopy(c1,&cd1);
 return RET_YES;
 }



 B aaGridToCords                       (_rect*rect,_cord*g1,_cord*g2,_cord*c1,_cord*c2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(g1==NULL&&c1==NULL) { return RET_BADPARM; }
 if(g2!=NULL&&c2==NULL) { return RET_BADPARM; }
 if(g1==NULL&&c1!=NULL) { return RET_BADPARM; }
 if(g2==NULL&&c2!=NULL) { return RET_BADPARM; }
 if(g1&&c1) { aaGridToCord(rect,g1,c1); }
 if(g2&&c2) { aaGridToCord(rect,g2,c2); }
 return RET_YES;
 }


 B aaGridToRect                        (_rect*rect,_cord*g1,_cord*g2,_rect*r1)
 {
 D xs,ys;
 _cord cd1,cd2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 //if(xd) { *xd=xs; }
 //if(yd) { *yd=ys; }
 if(g1==NULL&&g2==NULL) { return RET_BADPARM; }
 if(g1==NULL) { aaCordSet(&cd1,rect->x,rect->y); }
 else
  {
  cd1.x=(g1->x*xs);
  cd1.y=(g1->y*ys);
  cd1.x+=rect->x;
  cd1.y+=rect->y;
  }
 if(g2==NULL) { aaCordSet(&cd2,(rect->x+rect->w)-1,(rect->y+rect->h)-1); }
 else
  {
  cd2.x=(g2->x*xs);
  cd2.y=(g2->y*ys);
  cd2.x+=rect->x;
  cd2.y+=rect->y;
  }
 if(r1)
  {
  aaRectSet(r1,cd1.x,cd1.y,(cd2.x-cd1.x)+1,(cd2.y-cd1.y)+1);
  }
 return RET_YES;
 }





 B aaGridRectToCord                    (_rect*rect,_rect*r1,_cord*c1)
 {
 _rect rc1;
 _cord gc1,gc2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(r1==NULL) { aaRectCopy(&rc1,rect); }
 else         { aaRectCopy(&rc1,r1); }
 aaRectToCords(&rc1,&gc1,&gc2);
 aaGridToCord(rect,&gc1,c1);
 return RET_YES;
 }






 B aaGridRectToCords                   (_rect*rect,_rect*r1,_cord*c1,_cord*c2)
 {
 _rect rc1;
 _cord gc1,gc2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(r1==NULL) { aaRectCopy(&rc1,rect); }
 else         { aaRectCopy(&rc1,r1); }
 aaRectToCords(&rc1,&gc1,&gc2);
 aaGridToCords(rect,&gc1,&gc2,c1,c2);
 return RET_YES;
 }




 B aaGridRectToRect                    (_rect*rect,_rect*r1,_rect*r2)
 {
 _rect rc1;
 _cord gc1,gc2;
 _cord cd1,cd2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(r1==NULL) { aaRectCopy(&rc1,rect); }
 else         { aaRectCopy(&rc1,r1); }
 aaRectToCords(&rc1,&gc1,&gc2);
 aaGridToCords(rect,&gc1,&gc2,&cd1,&cd2);
 aaCordsToRect(&cd1,&cd2,r2);
 return RET_YES;
 }




//..............................


 B aaCordToGrid                        (_rect*rect,_cord*c1,_cord*g1)
 {
 D xs,ys;
 _cord cd1;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 //if(xd) { *xd=xs; }
 //if(yd) { *yd=ys; }
 if(c1==NULL) { aaCordSet(&cd1,rect->x,rect->y); }
 else
  {
  cd1.x=c1->x/xs;
  cd1.y=c1->y/ys;
  }
 if(g1)
  {
  aaCordCopy(g1,&cd1);
  }
 return RET_YES;
 }





 B aaCordToGrids                       (_rect*rect,_cord*c1,_cord*c2,_cord*g1,_cord*g2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(g1!=NULL&&c1==NULL) { return RET_BADPARM; }
 if(g2!=NULL&&c2==NULL) { return RET_BADPARM; }
 if(g1==NULL&&c1!=NULL) { return RET_BADPARM; }
 if(g2==NULL&&c2!=NULL) { return RET_BADPARM; }
 if(g1&&c1) { aaCordToGrid(rect,c1,g1); }
 if(g2&&c2) { aaCordToGrid(rect,c2,g2); }
 return RET_YES;
 }




 B aaRectToGrid                        (_rect*rect,_rect*r1,_cord*g1,_cord*g2)
 {
 D xs,ys;
 _rect rc1;
 _cord cd1,cd2;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 xs=rect->w/10000.0; ys=rect->h/10000.0;
 //if(xd) { *xd=xs; }
 //if(yd) { *yd=ys; }
 if(r1==NULL) { aaRectSet(&rc1,rect->x,rect->y,rect->w,rect->h); }
 else         { aaRectCopy(&rc1,r1);  }
 cd1.x=(rc1.x)/xs;
 cd1.y=(rc1.y)/ys;
 cd2.x=(((rc1.x+rc1.w)-1)/xs);
 cd2.y=(((rc1.y+rc1.h)-1)/ys);
 if(g1)  {  aaCordCopy(g1,&cd1); }
 if(g2)  {  aaCordCopy(g2,&cd2); }
 return RET_YES;
 }



 B aaGridFromFloats                    (_cord*cord1,_cord*cord2,D x1,D y1,D x2,D y2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord1==NULL&&cord2==NULL) { return RET_BADPARM; }
 if(cord1)
  {
  x1=x1*100.0;
  y1=y1*100.0;
  x1=aaNumClamp(x1,0.0,10000.0);
  y1=aaNumClamp(y1,0.0,10000.0);
  cord1->x=x1;
  cord1->y=y1;
  }
 if(cord2)
  {
  x2=x2*100.0;
  y2=y2*100.0;
  x2=aaNumClamp(x2,0.0,10000.0);
  y2=aaNumClamp(y2,0.0,10000.0);
  cord2->x=x2;
  cord2->y=y2;
  }
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/


 B aaFCordSet                          (_fcord*fcord,F x,F y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fcord==NULL)  { return RET_BADPARM; }
 fcord->x=x;
 fcord->y=y;
 return RET_YES;
 }


 B aaFCordCopy                         (_fcord*fcord,_fcord*sfcord)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fcord==NULL)  { return RET_BADPARM; }
 if(sfcord==NULL)  { return RET_BADPARM; }
 fcord->x=sfcord->x;
 fcord->y=sfcord->y;
 return RET_YES;
 }


 B aaFSizeSet                          (_fsize*fsize,F w,F h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fsize==NULL)   { return RET_BADPARM; }
 fsize->w=w;
 fsize->h=h;
 return RET_YES;
 }


 B aaFsizeCopy                         (_fsize*fsize,_fsize*sfsize)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fsize==NULL)  { return RET_BADPARM; }
 if(sfsize==NULL)  { return RET_BADPARM; }
 fsize->w=sfsize->w;
 fsize->h=sfsize->h;
 return RET_YES;
 }

 B aaFRectSet                          (_frect*frect,F x,F y,F w,F h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(frect==NULL) { return RET_BADPARM; }
 frect->x=x;
 frect->y=y;
 frect->w=w;
 frect->h=h;
 return RET_YES;
 }


 B aaFRectCopy                         (_frect*frect,_frect*sfrect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(frect==NULL) { return RET_BADPARM; }
 if(sfrect==NULL) { return RET_BADPARM; }
 frect->x=sfrect->x;
 frect->y=sfrect->y;
 frect->w=sfrect->w;
 frect->h=sfrect->h;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/





 B aaRgbaSet                           (_rgba*rgba,B r,B g,B b,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)  { return RET_BADPARM; }
 rgba->r=r;
 rgba->g=g;
 rgba->b=b;
 rgba->a=a;
 return RET_YES;
 }





 B aaRgbaCopy                          (_rgba*rgba,_rgba*srgba)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)   { return RET_BADPARM; }
 if(srgba==NULL)  { return RET_BADPARM; }
 rgba->r=srgba->r;
 rgba->g=srgba->g;
 rgba->b=srgba->b;
 rgba->a=srgba->a;
 return RET_YES;
 }




 B aaRgbaCopyWithAlpha                 (_rgba*rgba,_rgba*srgba,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)   { return RET_BADPARM; }
 if(srgba==NULL)  { return RET_BADPARM; }
 rgba->r=srgba->r;
 rgba->g=srgba->g;
 rgba->b=srgba->b;
 rgba->a=a;
 return RET_YES;
 }



 B aaRgbaAdjust                        (_rgba*rgba,N ramnt,N gamnt,N bamnt,N aamnt)
 {
 N r,g,b,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 r=rgba->r+ramnt;
 g=rgba->g+gamnt;
 b=rgba->b+bamnt;
 a=rgba->a+aamnt;
 r=aaNumClamp(r,0,255);
 g=aaNumClamp(g,0,255);
 b=aaNumClamp(b,0,255);
 a=aaNumClamp(a,0,255);
 rgba->r=(B)r;
 rgba->g=(B)g;
 rgba->b=(B)b;
 rgba->a=(B)a;
 return RET_YES;
 }







 B aaRgbaEqualsRgba                    (_rgba*rgba,_rgba*rgba2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)    { return RET_BADPARM; }
 if(rgba2==NULL)   { return RET_BADPARM; }
 if(rgba->r!=rgba2->r) return RET_NO;
 if(rgba->g!=rgba2->g) return RET_NO;
 if(rgba->b!=rgba2->b) return RET_NO;
 if(rgba->a!=rgba2->a) return RET_NO;
 return RET_YES;
 }





 B aaRgbaGradientArray                 (_rgba*rgba1,_rgba*rgba2,H count,_rgba*rgbaarray)
 {
 F rx,gx,bx,ax;
 F rs,gs,bs,as,d;
 H i;
// B al;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba1==NULL) { return RET_BADPARM; }
 if(rgba2==NULL) { return RET_BADPARM; }
 if(rgbaarray==NULL) { return RET_BADPARM; }
 if(count==0) { return RET_BADPARM; }
 rs=(F)rgba1->r; d=rgba2->r-rgba1->r; rx=d/(F)count;
 gs=(F)rgba1->g; d=rgba2->g-rgba1->g; gx=d/(F)count;
 bs=(F)rgba1->b; d=rgba2->b-rgba1->b; bx=d/(F)count;
 as=(F)rgba1->a; d=rgba2->a-rgba1->a; ax=d/(F)count;
 for(i=0;i<count;i++)
  {
  rgbaarray[i].r=(B)rs; //(B)aaNumClamp(r,rgba1->r,rgba2->r);
  rgbaarray[i].g=(B)gs;//(B)aaNumClamp(g,rgba1->g,rgba2->g);
  rgbaarray[i].b=(B)bs;//(B)aaNumClamp(b,rgba1->b,rgba2->b);
  rgbaarray[i].a=(B)as;//(B)aaNumClamp(a,rgba1->a,rgba2->a);
  rs+=rx; gs+=gx; bs+=bx; as+=ax;
  aaNumDoClamp(rs,0.0,255.0);
  aaNumDoClamp(gs,0.0,255.0);
  aaNumDoClamp(bs,0.0,255.0);
  aaNumDoClamp(as,0.0,255.0);
  }
 if(rgba1->a==255&&rgba2->a==255)
  {
  for(i=0;i<count;i++) { if(rgbaarray[i].a!=255) { oof; }} // delme
  }
 return RET_YES;
 }





 B aaRgbaDwordSet                      (_rgba*rgba,H dword)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 rgba->a=(B)((dword>>0)&F8);
 rgba->r=(B)((dword>>24)&F8);
 rgba->g=(B)((dword>>16)&F8);
 rgba->b=(B)((dword>>8)&F8);
 return RET_YES;
 }





 B aaRgbaYuvaSet                       (_rgba*rgba,B y,B u,B v,B a)
 {
 F yy,uu,vv;
 N r,g,b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL)  {  return RET_BADPARM;  }
 yy=(F)y;
 uu=(F)u;
 vv=(F)v;
 r=(yy+1.402*(vv-128.0));
 g=(yy-0.34414*(uu-128.0)-0.71414*(vv-128.0));
 b=(yy+1.772*(uu-128.0));
 rgba->r=(B)aaNumClamp(r,0,255);
 rgba->g=(B)aaNumClamp(g,0,255);
 rgba->b=(B)aaNumClamp(b,0,255);
 rgba->a=a;
 return RET_YES;
 }






 B aaRgbaSetUsingHlsa                  (_rgba*rgba,B h,B l,B s,B a)
 {
 _hlsa hh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 aaHlsaSet(&hh,h,l,s,a);
 aaHlsaToRgba(&hh,rgba);
 return RET_YES;
 }





 B aaRgbaShadeSet                      (_rgba*p1,_rgba*p2,F amnt)
 {
 D l,s;
 _hlsa hh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL) { return RET_BADPARM; }
 if(amnt<0.0) { return RET_BOUNDS; }
// if(amnt>1.0) { return RET_BOUNDS; }
 aaHlsaFromRgba(&hh,p1);
 l=hh.l;
 l=l*amnt;
 l=aaNumClamp(l,0.0,255.0);
 s=hh.s;
 s=s*amnt;
 s=aaNumClamp(s,0.0,255.0);
 hh.l=(B)l;
 hh.s=(B)s;
 if(p2==NULL) {  aaHlsaToRgba(&hh,p1); }
 else           {  aaHlsaToRgba(&hh,p2); }
 return RET_YES;
 }






 B aaRgbaSwap                          (_rgba*p1,_rgba*p2)
 {
 _rgba pn;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL) { return RET_BADPARM; }
 if(p2==NULL) { return RET_BADPARM; }
 if(p1==p2) { oof; return RET_YES; }
 aaRgbaCopy(&pn,p1);
 aaRgbaCopy(p1,p2);
 aaRgbaCopy(p2,&pn);
 return RET_YES;
 }





 B aaRgbaMix                           (_rgba*p1,_rgba*p2,_rgba*p3)
 {
 N a1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL||p2==NULL||p3==NULL) { return RET_BADPARM; }
 a1=(p1->r+p2->r)>>1;  p3->r=(B)(a1);
 a1=(p1->g+p2->g)>>1;  p3->g=(B)(a1);
 a1=(p1->b+p2->b)>>1;  p3->b=(B)(a1);
 a1=(p1->a+p2->a)>>1;  p3->a=(B)(a1);
 return RET_YES;
 }






 B aaRgbaAdjustUsingHlsa               (_rgba*p1,N hamnt,N lamnt,N samnt,N aamnt,_rgba*p2)
 {
 _hlsa hh;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(p1==NULL) { return RET_BADPARM; }
 aaHlsaFromRgba(&hh,p1);
 aaHlsaAdjust(&hh,hamnt,lamnt,samnt,aamnt);
 if(p2) { aaHlsaToRgba(&hh,p2); }
 else   { aaHlsaToRgba(&hh,p1); }
 return RET_YES;
 }



 B aaRgbabfSet                         (_rgbabf*rgbabf,B rb,B gb,B bb,B ab,B rf,B gf,B bf,B af)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgbabf==NULL) { return RET_BADPARM; }
 aaRgbaSet(&rgbabf->bg,rb,gb,bb,ab);
 aaRgbaSet(&rgbabf->fg,rf,gf,bf,af);
 return RET_YES;
 }


 B aaRgbabfCopy                        (_rgbabf*rgbabf,_rgba*rgbab,_rgba*rgbaf)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgbabf==NULL) { return RET_BADPARM; }
 if(rgbab!=NULL) { aaRgbaCopy(&rgbabf->bg,rgbab); }
 if(rgbaf!=NULL) { aaRgbaCopy(&rgbabf->fg,rgbaf); }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 B aaYuvaSet                           (_yuva*yuva,B y,B u,B v,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 yuva->y=y;
 yuva->u=u;
 yuva->v=v;
 yuva->a=a;
 return RET_YES;
 }



 B aaYuvaCopy                          (_yuva*yuva,_yuva*syuva)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 if(syuva==NULL) { return RET_BADPARM; }
 yuva->y=syuva->y;
 yuva->u=syuva->u;
 yuva->v=syuva->v;
 yuva->a=syuva->a;
 return RET_YES;
 }



 B aaYuvaAdjust                        (_yuva*yuva,N yamnt,N uamnt,N vamnt,N aamnt)
 {
 N y,u,v,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 y=yuva->y+yamnt;
 u=yuva->u+uamnt;
 v=yuva->v+vamnt;
 a=yuva->a+aamnt;
 y=aaNumClamp(y,0,255);
 u=aaNumClamp(u,0,255);
 v=aaNumClamp(v,0,255);
 a=aaNumClamp(a,0,255);
 yuva->y=(B)y;
 yuva->u=(B)u;
 yuva->v=(B)v;
 yuva->a=(B)a;
 return RET_YES;
 }



 B aaYuvaToRgba                        (_yuva*yuva,_rgba*rgba)
 {
 F yy,uu,vv;
 N r,g,b;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 yy=(F)yuva->y;
 uu=(F)yuva->u;
 vv=(F)yuva->v;
 r=(yy+1.402*(vv-128.0));
 g=(yy-0.34414*(uu-128.0)-0.71414*(vv-128.0));
 b=(yy+1.772*(uu-128.0));
 rgba->r=(B)aaNumClamp(r,0,255);
 rgba->g=(B)aaNumClamp(g,0,255);
 rgba->b=(B)aaNumClamp(b,0,255);
 rgba->a=yuva->a;
 return RET_YES;
 }



 B aaYuvaFromRgba                      (_yuva*yuva,_rgba*rgba)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yuva==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 yuva->y=rgba->r*.299000+rgba->g*.587000+rgba->b*.114000;
 yuva->u=rgba->r*-.168736+rgba->g*-.331264+rgba->b*.500000+128;
 yuva->v=rgba->r*.500000+rgba->g*-.418688+rgba->b*-.081312+128;
 yuva->a=rgba->a;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaHlsaSet                           (_hlsa*hlsa,B h,B l,B s,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hlsa==NULL) { return RET_BADPARM; }
 hlsa->h=h;
 hlsa->l=l;
 hlsa->s=s;
 hlsa->a=a;
 return RET_YES;
 }



 B aaHlsaCopy                          (_hlsa*hlsa,_hlsa*shlsa)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(shlsa==NULL) { return RET_BADPARM; }
 return(aaHlsaSet(hlsa,shlsa->h,shlsa->l,shlsa->s,shlsa->a));
 }




 B aaHlsaAdjust                        (_hlsa*hlsa,N hamnt,N lamnt,N samnt,N aamnt)
 {
 N h,l,s,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hlsa==NULL) { return RET_BADPARM; }
 h=(N)hlsa->h+hamnt;
 l=(N)hlsa->l+lamnt;
 s=(N)hlsa->s+samnt;
 a=(N)hlsa->a+aamnt;
 h=aaNumClamp(h,0,255);
 l=aaNumClamp(l,0,255);
 s=aaNumClamp(s,0,255);
 a=aaNumClamp(a,0,255);

 hlsa->h=(B)h;
 hlsa->l=(B)l;
 hlsa->s=(B)s;
 hlsa->a=(B)a;
 return RET_YES;
 }






 B aaHlsaToRgba                        (_hlsa*hlsa,_rgba*rgba)
 {
 F hue,lum,sat;
 F rm1,rm2;
 F trm1,trm2,th;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hlsa==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 hue=((F)hlsa->h/255.0)*360.0;
 lum=(F)hlsa->l/255.0;

 sat=(F)hlsa->s/255.0;

 if(sat==0.0) // Grauton, einfacher Fall
  {
  rgba->r=rgba->g=rgba->b=(B)(lum*255.0);
  }
 else
  {
  if(lum<=0.5f) { rm2=lum+lum*sat; }  else { rm2=lum+sat-lum*sat; }
  rm1=2.0f*lum-rm2;
  trm1=rm1; trm2=rm2; th=hue+120.f;
  if      (th>360.0f) th-=360.0f;  else
  if      (th<0.0f)   th+=360.0f;

  if      (th<60.0f)  trm1=trm1+(trm2-trm1)*th/60.0f;  else
  if      (th<180.0f) trm1=trm2;  else
  if      (th<240.0f) trm1=trm1+(trm2-trm1)*(240.0f-th)/60.0f;
  rgba->r=(B)(trm1*255);

  trm1=rm1; trm2=rm2; th=hue;
  if      (th>360.0f) th-=360.0f;  else
  if      (th<0.0f)   th+=360.0f;

  if      (th<60.0f)  trm1=trm1+(trm2-trm1)*th/60.0f;  else
  if      (th<180.0f) trm1=trm2;  else
  if      (th<240.0f) trm1=trm1+(trm2-trm1)*(240.0f-th)/60.0f;
  rgba->g=(B)(trm1*255);

  trm1=rm1; trm2=rm2; th=hue-120.0f;
  if      (th>360.0f) th-=360.0f;  else
  if      (th<0.0f)   th+=360.0f;

  if      (th<60.0f)  trm1=trm1+(trm2-trm1)*th/60.0f;  else
  if      (th<180.0f) trm1=trm2;  else
  if      (th<240.0f) trm1=trm1+(trm2-trm1)*(240.0f-th)/60.0f;
  rgba->b=(B)(trm1*255);
  }
 rgba->a=hlsa->a;
// aaNote(0,"hlsa2rgba  hlsa %i %i %i %i   to rgba %i %i %i %i",hlsa->h,hlsa->l,hlsa->s,hlsa->a,rgba->r,rgba->g,rgba->b,rgba->a);
 return RET_YES;
 }





 B aaHlsaFromRgba                      (_hlsa*hlsa,_rgba*rgba)
 {
 B minval,maxval;
 F mdiff,msum;
 F rnorm,gnorm,bnorm;
 F lum,sat,hue;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hlsa==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 minval=aaNumMin(rgba->r,aaNumMin(rgba->g,rgba->b));
 maxval=aaNumMax(rgba->r,aaNumMax(rgba->g,rgba->b));
 mdiff=(F)(maxval)-(F)(minval);
 msum=(F)(maxval)+(F)(minval);
 lum=msum/510.0f;
 sat=0.0f;
 hue=0.0f;
 if(maxval!=minval)
  {
  rnorm=(maxval-rgba->r)/mdiff;
  gnorm=(maxval-rgba->g)/mdiff;
  bnorm=(maxval-rgba->b)/mdiff;
  sat=(lum<=0.5f)?(mdiff/msum):(mdiff/(510.0f-msum));
  if(rgba->r==maxval) hue=60.0f*(6.0f+bnorm-gnorm);
  if(rgba->g==maxval) hue=60.0f*(2.0f+rnorm-bnorm);
  if(rgba->b==maxval) hue=60.0f*(4.0f+gnorm-rnorm);
  if(hue>360.0f)      hue=hue-360.0f;
  }
 hlsa->h=(B)((hue/360.0)*255.0);
 hlsa->l=(B)(lum*255.0);
 hlsa->s=(B)(sat*255.0);
 hlsa->a=rgba->a;
/// aaNote(0,"rgba2hlsa  rgba %i %i %i %i   to hlsa %i %i %i %i\nhue=%.2lf\nsat=%.2f",rgba->r,rgba->g,rgba->b,rgba->a,hlsa->h,hlsa->l,hlsa->s,hlsa->a,hue,sat);
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/


 _cord*aaCord                          (_cord*cd,N x,N y)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cd==NULL) { return NULL; }
 cd->x=x;
 cd->y=y;
 return cd;
 }




 _size*aaSize                          (_size*sz,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sz==NULL) { return NULL; }
 sz->w=w;
 sz->h=h;
 return sz;
 }





 _rect*aaRect                          (_rect*rc,N x,N y,H w,H h)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rc==NULL) { return NULL; }
 rc->x=x;
 rc->y=y;
 rc->w=w;
 rc->h=h;
 return rc;
 }





 _rgba*aaRgba                          (_rgba*pn,B r,B g,B b,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(pn==NULL) { return NULL; }
 pn->r=r;
 pn->g=g;
 pn->b=b;
 pn->a=a;
 return pn;
 }






 _yuva*aaYuva                          (_yuva*yu,B y,B u,B v,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(yu==NULL) { return NULL; }
 yu->y=y;
 yu->u=u;
 yu->v=v;
 yu->a=a;
 return yu;
 }






 _hlsa*aaHlsa                          (_hlsa*hl,B h,B l,B s,B a)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hl==NULL) { return NULL; }
 hl->h=h;
 hl->l=l;
 hl->s=s;
 hl->a=a;
 return hl;
 }





/*-----------------------------------------------------------------------*/

 B aaGfxClawInit                       (_gfxclaw*gfxclaw)
 {
 H mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(gfxclaw==NULL) { return RET_BADPARM; }
 mx=aaElementCount(gfxclaw->rc);
 if(aaElementCount(gfxclaw->sz)!=mx) { oof; }
 if(aaElementCount(gfxclaw->cd)!=mx) { oof; }
 if(aaElementCount(gfxclaw->pn)!=mx) { oof; }
 if(aaElementCount(gfxclaw->yv)!=mx) { oof; }
 if(aaElementCount(gfxclaw->hl)!=mx) { oof; }
 aaMemoryFill(gfxclaw,sizeof(_gfxclaw),0);
 gfxclaw->rc[0]=&gfxclaw->rc0; gfxclaw->rc[1]=&gfxclaw->rc1; gfxclaw->rc[2]=&gfxclaw->rc2;  gfxclaw->rc[3]=&gfxclaw->rc3;
 gfxclaw->sz[0]=&gfxclaw->sz0; gfxclaw->sz[1]=&gfxclaw->sz1; gfxclaw->sz[2]=&gfxclaw->sz2;  gfxclaw->sz[3]=&gfxclaw->sz3;
 gfxclaw->cd[0]=&gfxclaw->cd0; gfxclaw->cd[1]=&gfxclaw->cd1; gfxclaw->cd[2]=&gfxclaw->cd2;  gfxclaw->cd[3]=&gfxclaw->cd3;
 gfxclaw->pn[0]=&gfxclaw->pn0; gfxclaw->pn[1]=&gfxclaw->pn1; gfxclaw->pn[2]=&gfxclaw->pn2;  gfxclaw->pn[3]=&gfxclaw->pn3;
 gfxclaw->yv[0]=&gfxclaw->yv0; gfxclaw->yv[1]=&gfxclaw->yv1; gfxclaw->yv[2]=&gfxclaw->yv2;  gfxclaw->yv[3]=&gfxclaw->yv3;
 gfxclaw->hl[0]=&gfxclaw->hl0; gfxclaw->hl[1]=&gfxclaw->hl1; gfxclaw->hl[2]=&gfxclaw->hl2;  gfxclaw->hl[3]=&gfxclaw->hl3;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaPoolCreate                        (HP handle,H bytesperblock,H blocksperpage,H maxpages)
 {
 B ret;
 _aa_poolobject*poop;
 H add;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if((ret=aa_ObjectCreate(aa.pool_system.object_id,handle,(VP)&poop))!=RET_YES) { oops; return ret; }
 poop->self_handle=*handle;
 ret=RET_YES;
 while(1)
  {
  if(bytesperblock==0||bytesperblock>_1GIG) { ret=RET_BOUNDS; break; }
  if(blocksperpage==0||blocksperpage>_1GIG) { ret=RET_BOUNDS; break; }
  if(maxpages==0||maxpages>_1GIG) { ret=RET_BOUNDS; break; }
  poop->status.max_possible_blocks=(Q)blocksperpage*(Q)maxpages;
  poop->status.max_possible_memory=poop->status.max_possible_blocks*(Q)bytesperblock;
  if(poop->status.max_possible_blocks>_2GIG) { ret=RET_BOUNDS; break; }
  poop->status.blocks_per_page=blocksperpage;
  poop->status.bytes_per_block=bytesperblock;
  poop->status.max_pages=maxpages;
  poop->id_counter=1;
  add=poop->status.blocks_per_page;
  add=add/10; // 10% pre-alloced
  add=aaNumFloor(add,10); // minimum of 10 pages
  add=aaNumRoof(add,100); // max of 100 pages
  poop->pages_topup_amount=add;
  poop->pages_topup_threshold=poop->pages_topup_amount/10;
  if((poop->pages_topup_amount-poop->pages_topup_threshold)<10) { poop->pages_topup_amount+=10; }
  if((ret=aa_PoolSystemAddPages((VP)&poop,poop->pages_topup_amount))!=YES) { break; }
  break;
  }
 if(ret!=RET_YES)
  {
  aaPoolDestroy(*handle);
  *handle=0;
  return ret;
  }
 return RET_YES;
 }





 B aaPoolDestroy                       (H handle)
 {
 B ret;
 _aa_poolobject*poop;
 B isprot;
 H page_index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 for(page_index=0;page_index<poop->pages_allocated;page_index++)
  {
  if(poop->page[page_index].blocks_allocated==0) { continue; }
  if((ret=aaMemoryRelease(poop->page[page_index].block_memory))!=YES) { oops; break; }
  if((ret=aaMemoryRelease(poop->page[page_index].block_state))!=YES) { oops; break; }
  }
 if(page_index!=0)
  {
  aaMemoryRelease(poop->page);
  }
 aa_ObjectDestroy(aa.pool_system.object_id,handle);
 return RET_YES;
 }



 B aaPoolStatus                        (H handle,_poolstatus*poolstatus)
 {
 B ret;
 _aa_poolobject*poop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolstatus) { aaMemoryCopy(poolstatus,sizeof(_poolstatus),&poop->status); }
 return RET_YES;
 }




 B aaPoolStatusToString                (H handle,_poolstatus*poolstatus,VP str)
 {
 B ret;
 _aa_poolobject*poop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolstatus) { aaMemoryCopy(poolstatus,sizeof(_poolstatus),&poop->status); }
 if(str)
  {
  aaStringNull(str);
  aaStringAppendf(str,"bytes_per_block=%u     \n",poop->status.bytes_per_block);
  aaStringAppendf(str,"blocks_per_page=%u  \n",poop->status.blocks_per_page);
  aaStringAppendf(str,"max_Pages=%u\n\n",poop->status.max_pages);
  aaStringAppendf(str,"block_count=%u  \n",poop->status.block_count);
  aaStringAppendf(str,"max_possible_blocks=%I64u  \n",poop->status.max_possible_blocks);
  aaStringAppendf(str,"max_possible_memory=%I64u  \n",poop->status.max_possible_memory);
//  aaStringAppendf(str,"total_blocks_allocated=%u  \n",poop->status.total_blocks_allocated);
//  aaStringAppendf(str,"total_blocks_inuse=%u  \n",poop->status.total_blocks_inuse);
  aaStringAppendf(str,"-----------------\n");
  }
 return RET_YES;
 }






 B aaPoolBlockNew                      (H handle,_poolblock*poolblock)
 {
 B ret;
 _aa_poolobject*poop;
 H b,p,x=0,y=0;
 H page_index;
 H blok_index;
 H left,bytes;
 BP bp;
 _aa_poolblockstub*blockstub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolblock==NULL) { return RET_BADPARM; }
 aaMemoryFill(poolblock,sizeof(_poolblock),0);
 page_index=F32;
 blok_index=F32;
 for(p=0;p<poop->pages_allocated;p++)
  {
  y=poop->page_pf;
  left=poop->page[y].blocks_allocated-poop->page[y].blocks_inuse;
  if(left==0)
   {
   left=poop->pages_allocated-poop->pages_full;
   if(left<poop->pages_topup_threshold)
    {
    if((ret=aa_PoolSystemAddPages((VP)&poop,poop->pages_topup_amount))!=YES) { oops; }
    }
   left=poop->page[y].blocks_allocated-poop->page[y].blocks_inuse;
   poop->page_pf=poop->pages_full;
   y=poop->page_pf;
   bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
   if((ret=aaMemoryAllocate((VP)&poop->page[y].block_memory,bytes*poop->status.blocks_per_page))!=YES) { oops; }
   aaMemoryNameSet(poop->page[y].block_memory,"poolblock");
   if((ret=aaMemoryAllocate((VP)&poop->page[y].block_state,poop->status.blocks_per_page))!=YES) { oops; }
   aaMemoryNameSet(poop->page[y].block_state,"poolblocksta");
   poop->page[y].blocks_allocated=poop->status.blocks_per_page;
   poop->page[y].blocks_inuse=0;
   poop->page[y].block_pf=0;
//   poop->status.total_blocks_allocated+=poop->status.blocks_per_page;
   }
  for(b=0;b<poop->page[y].blocks_allocated;b++)
   {
   x=poop->page[y].block_pf;
   poop->page[y].block_pf++;
   poop->page[y].block_pf%=poop->page[y].blocks_allocated;
   if(poop->page[y].block_state[x]!=0) { continue; }
   page_index=y;
   blok_index=x;
   break;
   }
  if(page_index!=F32&&blok_index!=F32) break;
  }
 if(page_index==F32||blok_index==F32)
  {
  aaNote(0,"page_index=%i blok_index=%i pgpf=%i pa=%i pul=%i x=%i y=%i",
            page_index,blok_index,poop->page_pf,poop->pages_allocated,
            poop->pages_full,x,y);//
            //,poop->status.total_blocks_allocated,            poop->status.total_blocks_inuse);
  }
 bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 blockstub=(_aa_poolblockstub*)bp;
 blockstub->magic=(H)(PP)aaPoolBlockNew;
 blockstub->state=1;
 blockstub->page_index=page_index;
 blockstub->block_index=blok_index;
 blockstub->id=poop->id_counter;
 poop->id_counter++;
 bp+=sizeof(_aa_poolblockstub);
 poop->page[page_index].block_state[blok_index]=1;
 poop->page[page_index].blocks_inuse++;
// poop->status.total_blocks_inuse++;
 poop->status.block_count++;
 if(poop->page[page_index].blocks_inuse==poop->page[page_index].blocks_allocated)
  {
  poop->pages_full++;
  }
 poolblock->id=blockstub->id;
 poolblock->index= (blockstub->page_index*poop->status.blocks_per_page)+blockstub->block_index;
 poolblock->state=blockstub->state;
 poolblock->mem=bp;
 return RET_YES;
 }






 B aaPoolBlockDelete                   (H handle,VP block)
 {
 B ret;
 _aa_poolobject*poop;
 BP bp;
 _aa_poolblockstub*blockstub;
// H bytes;
 H page_index,blok_index;
 B was_full;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(block==NULL) { return RET_BADPARM; }
 bp=(BP)block;
 bp-=sizeof(_aa_poolblockstub);
 blockstub=(_aa_poolblockstub*)bp;
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 bp=(BP)block;
 //bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
 page_index=blockstub->page_index;
 blok_index=blockstub->block_index;
 if(poop->page[page_index].block_state[blockstub->block_index]==0) { return RET_YES; }
 was_full=NO;
 if(poop->page[page_index].blocks_inuse==poop->page[page_index].blocks_allocated) { was_full=YES; }
 poop->page[page_index].block_state[blockstub->block_index]=0;
 poop->page[page_index].blocks_inuse--;
 poop->status.block_count--;
 if(was_full) {  poop->pages_full--;  }
 poop->page[page_index].block_pf=blok_index;
 poop->page_pf=page_index;
 blockstub->state=0;
 return RET_YES;
 }





 B aaPoolBlockDeleteByIndex            (H handle,H bindex)
 {
 B ret;
 _aa_poolobject*poop;
 BP bp;
 _aa_poolblockstub*blockstub;
 H bytes;
 H page_index,blok_index;
 B was_full;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 page_index=bindex/poop->status.blocks_per_page;
 blok_index=bindex%poop->status.blocks_per_page;
 if(page_index>=poop->pages_allocated) { return RET_BOUNDS; }
 bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 blockstub=(_aa_poolblockstub*)bp;
 if(poop->page[page_index].block_state[blok_index]!=1) { return RET_BADHANDLE; }
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 was_full=NO;
 if(poop->page[page_index].blocks_inuse==poop->page[page_index].blocks_allocated) { was_full=YES; }
 poop->page[page_index].block_state[blockstub->block_index]=0;
 poop->page[page_index].blocks_inuse--;
 poop->status.block_count--;
 if(was_full) {  poop->pages_full--;  }
 poop->page[page_index].block_pf=blok_index;
 poop->page_pf=page_index;
 blockstub->state=0;
 return RET_YES;
 }





 B aaPoolBlockInfoGet                  (H handle,VP block,_poolblock*poolblock)
 {
 B ret;
 _aa_poolobject*poop;
 _aa_poolblockstub*blockstub;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolblock) { aaMemoryFill(poolblock,sizeof(_poolblock),0); }
 bp=(BP)block;
 bp-=sizeof(_aa_poolblockstub);
 blockstub=(_aa_poolblockstub*)bp;
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 bp=(BP)block;
 if(poolblock)
  {
  poolblock->id=blockstub->id;
  poolblock->index= (blockstub->page_index*poop->status.blocks_per_page)+blockstub->block_index;
  poolblock->state=blockstub->state;
  poolblock->mem=bp;
  }
 return RET_YES;
 }






 B aaPoolBlockGetByIndex               (H handle,H bindex,_poolblock*poolblock)
 {
 B ret;
 _aa_poolobject*poop;
 _aa_poolblockstub*blockstub;
 BP bp;
 H page_index;
 H blok_index;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.pool_system.object_id,handle,(VP)&poop,NULL))!=RET_YES) { return ret; }
 if(poolblock) { aaMemoryFill(poolblock,sizeof(_poolblock),0); }
 page_index=bindex/poop->status.blocks_per_page;
 blok_index=bindex%poop->status.blocks_per_page;
 if(page_index>=poop->pages_allocated) { return RET_BOUNDS; }
 bytes=sizeof(_aa_poolblockstub)+poop->status.bytes_per_block;
 bp=&poop->page[page_index].block_memory[(blok_index*bytes)];
 blockstub=(_aa_poolblockstub*)bp;
 if(poop->page[page_index].block_state[blok_index]!=1) { return RET_BADHANDLE; }
 if(blockstub->magic!=(H)(PP)aaPoolBlockNew) { oof; }
 if(blockstub->id==0||blockstub->id>=poop->id_counter) { oof; return RET_FAILED; }
 bp+=sizeof(_aa_poolblockstub);
 if(poolblock)
  {
  poolblock->id=blockstub->id;
  poolblock->index= (blockstub->page_index*poop->status.blocks_per_page)+blockstub->block_index;
  poolblock->state=blockstub->state;
  poolblock->mem=bp;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aa_EventDefine                      (_aa_event*event,B manualreset,B startsignaled,VP fmt,...)
 {
 va_list argptr;
 B txt[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(event==NULL) { return RET_BADPARM; }
 aaMemoryFill(event,sizeof(_aa_event),0);
 if(fmt==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_BADPARM; }
 if(manualreset==YES) event->is_manual_reset=YES;
 if(startsignaled==YES) event->is_signaled=YES;
 event->handle=CreateEvent(NULL,event->is_manual_reset,event->is_signaled,(CP)txt);
 if(event->handle==NULL) { event->handle=NULL; return RET_FAILED; }
 logg("Event %s created",txt);
 return RET_YES;
 }




 B aa_EventUndefine                    (_aa_event*event)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(CloseHandle(event->handle)==FALSE) { return RET_FAILED; }
 aaMemoryFill(event,sizeof(_aa_event),0);
 return RET_YES;
 }





 B aa_EventSignal                      (_aa_event*event)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(event->is_signaled==YES) { return RET_YES; }
 if(SetEvent(event->handle)==FALSE) { oof; oow; Boop; }
 event->is_signaled=YES;
 return RET_YES;
 }



 B aa_EventIsSignaled                  (_aa_event*event)
 {
 H w;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(event->is_signaled==YES) { return RET_YES; }
 w=WaitForSingleObject(event->handle,0);
 if(w==WAIT_FAILED||w==WAIT_ABANDONED) { return RET_FAILED; }
 if(w==WAIT_OBJECT_0) { event->is_signaled=YES; return RET_YES; }
 return RET_NO;
 }





 B aa_EventReset                       (_aa_event*event)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(event==NULL)  { return RET_BADPARM; }
 if(event->handle==NULL) { return RET_NOTOPEN; }
 if(event->is_signaled==NO) { return RET_YES; }
 if(ResetEvent(event->handle)==0) { return RET_FAILED; }
 event->is_signaled=NO;
 return RET_NO;
 }



/*-----------------------------------------------------------------------*/


 B aaFiberCreate                       (HP handle,H ssize,V(*proc)(VP),H data)
 {
 B ret;
 _aa_fiberobject*fibp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(proc==NULL) { return RET_BADPARM; }
 if(aa_FiberSystemModuleInit()!=RET_YES) { return RET_FAILED; }
 if((ret=aa_ObjectCreate(aa.fiber_system.object_id,handle,(VP)&fibp))!=RET_YES) { oops; return ret; }
 fibp->self_handle=*handle;
 fibp->data=data;
 if((fibp->fib=aa.fiber_system.CreateFiber(ssize,(LPFIBER_START_ROUTINE)proc,fibp))==NULL)
  {
  aa_ObjectDestroy(aa.fiber_system.object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }

 fibp->Proc=proc;
 return RET_YES;
 }




 B aaFiberDestroy                      (H handle)
 {
 B ret;
 _aa_fiberobject*fibp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.fiber_system.object_id,handle,(VP)&fibp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 aa.fiber_system.DeleteFiber(fibp->fib);
 aaFiberExtraDataSet(handle,0);
 aa_ObjectDestroy(aa.fiber_system.object_id,handle);
 return RET_YES;
 }



 B aaFiberStatus                       (H handle,_fiberstatus*fiberstatus)
 {
 B ret;
 _aa_fiberobject*fibp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.fiber_system.object_id,handle,(VP)&fibp,NULL))!=RET_YES) { return ret; }
 if(fiberstatus) { aaMemoryCopy(fiberstatus,sizeof(_fiberstatus),&fibp->status); }
 return RET_YES;
 }



 B aaFiberConvert                      (H handle)
 {
 B ret;
 _aa_fiberobject*fibp;
 VP fab;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.fiber_system.object_id,handle,(VP)&fibp,NULL))!=RET_YES) { return ret; }
 if(fibp->status.is_converted==YES) { return RET_YES; }
 fab=aa.fiber_system.ConvertThreadToFiber((VP)&handle);
 if(fab==NULL)  {  return RET_FAILED;  }
 fibp->parent_fib=fab;
 fibp->status.is_converted=YES;
 return RET_YES;
 }





 B aaFiberSwitch                       (H handle)
 {
 B ret;
 _aa_fiberobject*fibp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.fiber_system.object_id,handle,(VP)&fibp,NULL))!=RET_YES) { return ret; }
 fibp->status.switch_count++;
 aa.fiber_system.SwitchToFiber(fibp->fib);
 return RET_YES;
 }




 B aaFiberReturn                       (H handle)
 {
 B ret;
 _aa_fiberobject*fibp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.fiber_system.object_id,handle,(VP)&fibp,NULL))!=RET_YES) { return ret; }
 if(fibp->status.switch_count==0) { oof; return RET_FAILED; }
 fibp->status.switch_count--;
 aa.fiber_system.SwitchToFiber(fibp->parent_fib);
 return RET_YES;
 }



 B aaFiberExtraDataSet                 (H handle,H bytes)
 {
 B ret;
 _aa_fiberobject*fibp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.fiber_system.object_id,handle,(VP)&fibp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)
  {
  if(fibp->status.extra_bytes!=0)
   {
   if((ret=aaMemoryRelease(fibp->status.extra_data))!=RET_YES) { oops; }
   }
  fibp->status.extra_data=NULL;
  fibp->status.extra_bytes=bytes;
  }
 else
  {
  if(fibp->status.extra_bytes==0) {  fibp->status.extra_data=NULL;  }
  if(fibp->status.extra_bytes!=bytes)
   {
   if((ret=aaMemoryMake((VP)&fibp->status.extra_data,bytes))!=RET_YES) { oops; }
   }
  fibp->status.extra_bytes=bytes;
  }
 return RET_YES;
 }






/*-----------------------------------------------------------------------*/



 B aaThreadCreate                      (HP handle,H(*function)(VP parm),H data,B startpaused)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(function==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.thread_system.object_id,handle,(VP)&thrp))!=RET_YES) { oops; return ret; }
 thrp->self_handle=*handle;
 InitializeCriticalSection(&thrp->mutex);
 aa_EventDefine(&thrp->event,YES,NO,"aa.thread.event.%lu.%lu",aa.core_system.launch_tik,*handle);
// thrp->data=data;
 thrp->status.is_paused=YES;
 thrp->status.data=data;
 //aaDebugf("creating  thread %x",*handle);
 //thrp->handle=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)function,thrp,CREATE_SUSPENDED,&thrp->id);
 thrp->handle=CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)function,(VP)*handle,CREATE_SUSPENDED,&thrp->id);
 logg("thread created");
 if(startpaused!=YES)
  {
  logg("Initializing thread to Unpause");
  if((ret=aaThreadPause(*handle,NO))!=YES)
   {
   logg("holy crap %i",ret);
   }
  }
 logg("ThreadCreate success");
 return RET_YES;
 }





 B aaThreadDestroy                     (H handle)
 {
 B ret;
 _aa_threadobject*thrp;
 B isprot;
 H elapsed;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { oof; return RET_FORBIDDEN; }
 //aaDebugf("destroying thread %x",handle);
 if(thrp->status.is_exited!=YES)
  {
  if(is_aa_started_by_winmain==YES)
   {
   if(thrp->status.is_exiting==NO)
    {
    ///aaDebugf("in %s about to threadexit(%x)",__func__,handle);
    if(aaThreadExit(handle)!=RET_YES) {}
    }
   elapsed=0;
   //aaLog(-555,"%i %i %i",aa_is_quit_called,aa_is_quit_received,aa_is_esc);
   while(1)
    {
    if(thrp->status.is_exited==YES)   {  break; }
    if((ret=aaThreadStatus(handle,&thrp->status))!=RET_YES)  { oops; }
    //if(thrp->status.is_exited==YES)    { break; }
    aaSleep(1);
    if(aa_is_quit_called)
     {
     if((elapsed++)>10)    {  break;  }
     }
    else
     {
     if((elapsed++)>100)    {  break;  }
     }
    }
   }
  }
 CloseHandle(thrp->handle);
 if(aa_EventUndefine(&thrp->event)!=RET_YES) {} //  log(eventdestroy failled");
 DeleteCriticalSection(&thrp->mutex);

 aa_ObjectDestroy(aa.thread_system.object_id,handle);
 return RET_YES;
 }






 // the thread shouldnt call this, only the parent to tell the thread to exit
 B aaThreadExit                        (H handle)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
// if(thrp->status.is_exited==YES) {  return RET_YES; }
 if(thrp->status.is_exiting==YES) { return RET_YES; }
// aaLog(-555,"signal %lu",handle);
 if(aa_EventSignal(&thrp->event)!=RET_YES) { oof; Boop; return RET_FAILED; }
 thrp->status.is_exiting=YES;
 return RET_YES;
 }






 B aaThreadStatus                      (H handle,_threadstatus*threadstatus)
 {
 B ret;
 _aa_threadobject*thrp;
 H ec;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if(thrp->status.is_exiting==NO&&thrp->status.is_exited==NO)
  {
  ret=aa_EventIsSignaled(&thrp->event);
  if(ret==RET_YES)
   {
///   aa_DIAG_IGNORECRASH("...  aaThreadStatus>>aa_EventIsSignaled>>YES");
   }
  else
   {
///   aa_DIAG_IGNORECRASH("...  aaThreadStatus>>aa_EventIsSignaled>>NO");
   }

  if(ret==RET_YES)
   {
   //aaDebugf("isexitingb thrhandle=%x",handle);
   thrp->status.is_exiting=YES;
   }
  else
  if(ret!=RET_NO)  { Boop; oof; return RET_FAILED; }
  }
 else
 if(thrp->status.is_exiting==YES&&thrp->status.is_exited==NO)
  {
  if(GetExitCodeThread((HANDLE)thrp->handle,&ec)!=0)
   {
   if(ec!=STILL_ACTIVE)
    {
    thrp->status.is_exited=YES;
    thrp->status.is_exiting=YES;
    thrp->status.exit_code=ec;
    }
   }
  }
 if(threadstatus)
  {
  aaMemoryCopy(threadstatus,sizeof(_threadstatus),&thrp->status); // only 8 bytes
  #if 0
  HP sp,dp;
  aaCast(sp,HP,&thrp->status);
  aaCast(dp,HP,threadstatus);
  dp[0]=sp[0];
  dp[1]=sp[1];
  #endif
  }
 return RET_YES;
 }




 B aaThreadWait                        (H handle,B waitexit)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if((ret=aaThreadStatus(handle,&thrp->status))!=YES) { return ret; }
 if(thrp->status.is_exited==YES) { return RET_YES; }
 if(thrp->status.is_exiting==NO) { return RET_NOTREADY; }
 if(waitexit==YES) { return RET_NOTREADY; }
 return RET_YES;
 }








 B aaThreadPause                       (H handle,B state)
 {
 B ret;
 _aa_threadobject*thrp;
 H e;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if(thrp->status.is_exiting==YES)
  {
  logg("failed to set threadpause to %s, as we are exiting",aaBoolString(state));
  return RET_FAILED;
  }
 if(state==YES)
  {
  if(thrp->status.is_paused==YES) { return RET_YES; }
  if(thrp->status.is_locked==YES) { return RET_FAILED; }
  e=SuspendThread(thrp->handle);
  if(e==F32)
   {
   logg("suspend thread failed");
   return RET_FAILED;
   }
  thrp->status.is_paused=YES;
  }
 else
  {
  if(thrp->status.is_paused==NO) { return RET_YES; }
  if(thrp->status.is_locked==YES) { return RET_FAILED; }
  e=ResumeThread(thrp->handle);
  if(e==F32)
   {
   logg("Resume thread failed");
   return RET_FAILED;
   }
  else
  if(e<=1) { thrp->status.is_paused=NO; } //  see remarks in Win32 ResumeThread,, e is prev count
  else
   {
//   BUG,"ee=%i",e);
   }
  }
 logg("Thread has been set to %s",aaBoolString(thrp->status.is_paused));
 return RET_YES;
 }





 B aaThreadLock                        (H handle,B wait)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 if(wait)  {  EnterCriticalSection(&thrp->mutex);  }
 else      {  if(aa.core_system.TryEnterCriticalSection(&thrp->mutex)==0) { return RET_NOTREADY; }  }
 thrp->status.is_locked=YES;
 return RET_YES;
 }




 B aaThreadUnLock                      (H handle)
 {
 B ret;
 _aa_threadobject*thrp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,handle,(VP)&thrp,NULL))!=RET_YES) { return ret; }
 LeaveCriticalSection(&thrp->mutex);
 thrp->status.is_locked=NO;
 return RET_YES;
 }






/*-----------------------------------------------------------------------*/




 H aa_ProcessCrashTester               (VP parm)
 {
 B ret;
 _aa_threadobject*thrp;
 HP hp;
 H handle;
 _aa_processobject*prop;
// H han;
 DWORD res;
 LRESULT lr;
 _threadunit tu;

 //aaDebugf("crashess");
 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 hp=(HP)parm;
 tu.handle=(H)&hp[0];
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,tu.handle,(VP)&thrp,NULL))!=YES) { oops; }
 if((ret=aaThreadStatus(tu.handle,&tu.status))!=RET_YES) { oops; }
 handle=tu.status.data;
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES)  { oops;  }
 else
  {
  #if aa_USE_GLOBAL_MUTEX == 1
  LeaveCriticalSection(&global_mutex);
  #endif
  while(1)
   {
   #if aa_USE_GLOBAL_MUTEX == 1
   EnterCriticalSection(&global_mutex);
   #endif
   if(prop->status.crash_thread.handle==0) { break; }
   if(is_aa_quit_posted)                   { break; }

   aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);

   if(prop->status.unresponsive_count>5) { prop->status.is_unresponsive=YES; }

   //if(prop->status.is_unresponsive)                     { aaDebugf("ex unresp"); break; }
   if(prop->status.crash_thread.status.is_exited==YES)  { break; }// aaDebugf("ex is ext");  break; }
   if(prop->status.crash_thread.status.is_exiting==YES) { break; } //aaDebugf("ex is ex");  break; }

   if(prop->status.is_ready==YES)
    {
    aaTimerUpdate(&prop->crash_tm,1);
    if(prop->crash_tm.elapsed>prop->status.unresponsive_timeout)
     {
     //SMTO_ERRORONEXIT=0x20
     lr=SendMessageTimeout(prop->status.hwnd,WM_NULL,0,0,SMTO_NORMAL|SMTO_ABORTIFHUNG,prop->status.unresponsive_timeout,&res);
     if(lr==0)      {      prop->status.unresponsive_count++;      }
     else           {      prop->status.unresponsive_count=0;      }
     aaTimerInit(&prop->crash_tm,1);
     }
    }
   #if aa_USE_GLOBAL_MUTEX == 1
   LeaveCriticalSection(&global_mutex);
   #endif
   aaSleep(2);
   }
  }
 //aaDebugf("%i %x about to return from %s",__LINE__,handle,__func__);
 //if(prop->status.crash_thread.handle==0) { BUGGY; }
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 aaThreadQuit(prop->status.crash_thread.handle,RET_YES);
 }





 B aaProcessCreate                     (HP handle,VP fname,VP cmdline,B clmode,B inherit,B startpaused,B detach,B newroot,W showcmd,B isconsole,VP desktop)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret=aa_ProcessSystemCreate(handle,fname,cmdline,clmode,inherit,startpaused,detach,newroot,showcmd,isconsole,desktop);
 if(ret==RET_YES)
  {
  if((ret=aaProcessUnresponsiveTimeoutSet(*handle,500))!=YES) { oops; }
  return RET_YES;
  }
 return ret;
 }






 B aaProcessCreateWithLogin            (HP handle,VP fname,VP cmdline,VP user,VP pass,B detach,B newroot)
 {
 B ret;
 _aa_processobject*prop;
 BOOL bl;
 USER_INFO_1 ui1;
 H sl,flags;
 wchar_t user_name[256];
 wchar_t pass_word[256];
 wchar_t file_name[1513];
 wchar_t cmnd_line[1513];
 B txt[_3K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fname==NULL) { return RET_BADPARM; }
 if(user==NULL)  { return RET_BADPARM; }
 if(aaFileExists(fname)!=YES) { return RET_NOTFOUND; }
 detach&=1;
 newroot&=1;
 if((ret=aa_ObjectCreate(aa.process_system.object_id,handle,(VP)&prop))!=RET_YES) { oops; return ret; }
 prop->self_handle=*handle;
 aaMemoryFill(&ui1,sizeof(ui1),0);
 aaMemoryFill(user_name,sizeof(user_name),0);
 aaMemoryFill(pass_word,sizeof(pass_word),0);
 aaMemoryFill(file_name,sizeof(file_name),0);
 aaMemoryFill(cmnd_line,sizeof(cmnd_line),0);
 if(user)  { aaStringLen(user,&sl);  MultiByteToWideChar(CP_ACP,0,user,sl,user_name,sizeof(user_name));  }
 if(pass)  { aaStringLen(pass,&sl);  MultiByteToWideChar(CP_ACP,0,pass,sl,pass_word,sizeof(pass_word)); }
 aaStringLen(fname,&sl);
 MultiByteToWideChar(CP_ACP,0,fname,sl,file_name,sizeof(file_name));
 if(cmdline)
  {
  aaStringLen(cmdline,&sl);
  MultiByteToWideChar(CP_ACP,0,cmdline,sl,cmnd_line,sizeof(cmnd_line));
  }
 if(NetUserGetInfo(NULL,user_name,1,(LPBYTE*)&prop->user_info)!=NERR_Success)
  {
  ui1.usri1_name=user_name;
  if(pass) ui1.usri1_password=pass_word;
  ui1.usri1_password_age=0;
  ui1.usri1_priv=USER_PRIV_USER;
  ui1.usri1_home_dir=NULL;
  ui1.usri1_comment=NULL;
  ui1.usri1_flags=UF_NORMAL_ACCOUNT|UF_SCRIPT|UF_PASSWD_CANT_CHANGE|UF_DONT_EXPIRE_PASSWD|UF_PASSWD_NOTREQD;
  ui1.usri1_script_path=NULL;
  if(NetUserAdd(NULL,1,(LPBYTE)&ui1,NULL)!=NERR_Success)
   { oof;
   aa_ObjectDestroy(aa.process_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  if(NetUserGetInfo(NULL,user_name,1,(LPBYTE *)&prop->user_info)!=NERR_Success)
   {
   aa_ObjectDestroy(aa.process_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  }

 prop->siw.cb=sizeof(prop->siw);
 if(newroot==YES) {  flags=0x200;  }
 else             {  flags=0x000; }
 if(cmdline)
  {
  aaStringCopyf(txt,"\"%s\"  %s",fname,cmdline);
  aaStringToWideString(txt,cmnd_line);
  //aaNote(0,"%i %i %i",strlen(txt),strlen(cmnd_line),wcslen(cmnd_line));
  //aaStringLen(txt,&sl);
  //MultiByteToWideChar(CP_ACP,0,txt,sl,cmnd_line,sizeof(cmnd_line));
//  flags+=0x400;
  bl=aa.core_system.CreateProcWithLogin(user_name,L".",(pass)?pass_word:0,0x00000001,0,cmnd_line,flags,NULL,NULL,&prop->siw,&prop->pi);
//  bl=aa.core_system.CreateProcWithLogin(user_name,L".",(pass)?pass_word:0,0x00000001, file_name,cmnd_line, flags, NULL, NULL,&prop->siw, &prop->pi);
  }
 else
  {
  bl=aa.core_system.CreateProcWithLogin(user_name,L".",(pass)?pass_word:0,0x00000001,0,file_name,flags,NULL,NULL,&prop->siw,&prop->pi);
  }
 if(bl==0)
  {
  oow;
  if(prop->user_info) { NetApiBufferFree(prop->user_info); }
  aa_ObjectDestroy(aa.process_system.object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 prop->status.is_login=YES;
 aaTimerTikGet(&prop->ms_root);
 if(detach==YES) { prop->status.is_detached=YES; }
 // if(deleteuser==YES) { prop->status.delete_user=YES; }
 prop->status.tid=prop->pi.dwThreadId;
 prop->status.pid=prop->pi.dwProcessId;
 prop->status.thread_handle=prop->pi.hThread;
 prop->status.process_handle=prop->pi.hProcess;
 if(newroot) { prop->status.is_newroot=YES; }
 aaStringCopy(prop->status.user,user);
 aaStringCopy(prop->status.pass,pass);
 return RET_YES;
 }






 B aaProcessDestroy                    (H handle)
 {
 B ret;
 _aa_processobject*prop;
 B isprot;
 H elapsed,sl,cnt;
 wchar_t user_name[256];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }

 if(prop->status.crash_thread.handle!=0)
  {
  ///aaDebugf("in %s (%x) about to threadexit(%x)",__func__,handle,prop->status.crash_thread.handle);
  if((ret=aaThreadExit(prop->status.crash_thread.handle))!=YES) { oops; }
  cnt=0;
  while(1)
   {
   aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
   if(prop->status.crash_thread.status.is_exited) { break; }
   //if((ret=aaThreadWait(dnsp->thread.handle,YES))==RET_YES) { break; }
   //if(ret!=RET_NOTREADY) { oops; }
   cnt++;
   aaSleep(1);
   if(cnt>10) { break; }
   }
  if((ret=aaThreadDestroy(prop->status.crash_thread.handle))!=YES) { oops; }
  prop->status.crash_thread.handle=0;
  }

 if(prop->status.is_login==YES)
  {
  if(prop->status.is_detached==NO)
   {
   if(prop->pi.dwThreadId) { PostThreadMessage(prop->pi.dwThreadId,WM_QUIT,0,0); }
   if(prop->pi.hProcess) { CloseHandle(prop->pi.hProcess);  }
   if(prop->pi.hThread) { CloseHandle(prop->pi.hThread);    }
   aaMemoryFill(user_name,sizeof(user_name),0);
   aaStringLen(prop->status.user,&sl);
   MultiByteToWideChar(CP_ACP,0,(LPCSTR)prop->status.user,sl,user_name,sizeof(user_name));
   ///if(NetUserDel(NULL,user_name)!=NERR_Success) { oof; }
   if(prop->user_info) { NetApiBufferFree(prop->user_info); }
   }
  aa_ObjectDestroy(aa.process_system.object_id,handle);
  return RET_YES;
  }

 // dont allow processes which are newroot and paused as they will never have a chance to resume
 // if(prop->status.is_newroot==YES&&prop->status.is_paused==NO&&prop->status.is_unresponsive==NO&&prop->status.is_ready==YES)
 if(prop->status.is_newroot==YES||prop->status.is_detached==YES)
  {
  if(prop->status.is_paused==NO&&prop->status.is_unresponsive==NO&&prop->status.is_ready==YES)
   {
   aa_ObjectDestroy(aa.process_system.object_id,handle);
   return RET_YES;
   }
  }
 if(prop->status.is_exited==YES) {} // logg("is already exited");
 else
 if(prop->status.is_detached!=YES)
  {
  if(prop->status.is_exiting==NO)
   {
   if(aaProcessExit(handle)!=RET_YES) {} // logg("fail on quit");
   logg("process quited");
   }
  elapsed=0;
  while(1)
   {
   if(aaProcessStatus(handle,NULL)!=RET_YES)    {        }//    logg("failed on process status during destroy");
   if(prop->status.is_exited==YES)              { break; }//    logg("process is exit code= %i",prop->status.exit_code);
   if(prop->status.is_unresponsive==YES)        { break; }
   aaSleep(1);
   elapsed+=3;
   if(elapsed>1000) { break; }//   logg("Timeout waiting for process to exit");
   }
  if(prop->status.is_exited==NO)
   {
   if(TerminateProcess((HANDLE)prop->pi.hProcess,(UINT)123)==FALSE) {}//  logg("Failed to terminate process");
   }
  }
 if(prop->pi.hThread)  { CloseHandle(prop->pi.hThread);  prop->pi.hThread=0; }
 if(prop->pi.hProcess) { CloseHandle(prop->pi.hProcess); prop->pi.hProcess=0; }
 aa_ObjectDestroy(aa.process_system.object_id,handle);
 return RET_YES;
 }








 B aaProcessExit                       (H handle)
 {
 B ret;
 _aa_processobject*prop;
 H go,cnt;//ex

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }

 if(prop->status.is_exiting==YES) { return RET_YES;  }
 //if(prop->status.is_exited==YES)  {  return RET_YES;  }
 aaProcessStatus(handle,0);

 if(prop->status.crash_thread.handle!=0)
  {
  ///aaDebugf("in %s (%x) about to threadexit(%x)",__func__,handle,prop->status.crash_thread.handle);
  if((ret=aaThreadExit(prop->status.crash_thread.handle))!=YES) { oops; }
  cnt=0;
  while(1)
   {
   aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
   ///aaDebugf("chh ing=%i ited=%i",prop->status.crash_thread.status.is_exiting,  prop->status.crash_thread.status.is_exited);
   if(prop->status.crash_thread.status.is_exited) { break; }
   cnt++;
   aaSleep(1);
   if(cnt>10) { break; }
   }
  if(cnt>5) { aaNote(0,"xzcn %i",cnt); }
  if((ret=aaThreadDestroy(prop->status.crash_thread.handle))!=YES) { oops; }
  prop->status.crash_thread.handle=0;
  }
 // aaDebugf("%s %i .. %i %i ",__func__,__LINE__,prop->status.is_exited, prop->status.is_ready);
 if(prop->status.is_exited==NO&&prop->status.is_ready==YES)
  {
  go=0;
  ///aaDebugf("%s %i",__func__,__LINE__);
  while(1)
   {
   if(prop->status.is_exiting) { break; }
   if(PostThreadMessage(prop->pi.dwThreadId,WM_QUIT,0,0)!=0) {  break; } //BUGGY;
   if(GetLastError()==ERROR_INVALID_THREAD_ID) {  break; }
   go++;
   aaSleep(4);
   if(go<10) { continue; }
   TerminateProcess(prop->pi.hProcess,(UINT)123);
   prop->status.is_exiting=YES;
   break;
   }
  }
 else
 if(prop->status.is_exited==NO&&prop->status.is_ready==NO)
  {
  if(TerminateProcess(prop->pi.hProcess,(UINT)123)==0)   { oof;  oow; oof; return RET_FAILED; }
  }
 prop->status.is_exiting=YES;
 return RET_YES;
 }






 B aaProcessPause                      (H handle,B state)
 {
 B ret;
 _aa_processobject*prop;
 H e;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 //aaDebugf("%s %i",__func__,state);
 if(prop->status.is_exiting==YES)
  {
  logg("failed to set processpause to %s, as we are exiting",aaBoolString(state));
  return RET_FAILED;
  }
 if(state==YES)
  {
  if(prop->status.is_paused==YES) { return RET_YES; }// "status is already paused");
  e=SuspendThread(prop->pi.hThread);
  if(e==F32) { return RET_FAILED; } // logg("suspend thread failed in process pause");
  prop->status.is_paused=YES;
  }
 else
  {
  if(prop->status.is_paused==NO) { return RET_YES; }//BUG,"pausing already off"
  e=ResumeThread(prop->pi.hThread);
  if(e==F32) { return RET_FAILED; } // logg("Resume thread failed in process pause");
  else
  if(e<=1) { prop->status.is_paused=NO; }
  }
 logg("Process has been set to %s",aaBoolString(prop->status.is_paused));
 return RET_YES;
 }






 B aaProcessStatus                     (H handle,_processstatus*processstatus)
 {
 B ret;
 _aa_processobject*prop;
 H rc,ec;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 aaTimerTikElapsed(prop->ms_root,&prop->status.ms);

  if(prop->status.is_ready!=YES)
   {
   rc=WaitForInputIdle(prop->pi.hProcess,0);
   if(rc==0)
    {
    EnumThreadWindows(prop->status.tid,aa_ProcessSystemEnum,(LPARAM)prop);
    if(prop->status.hwnd==0) { EnumThreadWindows(GetCurrentThreadId(),aa_ProcessSystemEnum,(LPARAM)prop);     }
    if(prop->status.hwnd==0)
     {
     //aaDebugf("shit one");
     }
    prop->status.is_ready=YES;
    }
   else
    {
    if(prop->status.ms>500)
     {
     EnumThreadWindows(prop->status.tid,aa_ProcessSystemEnum,(LPARAM)prop);
     if(prop->status.hwnd==0) { EnumThreadWindows(GetCurrentThreadId(),aa_ProcessSystemEnum,(LPARAM)prop);     }
     if(prop->status.hwnd==0)
      {
      //aaDebugf("shit two");
      }
     prop->status.is_ready=YES;
     }
    }
   }
 else
  {

  if(prop->status.crash_thread.status.is_exited&&prop->status.crash_thread.status.is_exiting)
   {
   if(prop->status.is_exiting&&prop->status.is_exited==NO)
    {
    if((rc=GetExitCodeThread((HANDLE)prop->pi.hThread,&ec))!=0)
     {
     if(ec!=STILL_ACTIVE)
      {
      prop->status.is_exited=YES;
      //prop->status.is_exiting=YES;
      prop->status.exit_code=ec;
      ///aaDebugf("@@ %i,%i,%i",prop->status.is_exited,prop->status.is_exiting,prop->status.exit_code);
      }
     }
    }
   }

  if(prop->status.crash_thread.handle==0)
   {
   if(prop->crash_tm.magic==0) // use this to check if really first time, otherwise on ProcessExit , clearing crash_handle will cause this to recreate
    {
    aaTimerInit(&prop->crash_tm,1);
    if((ret=aaThreadCreate(&prop->status.crash_thread.handle,aa_ProcessCrashTester,handle,NO))!=YES) { oops; }
    aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
    }
   }
  else
   {
   prop->crash_tm_counter++;
   if(aaNumIsMod(prop->crash_tm_counter,5))
    {
    ret=aaThreadStatus(prop->status.crash_thread.handle,&prop->status.crash_thread.status);
    if(ret!=YES) oops;

    if(prop->status.crash_thread.status.is_exiting||prop->status.crash_thread.status.is_exited)
     {
     //aaDebugf("crashthread exiting %i exited %i",prop->status.crash_thread.status.is_exiting,prop->status.crash_thread.status.is_exited);
     }
    if(prop->status.is_exiting||prop->status.is_exited)
     {
  //   aaDebugf("pro exiting %i exited %i",prop->status.is_exiting,prop->status.is_exited);
     }
    if((rc=GetExitCodeThread((HANDLE)prop->pi.hThread,&ec))!=0)
     {
     if(ec!=STILL_ACTIVE)
      {
      prop->status.is_exited=YES;
      //prop->status.is_exiting=NO;
      prop->status.exit_code=ec;
//      aaDebugf("<> %i,%i,%i",prop->status.is_exited,prop->status.is_exiting,prop->status.exit_code);
      }
     }
    else
     {
     ///aaDebugf("?");
     }

    }
   }
  }

 if(processstatus) { aaMemoryCopy(processstatus,sizeof(_processstatus),&prop->status); }
 return RET_YES;
 }








 B aaProcessStatusToString             (H handle,_processstatus*processstatus,VP str)
 {
 B ret;
 _processstatus ps;
 _processstatus*psp;
 B buf[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str) { aaStringNull(str); }
 if(processstatus==NULL) psp=(_processstatus*)&ps;
 else             psp=(_processstatus*)processstatus;
 if((ret=aaProcessStatus(handle,psp))!=YES) {  return ret; }
 if(str)
  {
  aaStringNull(buf);
  aaStringAppendf(buf,"is_paused=%i   ",psp->is_paused);
  aaStringAppendf(buf,"is_exiting=%i ",psp->is_exiting);
  aaStringAppendf(buf,"is_exited=%i  ",psp->is_exited);
  aaStringAppendf(buf,"is_ready=%i ",psp->is_ready);
  aaStringAppendf(buf,"is_inherit=%i ",psp->is_inherit);
  aaStringAppendf(str,"%s\n",buf);
  aaStringNull(buf);
  aaStringAppendf(buf,"is_detached=%i ",psp->is_detached);
  aaStringAppendf(buf,"is_newroot=%i ",psp->is_newroot);
  aaStringAppendf(buf,"is_console=%i ",psp->is_console);
  aaStringAppendf(buf,"is_login=%i ",psp->is_login);
  aaStringAppendf(buf,"is_unresponsive=%i ",psp->is_unresponsive);
  aaStringAppendf(buf,"unresponsive_count=%i ",psp->unresponsive_count);
  aaStringAppendf(str,"%s\n",buf);
  aaStringNull(buf);
  //aaStringAppendf(buf,"del_user=%i ",psp->delete_user);
  aaStringAppendf(buf,"exit_code=%i  ",psp->exit_code);
  aaStringAppendf(buf,"ms=%i ",psp->ms);
  //aaStringAppendf(str,"%s\n",buf);
  //aaStringNull(buf);
  aaStringAppendf(buf,"tid=%-8u  ",psp->tid);
  aaStringAppendf(buf,"pid=%-u     ",psp->pid);
  aaStringAppendf(buf,"thread_han=0x%08x   ",psp->thread_handle);
  aaStringAppendf(buf,"process_han=0x%08x ",psp->process_handle);
  aaStringAppendf(str,"%s\n",buf);
  //aaStringNull(buf);
  ///aaStringAppendf(buf,"user=%s    ",psp->user);
  //aaStringAppendf(buf,"pass=%s    ",psp->pass);
  //aaStringAppendf(str,"%s\n",buf);
  aaStringNull(buf);
  aaStringAppendf(buf,"hwnd=0x%08x ",psp->hwnd);
  aaStringAppendf(str,"%s\n",buf);
  ///aaStringNull(buf);
  //aaStringAppendf(buf,"file_name=%s ",psp->file_name);
  //aaStringAppendf(str,"%s\n",buf);
  ////aaStringNull(buf);
  ///aaStringAppendf(buf,"cmnd_line=%s ",psp->cmd_line);
  ///aaStringAppendf(str,"%s\n",buf);
  }
 return RET_YES;
 }







 B aaProcessUnresponsiveTimeoutSet     (H handle,H ms)
 {
 B ret;
 _aa_processobject*prop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 if(ms<100||ms>5000) { oops; return RET_BOUNDS; }
 prop->status.unresponsive_timeout=ms;
 return RET_YES;
 }





 B aaProcessRetry                      (H handle)
 {
 B ret;
 _aa_processobject*prop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.process_system.object_id,handle,(VP)&prop,NULL))!=RET_YES) { return ret; }
 if(prop->status.crash_thread.handle==0) { return RET_FAILED; }
 if(is_aa_quit_posted) {  return RET_FAILED; }
 if(prop->status.is_unresponsive!=YES) { return RET_YES; }
 prop->status.is_unresponsive=NO;
 prop->status.unresponsive_count=0;
 aaTimerInit(&prop->crash_tm,1);
 return RET_YES;
 }






 B aaProcessSpawn                      (VP fname,VP cmdline,W showcmd,HP prochan,HP procid)
 {
 B txt[_1K];
 SHELLEXECUTEINFO execinfo;
 BOOL bl;
 HANDLE ss;
 HANDLE hh;
 PROCENTRY32 entry;
 H num;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&execinfo,sizeof(execinfo),0);
 if(prochan) { *prochan=0; }
 if(procid) { *procid=0; }
 if(fname==NULL&&cmdline==NULL) { return RET_BADPARM; }
 aaStringNull(txt);
 execinfo.cbSize=sizeof (execinfo);
 execinfo.fMask=SEE_MASK_NOCLOSEPROCESS|SEE_MASK_FLAG_NO_UI;
 //execinfo.fMask|= 0x00000100; // no async
 //execinfo.fMask|= 0x00100000; // asyncok;
 // was  execinfo.fMask=SEE_MASK_NOCLOSEPROCESS|0x02000000|0x00000100;//SEE_MASK_WAITFORINPUTIDLE;

 // 0x02000000=waitforinputidle
 // 0x00000100=SEE_MASK_NOASYNC
 // 0x00000400=SEE_MASK_FLAG_NO_UI
 // 0x00008000=SEE_MASK_NO_CONSOLE

 //|0x00000100; //0x02000000;///|0x00000100;//|0x00008000|0x00000400;
 //SEE_MASK_NO_CONSOLE|SEE_MASK_NO_UI;//SEE_MASK_WAITFORINPUTIDLE;
 //execinfo.fMask=SEE_MASK_NOCLOSEPROCESS|0x00800000|0x02000000;//|0x00000100;
 //aaLog(-555,"spawing %s - %s",fname,cmdline);
 execinfo.hwnd=NULL;
 execinfo.lpVerb="open";
 if(fname)   execinfo.lpFile=fname;
 if(cmdline) execinfo.lpParameters=cmdline;
 execinfo.nShow=showcmd;
 bl=ShellExecuteEx(&execinfo);
 if(bl==FALSE) { return RET_FAILED; }
 if(prochan)
  {
  *prochan=(H)execinfo.hProcess;
  }
 if(procid)
  {
  if((ss=aa.core_system.Create32Snapshot(0x00000002,0))==INVALID_HANDLE_VALUE) {  oof; }
  num=0;
  while(1)
   {
   entry.dwSize=sizeof(PROCENTRY32);
   if(num==0) { bl=aa.core_system.Process32First(ss,&entry); }
   else       { bl=aa.core_system.Process32Next(ss,&entry); }
   if(bl==FALSE) { break; }
   num++;
   if(aaStringICompare(entry.szExeFile,fname,0)!=YES) { continue; }
   if((hh=OpenProcess(PROCESS_QUERY_INFORMATION,FALSE,entry.th32ProcessID))==NULL) { oof; }
   CloseHandle(hh);
   *procid=entry.th32ProcessID;
   break;
   }
  CloseHandle(ss);
  }



 return RET_YES;
 }





 B aaProcessLaunch                     (VP exefile,VP exeargs,VP workdir,W showcmd,HP prochan,HP procid)
 {
 PROCESS_INFORMATION processInfo;
 STARTUPINFO startupInfo;
 H flags;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&startupInfo,sizeof(startupInfo),0);
 if(prochan) { *prochan=0; }
 if(procid) { *procid=0; }
 startupInfo.cb=sizeof(startupInfo);
 startupInfo.dwFlags=STARTF_USESHOWWINDOW;
 startupInfo.wShowWindow=showcmd;
 flags=0;
 if(1) { flags|=CREATE_NEW_PROCESS_GROUP; }
 if(0) { flags|=CREATE_NEW_CONSOLE; }
 if(1) { flags|=CREATE_NO_WINDOW; }
 if(0) { flags|=DETACHED_PROCESS; }
 if(exeargs)
  {
  aaStringCopyf(txt,"\"%s\" %s",exefile,exeargs);
  }
 else
  {
  aaStringCopyf(txt,"\"%s\"",exefile);
  }
 if(CreateProcess(0,(LPTSTR)txt,NULL,NULL,FALSE,flags,NULL,workdir,&startupInfo,&processInfo)==0)
  {
  oow;
  return RET_FAILED;
  }
 if(prochan) { *prochan=(H)processInfo.hProcess; }
 if(procid)  { *procid=(H)processInfo.dwProcessId; }
 return RET_YES;
 }






 B aaProcessIsRunning                  (VP exename,HP count)
 {
 // H e;
 H num,c;
 HANDLE ss;
 PROCENTRY32 entry;
 BOOL bl;
 //DWORD err;
// HANDLE tmp;

 //B fullpath[_1K];
 //H fulllen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 c=0;
 if(count) { *count=0; }
 if(exename==NULL) { return RET_BADPARM; }
 if(aaStringIsEmpty(exename,YES)!=NO) { return RET_BADPARM; }
 //return RET_NO;

 if((ss=aa.core_system.Create32Snapshot(0x00000002,0))==INVALID_HANDLE_VALUE) {  return RET_FAILED; }
 num=0;
 while(1)
  {
  entry.dwSize=sizeof(PROCENTRY32);
  if(num==0) { bl=aa.core_system.Process32First(ss,&entry); }
  else       { bl=aa.core_system.Process32Next(ss,&entry); }
  //aaDebugf("num=%i %i %s",num,bl,entry.szExeFile);
  if(bl==FALSE)
   {
   break;
   }

  num++;
  //aaDebugf(">> %s",entry.szExeFile);
//  aaLog(-1,">> %s",entry.szExeFile);
  if(aaStringICompare(entry.szExeFile,exename,0)==YES) { c++;   }
  }
 CloseHandle(ss);
 if(count) { *count=c; }
 if(c!=0) { return RET_YES; }
 return RET_NO;
 }








 B aaProcessListGather                 (_processlist*processlist)
 {
 H slots,left;
 B ret;
 H index;
 _processentry*processentry;
 PROCENTRY32 entry;
 B space[_1K];
 BOOL bl;
 HANDLE tmp;
// DWORD res;
 HMODULE mod;
 H sl,han;
 ntQueryInformationProcess NtQueryInformationProcess;
 PROCESS_BASIC_INFORMATION pbi;
 VP pebAddress,rtlUserProcParamsAddress;
 UNICODE_STRING commandLine;
 BP tmpmem;
 B buf[_1K];
 //MEMORY_BASIC_INFORMATION memInfo;
 //N done;
 //H off,attempt,from;
 //BP pRTLUserInfo;
 //BP envblock;
 //B ascii,bscii;
 //H len;
 //B str[_8K];
 //C cBuffRTLUserInfo[0x64]={0};
 UNUSE(space);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(processlist);


 mod=GetModuleHandleA("ntdll.dll");
 if(mod==NULL)  {  return RET_FAILED;  }
 aaMemoryFill(processlist,sizeof(_processlist),0);
 processlist->magic=aaHPP(aaProcessListGather);
 slots=60;
 ret=aaMemoryAllocate((VP)&processlist->entry,slots*sizeof(_processentry));
 if(ret!=YES) { oops; }
 aaMemoryNameSet(processlist->entry,"plistent"); //charlie
 han=(H)aa.core_system.Create32Snapshot(1|8|2|4,0);
 if(((H)han)==(H)INVALID_HANDLE_VALUE)
  {
  aaMemoryRelease(&processlist->entry);
  aaMemoryFill(processlist,sizeof(_processlist),0);
  return RET_FAILED;
  }
 index=0;
 while(1)
  {
  processentry=(_processentry*)&processlist->entry[index];

  left=slots-processlist->entries;
  if(left<50)
   {
   slots=slots+(slots/4)+50;
   if((ret=aaMemoryReAllocate((VP)&processlist->entry,slots*sizeof(_processentry)))!=YES) { oops; }
   left=slots-processlist->entries;
   }
  processentry=(_processentry*)&processlist->entry[index];
  processentry->exe_path[0]=0;
  processentry->dev_path[0]=0;
  processentry->cmd_line[0]=0;
  processentry->exe_file[0]=0;
  aaMemoryFill(&entry,sizeof(entry),0);
  entry.dwSize=sizeof(PROCENTRY32);
  if(index==0) { bl=aa.core_system.Process32First((HANDLE)han,&entry); }
  else         { bl=aa.core_system.Process32Next((HANDLE)han,&entry);  }
  if(bl==FALSE)
   {
   if(GetLastError()==ERROR_NO_MORE_FILES) { }
   break;
   }

  if((tmp=OpenProcess(PROCESS_ALL_ACCESS,FALSE,entry.th32ProcessID))!=NULL)
   {
   processentry->process_handle=tmp;
   if((NtQueryInformationProcess=(VP)GetProcAddress(mod,"NtQueryInformationProcess"))!=NULL)
    {
    NtQueryInformationProcess(tmp,0,&pbi,sizeof(pbi),NULL);
    pebAddress=pbi.PebBaseAddress;

    if(ReadProcessMemory(tmp,(PCHAR)pebAddress+0x10,&rtlUserProcParamsAddress,sizeof(PVOID),NULL)!=0)
     {
     if(ReadProcessMemory(tmp,(PCHAR)rtlUserProcParamsAddress+0x40,&commandLine,sizeof(commandLine),NULL)!=0)
      {
      if((ret=aa_MemoryTemp((VP)&tmpmem,_256K,aa_MEMORYTEMP_ProcessList))==RET_YES)
       {
       if(ReadProcessMemory(tmp,commandLine.Buffer,tmpmem,commandLine.Length,NULL)!=0)
        {
        aaStringFromWideString(processentry->cmd_line,(WCHAR*)tmpmem);
        processentry->cmd_line[commandLine.Length/2]=0;
        }
       }
      }
     }
    }

   if(aa.core_system.GetProcessFileName(tmp,(CP)processentry->exe_path,sizeof(processentry->exe_path))!=0)
    {
    aaStringCopyf(processentry->dev_path,"%s",processentry->exe_path);
    aaStringCopy(buf,"\\Device\\Harddisk");
    aaStringLen(buf,&sl);
    if(aaStringNICompare(processentry->exe_path,buf,sl,0)==YES)
     {
     aaStringDeleteChars(processentry->exe_path,0,0,sl);
     }
    }
   CloseHandle(tmp);
   }

  processentry->process_id=entry.th32ProcessID;
  processentry->module_id=entry.th32ModuleID;
  processentry->thread_count=entry.cntThreads;
  processentry->parent_process_id=entry.th32ParentProcessID;
  aaStringCopy(processentry->exe_file,entry.szExeFile);
  //aaDebugf("was %s",processentry->exe_file);
  index++;
  processlist->entries++;
  }
 CloseHandle((HANDLE)han);
 #if 0
 if(aa.input_system.mutex_handle!=0)
  {
  if(!ReleaseMutex(aa.input_system.mutex_handle))  { oof;  }
  aaDebugf("releaSe");
  }
 #endif
 return RET_YES;
 }






 B aaProcessListRelease                (_processlist*processlist)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(processlist);
 if(processlist->magic!=aaHPP(aaProcessListGather)) { return RET_NOTINITIALIZED; }
 if(processlist->entry!=NULL)
  {
  if((ret=aaMemoryRelease(processlist->entry))!=YES) { oops; }
  }
 aaMemoryFill(processlist,sizeof(_processlist),0);
 return RET_YES;
 }


 //T DWORD  (NTAPI  *ntQueryInformationProcess) (HANDLE,DWORD,PVOID,DWORD,PDWORD);
 B aaProcessList                       (HP handle,H index,_processentry*processentry)
 {
 B ret;
 H han;
 PROCENTRY32 entry;
 BOOL bl;
 HANDLE tmp;
 B ok;// ascii;
 B drive;
 B path[_1K];
 B buf[_1K];
 H pos,sl;
 BP tmpmem;
 HMODULE mod;
 VP pebAddress,rtlUserProcParamsAddress;
 UNICODE_STRING commandLine;
 PROCESS_BASIC_INFORMATION pbi;
 ntQueryInformationProcess NtQueryInformationProcess;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 if(processentry==NULL) { return RET_BADPARM; }
 aaMemoryFill(processentry,sizeof(_processentry),0);
 if(index==0)  {  *handle=0;  }
 else          {  if(*handle==0) { return RET_BADHANDLE; }  }
 if(index==0)
  {
  han=(H)aa.core_system.Create32Snapshot(0x00000002,0);
  if(((H)han)==(H)INVALID_HANDLE_VALUE) {  return RET_FAILED; }
  *handle=han;
  }
 han=*handle;
 while(1)
  {
  processentry->exe_path[0]=0;
  processentry->dev_path[0]=0;
  processentry->cmd_line[0]=0;
  processentry->exe_file[0]=0;

  entry.dwSize=sizeof(PROCENTRY32);
  if(index==F32) {  CloseHandle((HANDLE)han);   *handle=0;   return RET_FINISHED;   }
  if(index==0) { bl=aa.core_system.Process32First((HANDLE)han,&entry); }
  else         { bl=aa.core_system.Process32Next((HANDLE)han,&entry); }
  if(bl==FALSE)
   {
   if(GetLastError()==ERROR_NO_MORE_FILES) { break; }
   CloseHandle((HANDLE)han);
   *handle=0;
   return RET_FAILED;
   }
  ok=NO;
  if((tmp=OpenProcess(PROCESS_ALL_ACCESS,FALSE,entry.th32ProcessID))!=NULL)
   {
   processentry->process_handle=tmp;
   mod=GetModuleHandleA("ntdll.dll");
   if((NtQueryInformationProcess=(VP)GetProcAddress(mod,"NtQueryInformationProcess"))!=NULL)
    {
    NtQueryInformationProcess(tmp,0,&pbi,sizeof(pbi),NULL);
    pebAddress=pbi.PebBaseAddress;
    if(ReadProcessMemory(tmp,(PCHAR)pebAddress+0x10,&rtlUserProcParamsAddress,sizeof(PVOID),NULL)!=0)
     {
     if(ReadProcessMemory(tmp,(PCHAR)rtlUserProcParamsAddress+0x40,&commandLine,sizeof(commandLine),NULL)!=0)
      {
      if((ret=aa_MemoryTemp((VP)&tmpmem,_256K,aa_MEMORYTEMP_ProcessList))==RET_YES)
       {
       if(ReadProcessMemory(tmp,commandLine.Buffer,tmpmem,commandLine.Length,NULL)!=0)
        {
        //tmpmem[(_1K-1)*2]=NULL_CHAR;
        aaStringFromWideString(processentry->cmd_line,(WCHAR*)tmpmem);
        processentry->cmd_line[commandLine.Length/2]=0;
        }
       }
      }
     }
    }
   if(aa.core_system.GetProcessFileName(tmp,(CP)processentry->exe_path,sizeof(processentry->exe_path))!=0)
    {
    ok=YES;
    aaStringCopyf(processentry->dev_path,"%s",processentry->exe_path);
    aaStringCopy(buf,"\\Device\\Harddisk");
    aaStringLen(buf,&sl);
    if(aaStringNICompare(processentry->exe_path,buf,sl,0)==YES)
     {
     aaStringDeleteChars(processentry->exe_path,0,0,sl);
     aaStringFindChar(processentry->exe_path,0,&pos,'\\',YES,0,YES);
     if(pos!=F32)
      {
      aaStringDeleteChars(processentry->exe_path,0,0,pos+1);
      for(drive='c';drive<('z'+1);drive++)
       {
       aaStringCopyf(path,"%c:\\%s",drive,processentry->exe_path);
       if(aaFileExists(path)==YES) { break; }
       }
      if(drive!=('z'+1))
       {
       aaStringCopyf(processentry->exe_path,"%s",path);
       aaStringFindChar(processentry->exe_path,0,&pos,'\\',YES,0,NO);
       if(pos!=F32) { processentry->exe_path[pos+1]=NULL_CHAR;  }
       }
      }
     }
    }
   CloseHandle(tmp);
   }
  if(ok==NO)
   {
   aaStringNull(processentry->exe_path);
   }
  processentry->process_id=entry.th32ProcessID;
  processentry->module_id=entry.th32ModuleID;
  processentry->thread_count=entry.cntThreads;
  processentry->parent_process_id=entry.th32ParentProcessID;
  aaStringCopy(processentry->exe_file,entry.szExeFile);
  return RET_YES;
  }
 CloseHandle((HANDLE)han);
 *handle=0;
 return RET_FINISHED;
 }





 B aaProcessListDestroy                (H handle)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(CloseHandle((HANDLE)handle)==0) { return RET_BADHANDLE; }
 return RET_YES;
 }





 B aaProcessThreadList                 (HP handle,H index,_processthreadentry*processthreadentry)
 {
 H han;
 THREADENTRY32 entry;
 BOOL bl;
 //HANDLE tmp;
 //B ok;// ascii;
 //BP bp;
 //B buf[_1K];
// H pos,sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 if(processthreadentry==NULL) { return RET_BADPARM; }
 if(index==0)  {  *handle=0;  }
 else          {  if(*handle==0) { return RET_BADHANDLE; }  }
 aaMemoryFill(processthreadentry,sizeof(_processthreadentry),0);

 if(index==0)
  {
  han=(H)aa.core_system.Create32Snapshot(0x00000004,0);
  if(((H)han)==(H)INVALID_HANDLE_VALUE) {  return RET_FAILED; }
  *handle=han;
  }
 han=*handle;
 while(1)
  {
  aaMemoryFill(&entry,sizeof(entry),0);
  entry.dwSize=sizeof(THREADENTRY32);
  if(index==F32)   {   CloseHandle((HANDLE)han);   *handle=0;   return RET_FINISHED;   }
  if(index==0) { bl=aa.core_system.Thread32First((HANDLE)han,&entry); }
  else         { bl=aa.core_system.Thread32Next((HANDLE)han,&entry); }
  if(bl==FALSE)
   {
   if(GetLastError()==ERROR_NO_MORE_FILES) { break; }
   CloseHandle((HANDLE)han);
   *handle=0;
   return RET_FAILED;
   }
  processthreadentry->thread_id=entry.th32ThreadID;
  processthreadentry->owner_process_id=entry.th32OwnerProcessID;
  return RET_YES;
  }
 CloseHandle((HANDLE)han);
 *handle=0;
 return RET_FINISHED;
 }






 B aaProcessThreadListDestroy          (H handle)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(CloseHandle((HANDLE)handle)==0) { return RET_BADHANDLE; }
 return RET_YES;
 }



// https://msdn.microsoft.com/en-us/library/windows/desktop/ms683189%28v=vs.85%29.aspx

/*Important  The GetExitCodeProcess function returns a valid error
  code defined by the application only after the thread terminates.
  Therefore, an application should not use STILL_ACTIVE (259) as an error code.
  If a thread returns STILL_ACTIVE (259) as an error code,
  applications that test for this value could interpret it to mean
  that the thread is still running and continue to test for the
  completion of the thread after the thread has terminated,
  which could put the application into an infinite loop.
  */

 BOOL SafeTerminateProcess             (HANDLE hProcess,UINT uExitCode)
 {
 DWORD dwTID,dwCode,dwErr;
 HANDLE hProcessDup=INVALID_HANDLE_VALUE;
 HANDLE hRT=NULL;
 HINSTANCE hKernel=GetModuleHandle("Kernel32");
 FARPROC pfnExitProc;
 BOOL bSuccess=FALSE;
 BOOL bDup;

 dwErr=TerminateProcess(hProcess,uExitCode);
 if(dwErr==0)
  {
  oow;
  //aaDebugf("shit");
  return FALSE;
  }
 //dwErr=GetExitCodeProcess((bDup)?hProcessDup:hProcess,&dwCode);
 //aaDebugf("exp=%i dw=%i %i",dwErr,dwCode,STILL_ACTIVE);
 //return RET_FAILED;

 bDup=DuplicateHandle(GetCurrentProcess(),hProcess,GetCurrentProcess(),&hProcessDup,PROCESS_ALL_ACCESS,FALSE,0);
 if(bDup==0) { oow; return FALSE; }

 //aaDebugf("dup=%x",bDup);
 //UNUSE(bDup);

 dwErr=GetExitCodeProcess((bDup)?hProcessDup:hProcess,&dwCode);
 //aaDebugf("exp=%i dw=%i %i",dwErr,dwCode,STILL_ACTIVE);
 if(dwErr!=0&&(dwCode==STILL_ACTIVE))
  {
  pfnExitProc=GetProcAddress(hKernel,"ExitProcess");
  hRT=CreateRemoteThread((bDup)?hProcessDup:hProcess,NULL,0,(LPTHREAD_START_ROUTINE)pfnExitProc,(PVOID)uExitCode,0,&dwTID);
  if(hRT==NULL) { dwErr=GetLastError(); } //aaDebugf("still active, but hrt is nul"); }
  else          { bSuccess=TRUE; } //aaDebugf("stil active, and hrt is good"); }
  }
 else
  {
  dwErr=ERROR_PROCESS_ABORTED;
  bSuccess=TRUE;
  }

 if(hRT)
  {
  //aaDebugf("wait");
  // Must wait process to terminate to guarantee that it has exited...
  WaitForSingleObject((bDup)?hProcessDup:hProcess,INFINITE);
  CloseHandle(hRT);
  bSuccess=TRUE;
  }
 if(bDup) CloseHandle(hProcessDup);
 if(!bSuccess) SetLastError(dwErr);
 return TRUE;//bSuccess;
 }






 B aaProcessTerminateByHandle          (HANDLE handle,W ecode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(SafeTerminateProcess(handle,ecode)==0) { oow; return RET_FAILED; }
 return RET_YES;
 }




 B aaProcessTerminateByPid             (H pid,W ecode)
 {
 B ret;
 HANDLE han;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((han=OpenProcess(PROCESS_TERMINATE,FALSE,pid))==NULL) { return RET_FAILED; }
 ret=aaProcessTerminateByHandle(han,ecode);
 CloseHandle(han);
 return ret;
 }






 B aaProcessRestart                    (VP exename,VP cmdline,HP prochan,HP procid)
 {
 _processentry pe;
 H i,han;
 B ret,flag;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(prochan) { *prochan=0; }
 if(procid) { *procid=0; }
 if(exename==NULL) { return RET_BADPARM; }
 if(aaStringIsEmpty(exename,YES)!=NO) { return RET_BADPARM; }
 flag=0;
 han=0;
 for(i=0;i<F32;i++)
  {
  if((ret=aaProcessList(&han,i,&pe))!=YES) {  break; }
  if(flag==0)
   {
   if(aaStringICompare(pe.exe_file,exename,0)!=YES) { continue; }
   aaStringCopyf(txt,"%s\\%s",pe.exe_path,pe.exe_file);
   aaProcessTerminateByPid(pe.process_id,0);
   if((ret=aaProcessSpawn(txt,cmdline,0,prochan,procid))!=RET_YES) { return ret; }
   flag=1;
   }
  }
 if(han!=0) { aaProcessListDestroy(han); }
 if(flag==1) { return RET_YES; }
 return RET_NOTFOUND;
 }



/*-----------------------------------------------------------------------*/



 BOOL CALLBACK aa_WinEnumProc          (HWND hwnd,LPARAM lparm)
 {
 B ret;
 _aa_winenumobject*wenp;
 H mom,left,add;
 _winenumentry*wnt;

 aaDebugf("%s(%i)",__func__,__LINE__);

 mom=(H)lparm;
 if((ret=aa_ObjectCheck(aa.winenum_system.object_id,mom,(VP)&wenp,NULL))!=RET_YES) { oops;  }
 left=wenp->slots-wenp->status.total_entries;
 add=64;
 if(left<(add/2))
  {
  if((ret=aaMemoryReAllocate((VP)&wenp->mem,(wenp->slots+add)*sizeof(_winenumentry)))!=YES) { oops; }
  wenp->slots+=add;
  }
 aaCast(wnt,_winenumentry*,&wenp->mem[wenp->status.total_entries*sizeof(_winenumentry)]);
   aaDebugf("%s(%i)",__func__,__LINE__);
 if(IsWindow(hwnd)!=0)
  {
  wnt->hwnd=hwnd;
  if(aaHwndInfoGet(wnt->hwnd,NULL,NULL,NULL,wnt->c_txt,wnt->t_txt)!=YES) { return TRUE; }
  wnt->tid=GetWindowThreadProcessId(wnt->hwnd,&wnt->pid);
  if(IsWindowVisible(wnt->hwnd)!=0) { wenp->status.total_visible++; wnt->is_visible=YES; } else { wnt->is_visible=NO; }
  wnt->is_child=NO;
  wnt->is_visible=NO;

  switch(wenp->status.mode)
   {
   case aa_WINENUM_STANDARD:

   aaDebugf("%s(%i)",__func__,__LINE__);
   //if(IsChild((HWND)wenp->status.hanhwn,wnt->hwnd)!=0) { wnt->is_child=YES; } else { wnt->is_child=NO; }
   wnt->parent_hwnd=GetParent(hwnd);
   wnt->owner_hwnd=GetWindow(hwnd,GW_OWNER);
   wenp->status.total_entries++;
   if(wnt->is_child) { wenp->status.total_children++; }
   else              {  wenp->status.total_windows++; }
   break;

   case aa_WINENUM_THREADID:
   aaDebugf("%s(%i)",__func__,__LINE__);
   ///if(IsChild((HWND)wenp->status.hanhwn,wnt->hwnd)!=0) { wnt->is_child=YES; } else { wnt->is_child=NO; }
   wnt->parent_hwnd=GetParent(wnt->hwnd);
   wnt->owner_hwnd=GetWindow(hwnd,GW_OWNER);
   wenp->status.total_entries++;
   if(wnt->is_child) { wenp->status.total_children++; }
   else              {  wenp->status.total_windows++; }
   break;

   case aa_WINENUM_CHILDREN:
   aaDebugf("%s(%i)",__func__,__LINE__);
   //aaDebugf("lin=%i",__LINE__);
   if(IsChild((HWND)wenp->status.hanhwn,wnt->hwnd)!=0) { wnt->is_child=YES; } else { wnt->is_child=NO; }
   wnt->parent_hwnd=GetParent(hwnd);
   wnt->owner_hwnd=GetWindow(hwnd,GW_OWNER);
   wenp->status.total_entries++;
   if(wnt->is_child) { wenp->status.total_children++; }
   else              {  wenp->status.total_windows++; }

   break;
   }

  }
 return TRUE;
 }




 H aa_WinEnumThread                    (VP parm)
 {
 B ret;
 _aa_threadobject*thrp;
 H handle;
 HP hp;
 _threadunit tu;
 _aa_winenumobject*wenp;
 //_threadstatus thread_status;

 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 hp=(HP)parm;
 tu.handle=(H)&hp[0];
 if((ret=aa_ObjectCheck(aa.thread_system.object_id,tu.handle,(VP)&thrp,NULL))!=YES) { oops; }
 if((ret=aaThreadStatus(tu.handle,&tu.status))!=RET_YES) { oops; }
 handle=tu.status.data;
 if(aa_ObjectCheck(aa.winenum_system.object_id,handle,(VP)&wenp,NULL)!=RET_YES) oof;
 ret=RET_YES;
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 while(1)
  {
  #if aa_USE_GLOBAL_MUTEX == 1
  EnterCriticalSection(&global_mutex);
  #endif
  if(is_aa_quit_posted) {  break; }
  //if(wenp->thread_handle==0) { break; }
  aaThreadStatus(tu.handle,&tu.status);
  if(tu.status.is_exiting==YES)    {     break;   }
  ret=RET_YES;
  switch(wenp->status.mode)
   {
   case aa_WINENUM_STANDARD:
   if(EnumWindows(aa_WinEnumProc,(LPARAM)handle)==0) { ret=RET_FAILED;   }
   break;
   case aa_WINENUM_THREADID:
   if(EnumThreadWindows(wenp->status.hanhwn,aa_WinEnumProc,(LPARAM)handle)==0) {  ret=RET_FAILED; }
   break;
   case aa_WINENUM_CHILDREN:
   if(EnumChildWindows((HWND)wenp->status.hanhwn,aa_WinEnumProc,(LPARAM)handle)==0) {  ret=RET_FAILED; }
   break;
   default: oof;
   break;
   }
  wenp->status.in_progress=NO;
  wenp->status.is_completed=YES;
  wenp->status.is_success=YES;
  //if(ret==RET_YES) { wenp->status.is_success=YES; }
  //else             { wenp->status.is_success=YES; } //wenp->status.is_fail=YES;  }
  wenp->sleep_cycle++;
  #if aa_USE_GLOBAL_MUTEX == 1
  LeaveCriticalSection(&global_mutex);
  #endif
  if(aaNumIsMod(wenp->sleep_cycle,10)) { aaSleep(1); }
  else                                 { aaSleep(0); }
  break;
  }
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 aaThreadQuit(tu.handle,ret);
 }




 B aaWinEnumCreate                     (HP handle,B mode,H hanhwn)
 {
 B ret;
 _aa_winenumobject*wenp;
 H c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 switch(mode)
  {
  case aa_WINENUM_STANDARD:
  break;
  case aa_WINENUM_THREADID:
  if(hanhwn==0) { return RET_BADPARM; }
  break;
  case aa_WINENUM_CHILDREN:
  if(hanhwn==0)   {   hanhwn=(H)GetDesktopWindow();   }
  if(hanhwn==0) return RET_BADPARM;
  break;
  default:
  return RET_FAILED;
  }
 if((ret=aa_ObjectCreate(aa.winenum_system.object_id,handle,(VP)&wenp))!=RET_YES) { oops;  return ret; }
 wenp->self_handle=*handle;
 c=10;
 if((ret=aaMemoryAllocate((VP)&wenp->mem,c*sizeof(_winenumentry)))!=YES) { oops; }
 aaMemoryNameSet(wenp->mem,"wenpme"); //charlie
 aaCast(wenp->status.entry,_winenumentry*,wenp->mem);
 wenp->slots=c;
 wenp->status.mode=mode;
 wenp->status.hanhwn=hanhwn;
 wenp->status.in_progress=YES;
// BUG,"%i %i %i",aa.object_system.object[4].instance_limit,aa.object_system.object[4].instance_count,aa.object_system.object[4].instance_slots);
 if((ret=aaThreadCreate(&wenp->thread_handle,aa_WinEnumThread,*handle,NO))!=YES) { oops; }
 return ret;
 }






 B aaWinEnumDestroy                    (H handle)
 {
 B ret;
 _aa_winenumobject*wenp;
 B isprot;
 H cnt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.winenum_system.object_id,handle,(VP)&wenp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { oof; Boop; return RET_FORBIDDEN; }
 if(wenp->thread_handle!=0)
  {
  if((ret=aaThreadExit(wenp->thread_handle))!=YES) { oops; }
  cnt=0;
  while(1)
   {
   aaThreadStatus(wenp->thread_handle,&wenp->thread_status);
   if(wenp->thread_status.is_exited) { break; }
   cnt++;
//   aaYield(aa_askhz);
   aaSleep(1);
   if(cnt>10) { break; }
//   BUG,"%i %i",wenp->thread_status.is_exited,wenp->thread_status.is_exiting);
   }
  //if(cnt>5) BUG,"yzcn %i",cnt);
  if((ret=aaThreadDestroy(wenp->thread_handle))!=YES) { oops; }
  wenp->thread_handle=0;
  }
 if(wenp->slots!=0)
  {
  aaMemoryRelease(wenp->mem);
  wenp->mem=NULL;
  }
 if((ret=aa_ObjectDestroy(aa.winenum_system.object_id,handle))!=YES) { oops;  }
 return RET_YES;
 }




 B aaWinEnumStatus                     (H handle,_winenumstatus*winenumstatus)
 {
 B ret;
 _aa_winenumobject*wenp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.winenum_system.object_id,handle,(VP)&wenp,NULL))!=RET_YES) { return ret; }
 aaYieldRaw();
 aaCast(wenp->status.entry,_winenumentry*,wenp->mem);
 if(winenumstatus)  {  aaMemoryCopy(winenumstatus,sizeof(_winenumstatus),&wenp->status); }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 Z aa__map_mman_error                  (Y err,Z deferr)
 {
 UNUSE(deferr);
 if(err==0) return 0;
 return err;
 }

 Y aa__map_mmap_prot_page              (Z prot)
 {
 Y protect=0;
 if(prot==PROT_NONE) return protect;
 if((prot&PROT_EXEC)!=0)  { protect=((prot&PROT_WRITE)!=0)?PAGE_EXECUTE_READWRITE:PAGE_EXECUTE_READ;   }
 else                     { protect=((prot&PROT_WRITE)!=0)?PAGE_READWRITE:PAGE_READONLY;   }
 return protect;
 }

 Y aa__map_mmap_prot_file              (Z prot)
 {
 Y desiredAccess=0;
 if(prot==PROT_NONE)      return desiredAccess;
 if((prot&PROT_READ)!=0)  desiredAccess|=FILE_MAP_READ;
 if((prot&PROT_WRITE)!=0) desiredAccess|=FILE_MAP_WRITE;
 if((prot&PROT_EXEC)!=0)  desiredAccess|=FILE_MAP_EXECUTE;
 return desiredAccess;
 }



VP aa_mmap                             (VP addr,size_t len,Z prot,Z flags,Z fildes,off_t off)
 {
 HANDLE fm,h;
 VP map=MAP_FAILED;
 Y dwFileOffsetLow=(sizeof(off_t)<=sizeof(Y))?(Y)off:(Y)(off&0xFFFFFFFFL);
 Y dwFileOffsetHigh=(sizeof(off_t)<=sizeof(Y))?(Y)0:(Y)((off>>32)&0xFFFFFFFFL);
 Y protect=aa__map_mmap_prot_page(prot);
 Y desiredAccess=aa__map_mmap_prot_file(prot);
 off_t maxSize=off+(off_t)len;
 Y dwMaxSizeLow=(sizeof(off_t)<=sizeof(Y))?(Y)maxSize:(Y)(maxSize&0xFFFFFFFFL);
 Y dwMaxSizeHigh=(sizeof(off_t)<=sizeof(Y))?(Y)0:(Y)((maxSize>>32)&0xFFFFFFFFL);
 UNUSE(addr);
 errno=0;
 if(len==0||(flags&MAP_FIXED)!=0||prot==PROT_EXEC)     { errno=EINVAL; return MAP_FAILED;   }
 h=((flags&MAP_ANONYMOUS)==0)?(HANDLE)_get_osfhandle(fildes):INVALID_HANDLE_VALUE;
 if((flags&MAP_ANONYMOUS)==0&&h==INVALID_HANDLE_VALUE) { errno=EBADF; return MAP_FAILED;   }
 fm=CreateFileMapping(h,NULL,protect,dwMaxSizeHigh,dwMaxSizeLow,NULL);
 if(fm==NULL)     { errno=aa__map_mman_error(GetLastError(),EPERM); return MAP_FAILED;   }
 map=MapViewOfFile(fm,desiredAccess,dwFileOffsetHigh,dwFileOffsetLow,len);
 CloseHandle(fm);
 if(map==NULL)    { errno=aa__map_mman_error(GetLastError(),EPERM); return MAP_FAILED;   }
 return map;
 }

 Z aa_munmap                           (VP addr,size_t len)
 {
 UNUSE(len);
 if(UnmapViewOfFile(addr)) return 0;
 errno=aa__map_mman_error(GetLastError(),EPERM);
 return -1;
 }


 Z aa_mprotect                         (VP addr,size_t len,Z prot)
 {
 Y newProtect=aa__map_mmap_prot_page(prot);
 Y oldProtect=0;
 if(VirtualProtect(addr,len,newProtect,(PDWORD)&oldProtect)) return 0;
 errno=aa__map_mman_error(GetLastError(),EPERM);
 return -1;
 }

 Z aa_msync                            (VP addr,size_t len,Z flags)
 {
 UNUSE(flags);
 if(FlushViewOfFile(addr,len)) return 0;
 errno=aa__map_mman_error(GetLastError(),EPERM);
 return -1;
 }

 Z aa_mlock                            (VP addr,size_t len)
 {
 if(VirtualLock((LPVOID)addr,len)) return 0;
 errno=aa__map_mman_error(GetLastError(),EPERM);
 return -1;
 }

 Z aa_munlock                          (VP addr,size_t len)
 {
 if(VirtualUnlock((LPVOID)addr,len)) return 0;
 errno=aa__map_mman_error(GetLastError(),EPERM);
 return -1;
 }



/*-----------------------------------------------------------------------*/


 #define aa_MATH_DCT_ACCURATE_ROUNDING
 #define aa_MATH_DCT_RIGHT_SHIFT(x,s)  ((x)>>(s))

 #ifdef  aa_MATH_DCT_ACCURATE_ROUNDING
 #define aa_MATH_DCT_ONE               ((N) 1)
 #define aa_MATH_DCT_DESCALE(x,n)      aa_MATH_DCT_RIGHT_SHIFT((x)+(aa_MATH_DCT_ONE<<((n)-1)),n)
 #else
 #define aa_MATH_DCT_DESCALE(x,n)      aa_MATH_DCT_RIGHT_SHIFT(x,n)
 #endif

 #define aa_MATH_DCT_CONST_BITS        13
 #define aa_MATH_DCT_PASS1_BITS        2

 #define aa_MATH_DCT_FIX_0_298631336   ((N)2446)
 #define aa_MATH_DCT_FIX_0_390180644   ((N)3196)
 #define aa_MATH_DCT_FIX_0_541196100   ((N)4433)
 #define aa_MATH_DCT_FIX_0_765366865   ((N)6270)
 #define aa_MATH_DCT_FIX_0_899976223   ((N)7373)
 #define aa_MATH_DCT_FIX_1_175875602   ((N)9633)
 #define aa_MATH_DCT_FIX_1_501321110   ((N)12299)
 #define aa_MATH_DCT_FIX_1_847759065   ((N)15137)
 #define aa_MATH_DCT_FIX_1_961570560   ((N)16069)
 #define aa_MATH_DCT_FIX_2_053119869   ((N)16819)
 #define aa_MATH_DCT_FIX_2_562915447   ((N)20995)
 #define aa_MATH_DCT_FIX_3_072711026   ((N)25172)

 #define aa_MATH_DCT_W1                2841
 #define aa_MATH_DCT_W2                2676
 #define aa_MATH_DCT_W3                2408
 #define aa_MATH_DCT_W5                1609
 #define aa_MATH_DCT_W6                1108
 #define aa_MATH_DCT_W7                565




 B aa_MathSystemStart                  (V)
 {
 N i;//,j,seed,tmp;
 //Q qt;
 B txt[_1K];
 H key[8];
 B ret;
 POINT pnt;
 D f1;

 logg("aa_MathSystemStart()");
 aa.math_system.four_billion=65536.0*65536.0;
// aa.math_system.four_billion=aa.math_system.four_billion*(D)65536;
 aa.math_system.one_million=(D)1000000;
 aa.math_system.ten_million=(D)10000000;
 aa.math_system.dct_iclip_ptr=aa.math_system.dct_iclip+512;
 for(i=-512;i<512; i++) { aa.math_system.dct_iclip_ptr[i]=(I)aaNumClamp(i,-256,255); }
 aaStringCopyf(txt,"%s","pmmzech");
 key[0]=(H)&txt;
 #ifdef IS_A_DLL
 key[0]+=(H)(PP)DllMain;
 #else
 key[0]+=(H)(PP)WinMain;
 #endif
 key[0]+=(H)aa_avgcpuload;
 aa_CoreSystemCpuLoadGet();
 f1=aa_avgcpuload;
 f1=f1*10000000.0;
 key[0]+=(H)f1;
 key[0]+=aa_launchtik;
 key[0]+=aa.core_system.process_id;
 //if((ret=aaMathTwisterInit(&aa.math_system.twister,54321,0))!=YES) oops;

 for(i=0;i<7;i++) txt[i]--;
 GetCursorPos(&pnt);
 for(i=0;i<48*6;i++)
  {
  if(i==0) {  txt[7]='.'; }
//  tmp=(aa.math_system.vec[aa.math_system.tap] - aa.math_system.vec[aa.math_system.feed]) - aa.math_system.borrow;
//  if(tmp<0) { aa.math_system.borrow=1; tmp+=(1<<31); }
//  else         { aa.math_system.borrow=0; }
//  aa.math_system.vec[aa.math_system.feed]=tmp;
//  if(++aa.math_system.feed>=48) { aa.math_system.feed=0; }
//  if(++aa.math_system.tap>=48) { aa.math_system.tap=0; }
//  aa.math_system.rand_seed+=tmp;
  }
 ///if(aaProcessIsRunning("appverif.exe",0)==YES)  { aaQuit(); }
 key[1]=GetTickCount();
 txt[8]='e';
 for(i=0;i<572;i++)
  {
//  tmp=(aa.math_system.vec[aa.math_system.tap] - aa.math_system.vec[aa.math_system.feed]) - aa.math_system.borrow;
//  if(tmp<0) { aa.math_system.borrow=1; tmp+=(1<<31); }
//  else         { aa.math_system.borrow=0; }
//  aa.math_system.vec[aa.math_system.feed]=tmp;
//  if(++aa.math_system.feed>=48) { aa.math_system.feed=0; }
//  if(++aa.math_system.tap>=48) { aa.math_system.tap=0; }
//  if(i==571) { aa.math_system.rand_y=tmp; }
//  else         { aa.math_system.rand_v[i]=tmp; }
  if(i==10) {  key[4]=(H)aa.core_system.this_instance+(pnt.x); txt[9]='x'; }
  }
 key[2]=aa.core_system.process_id;

 for(i=0;i<48*6; i++)
  {
//  tmp=(aa.math_system.vec[aa.math_system.tap] - aa.math_system.vec[aa.math_system.feed]) - aa.math_system.borrow;
//  if(tmp<0) { aa.math_system.borrow=1; tmp+=(1<<31); }
//  else         { aa.math_system.borrow=0; }
//  aa.math_system.vec[aa.math_system.feed]=tmp;
  if(i==5) { txt[10]='e';  key[3]=aa.core_system.thread_id; }
//  if(++aa.math_system.feed>=48) { aa.math_system.feed=0; }
//  if(++aa.math_system.tap>=48)  { aa.math_system.tap=0; }
//  j=aa.math_system.rand_y & 511;
//  aa.math_system.rand_y=aa.math_system.rand_v[j];
//  aa.math_system.rand_v[j]=tmp;
  if(i==20) { key[5]=(H)aa.core_system.process_handle; txt[11]=0;  }
//  aa.math_system.rand_seed+=aa.math_system.rand_y;
  }

 key[6]=(H)aa.core_system.thread_handle+(pnt.y);
 key[7]=aa_launchtik;
 if((ret=aaMathTwisterInit(&aa.math_system.twister,8,key))!=YES) oops;
 if(aaProcessIsRunning(txt,0)==((txt[0]-'o')+1))  { aaQuit(); }
 ///aa_randval=aaMathRand(0,F32);
 logg("");
 return RET_YES;
 }




 V aa_MathSystemStop                   (V)
 {
 logg("aa_MathSystemStop()");
 logg("");
 }




 B aa_MathRandomGet                    (VP buf,H bytes)
 {
 BP bp,tp;
 HP hp;
 H val,b;
 S H woff=0;
 S H roff=0;
 S H have=0;
 S H hlen=256;
 S B hold[256];
 H thresh=128;
 N left,edge;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL) { return RET_BADPARM;  }
 aaCast(bp,BP,buf);
 while(1)
  {
  while(1)
   {
   if(have==0) { break; }
   if(bytes==0) { break; }
   bp[0]=hold[roff];
   bp++;
   roff++;
   roff%=hlen;
   have--;
   bytes--;
   }
  if(bytes==0) break;
  while(1)
   {
   if(have>=thresh) { break; }
   left=(N)hlen-(N)have;
   edge=(N)hlen-(N)woff;
   if(left>=4&&edge>=4)
    {
    aaCast(hp,HP,&hold[woff]);
    *hp=aaMathTwisterInt32(&aa.math_system.twister);
    woff+=4;
    have+=4;
    continue;
    }
   val=aaMathTwisterInt32(&aa.math_system.twister);
   aaCast(tp,BP,&val);
   for(b=0;b<4;b++) {  hold[woff]=tp[b];   woff++;   woff%=hlen; have++;   }
   }
  }
 return RET_YES;
 }

/*-----------------------------------------------------------------------*/





/*
inline double to_degrees(double radians) {    return radians*(180.0/M_PI);}
// Converts degrees to radians.
#define degreesToRadians(angleDegrees) (angleDegrees*M_PI/180.0)
// Converts radians to degrees.
#define radiansToDegrees(angleRadians) (angleRadians*180.0/M_PI)
//
private static double calculateDirection(double x, double y){    return Math.toDegrees(Math.atan2(y, x));}
*/


 B aaMathDct                           (IP block,B fwd,B descale)
 {
 N tmp0,tmp1,tmp2,tmp3,tmp4,tmp5,tmp6,tmp7;
 N tmp10,tmp11,tmp12,tmp13;
 N X0,X1,X2,X3,X4,X5,X6,X7,X8;
 N z1,z2,z3,z4,z5;
 IP blkptr;
 NP dataptr;
 N data[64];
 N i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fwd==YES)
  {
   // Pass 1: process rows.
 // Note results are scaled up by sqrt(8) compared to a true DCT;
 // furthermore, we scale the results by 2**aa_MATH_DCT_PASS1_BITS.
  aaCast(dataptr,NP,data);
  aaCast(blkptr,IP,block);
  for(i=0;i<8; i++)
   {
  tmp0=blkptr[0]+blkptr[7];
  tmp7=blkptr[0]-blkptr[7];
  tmp1=blkptr[1]+blkptr[6];
  tmp6=blkptr[1]-blkptr[6];
  tmp2=blkptr[2]+blkptr[5];
  tmp5=blkptr[2]-blkptr[5];
  tmp3=blkptr[3]+blkptr[4];
  tmp4=blkptr[3]-blkptr[4];
  // Even part per LL&M figure 1 --- note that published figure is faulty;
  // rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
  tmp10=tmp0+tmp3;
  tmp13=tmp0-tmp3;
  tmp11=tmp1+tmp2;
  tmp12=tmp1-tmp2;
  dataptr[0]=(tmp10+tmp11)<<aa_MATH_DCT_PASS1_BITS;
  dataptr[4]=(tmp10-tmp11)<<aa_MATH_DCT_PASS1_BITS;
  z1=(tmp12+tmp13)*aa_MATH_DCT_FIX_0_541196100;
  dataptr[2]=aa_MATH_DCT_DESCALE(z1+tmp13*aa_MATH_DCT_FIX_0_765366865,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[6]=aa_MATH_DCT_DESCALE(z1+tmp12*(-aa_MATH_DCT_FIX_1_847759065),aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  // Odd part per figure 8 --- note paper omits factor of sqrt(2).
  // cK represents cos(K*pi/16).
  // i0..i3 in the paper are tmp4..tmp7 here.
  z1=tmp4+tmp7;
  z2=tmp5+tmp6;
  z3=tmp4+tmp6;
  z4=tmp5+tmp7;
  z5=(z3+z4)*aa_MATH_DCT_FIX_1_175875602; // sqrt(2)*c3
  tmp4*=aa_MATH_DCT_FIX_0_298631336; // sqrt(2)*(-c1+c3+c5-c7)
  tmp5*=aa_MATH_DCT_FIX_2_053119869; // sqrt(2)*( c1+c3-c5+c7)
  tmp6*=aa_MATH_DCT_FIX_3_072711026; // sqrt(2)*( c1+c3+c5-c7)
  tmp7*=aa_MATH_DCT_FIX_1_501321110; // sqrt(2)*( c1+c3-c5-c7)
  z1*=-aa_MATH_DCT_FIX_0_899976223; // sqrt(2)*(c7-c3)
  z2*=-aa_MATH_DCT_FIX_2_562915447; // sqrt(2)*(-c1-c3)
  z3*=-aa_MATH_DCT_FIX_1_961570560; // sqrt(2)*(-c3-c5)
  z4*=-aa_MATH_DCT_FIX_0_390180644; // sqrt(2)*(c5-c3)
  z3+=z5;
  z4+=z5;
  dataptr[7]=aa_MATH_DCT_DESCALE(tmp4+z1+z3,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[5]=aa_MATH_DCT_DESCALE(tmp5+z2+z4,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[3]=aa_MATH_DCT_DESCALE(tmp6+z2+z3,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr[1]=aa_MATH_DCT_DESCALE(tmp7+z1+z4,aa_MATH_DCT_CONST_BITS-aa_MATH_DCT_PASS1_BITS);
  dataptr+=8;   // advance pointer to next row
  blkptr+=8;
  }
  // Pass 2: process columns.
 // We remove the aa_MATH_DCT_PASS1_BITS scaling, but leave the results scaled up
 // by an overall factor of 8.
 dataptr=data;
 for(i=0;i<8;i++)
  {
  tmp0=dataptr[0]+dataptr[56];
  tmp7=dataptr[0]-dataptr[56];
  tmp1=dataptr[8]+dataptr[48];
  tmp6=dataptr[8]-dataptr[48];
  tmp2=dataptr[16]+dataptr[40];
  tmp5=dataptr[16]-dataptr[40];
  tmp3=dataptr[24]+dataptr[32];
  tmp4=dataptr[24]-dataptr[32];
  // Even part per LL&M figure 1 --- note that published figure is faulty;
  // rotator "sqrt(2)*c1" should be "sqrt(2)*c6".
  tmp10=tmp0+tmp3;
  tmp13=tmp0-tmp3;
  tmp11=tmp1+tmp2;
  tmp12=tmp1-tmp2;
  dataptr[0]=aa_MATH_DCT_DESCALE(tmp10+tmp11,aa_MATH_DCT_PASS1_BITS);
  dataptr[32]=aa_MATH_DCT_DESCALE(tmp10-tmp11,aa_MATH_DCT_PASS1_BITS);
  z1=(tmp12+tmp13)*aa_MATH_DCT_FIX_0_541196100;
  dataptr[16]=aa_MATH_DCT_DESCALE(z1+tmp13*aa_MATH_DCT_FIX_0_765366865,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[48]=aa_MATH_DCT_DESCALE(z1+tmp12*(-aa_MATH_DCT_FIX_1_847759065),aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  // Odd part per figure 8 --- note paper omits factor of sqrt(2).
  // cK represents cos(K*pi/16).
  // i0..i3 in the paper are tmp4..tmp7 here.
  z1=tmp4+tmp7;
  z2=tmp5+tmp6;
  z3=tmp4+tmp6;
  z4=tmp5+tmp7;
  z5=(z3+z4)*aa_MATH_DCT_FIX_1_175875602; // sqrt(2)*c3
  tmp4*=aa_MATH_DCT_FIX_0_298631336; // sqrt(2)*(-c1+c3+c5-c7)
  tmp5*=aa_MATH_DCT_FIX_2_053119869; // sqrt(2)*( c1+c3-c5+c7)
  tmp6*=aa_MATH_DCT_FIX_3_072711026; // sqrt(2)*( c1+c3+c5-c7)
  tmp7*=aa_MATH_DCT_FIX_1_501321110; // sqrt(2)*( c1+c3-c5-c7)
  z1*=-aa_MATH_DCT_FIX_0_899976223; // sqrt(2)*(c7-c3)
  z2*=-aa_MATH_DCT_FIX_2_562915447; // sqrt(2)*(-c1-c3)
  z3*=-aa_MATH_DCT_FIX_1_961570560; // sqrt(2)*(-c3-c5)
  z4*=-aa_MATH_DCT_FIX_0_390180644; // sqrt(2)*(c5-c3)
  z3+=z5;
  z4+=z5;
  dataptr[56]=aa_MATH_DCT_DESCALE(tmp4+z1+z3,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[40]=aa_MATH_DCT_DESCALE(tmp5+z2+z4,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[24]=aa_MATH_DCT_DESCALE(tmp6+z2+z3,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr[8]=aa_MATH_DCT_DESCALE(tmp7+z1+z4,aa_MATH_DCT_CONST_BITS+aa_MATH_DCT_PASS1_BITS);
  dataptr++;    // advance pointer to next column
  }
   // aa_MATH_DCT_DESCALE
 if(descale==YES) {   for(i=0;i<64;i++) { block[i]=(short int)aa_MATH_DCT_DESCALE(data[i],3); } }
 else             {   for(i=0;i<64;i++) { block[i]=(short int)data[i]; } }
 }
 else ////////// REVERSE
  {
  for(i=0;i<8;i++)  // idct rows
  {
  blkptr=block+(i<<3);
  if(!((X1=blkptr[4]<<11)|(X2=blkptr[6])|(X3=blkptr[2])|(X4=blkptr[1])|(X5=blkptr[7])|(X6=blkptr[5])|(X7=blkptr[3])))
      {
      blkptr[0]=blkptr[1]=blkptr[2]=blkptr[3]=blkptr[4]=blkptr[5]=blkptr[6]=blkptr[7]=(I)(blkptr[0]<<3); // was blptr[7]=blkptr[0]<<3;
      continue;
      }
  X0=(blkptr[0]<<11)+128; // for proper rounding in the fourth stage
  // first stage
  X8=aa_MATH_DCT_W7*(X4+X5);
  X4=X8+(aa_MATH_DCT_W1-aa_MATH_DCT_W7)*X4;
  X5=X8-(aa_MATH_DCT_W1+aa_MATH_DCT_W7)*X5;
  X8=aa_MATH_DCT_W3*(X6+X7);
  X6=X8-(aa_MATH_DCT_W3-aa_MATH_DCT_W5)*X6;
  X7=X8-(aa_MATH_DCT_W3+aa_MATH_DCT_W5)*X7;
  // second stage
  X8=X0+X1;
  X0-=X1;
  X1=aa_MATH_DCT_W6*(X3+X2);
  X2=X1-(aa_MATH_DCT_W2+aa_MATH_DCT_W6)*X2;
  X3=X1+(aa_MATH_DCT_W2-aa_MATH_DCT_W6)*X3;
  X1=X4+X6;
  X4-=X6;
  X6=X5+X7;
  X5-=X7;
  // third stage
  X7=X8+X3;
  X8-=X3;
  X3=X0+X2;
  X0-=X2;
  X2=(181*(X4+X5)+128)>>8;
  X4=(181*(X4-X5)+128)>>8;
  // fourth stage
  blkptr[0]=(short)((X7+X1)>>8);
  blkptr[1]=(short)((X3+X2)>>8);
  blkptr[2]=(short)((X0+X4)>>8);
  blkptr[3]=(short)((X8+X6)>>8);
  blkptr[4]=(short)((X8-X6)>>8);
  blkptr[5]=(short)((X0-X4)>>8);
  blkptr[6]=(short)((X3-X2)>>8);
  blkptr[7]=(short)((X7-X1)>>8);
  }       // end for( i=0;i<8; ++i ) IDCT-rows
 for(i=0;i<8;i++)  // idct columns
  {
  blkptr=block+i;
  // shortcut
  if(!((X1=(blkptr[8*4]<<8))|(X2=blkptr[8*6])|(X3=blkptr[8*2])|(X4=blkptr[8*1])|(X5=blkptr[8*7])|(X6=blkptr[8*5])|(X7=blkptr[8*3])))
   {
   blkptr[8*0]=blkptr[8*1]=blkptr[8*2]=blkptr[8*3]=blkptr[8*4]=blkptr[8*5]=blkptr[8*6]=blkptr[8*7]=aa.math_system.dct_iclip_ptr[(blkptr[8*0]+32)>>6];
   continue;
   }
  X0=(blkptr[8*0]<<8)+8192;
  // first stage
  X8=aa_MATH_DCT_W7*(X4+X5)+4;
  X4=(X8+(aa_MATH_DCT_W1-aa_MATH_DCT_W7)*X4)>>3;
  X5=(X8-(aa_MATH_DCT_W1+aa_MATH_DCT_W7)*X5)>>3;
  X8=aa_MATH_DCT_W3*(X6+X7)+4;
  X6=(X8-(aa_MATH_DCT_W3-aa_MATH_DCT_W5)*X6)>>3;
  X7=(X8-(aa_MATH_DCT_W3+aa_MATH_DCT_W5)*X7)>>3;
  // second stage
  X8=X0+X1;
  X0-=X1;
  X1=aa_MATH_DCT_W6*(X3+X2)+4;
  X2=(X1-(aa_MATH_DCT_W2+aa_MATH_DCT_W6)*X2)>>3;
  X3=(X1+(aa_MATH_DCT_W2-aa_MATH_DCT_W6)*X3)>>3;
  X1=X4+X6;
  X4-=X6;
  X6=X5+X7;
  X5-=X7;
  // third stage
  X7=X8+X3;
  X8-=X3;
  X3=X0+X2;
  X0-=X2;
  X2=(181*(X4+X5)+128)>>8;
  X4=(181*(X4-X5)+128)>>8;
  // fourth stage
  blkptr[8*0]=aa.math_system.dct_iclip_ptr[(X7+X1)>>14];
  blkptr[8*1]=aa.math_system.dct_iclip_ptr[(X3+X2)>>14];
  blkptr[8*2]=aa.math_system.dct_iclip_ptr[(X0+X4)>>14];
  blkptr[8*3]=aa.math_system.dct_iclip_ptr[(X8+X6)>>14];
  blkptr[8*4]=aa.math_system.dct_iclip_ptr[(X8-X6)>>14];
  blkptr[8*5]=aa.math_system.dct_iclip_ptr[(X0-X4)>>14];
  blkptr[8*6]=aa.math_system.dct_iclip_ptr[(X3-X2)>>14];
  blkptr[8*7]=aa.math_system.dct_iclip_ptr[(X7-X1)>>14];
  }
  }
 return RET_YES;
 }





 B aaMathSinTableCreate                (FP*table)
 {
 F the,rad,a;
 D s;
 W z;
 FP ptr;
 BP mem;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(table==NULL) return RET_BADPARM;
 if((ret=aaMemoryAllocate((VP)&mem,3600*sizeof(F)))!=RET_YES) { return ret; }
 aaMemoryNameSet(mem,"sintable");
 aaCast(ptr,FP,mem);
 a=0;
 for(z=0;z<3600;z++)
  {
  the=(F)a;
  rad=(the*aaPi)/180.0;
  s=sin(rad);
  ptr[z]=(F)s;
  a+=0.1;
  }
 *table=ptr;
 return RET_YES;
 }







 B aaMathCosTableCreate                (FP*table)
 {
 F the,rad,a;
 D s;
 W z;
 FP ptr;
 BP mem;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(table==NULL) return RET_BADPARM;
 if((ret=aaMemoryAllocate((VP)&mem,3600*sizeof(F)))!=RET_YES) { return ret; }
 aaMemoryNameSet(mem,"costable");
 aaCast(ptr,FP,mem);
 a=0;
 for(z=0;z<3600;z++)
  {
  the=(F)a;
  rad=(the*aaPi)/180.0;
  s=cos(rad);
  ptr[z]=(F)s;
  a+=0.1;
  }
 *table=ptr;
 return RET_YES;
 }






 B aaMathDtmfSet                       (H samples,_audiomode*audiomode,N amp,B code,VP buf)
 {
 S N dtmf_tone[17][2]=
 {
 {941,1336}, // 0
 {697,1209}, // 1
 {697,1336}, // 2
 {697,1477}, // 3
 {770,1209}, // 4
 {770,1336}, // 5
 {770,1477}, // 6
 {852,1209}, // 7
 {852,1336}, // 8
 {852,1477}, // 9
 {697,1633}, // a
 {770,1633}, // b
 {852,1633}, // c
 {941,1633}, // d
 {941,1209}, // *
 {941,1447}, // #
 };

 D tonelen;
 N srate,j;
 D t1,t2,t,v;
 C q[2];
 CP cp;
 IP ip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL)  { return RET_BADPARM; }
 if(audiomode==NULL) { return RET_BADPARM; }
 if(samples==0) { return RET_BADPARM; }

 srate=audiomode->frequency;

 cp=(CP)buf;
 ip=(IP)buf;

 tonelen=0.2;

 tonelen=(D)samples/(D)audiomode->frequency;

 for(t=0;t<tonelen;t+=1.0/srate)
  {
  t1=sin(2.0*aaPi*dtmf_tone[code][0]*t);
  t2=sin(2.0*aaPi*dtmf_tone[code][1]*t);
  v=amp*(t1+t2);
  j=(Z)v;
  q[0]=(C)(j&F8);
  q[1]=(C)((j>>8)&F8);
  j=*(NP)q;
  if(audiomode->channels==1)
   {
   if(audiomode->bits==16) { ip[0]=j*128;       ip+=1;    }
   else
   if(audiomode->bits==8)  { cp[0]=q[0]-128;    cp+=1;    }
   }
  else
   {
   if(audiomode->bits==16) { ip[0]=j*128;      ip[1]=j*128;     ip+=2;   }
   else
   if(audiomode->bits==8)  { cp[0]=q[0]-128;   cp[1]=q[1]-128;  cp+=2;   }
   }

  }

 return RET_YES;
 }



/*

<<< http://gis.stackexchange.com/questions/8650/how-to-measure-the-accuracy-of-latitude-and-longitude
http://www.longitudestore.com/how-big-is-one-gps-degree.html
http://msi.nga.mil/MSISiteContent/StaticFiles/Calculators/degree.html
https://www.maptools.com/tutorials/lat_lon/formats
https://knowledge.safe.com/articles/725/calculating-accurate-length-in-meters-for-lat-long.html
http://stackoverflow.com/questions/639695/how-to-convert-latitude-or-longitude-to-meters


function measure(lat1, lon1, lat2, lon2){  // generally used geo measurement function
    var R=6378.137; // Radius of earth in KM
    var dLat=(lat2 - lat1)*Math.PI/180;
    var dLon=(lon2 - lon1)*Math.PI/180;
    var a=Math.sin(dLat/2)*Math.sin(dLat/2) +
    Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180) *
    Math.sin(dLon/2)*Math.sin(dLon/2);
    var c=2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    var d=R*c;
    return d*1000; // meters
}
*/


 /*
 (((acos(sin(($lat*pi()/180))*sin((latitude*pi()/180)) cos(($lat*pi()/180))*cos((latitude*pi()/180))*cos((($lng - longitude)*pi()/180))))*180/pi())*60*1.1515)
 */


 // lat=-90/+90  lon=-180/+180


 B aaMathLatLongDistanceGet            (D lat1,D lon1,D lat2,D lon2,DP distance)
 {
 D th,di;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(distance==NULL) { return RET_BADPARM; }
 *distance=0;
 if(lon1<-180||lon1>+180) { return RET_BOUNDS; }
 if(lat1<-90||lat1>+90) { return RET_BOUNDS; }
 if(lon2<-180||lon2>+180) { return RET_BOUNDS; }
 if(lat2<-90||lat2>+90) { return RET_BOUNDS; }
 th=lon1-lon2;
 di=sin((lat1*aaPi/180.0))*sin((lat2*aaPi/180.0))+cos((lat1*aaPi/180.0))*cos((lat2*aaPi/180.0))*cos((th*aaPi/180.0));
 di=acos(di);
 di=(di*180.0/aaPi);
 di=di*60*1.1515;
 ////
 di=di*1.609344;
 // default is miles
 // to covert to k's di=di*1.609344
 // to conver to nautical milex di=di*0.8684
 *distance=di;
 return RET_YES;
 }



 B aaMathLatLongCordGet                (D lat,D lon,_size*size,_cord*cord)
 {
 D minlat=-90.0;//-85.05112878;
 D maxlat=+90.0;//+85.05112878;
 D minlon=-180;
 D maxlon=+180;
 D x,y;
// D sinlat;
 //D ml,op,om,dv;

 //minlat=-85.05112878;
 //maxlat=+85.05112878;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 cord->x=cord->y=0;
 if(size==NULL) { return RET_BADPARM; }
 if(size->w==0||size->h==0) { return RET_BADPARM; }
 lat=aaNumClamp(lat,minlat,maxlat);
 lon=aaNumClamp(lon,minlon,maxlon);
 x=((lon+180.0)*(size->w/360.0));
 y=(((lat*-1.0)+90.0)*(size->h/180.0));
 cord->x=aaNumClamp((N)x,0,(N)(size->w-1)); // ningy added (N)
 cord->y=aaNumClamp((N)y,0,(N)(size->h-1)); // ningy added (N)
 return RET_YES;
 }



 D aaMathDoubleRound                   (D val,N numer,N denom)
 {
 D y;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 y=floor(val*(D)denom+(D)numer/2.0);
 return((D)((y-(N)y%numer)/(D)denom));
 }



 B aaMathRandomGet                     (HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 *val=aaMathTwisterInt32(&aa.math_system.twister);
 return RET_YES;//aa_MathRandomGet(val,4));
 }



 H aaMathRand32                        (H lo,H hi)
 {
 H rn,val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lo>hi) { val=lo; lo=hi; hi=val;   }
 rn=(hi-lo)+1;
 val=aaMathTwisterInt32(&aa.math_system.twister);
 //aa_MathRandomGet(&val,4);
 if(rn!=0&&rn!=F32) {  val%=(rn); }
 val=lo+val;
 return(val);
 }



 Q aaMathRand64                        (Q lo,Q hi)
 {
 Q val,rn;
 HP hp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lo>hi) { val=lo; lo=hi; hi=val;   }
 rn=(hi-lo)+1;
 hp=(HP)&val;
 hp[0]=aaMathTwisterInt32(&aa.math_system.twister);
 hp[1]=aaMathTwisterInt32(&aa.math_system.twister);
 //aa_MathRandomGet(&val,8);
 if(rn!=0&&rn!=F64) {  val%=(rn); }
 val=lo+val;
 return(val);
 }



 D aaMathRandDouble                    (D lo,D hi)
 {
 D v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(lo>hi) { v=lo; lo=hi; hi=v;   }
 v=((hi-lo)*((D)aaMathRand32(0,F32)/4294967296.0))+lo;
 return v;
 }



 B aaMathTwisterInit                   (_twister*twister,H seed,HP key)
 {
 H kylen;
 Z i,j,k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(twister==NULL) { return RET_BADPARM; }
 if(key==NULL&&seed==0) { seed=5489UL; }
 aaMemoryFill(twister,sizeof(_twister),0);
 twister->magic=(H)(PP)aaMathTwisterInit;
 twister->mag01[0]=0x0UL;
 twister->mag01[1]=aa_MathTwister_MATRIX_A;
 twister->mti=624+1;
 kylen=0;
 if(key!=NULL)  // if key not null, seed is length of key, else it's seed
  {
  kylen=seed;
  seed=19650218UL;
  }
 twister->mt[0]=seed&0xffffffffUL;
 for(twister->mti=1;twister->mti<624;twister->mti++)
  {
  twister->mt[twister->mti]=(1812433253UL*(twister->mt[twister->mti-1]^(twister->mt[twister->mti-1]>>30))+twister->mti);
  twister->mt[twister->mti]&=0xffffffffUL;
  }
 if(kylen>0)
  {
  i=1;
  j=0;
  k=(624>kylen?624:kylen);
  for(;k;k--)
   {
   twister->mt[i]=(twister->mt[i]^((twister->mt[i-1]^(twister->mt[i-1]>>30))*1664525UL))+key[j]+j;
   twister->mt[i]&=0xffffffffUL;
   i++; j++;
   if(i>=624)   { twister->mt[0]=twister->mt[624-1];i=1;}
   if((H)j>=kylen) { j=0; }
   }
  for(k=624-1;k;k--)
   {
   twister->mt[i]=(twister->mt[i]^((twister->mt[i-1]^(twister->mt[i-1]>>30))*1566083941UL))-i;
   twister->mt[i]&=0xffffffffUL;
   i++;
   if(i>=624) { twister->mt[0]=twister->mt[624-1]; i=1; }
   }
  twister->mt[0]=0x80000000UL;
  }
 twister->ret=RET_YES;
 return RET_YES;
 }




 H aaMathTwisterInt32                  (_twister*twister)
 {
 H y;
 Z kk;
 _twister*twt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(twister==NULL) { twt=&aa.math_system.twister; }
 else              { twt=twister; }

 //if(twister==NULL) { return RET_BADPARM; }
 if(twt->magic!=(H)(PP)aaMathTwisterInit) { twt->ret=RET_NOTINITIALIZED; return RET_NOTINITIALIZED; }

 if(twt->mti>=624)
  {
  if(twt->mti==624+1) { twt->mti=0; }//oof; }
  for(kk=0;kk<624-aa_MathTwister_MM;kk++)
   {
   y=(twt->mt[kk]&aa_MathTwister_UPPER_MASK)|(twt->mt[kk+1]&aa_MathTwister_LOWER_MASK);
   twt->mt[kk]=twt->mt[kk+aa_MathTwister_MM]^(y>>1)^twt->mag01[y&0x1UL];
   }
  for(;kk<624-1;kk++)
   {
   y=(twt->mt[kk]&aa_MathTwister_UPPER_MASK)|(twt->mt[kk+1]&aa_MathTwister_LOWER_MASK);
   twt->mt[kk]=twt->mt[kk+(aa_MathTwister_MM-624)]^(y>>1)^twt->mag01[y&0x1UL];
   }
  y=(twt->mt[624-1]&aa_MathTwister_UPPER_MASK)|(twt->mt[0]&aa_MathTwister_LOWER_MASK);
  twt->mt[624-1]=twt->mt[aa_MathTwister_MM-1]^(y>>1)^twt->mag01[y&0x1UL];
  twt->mti=0;
  }
 y=twt->mt[twt->mti++];
 y^=(y>>11);
 y^=(y<<7)&0x9d2c5680UL;
 y^=(y<<15)&0xefc60000UL;
 y^=(y>>18);
 twt->ret=RET_YES;
 return y;
 }




 N aaMathTwisterInt31                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return (N)(aaMathTwisterInt32(twister)>>1);
 }


 D aaMathTwisterReal1                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return aaMathTwisterInt32(twister)*(1.0/4294967295.0);
 }


 D aaMathTwisterReal2                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return aaMathTwisterInt32(twister)*(1.0/4294967296.0);
 }


 D aaMathTwisterReal3                  (_twister*twister)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return (((D)aaMathTwisterInt32(twister))+0.5)*(1.0/4294967296.0);
 }



 D aaMathTwisterRes53                  (_twister*twister)
 {
 H a,b;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 a=aaMathTwisterInt32(twister)>>5;
 b=aaMathTwisterInt32(twister)>>6;
 return(a*67108864.0+b)*(1.0/9007199254740992.0);
 }




 B aaMathAngleToCord                   (D angle,_rect*rect,_cord*cord)
 {
 D a,radius1,radius2;
 D x_tmp,y_tmp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rect==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(rect)!=YES) { return RET_BADPARM; }
 radius1=rect->w/2.0;
 radius2=rect->h/2.0;
 a=angle*(aaPi/180.0)-(aaPi/2.0);
 x_tmp=cos(a)*radius1;
 y_tmp=sin(a)*radius2;
 if(cord)
  {
  x_tmp=x_tmp+radius1+rect->x;
  y_tmp=y_tmp+radius2+rect->y;
  cord->x=x_tmp;
  cord->y=y_tmp;
  }
 return RET_YES;
 }



 B aaMathLog2                          (Y val,YP res)
 {
 Y ans;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(res==NULL) { return RET_BADPARM; }
 ans=0;
 while(val>>=1) ans++;
 *res=ans;
 return RET_YES;
 }


 B aaMathLog2D                         (D val,DP res)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(res==NULL) { return RET_BADPARM; }
 *res=log(val)/log(2.0);
 return RET_YES;
 }



 B aaMathIsPowerOfTwo                  (Q val)
 {
 Q res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 res=((val!=0LL)&&((val&(~val+1LL))==val));
 if(res) { return RET_YES; }
 return RET_NO;
 }




/*-----------------------------------------------------------------------*/



 B aaBigInit                           (_big*r)
 {
 aaMissingParm(r);
 aaMemoryFill(r,sizeof(_big),0);
 aaMagicSet(r,aaBigInit);
 r->sign_bit=1;
 r->last_digit=-1;
 r->base=10;
 return RET_YES;
 }





 B aaBigCopy                           (_big*r,_big*a)
 {
 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMemoryCopy(r,sizeof(_big),a);
 return RET_YES;
 }





 B aaBigDump                           (_big*r,B showdigits,VP fmt,...)
 {
 B txt[_4K];
 B str[_8K];
 Z i;

 aaVargsf4K(fmt);
 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit);

 if(aaBigToString(r,sizeof(txt),txt)!=YES) { oof; }
 aaStringNull(str);
 aaStringAppendf(str,"sign=%-2i ",r->sign_bit);
 aaStringAppendf(str,"base=%-2i ",r->base);
 aaStringAppendf(str,"ldig=%-4i ",r->last_digit);
 aaStringAppendf(str,"%s ",txt);
 if(showdigits)
  {
  aaStringAppendf(str,"\n");
  aaStringAppendf(str,"digits: ");
  for(i=r->last_digit;i>=0;i--)
   {
   aaStringAppendf(str,"%-2x ",r->digits[i]);
   }
  }
 aaDebugf("%s%s",str4k.buf,str);
 return RET_YES;
 }





 B aaBigBaseSet                        (_big*r,Z base)
 {
 s16 fs[(sizeof(r->digits)*3)];
 s16 ts[(sizeof(r->digits)*3)];
 s16 cums[(sizeof(r->digits)*3)];
 s32 temp,rem,first;
 s32 k,i,j,il,ol,ip;
 s32 s_len,from,tooo,bo;
 _str4k sin;
 BP s;
 BP bp;
 _big tbn;
 Z ascii;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 if(base<2) { return RET_BADPARM; }
 if(r->base==base) { return RET_YES; }

 aaMemoryFill(ts,sizeof(ts),0);
 aaMemoryFill(fs,sizeof(fs),0);
 aaMemoryFill(cums,sizeof(cums),0);

 from=r->base;
 tooo=base;

 sin.len=0;
 sin.buf[0]=0;

 bp=(BP)sin.buf;
 bo=0;
 if(r->sign_bit==-1)            { bp[bo++]='-';  bp[bo++]=SPACE_CHAR;  }
 for(i=r->last_digit;i>=0;i--)
  {
  ascii=r->digits[i];
  if(ascii>=0&&ascii<=9) {   bp[bo++]='0'+ascii; } //->digits[i];
  else                   {   bp[bo++]='A'+(ascii-10); }
  }
 bp[bo]=NULL_CHAR;
 sin.len=bo;

 s_len=sin.len;
 s=(BP)sin.buf;

 il=s_len;
 k=0;
 for(i=s_len-1;i>=0;i--)
  {
  if(s[i]>='0'&&s[i]<='9')   {    fs[k++]=(int)(s[i]-'0');         }
  else
  if(s[i]>='A'&&s[i]<='Z')   {    fs[k++]=10+(int)(s[i]-'A');      }
  else
  if(s[i]>='a'&&s[i]<='z')   {    fs[k++]=10+(int)(s[i]-'a');      }
  else                       {    aaNote(0,"Error: Input string must only contain any of 0-9 or A-Z %x %c",s[i],s[i]);      }
  }

 ol=il*(from/tooo+1);
 ts[0]=1;
 for(i=0;i<il;i++)
  {
  for(j=0;j<ol;j++)
   {
   cums[j]+=ts[j]*fs[i];
   temp=cums[j];
   rem=0;
   ip=j;
   do
    {
    rem=temp/tooo;
    cums[ip]=temp-rem*tooo;
    ip++;
    cums[ip]+=rem;
    temp=cums[ip];
    }
   while(temp>=tooo);
   }
  for(j=0;j<ol;j++)   { ts[j]=ts[j]*from; }
  for(j=0;j<ol;j++)
   {
   temp=ts[j];
   rem=0;
   ip=j;
   do
    {
    rem=temp/tooo;
    ts[ip]=temp-rem*tooo;
    ip++;
    ts[ip]+=rem;
    temp=ts[ip];
    }
   while(temp>=tooo);
   }
  }


 aaBigInit(&tbn);

 tbn.base=base;
 first=NO;
 for(i=ol;i>=0;i--)
  {
  if(cums[i]!=0) { first=YES; }
  if(!first)     { continue;}
  tbn.digits[i]=cums[i];
  }
 tbn.last_digit=ol;

 while((tbn.last_digit>0)&&(tbn.digits[tbn.last_digit]==0)) { tbn.last_digit--;  }
 if((tbn.last_digit==0)&&(tbn.digits[0]==0)) {  tbn.sign_bit=1;  }
 aaBigCopy(r,&tbn);

 return RET_YES;
 }








 B aaBigToInt                          (_big*r,GP val)
 {
 G v;
 Z j;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaMissingParm(val);
 *val=0;
 v=0;
 if(r->base!=10) { oof; }
 for(j=r->last_digit;j>=0;j--)
  {
  v=v*10LL;
  v=v+(G)r->digits[j];
  }
 *val=v;
 return RET_YES;
 }






 B aaBigFromInt                        (_big*r,G val)
 {
 G t;

 aaMissingParm(r);
 aaBigInit(r);
 if(val>=0) { r->sign_bit=1;   }
 else       { r->sign_bit=-1;  }
 r->last_digit=-1;
 t=aaNumAbs(val);
 while(t>0)
  {
  r->last_digit++;
  r->digits[r->last_digit]=(t%10);
  t=t/10;
  }
 if(val==0) { r->last_digit=0;  }
 return RET_YES;
 }








 B aaBigToString                       (_big*r,H maxchars,VP str)
 {
 B ret;
 Z i,p,v;
 BP bp;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit);
 aaMissingParm(str);
 aaStringNull(str);
 bp=(BP)str;
 p=0;
 if(r->sign_bit==-1)  {  bp[p++]='-';  }
 ret=RET_YES;
 for(i=r->last_digit;i>=0;i--)
  {
  if(p>=(Z)maxchars) { ret=RET_BOUNDS; break; }
  v=r->digits[i];
  if(v>=0&&v<=9) { bp[p++]='0'+v;      }
  else           { bp[p++]='A'+(v-10); }
  }
 bp[p]=NULL_CHAR;
 return ret;
 }






 B aaBigFromString                     (_big*r,H chars,VP str)
 {
 B ascii;
 Z i,sl,tl,mx;
 BP bp;

 aaMissingParm(r);
 aaBigInit(r);
 aaMissingParm(str);
 mx=aaElementCount(r->digits);
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { return RET_YES; }
 sl=chars-1;
 if(sl>=(Z)chars) { sl=chars; }
 if(sl>mx) { oof; sl=mx; }
 bp=(BP)str;
 tl=0;
 for(i=sl;i>=0;i--)
  {
  ascii=bp[i];
  if(ascii=='-')   {   r->sign_bit=-1;   continue;   }
  if(ascii=='+')   {   r->sign_bit=1;    continue;   }
  if(ascii==SPACE_CHAR) { continue; }
  if((ascii>='0')&&(ascii<='9')) { ascii=ascii-'0';  }
  else                           { oof; break; }
  r->digits[tl++]=ascii;
  }
 r->last_digit=tl;
 while((r->last_digit>0)&&(r->digits[r->last_digit]==0)) { r->last_digit--;  }
 if((r->last_digit==0)&&(r->digits[0]==0)) {  r->sign_bit=1;  }
 return RET_YES;
 }







 B aaBigFromStringf                    (_big*r,VP fmt,...)
 {
 aaVargsf4K(fmt);
 return(aaBigFromString(r,str4k.len,str4k.buf));
 }











 B aaBigIsOdd                          (_big*r)
 {
 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 if(r->digits[0]&0x1) { return RET_YES; }
 return RET_NO;
 }






 B aaBigIsEven                         (_big*r)
 {
 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 if(r->digits[0]&0x1) { return RET_NO; }
 return RET_YES;
 }





 B aaBigIsZero                         (_big*r)
 {
 Z dif;
 _big zer;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaBigFromInt(&zer,0);
 aaBigCompare(r,&zer,&dif);
 if(dif==0) { return RET_YES; }
 return RET_NO;
 }






 B aaBigIsOne                          (_big*r)
 {
 Z dif;
 _big one;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaBigFromInt(&one,1);
 aaBigCompare(r,&one,&dif);
 if(dif==0) { return RET_YES; }
 return RET_NO;
 }





/*

 B aaBigIsDivisible                    (_big*r,_big*a)
 {
 _big t;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigInit(&t);
 aaBigModulo(&t,r,a);
 if(aaBigIsZero(&t)==RET_YES) { return RET_YES; }
 return RET_NO;
 }

*/





 B aaBigCompare                        (_big*r,_big*a,ZP dif)
 {
 Z i;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit);
 aaMissingParm(dif);
 *dif=0;
 if((r->sign_bit==-1)&&(a->sign_bit== 1))  {  *dif=-1;  return RET_YES;  }
 if((r->sign_bit== 1)&&(a->sign_bit==-1))  {  *dif=1;   return RET_YES;  }
 if(a->last_digit>r->last_digit)  {  *dif=(-1*r->sign_bit);  return RET_YES;  }
 if(r->last_digit>a->last_digit)  {  *dif=(+1*r->sign_bit);  return RET_YES;  }
 for(i=r->last_digit;i>=0;i--)
  {
  if(r->digits[i]>a->digits[i])   {   *dif=(+1*r->sign_bit);  return RET_YES;  }
  if(a->digits[i]>r->digits[i])   {   *dif=(-1*r->sign_bit);  return RET_YES;  }
  }
 return RET_YES;
 }












 B aaBigAdd                            (_big*r,_big*a,_big*b)
 {
 Z carry,i;
 _big tbi;
 _big*cp;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)
 aaBigInit(&tbi);
 cp=&tbi;
 if(a->sign_bit==b->sign_bit)
  {
  cp->sign_bit=a->sign_bit;
  }
 else
  {
  if(a->sign_bit==-1) {  a->sign_bit=1;   aaBigSub(cp,b,a);   a->sign_bit=-1;   }
  else                {  b->sign_bit=1;   aaBigSub(cp,a,b);   b->sign_bit=-1;   }
  aaBigCopy(r,cp);
  return RET_YES;
  }
 cp->last_digit=aaNumMax(a->last_digit,b->last_digit)+1;
 carry=0;
 for(i=0;i<=(cp->last_digit);i++)
  {
  cp->digits[i]=(C)(carry+a->digits[i]+b->digits[i])%10;
  carry=(carry+a->digits[i]+b->digits[i])/10;
  }
 while((cp->last_digit>0)&&(cp->digits[cp->last_digit]==0)) { cp->last_digit--;  }
 if((cp->last_digit==0)&&(cp->digits[0]==0)) {  cp->sign_bit=1;  }
 aaBigCopy(r,cp);
 return RET_YES;
 }








 B aaBigSub                            (_big*r,_big*a,_big*b)
 {
 Z borrow,v,i,dif;
 _big tbi;
 _big*cp;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)
 aaBigInit(&tbi);
 cp=&tbi;
 if(a==b)  {  oof;}
 if((a->sign_bit==-1)||(b->sign_bit==-1))
  {
  if(b->sign_bit==-1) { b->sign_bit=+1;  }
  else                { b->sign_bit=-1;  }
  aaBigAdd(cp,b,a);
  if(b->sign_bit==-1) { b->sign_bit=+1; }
  else                { b->sign_bit=-1; }
  aaBigCopy(r,cp);
  return RET_YES;
  }
 aaBigCompare(b,a,&dif);
 if(dif>0)
  {
  aaBigSub(cp,b,a);
  cp->sign_bit=-1;
  aaBigCopy(r,cp);
  return RET_YES;
  }
 cp->last_digit=aaNumMax(a->last_digit,b->last_digit);
 borrow=0;
 for(i=0;i<=(cp->last_digit);i++)
  {
  v=(a->digits[i]-borrow-b->digits[i]);
  if(a->digits[i]>0) { borrow=0;         }
  if(v<0) { v=v+10; borrow=1; }
  cp->digits[i]=(C)v%10;
  }
 while((cp->last_digit>0)&&(cp->digits[cp->last_digit]==0))
  {
  cp->last_digit--;
  }
 if((cp->last_digit==0)&&(cp->digits[0]==0))
  {
  cp->sign_bit=1;
  }
 aaBigCopy(r,cp);
 return RET_YES;
 }











 B aaBigMul                            (_big*r,_big*a,_big*b)
 {
 _big*rp;
 _big row;
 _big tmp;
 _big tbi;
 _big*cp;
 Z i,j,k,digs;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)
 aaBigInit(&tmp);
 aaBigInit(&tbi);
 cp=&tbi;

 aaBigCopy(&row,a);
 for(i=0;i<=b->last_digit;i++)
  {
  for(j=1;j<=b->digits[i];j++)
   {
   aaBigAdd(&tmp,cp,&row);
   *cp=tmp;
   }

  rp=(_big*)&row;
  digs=1;
  while(1)
   {
   if((rp->last_digit==0)&&(rp->digits[0]==0)) { break; }
   for(k=rp->last_digit;k>=0;k--)  {  rp->digits[k+digs]=rp->digits[k];  }
   for(k=0;k<digs;k++)  {  rp->digits[k]=0;  }
   rp->last_digit=rp->last_digit+digs;
   break;
   }
  }
 cp->sign_bit=a->sign_bit*b->sign_bit;
 while((cp->last_digit>0)&&(cp->digits[cp->last_digit]==0)) { cp->last_digit--;  }
 if((cp->last_digit==0)&&(cp->digits[0]==0)) {  cp->sign_bit=1;  }
 aaBigCopy(r,cp);
 return RET_YES;
 }








 B aaBigDiv                            (_big*r,_big*a,_big*b)
 {
 _big result;
 _big row;
 _big tmp;
 _big*cp;
 _big*rp;
 Z i,asign,bsign,dif,digs,k;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)
 aaBigInit(&tmp);
 if(a==b)  { oof;}

 asign=a->sign_bit;
 bsign=b->sign_bit;
 a->sign_bit=1;
 b->sign_bit=1;

 aaBigInit(&row);
 aaBigInit(&result);
 result.last_digit=a->last_digit;
 for(i=a->last_digit;i>=0;i--)
  {
  rp=(_big*)&row;
  digs=1;
  while(1)
   {
   if((rp->last_digit==0)&&(rp->digits[0]==0)) { break; }
   for(k=rp->last_digit;k>=0;k--)  {  rp->digits[k+digs]=rp->digits[k];  }
   for(k=0;k<digs;k++)  {  rp->digits[k]=0;  }
   rp->last_digit=rp->last_digit+digs;
   break;
   }
  row.digits[0]=a->digits[i];
  result.digits[i]=0;
  while(1)
   {
   aaBigCompare(&row,b,&dif);
   if(dif==-1) { break; }
   result.digits[i]++;
   aaBigSub(&tmp,&row,b);
   aaBigCopy(&row,&tmp);
   }
  }
 cp=&result;
 while((cp->last_digit>0)&&(cp->digits[cp->last_digit]==0)) { cp->last_digit--;  }
 if((cp->last_digit==0)&&(cp->digits[0]==0)) {  cp->sign_bit=1;  }
 a->sign_bit=asign;
 b->sign_bit=bsign;
 aaBigCopy(r,&result);
 return RET_YES;
 }









 B aaBigMod                            (_big*r,_big*a,_big*b)
 {
 _big tt;
 _big rr;
 _big tbi;
 _big*cp;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)
 aaBigInit(&tbi);
 cp=&tbi;
 if(a==b)  { oof; }
 if(b->last_digit==0)
  {
  if(b->digits[b->last_digit]==0)
   {
   aaBigCopy(r,cp);
   return RET_FAILED;
   }
  }
 aaBigInit(&tt);
 aaBigInit(&rr);
 aaBigDiv(&tt,a,b);
 aaBigMul(&rr,b,&tt);
 aaBigSub(cp,a,&rr);
 aaBigCopy(r,cp);
 return RET_YES;
 }









 B aaBigPow                            (_big*r,_big*a,_big*b)
 {
 B ret;
 _big t;
 _big ans;
 _big sub;
 _big zer;
 Z asign;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)
 aaBigFromInt(&zer,0);
 if(b->sign_bit==-1)
  {
  return(aaBigCopy(r,&zer));
  }
 aaBigInit(&t);
 if(aaBigIsZero(b)==YES)  {  return(aaBigCopy(r,&zer));  }
 if(aaBigIsOne(b)==YES)   {  return(aaBigCopy(r,a));  }
 asign=a->sign_bit;
 if(asign==-1) { a->sign_bit=1; }
 aaBigCopy(&t,a);
 aaBigCopy(&ans,a);
 aaBigCopy(&sub,b);
 while(1)
  {
  ret=aaBigIsOne(&sub);
  if(ret==YES) { break; }
  if(ret!=NO) { oops; }
  ret=aaBigMul(&ans,&t,&ans);
  if(ret!=YES) { oops; }
  ret=aaBigDec(&sub);
  if(ret!=YES) { oops; }
  }
 ans.sign_bit=asign;
 a->sign_bit=asign;
 aaBigCopy(r,&ans);
 return RET_YES;
 }







/*

 B aaBigIsDivisibleInt                 (_big*r,G a)
 {
 _big ia;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaBigFromInt(&ia,a);
 return(aaBigIsDivisible(r,&ia));
 }



*/


 B aaBigCompareInt                     (_big*r,G a,ZP dif)
 {
 _big ia;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaBigFromInt(&ia,a);
 return(aaBigCompare(r,&ia,dif));
 }






 B aaBigAddInt                         (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigAdd(r,a,&ib));
 }





 B aaBigSubInt                         (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigSub(r,a,&ib));
 }






 B aaBigMulInt                         (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigMul(r,a,&ib));
 }






 B aaBigDivInt                         (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigDiv(r,a,&ib));
 }





 B aaBigModInt                         (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigMod(r,a,&ib));
 }






 B aaBigPowInt                         (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigPow(r,a,&ib));
 }







 B aaBigInc                            (_big*r)
 {
 _big one;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit);
 aaBigFromInt(&one,1);
 aaBigAdd(r,r,&one);
 return RET_YES;
 }





 B aaBigDec                            (_big*r)
 {
 _big one;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit);
 aaBigFromInt(&one,1);
 aaBigSub(r,r,&one);
 return RET_YES;
 }





 B aaBigSquareRoot                     (_big*r,_big*a)
 {
 _big tb;
 _big ta;
 _big zer;
 Z dif;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&zer,0);
 aaBigInit(&tb);
 aaBigCopy(&ta,a);
 while(1)
  {
  aaBigCompare(&ta,&zer,&dif);
  if(dif<0) { break; }
  aaBigSub(&ta,&ta,&tb);
  aaBigInc(&tb);
  aaBigSub(&ta,&ta,&tb);
  }
 aaBigDec(&tb);
 aaBigCopy(r,&tb);
 return RET_YES;
 }






 B aaBigIsPrime                        (_big*r,Z rounds)
 {
 H mx;
 Z i,dif;
 _big bi;
 _big bv;
 _big zer;
 _big one;
 _big two;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 mx=aaElementCount(aa_math_system_smallprime);
 if(rounds==-1) { rounds=(Z)mx; }
 if(rounds<=0)  { return RET_NO; }
 if(rounds>=(Z)mx) { rounds=(Z)mx; }

 aaBigFromInt(&zer,0);
 aaBigFromInt(&one,1);
 aaBigFromInt(&two,2);

 aaBigInit(&bv);

 aaBigCompare(r,&two,&dif);
 if(dif==0) {  return RET_YES; }
 aaBigCompare(r,&one,&dif);
 if(dif==0) {  return RET_NO; }
 aaBigCompare(r,&zer,&dif);
 if(dif==0) {  return RET_NO; }
 if(aaBigIsEven(r)==RET_YES) { return RET_NO; }
 for(i=0;i<rounds;i++)
  {
  aaBigFromInt(&bi,(G)aa_math_system_smallprime[i]);
  aaBigMod(&bv,r,&bi);
  if(aaBigIsZero(&bv)==YES)
   {
   aaBigCompare(&bi,r,&dif);
   if(dif==0) { return RET_YES; }
   return RET_NO;
   }
  }
 return RET_POSSIBLE;
 }









 B aaBigShiftLeft                      (_big*r,_big*a,_big*b)
 {
 Z j;
 _big tba;
 _big tbb;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)

 if(a->base!=10) { oof; }
 if(b->base!=10) { oof; }

 aaBigCopy(&tbb,b);

 aaBigCopy(&tba,a);
 aaBigBaseSet(&tba,2);

 while(1)
  {
  if(aaBigIsZero(&tbb)==YES) { break; }
  for(j=tba.last_digit;j>=0;j--)    {  tba.digits[j+1]=tba.digits[j];    } tba.digits[0]=0;
  tba.last_digit++;
  aaBigDec(&tbb);
  }

 aaBigBaseSet(&tba,10);
 return(aaBigCopy(r,&tba));
 }






 B aaBigShiftRight                     (_big*r,_big*a,_big*b)
 {
 Z j;
 _big tba;
 _big tbb;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaMissingParm(b);
 aaMagicCheck(b,aaBigInit)
 if(a->base!=10) { oof; }
 if(b->base!=10) { oof; }

 aaBigCopy(&tbb,b);

 aaBigCopy(&tba,a);
 aaBigBaseSet(&tba,2);

 while(1)
  {
  if(aaBigIsZero(&tbb)==YES) { break; }
  for(j=0;j<=tba.last_digit;j++)    {    tba.digits[j]=tba.digits[j+1];    }
  aaBigDec(&tbb);
  }

 aaBigBaseSet(&tba,10);
 return(aaBigCopy(r,&tba));
 }







 B aaBigShiftLeftInt                   (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigShiftLeft(r,a,&ib));
 }




 B aaBigShiftRightInt                  (_big*r,_big*a,G b)
 {
 _big ib;

 aaMissingParm(r);
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)
 aaBigFromInt(&ib,b);
 return(aaBigShiftRight(r,a,&ib));
 }







 B aaBigBitSet                         (_big*r,_big*a)
 {
 Z k;
 G v,toa;
 _big tbr;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)

 if(r->base!=10) { oof; }
 if(a->base!=10) { oof; }
 aaBigCopy(&tbr,r);
 aaBigBaseSet(&tbr,2);
 aaBigToInt(a,&v);
 if(v>(G)tbr.last_digit)
  {
  toa=v-(G)tbr.last_digit;
  for(k=0;k<(Z)toa;k++)
   {
   tbr.last_digit++;
   tbr.digits[tbr.last_digit]=0;
   }
  }
 tbr.digits[v]=1;
 aaBigBaseSet(&tbr,10);
 return(aaBigCopy(r,&tbr));
 }






 B aaBigBitIsSet                       (_big*r,_big*a)
 {
 Z k;
 G v,toa;
 _big tbr;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)

 if(r->base!=10) { oof; }
 if(a->base!=10) { oof; }
 aaBigCopy(&tbr,r);
 aaBigBaseSet(&tbr,2);
 aaBigToInt(a,&v);
 if(v>(G)tbr.last_digit)
  {
  toa=v-(G)tbr.last_digit;
  for(k=0;k<(Z)toa;k++)
   {
   tbr.last_digit++;
   tbr.digits[tbr.last_digit]=0;
   }
  }
 if(tbr.digits[v]) {  return RET_YES; }
 return RET_NO;
 }






 B aaBigBitClear                       (_big*r,_big*a)
 {
 Z k;
 G v,toa;
 _big tbr;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaMissingParm(a);
 aaMagicCheck(a,aaBigInit)

 if(r->base!=10) { oof; }
 if(a->base!=10) { oof; }
 aaBigCopy(&tbr,r);
 aaBigBaseSet(&tbr,2);
 aaBigToInt(a,&v);
 if(v>(G)tbr.last_digit)
  {
  toa=v-(G)tbr.last_digit;
  tbr.last_digit+=(Z)toa;
  for(k=0;k<(Z)toa;k++)
   {
   tbr.digits[tbr.last_digit-k]=0;
   }
  }
 tbr.digits[v]=0;
 aaBigBaseSet(&tbr,10);
 return(aaBigCopy(r,&tbr));
 }





 B aaBigBitSetInt                      (_big*r,G a)
 {
 _big ia;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaBigFromInt(&ia,a);
 return(aaBigBitSet(r,&ia));
 }



 B aaBigBitIsSetInt                    (_big*r,G a)
 {
 _big ia;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaBigFromInt(&ia,a);
 return(aaBigBitIsSet(r,&ia));
 }




 B aaBigBitClearInt                    (_big*r,G a)
 {
 _big ia;

 aaMissingParm(r);
 aaMagicCheck(r,aaBigInit)
 aaBigFromInt(&ia,a);
 return(aaBigBitClear(r,&ia));
 }







/*-----------------------------------------------------------------------*/


 B aaDynbufCreate                      (HP handle)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.dynbuf_system.object_id,handle,(VP)&dynp))!=RET_YES) { oops; return ret; }
 dynp->self_handle=*handle;
 return RET_YES;
 }




 B aaDynbufDestroy                     (H handle)
 {
 B ret;
 _aa_dynbufobject*dynp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(dynp->status.bytes_allocated!=0)
  {
  if((ret=aa_MemoryProtect(dynp->status.mem,NO))!=YES) { oops; }
  if((ret=aa_MemoryRelease(dynp->status.mem))!=YES) { oops; }
  }
 if((ret=aa_ObjectDestroy(aa.dynbuf_system.object_id,handle))!=YES) {oops; }
 return RET_YES;
 }





 B aaDynbufStatus                      (H handle,_dynbufstatus*dynbufstatus)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(dynbufstatus!=NULL) { aaMemoryCopy(dynbufstatus,sizeof(_dynbufstatus),&dynp->status); }
 return RET_YES;
 }





 B aaDynbufReset                       (H handle)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(dynp->status.bytes_allocated>0)   {   dynp->status.mem[0]=NULL_CHAR;  }
 dynp->status.bytes_used=0;
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 dynp->read_bit_pos=0;
 dynp->write_bit_pos=0;
 dynp->status.bits_used=0;
 return RET_YES;
 }




 B aaDynbufSeek                        (H handle,H offset)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(offset==F32) { offset=dynp->status.bytes_used; }
 if((offset+_1K)>=dynp->status.bytes_allocated)
  {
  if((ret=aa_DynbufSystemExtend((VP)&dynp,((offset+_4K)-dynp->status.bytes_allocated)))!=YES) { oops; }
  }
 dynp->status.bytes_used=(offset+1);
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 return RET_YES;
 }




 B aaDynbufAppendByte                  (H handle,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaDynbufAppend(handle,1,&val));
 }

 B aaDynbufAppendWord                  (H handle,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaDynbufAppend(handle,2,&val));
 }

 B aaDynbufAppendDword                 (H handle,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaDynbufAppend(handle,4,&val));
 }



 B aaDynbufAppend                      (H handle,H bytes,VP data)
 {
 B ret;
 _aa_dynbufobject*dynp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
// left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 if((bytes+_1K)>=dynp->status.bytes_left)
  {
  if((ret=aa_DynbufSystemExtend((VP)&dynp,bytes+_4K+(dynp->status.bytes_allocated/10)))!=YES) {oops; }
//  BUG,".. %i=%i %i",bytes,left,dynp->bytes_allocated);
  }
 aaMemoryCopy(&dynp->status.mem[dynp->status.bytes_used],bytes,data);
 dynp->status.bytes_used+=bytes;
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 dynp->status.mem[dynp->status.bytes_used]=NULL_CHAR;
 return RET_YES;
 }





 B aaDynbufAppendf                     (H handle,VP fmt,...)
 {
 B ret;
 _aa_dynbufobject*dynp;
 va_list argptr;
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_DynAppendf))!=RET_YES) { return ret; }
  }
 else oof;
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 aaStringLen(tmp,&sl);
 return(aaDynbufAppend(handle,sl,tmp));
 }





 B aaDynbufAppendBits                  (H handle,H bits,N data,B issigned)
 {
 B ret;
 _aa_dynbufobject*dynp;
 H bpos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dynbuf_system.object_id,handle,(VP)&dynp,NULL))!=RET_YES) { return ret; }
 if(issigned)
  {
  if(data<0) {   data=(1<<bits)+data; }
  }
 bpos=dynp->write_bit_pos;
 if(dynp->status.bytes_left<_1K)
  {
  if((ret=aa_DynbufSystemExtend((VP)&dynp,_4K+(dynp->status.bytes_allocated/16)))!=YES) {oops; }
  }
 while(bits>0)
  {
  if(bits+bpos>=8)
   {
   dynp->status.mem[dynp->status.bytes_used]+=(B)((data>>(bits+bpos-8))&F8);
   bits-=8-bpos;
   ++dynp->status.bytes_used;
   --dynp->status.bytes_left;
   dynp->status.bits_used+=(8-bpos);
   dynp->status.mem[dynp->status.bytes_used]=0;
   bpos=0;
   }
  else
   {
   dynp->status.mem[dynp->status.bytes_used]+=(B)((data<<(8-bits-bpos))&F8);
   dynp->status.bits_used+=bits;
   bpos+=bits;
   bits=0;
   }
  }
 dynp->write_bit_pos=bpos;
 dynp->status.bytes_used=dynp->status.bits_used/8;
 if(dynp->write_bit_pos!=0) { dynp->status.bytes_used++; }
 dynp->status.bytes_left=dynp->status.bytes_allocated-dynp->status.bytes_used;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaArrayCreate                       (HP handle)
 {
 B ret;
 _aa_arrayobject*arp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.array_system.object_id,handle,(VP)&arp))!=RET_YES) { oops; return ret; }
 if(aa_ArraySystemExtendPageSlots((VP)&arp,32)!=RET_YES)
  {
  aaArrayDestroy(*handle);
  *handle=0;
  return RET_FAILED;
  }
 arp->self_handle=*handle;
 return RET_YES;
 }







 B aaArrayDestroy                      (H handle)
 {
 B ret;
 _aa_arrayobject*arp;
 B isprot;
 H p;
 H release_count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.array_system.object_id,handle,(VP)&arp,&isprot))!=RET_YES) {  return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 release_count=0;
 for(p=0;p<arp->slots_allocated;p++)
  {
  if(arp->pge_slot[p]!=0)
   {
   if(arp->pages_allocated==0)
    {
    logg("pages allocated is zero, and were trying to release,, p = %i",p);
    }
   aa_PageRelease(arp->pge_slot[p]);
   arp->pge_slot[p]=0;
   arp->pages_allocated--;
   release_count++;
   }
  }
 if(arp->pages_allocated!=0)
  {
  logg("Page leak: pages allocated = %i slots allocated = %i releasecount=%i",arp->pages_allocated,arp->slots_allocated,release_count);
  }
 if(arp->slots_allocated!=0)
  {
  logg("array releasing memory for %i slots",arp->slots_allocated);
  aa_MemoryRelease(arp->pge_slot);
  arp->slots_allocated=0;
  arp->pge_slot=NULL;
  }
 if(release_count!=0)
  {
  logg("aaArrayDestroy released %i pages",release_count);
  }
 aa_ObjectDestroy(aa.array_system.object_id,handle);
 return RET_YES;
 }







 B aaArrayStatus                       (H handle,_arraystatus*arraystatus)
 {
 B ret;
 _aa_arrayobject*arp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.array_system.object_id,handle,(VP)&arp,NULL))!=RET_YES) { return ret; }
 if(arraystatus) {  aaMemoryCopy(arraystatus,sizeof(_arraystatus),&arp->status); }
 return RET_YES;
 }






 B aaArrayLengthSet                    (H handle,H bytes)
 {
 B ret;
 _aa_arrayobject*arp;
 H i,by;
 H pages_required;
 H pages_toadd;
 H slots_toadd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.array_system.object_id,handle,(VP)&arp,NULL))!=RET_YES) { return ret; }
 if(bytes<=arp->actual_bytes_allocated)
  {
  arp->status.length=bytes;
  return RET_YES;
  }
 pages_required=bytes/aa.page_system.bytes_per_page;
 if((bytes%aa.page_system.bytes_per_page)!=0) { pages_required++; }
 if(pages_required>=(arp->slots_allocated-arp->pages_allocated))
  {
  by=16;
  slots_toadd=(pages_required-(arp->slots_allocated-arp->pages_allocated))+by;
  if(aa_ArraySystemExtendPageSlots((VP)&arp,slots_toadd)!=RET_YES) { return ret; }
  }

 pages_toadd=pages_required-arp->pages_allocated;
 if(pages_toadd)
  {
  for(i=0;i<pages_toadd;i++)
   {
   if((ret=aa_PageAllocate(&arp->pge_slot[arp->pages_allocated+i],0,"ArrPgeSlot"))!=RET_YES) { return ret; }
   }
  arp->pages_allocated+=pages_toadd;
  }
 arp->actual_bytes_allocated=arp->pages_allocated*aa.page_system.bytes_per_page;
 arp->status.length=bytes;
 return RET_YES;
 }



 B aaArrayWrite                        (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_arrayobject*arp;
 H toend;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.array_system.object_id,handle,(VP)&arp,NULL))!=RET_YES) { return ret; }
 if(bytes!=0&&data==NULL) { return RET_BADPARM; }
 if(offset>=arp->status.length) { aaNote(0,"off=%i len=%i dif=%i",offset,arp->status.length,arp->status.length-offset);  return RET_BOUNDS; }
 toend=arp->status.length-offset;
 if(bytes>toend) { aaNote(0,"bty=%i 2end=%i len=%i",bytes,toend,arp->status.length); return RET_BOUNDS; }
 if(bytes==0) { return RET_YES; }
 if((ret=aa_PageArrayIo(arp->pge_slot,arp->pages_allocated,offset,bytes,data,YES))!=RET_YES) { oof; Boop; }
 return RET_YES;
 }






 B aaArrayRead                         (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_arrayobject*arp;
 H toend;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.array_system.object_id,handle,(VP)&arp,NULL))!=RET_YES) { return ret; }
 if(bytes!=0&&data==NULL) { return RET_BADPARM; }
 if(offset>=arp->status.length) { return RET_BOUNDS; }
 toend=arp->status.length-offset;
 if(bytes>toend) { return RET_BOUNDS; }
 if(bytes==0) { return RET_YES; }
 if((ret=aa_PageArrayIo(arp->pge_slot,arp->pages_allocated,offset,bytes,data,NO))!=RET_YES) { oof; Boop; }
 return RET_YES;
 }







 B aaArrayFill                         (H handle,H offset,H bytes,B val)
 {
 B ret;
 _aa_arrayobject*arp;
 H toend;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.array_system.object_id,handle,(VP)&arp,NULL))!=RET_YES) { return ret; }
 if(offset>=arp->status.length) { return RET_BOUNDS; }
 toend=arp->status.length-offset;
 if(bytes>toend) { return RET_BOUNDS; }
 if((ret=aa_PageArrayFill(arp->pge_slot,arp->pages_allocated,offset,bytes,val))!=RET_YES) { oof; Boop; }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/









 B aaQueCreate                         (HP handle)
 {
 B ret;
 _aa_queobject*quep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aa_last_line_executed=__LINE__;
 if((ret=aa_ObjectCreate(aa.que_system.object_id,handle,(VP)&quep))!=RET_YES) { oops; return ret; }
 aa_last_line_executed=__LINE__;
 if(aa_QueSystemExtendPageSlots((VP)&quep,128)!=RET_YES) // hooters
  {
  aa_last_line_executed=__LINE__;
  aaQueDestroy(*handle);
  *handle=0;
  return RET_FAILED;
  }
 aa_last_line_executed=__LINE__;
 quep->self_handle=*handle;
 logg("Que Created: handle=%lu",*handle);
 return RET_YES;
 }






 B aaQueDestroy                        (H handle)
 {
 B ret;
 _aa_queobject*quep;
 B isprot;
 H p;
 H release_count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 release_count=0;
 for(p=0;p<quep->slots_allocated;p++)
  {
  if(quep->pages_allocated==0)  { break; }
  if(quep->pge_slot[p]!=0)
   {
   aa_PageRelease(quep->pge_slot[p]);
   quep->pge_slot[p]=0;
   quep->pages_allocated--;
   release_count++;
   }
  }
 if(quep->pages_allocated!=0)
  {
  aaLog(-1,"Pge leak: pages allocated = %i slots allocated = %i releasecount=%i",quep->pages_allocated,quep->slots_allocated,release_count);
  //oof;
  Boop;
  }
 if(quep->slots_allocated!=0)
  {
  aa_MemoryRelease(quep->pge_slot);
  quep->slots_allocated=0;
  quep->pge_slot=NULL;
  }
 aa_ObjectDestroy(aa.que_system.object_id,handle);
 return RET_YES;
 }





 B aaQueStatus                         (H handle,_questatus*questatus)
 {
 B ret;
 _aa_queobject*quep;
 H mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(questatus)
  {
  mx=sizeof(_questatus);
  if(mx==4) {  questatus->bytes=quep->status.bytes;   } // goey: if status is only H bytes, then dont memcopy
  else      {  aaMemoryCopy(questatus,sizeof(_questatus),&quep->status);   }
  }
 return RET_YES;
 }







 B aaQueWrite                          (H handle,H bytes,VP data)
 {
 B ret;
 _aa_queobject*quep;
 H pages_required;
 H pages_available;
 H bytes_available;
 H extra_bytes_required;
 H extra_pages_required;
 H p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }

 bytes_available=(quep->pages_allocated*aa.page_system.bytes_per_page)-quep->head;
 pages_required=bytes/aa.page_system.bytes_per_page;
 if((bytes%aa.page_system.bytes_per_page)!=0) pages_required++;
 pages_available=quep->slots_allocated-quep->pages_allocated;

 if(pages_available<=(pages_required+2)) // why is this +2 ??
  {
  if((ret=aa_QueSystemExtendPageSlots((VP)&quep,pages_required+8))!=RET_YES) { oops; }
  // added nov 22 , 2006 - recalc bytes available after extending slots
  bytes_available=(quep->pages_allocated*aa.page_system.bytes_per_page)-quep->head;
  pages_required=bytes/aa.page_system.bytes_per_page;
  if((bytes%aa.page_system.bytes_per_page)!=0) pages_required++;
  pages_available=quep->slots_allocated-quep->pages_allocated;
  if(pages_available<=(pages_required+2)) { oof; }
  }


 if(bytes_available>=bytes)
  {
  if((ret=aa_PageArrayIo(quep->pge_slot,quep->pages_allocated,quep->head,bytes,data,YES))!=RET_YES) { oof; Boop; }
  quep->status.bytes+=bytes;
  quep->head+=bytes;
  quep->status.total_bytes_written+=(Q)bytes;
  return RET_YES;
  }

 extra_bytes_required=bytes-bytes_available;
 extra_pages_required=extra_bytes_required/aa.page_system.bytes_per_page;
 if((extra_bytes_required%aa.page_system.bytes_per_page)!=0) { extra_pages_required++; }

 if(extra_pages_required)
  {
  logg("Que handle %i, requires %i more pages",handle,extra_pages_required);
  }
 for(p=0;p<extra_pages_required;p++)
  {
  if((ret=aa_PageAllocate(&quep->pge_slot[quep->pages_allocated+p],0,"QuePage"))!=RET_YES) { oops; }
  }
 quep->pages_allocated+=extra_pages_required;
 if(extra_pages_required)
  {
  logg("Que handle %i, addiotional page allocation success",handle);
  }

 bytes_available=(quep->pages_allocated*aa.page_system.bytes_per_page)-quep->head;
 if(bytes_available<bytes) { oof; Boop; }
 if((ret=aa_PageArrayIo(quep->pge_slot,quep->pages_allocated,quep->head,bytes,data,YES))!=RET_YES)
  {
  oops;
  aaNote(0,"pages_allocated=%i head=%i bytes=%i bavail=%i",quep->pages_allocated,quep->head,bytes,bytes_available);
  }

 if(extra_pages_required)
  {
  logg("Que handle %i, has completed the pageIO",handle);
  }

 quep->status.bytes+=bytes;
 quep->head+=bytes;
 quep->status.total_bytes_written+=(Q)bytes;
 return RET_YES;
 }






 B aaQueWritef                         (H handle,VP fmt,...)
 {
 va_list argptr;
 B txt[_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_YES; }
 return(aaQueWrite(handle,sl,txt));
 }

 B aaQueWriteByte                      (H handle,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,1,&val));
 }


 B aaQueWriteWord                      (H handle,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,2,&val));
 }

 B aaQueWriteDword                     (H handle,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,4,&val));
 }

 B aaQueWriteQuad                      (H handle,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueWrite(handle,8,&val));
 }





 B aaQueRead                           (H handle,H bytes,VP data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaQuePeek(handle,0,bytes,data))!=RET_YES) {  return ret; }
 if((ret=aaQueDiscard(handle,bytes))!=RET_YES) { return ret; }
 return RET_YES;
 }


 B aaQueReadByte                       (H handle,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,1,val));
 }


 B aaQueReadWord                       (H handle,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,2,val));
 }

 B aaQueReadDword                      (H handle,HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,4,val));
 }

 B aaQueReadQuad                       (H handle,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQueRead(handle,8,val));
 }



 B aaQuePeek                           (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_queobject*quep;
 H avail;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes>quep->status.bytes) { return RET_BOUNDS; }
 if(offset>=quep->status.bytes) { return RET_BOUNDS; }
 avail=quep->status.bytes-offset;
 if(bytes>avail) { return RET_BOUNDS; }
 if((ret=aa_PageArrayIo(quep->pge_slot,quep->pages_allocated,quep->tail+offset,bytes,data,NO))!=RET_YES)
  {
  aaNote(0,"PLEASE TAKE A SCREEN SHOT OF THIS MESSAGE\n\nLINE=%i\n\nRET = %s\nquep->pages_allocated=%i\nquep->tail=%i,quep->head=%i\noffset=%i,bytes=%i\nquep->status.bytes=%i",__LINE__,ret_string[ret],quep->pages_allocated,quep->tail,quep->head,offset,bytes,quep->status.bytes);
  return ret;
  }
 return RET_YES;
 }


 B aaQuePeekByte                       (H handle,H offset,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,1,val));
 }

 B aaQuePeekWord                       (H handle,H offset,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,2,val));
 }

 B aaQuePeekDword                      (H handle,H offset,HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,4,val));
 }

 B aaQuePeekQuad                       (H handle,H offset,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaQuePeek(handle,offset,8,val));
 }



 B aaQueFindByte                       (H handle,H offset,H bytes,HP pos,B val,B logic,H number)
 {
 B ret;
 _aa_queobject*quep;
 BP tmp;
 H cando,have,todo,i,c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if((ret=aa_MemoryTemp((VP)&tmp,_4K+quep->status.bytes,aa_MEMORYTEMP_QueFind))!=RET_YES) { oops; return ret; }
 if(pos) { *pos=F32; }
 have=quep->status.bytes;
 if(offset>=have) { return RET_BOUNDS; }
 cando=have-offset;
 if(cando==0) { return RET_BOUNDS; }
 if(bytes==F32) { bytes=cando; }
 if(bytes>cando) { return RET_BOUNDS; }
 todo=bytes;
 if(todo==0) { return RET_NOTFOUND; }
 if((ret=aaQuePeek(handle,offset,todo,tmp))!=RET_YES) { oops; return ret; }
 c=0;
 for(i=0;i<todo;i++)
  {
  if(tmp[i]==val&&logic==YES)
   {
   if(number==c)
    {
    if(pos) { *pos=i; }
    return RET_YES;
    }
   c++;
   continue;
   }
  if(tmp[i]!=val&&logic!=YES)
   {
   if(number==c)
    {
    if(pos) { *pos=i; }
    return RET_YES;
    }
   c++;
   continue;
   }
  }
 return RET_NOTFOUND;
 }




 B aaQueDiscard                        (H handle,H bytes)
 {
 B ret;
 _aa_queobject*quep;
 H avail,todo;
 H t_page,t_offset;
// H h_page,h_offset;
 H bytes_to_next;
 H slot_index;
 H z;
// B temp[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 avail=quep->status.bytes;
 if(bytes==F32) { bytes=avail; }
 if(bytes>avail) { return RET_BOUNDS; }
// if(sizeof(temp)<aa.page_system.bytes_per_page)  {  fb; } // make temp equals or bigger than bytesperpage
 while(bytes)
  {
  todo=bytes;
  t_page=quep->tail/aa.page_system.bytes_per_page;
//  h_page=quep->head/aa.page_system.bytes_per_page;
  t_offset=quep->tail%aa.page_system.bytes_per_page;
//  h_offset=quep->head%aa.page_system.bytes_per_page;
  bytes_to_next=aa.page_system.bytes_per_page-t_offset;
  todo=aaNumRoof(todo,bytes_to_next);
  quep->tail+=todo;
  quep->status.bytes-=todo;
  quep->status.total_bytes_read+=(Q)todo;
  slot_index=quep->tail/aa.page_system.bytes_per_page;
  if(slot_index==t_page&&((bytes-todo)!=0)) { oof;  Boop; }
  if(slot_index>t_page)
   {
   if((slot_index-t_page)>1)
    {
    aaNote(0,"slot_ndx=%i, t_page=%i delta=%i",slot_index,t_page,slot_index-t_page);
    logg("aaa");
    Boop;
    }
   if(quep->slots_allocated==0)
    {
    aaNote(0,"slots_alocatd=0");
    logg("ggg");
    Boop;
    }
   if(quep->pages_allocated==0)
    {
    aaNote(0,"pges_alocatd=0");
    logg("seg");
    Boop;
    }
   if(t_page!=0)
    {
    logg("tp=%i",t_page);
    }

   if((ret=aa_PageRelease(quep->pge_slot[t_page]))!=RET_YES)
    {
    logg("rl=%i",ret);
    }
//   log(Que released page slot[%i] during QueDiscard(%i,%i)",t_page,handle,bytes);
   if(quep->slots_allocated>1)
    {
    for(z=0;z<(quep->slots_allocated-1);z++) {   quep->pge_slot[z]=quep->pge_slot[z+1]; }
    }
   quep->pages_allocated--;
   quep->pge_slot[quep->pages_allocated]=0;
   quep->tail-=aa.page_system.bytes_per_page;
   quep->head-=aa.page_system.bytes_per_page;
   }

  bytes-=todo;
  }
 if(quep->status.bytes==0)
  {
  quep->tail=quep->head=0;
  }
 quep->crlf_state=0;
 //quep->status.total_bytes_read+=(Q)bytes;
 return RET_YES;
 }



 B aaQueStringLen                      (H handle,HP chars,BP stringmode)
 {
 B ret;
 _aa_queobject*quep;
 H i,cando;
 H atatime;
 B block[_4K];
 C ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) {return ret; }
 if(chars==NULL)  {  return RET_BADPARM;  }
 *chars=0;
 if(stringmode) { *stringmode=0; }
 if((ret=aaQueStatus(handle,0))!=RET_YES) {  return ret; }
 atatime=_1K;
 switch(quep->crlf_state)
  {
  case 0:
  quep->line_chars=0;
  quep->line_peek_offset=0;
  quep->crlf_state=1;
  case 1:
  case 2:
  if((cando=aaNumRoof((quep->status.bytes-quep->line_peek_offset),atatime))!=0)
   {
   if((ret=aaQuePeek(handle,quep->line_peek_offset,cando,block))!=RET_YES) { oops; }
   for(i=0;i<cando;i++)
    {
    ch=block[i];
    quep->line_peek_offset++;
    quep->line_chars++;
    if(ch==CR_CHAR)
     {
     if(quep->crlf_state!=1) { quep->crlf_state=4; break; }
     quep->crlf_state=2;
     break;
     }
    if(ch==LF_CHAR)
     {
     if(quep->crlf_state==1) { quep->crlf_state=5; } // lf
     else
     if(quep->crlf_state==2) { quep->crlf_state=6; } // crlf
     break;
     }
    if(quep->crlf_state==2)
     {
     quep->line_chars--;
     quep->line_peek_offset--;
     quep->crlf_state=4; // cr
     break;
     }
    quep->crlf_state=1;
    }
   }
  break;

  default:
  break;
  }
 if(quep->crlf_state>=4)
  {
  if(stringmode) {  *stringmode=(B)(quep->crlf_state-3); }
  *chars=quep->line_chars; // dont' make *chars anything other than zero, until line complete,, to prevent binary data looking like part of incomplete header
  return RET_YES;
  }
 return RET_NOTREADY;
 }



 B aaQueStringRead                     (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H ch,len;
 B mo;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf) { aaStringNull(buf); }
 if(stringmode) { *stringmode=0; }
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(maxchars==0) { return RET_BADPARM; }
 if(buf==NULL) { return RET_BADPARM; }
 aaStringNull(buf);
 ret=aaQueStringLen(handle,&len,&mo);
 if(stringmode) { *stringmode=mo; }
 if(chars) { *chars=len; }
 if(ret!=RET_NOTREADY&&ret!=RET_YES) { return ret; }
 if(ret==RET_YES)
  {
  ch=len;
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { ch=len-1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { ch=len-2; }  else { oof; }
  *chars=ch;
  if(ch>maxchars) {  return RET_BOUNDS; }
  if((ret=aaQueRead(handle,len,buf))!=RET_YES) { oops; }
  aaCast(bp,BP,buf);
  bp[ch]=NULL_CHAR;
  return RET_YES;
  }
 return RET_NOTREADY;
 }





 B aaQueReturn                         (H handle,H bytes)
 {
 B ret;
 _aa_queobject*quep;
 B block[_4K];
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes>quep->status.bytes) { return RET_BOUNDS; }
 if(bytes==quep->status.bytes) { return RET_YES; }
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_4K);
  if((ret=aaQueRead(handle,todo,block))!=RET_YES) { oops; }
  if((ret=aaQueWrite(handle,todo,block))!=RET_YES) { oops; }
  bytes-=todo;
  }
 return RET_YES;
 }



 B aaQueTrim                           (H handle,H bytes)
 {
 B ret;
 _aa_queobject*quep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.que_system.object_id,handle,(VP)&quep,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(bytes==F32||bytes==quep->status.bytes)
  {
  if(quep->status.bytes==0) { return RET_YES; }
  if((ret=aaQueDiscard(handle,F32))!=RET_YES) { return ret; }
  }
 if(bytes>quep->status.bytes) { return RET_BOUNDS; }
 quep->head-=bytes;
 quep->status.bytes-=bytes;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/




 B aaVectorNew                         (_aavector*aavector,H slotbytes,H initialslots)
 {
 B ret;
 H hx=(H)(PP)aaVectorNew;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aavector==NULL) { return RET_BADPARM; }
 aaMemoryFill(aavector,sizeof(_aavector),0);
 if(slotbytes==0) { return RET_BADPARM; }
 aavector->magic=hx;
 aavector->bytes=slotbytes;
 if(initialslots)  {  if((ret=aaVectorExtendSlots(aavector,initialslots))!=RET_YES) { oops; return ret; }  }
 return RET_YES;
 }



 B aaVectorDelete                      (_aavector*aavector)
 {
 H hx=(H)(PP)aaVectorNew;
 _aavectorslot avs;
 B ret;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aavector==NULL) { return RET_BADPARM; }
 if(aavector->magic!=hx) { return RET_NOTINITIALIZED; }
 for(i=0;i<aavector->count;i++)
  {
  if((ret=aaVectorSlotGet(aavector,i,&avs))!=RET_YES) { oops; }
  if(avs.data_bytes)   {  if((ret=aaVectorDataBytesSet(aavector,i,0,0))!=RET_YES) { oops; }   }
  }
 if(aavector->count!=0)
  {
  if((ret=aa_MemoryProtect(aavector->mem,NO))!=RET_YES) { oops; }
  aaMemoryRelease(aavector->mem);
  }
 aaMemoryFill(aavector,sizeof(_aavector),0);
 return RET_YES;
 }




 B aaVectorExtendSlots                 (_aavector*aavector,H amnt)
 {
 H hx=(H)(PP)aaVectorNew;
 B ret;
 H add,sb;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aavector==NULL) { return RET_BADPARM; }
 if(aavector->magic!=hx) { return RET_NOTINITIALIZED; }
 sb=aavector->bytes+8;
 add=aavector->count+amnt;
 if(aavector->count!=0)   {   if((ret=aa_MemoryProtect(aavector->mem,NO))!=RET_YES) { oops; }    }
 if(aavector->count==0)
  {
  aaMemoryAllocate((VP)&aavector->mem,add*sb);
  aaMemoryNameSet(aavector->mem,"vecslot"); //charlie
  }
 else       { aaMemoryReAllocate((VP)&aavector->mem,add*sb); }
 if((ret=aa_MemoryProtect(aavector->mem,YES))!=RET_YES) { oops; }
 aavector->count=add;
 aavector->left=aavector->count-aavector->used;
 return RET_YES;
 }




 B aaVectorDataBytesSet                (_aavector*aavector,H slot,H bytes,_aavectorslot*aavectorslot)
 {
 _aavectorslot avs;
 BP byteptr;
 H sb;
 B ret;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aavectorslot) { aaMemoryFill(aavectorslot,sizeof(_aavectorslot),0); }
 if((ret=aaVectorSlotGet(aavector,slot,&avs))!=RET_YES) { oops; }
 byteptr=(BP)avs.data_ptr;
 bp=(BP)aavector->mem;
 sb=aavector->bytes+8;
 if(bytes!=0&&avs.data_bytes==0)
  {
  if((ret=aaMemoryAllocate((VP)&byteptr,bytes))!=RET_YES) { oops; }
  *(HP)&bp[((slot+1)*sb)-8]=bytes;
  *(HP)&bp[((slot+1)*sb)-4]=(H)byteptr;
  aaMemoryNameSet(byteptr,"vecdat");
  if((ret=aa_MemoryProtect(byteptr,YES))!=RET_YES) { oops; }
  aavector->total_data_bytes+=(Q)bytes;
  }
 else
 if(bytes==0&&avs.data_bytes!=0)
  {
  if((ret=aa_MemoryProtect(byteptr,NO))!=RET_YES) { oops; }
  if((ret=aaMemoryRelease(byteptr))!=RET_YES) { oops; }
  *(HP)&bp[((slot+1)*sb)-8]=0;
  *(HP)&bp[((slot+1)*sb)-4]=0;
  aavector->total_data_bytes-=(Q)avs.data_bytes;
  }
 else
 if(bytes!=0&&avs.data_bytes!=0)
  {
  if(bytes!=avs.data_bytes)
   {
   if((ret=aa_MemoryProtect(byteptr,NO))!=RET_YES) { oops; }
   aavector->total_data_bytes-=(Q)avs.data_bytes;
   if((ret=aaMemoryReAllocate((VP)&byteptr,bytes))!=RET_YES) { oops; }
   aavector->total_data_bytes+=(Q)bytes;
   *(HP)&bp[((slot+1)*sb)-8]=bytes;
   *(HP)&bp[((slot+1)*sb)-4]=(H)byteptr;
   if((ret=aa_MemoryProtect(byteptr,YES))!=RET_YES) { oops; }
   }
  }
 if(aavectorslot)
  {
  if((ret=aaVectorSlotGet(aavector,slot,aavectorslot))!=RET_YES) { oops; }
  }
 return RET_YES;
 }





 B aaVectorSlotGet                     (_aavector*aavector,H slot,_aavectorslot*aavectorslot)
 {
 H hx=(H)(PP)aaVectorNew;
 H sb;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aavector==NULL) { return RET_BADPARM; }
 if(aavector->magic!=hx) { return RET_NOTINITIALIZED; }
 //if(aavectorslot) { aaMemoryFill(aavectorslot,sizeof(_aavectorslot),0); }
 if(slot>=aavector->count)
  {
  if(aavectorslot) { aaMemoryFill(aavectorslot,sizeof(_aavectorslot),0); }
  return RET_BOUNDS;
  }
 bp=(BP)aavector->mem;
 sb=aavector->bytes+8;
 if(aavectorslot)
  {
  aavectorslot->ptr=&bp[slot*sb];
  aavectorslot->data_bytes=*(HP)&bp[((slot+1)*sb)-8];
  aavectorslot->data_ptr=(BP)(*(HP)&bp[((slot+1)*sb)-4]);
  }
 return RET_YES;
 }




 B aaVectorUsageAdjust                 (_aavector*aavector,N amount)
 {
 N pre;
 H hx=(H)(PP)aaVectorNew;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aavector==NULL) { return RET_BADPARM; }
 if(aavector->magic!=hx) { return RET_NOTINITIALIZED; }
 pre=aavector->used;
 pre+=(N)amount;
 if(pre<0||pre>=(N)aavector->count) { return RET_BOUNDS; }
 aavector->used+=amount;
 aavector->left=aavector->count-aavector->used;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaHuffNew                           (_aahuff*aahuff)
 {
 B ret;
 H bytes;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 aaMemoryFill(aahuff,sizeof(_aahuff),0);
 aahuff->magic=(H)(PP)aaHuffNew;
 aahuff->is_initialized=YES;
 bytes=aa_HUFF_HEAP_SIZE;
 if(bytes<_64K) { bytes=_64K; }
 if((ret=aaMemoryUnitAllocate(&aahuff->heap_buf,bytes))!=YES) oops;
 return RET_YES;
 }




 B aaHuffDelete                        (_aahuff*aahuff)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 if(aahuff->magic!=(H)(PP)aaHuffNew) { return RET_NOTINITIALIZED; }
 if(aahuff->is_initialized!=YES)  { return RET_NOTINITIALIZED; }
 if(aahuff->heap_buf.bytes) aaMemoryUnitRelease(&aahuff->heap_buf);
 aaMemoryFill(aahuff,sizeof(_aahuff),0);
 return RET_YES;
 }




 B aaHuffEncode                        (_aahuff*aahuff,H ibytes,VP ibuf,HP obytes,H obufmax,VP obuf)
 {
 H rr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 if(aahuff->magic!=(H)(PP)aaHuffNew) { return RET_NOTINITIALIZED; }
 if(aahuff->is_initialized!=YES)  { return RET_NOTINITIALIZED; }
 if(obytes==NULL) { return RET_BADPARM; }
 *obytes=0;
 if(ibuf==NULL) { return RET_BADPARM; }
 if(obuf==NULL) { return RET_BADPARM; }
 if(ibytes==0) { aaStringLen(ibuf,&ibytes); }
 rr=aa_huffmanCompress(ibuf,ibytes,obuf,obufmax,aahuff->heap_buf.mem);
 if(rr==(F32-1)) { return RET_BOUNDS; }
 if(rr==F32) { return RET_FAILED; }
 *obytes=rr;
 return RET_YES;
 }




 B aaHuffDecode                        (_aahuff*aahuff,H ibytes,VP ibuf,HP obytes,H obufmax,VP obuf)
 {
 H rr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aahuff==NULL) { return RET_BADPARM; }
 if(aahuff->magic!=(H)(PP)aaHuffNew) { return RET_NOTINITIALIZED; }
 if(aahuff->is_initialized!=YES)  { return RET_NOTINITIALIZED; }
 if(obytes==NULL) { return RET_BADPARM; }
 *obytes=0;
 if(ibuf==NULL) { return RET_BADPARM; }
 if(obuf==NULL) { return RET_BADPARM; }
 rr=aa_huffmanDecompress(ibuf,ibytes,obuf,obufmax,aahuff->heap_buf.mem,aahuff->heap_buf.bytes);
 if(rr==(F32-1)) { return RET_BOUNDS; }
 if(rr==F32) { return RET_FAILED; }
 *obytes=rr;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aaLz4Encode                         (VP source,H sbytes,VP dest,HP dbytes)
 {
 Z r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sbytes<(Z)aa_LZ4_64KLIMIT)
  {
  r=aa_LZ4_compress64kCtx(NULL,source,dest,sbytes,aa_LZ4_compressBound(sbytes));
  }
 else
  {
  r=aa_LZ4_compressCtx(NULL,source,dest,sbytes,aa_LZ4_compressBound(sbytes));
  }
 if(r<0) { return RET_FAILED; }
 if(dbytes) { *dbytes=r; }
 return RET_YES;
 }





 B aaLz4Decode                         (VP source,H sbytes,VP dest,HP dbytes,H maxdbytes)
 {
 BP ip=(BP)source;
 BP iend=ip+sbytes;
 BP op=(BP)dest;
 BP oend=op+maxdbytes;
 BP cpy,ref;
 BP src,dst;
 Z dec2,length,s,r;
 B token;
 size_t dec[]={0,3,2,3,0,0,0,0};

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 src=(BP)source;
 dst=(BP)dest;
 while(ip<iend)
  {
  token=*ip++;
  if((length=(token>>aa_LZ4_ML_BITS))==aa_LZ4_RUN_MASK) { s=255; while((ip<iend)&&(s==255)) { s=*ip++; length+=s; } }
  cpy=op+length;
  if((cpy>oend-aa_LZ4_COPYLENGTH)||(ip+length>iend-aa_LZ4_COPYLENGTH))
   {
   if(cpy>oend)       {  goto _output_error; }
   if(ip+length>iend) {  goto _output_error; }
   aaMemoryCopy(op,length,ip);
   //memcpy(op,ip,length);
   op+=length; ip+=length;
   if(ip<iend) { goto _output_error; }
   break;
   }
  aa_LZ4_WILDCOPY(ip,op,cpy); ip-=(op-cpy); op=cpy;
  aa_LZ4_READ_LE_16(ref,cpy,ip); ip+=2;
  if(ref<(BP)dst) { goto _output_error; }
  if((length=(token&aa_LZ4_ML_MASK))==aa_LZ4_ML_MASK) { while(ip<iend) { Z s=*ip++; length+=s; if(s==255) continue; break; } }
  if unlikely(op-ref<aa_LZ4_STEPSIZE)
   {
   dec2=0;
   *op++=*ref++; *op++=*ref++; *op++=*ref++; *op++=*ref++;
   ref-=dec[op-ref];
   aa_LZ4_A32(op)=aa_LZ4_A32(ref); op+=aa_LZ4_STEPSIZE-4;
   ref-=dec2;
   }
  else
   {
   aa_LZ4_COPYSTEP(ref,op);
   }
  cpy=op+length-(aa_LZ4_STEPSIZE-4);
  if(cpy>oend-aa_LZ4_COPYLENGTH)
   {
   if(cpy>oend) {  goto _output_error; }
   aa_LZ4_SECURECOPY(ref,op,(oend-aa_LZ4_COPYLENGTH));
   while(op<cpy) *op++=*ref++;
   op=cpy;
   if(op==oend) break;
   continue;
   }
  aa_LZ4_SECURECOPY(ref,op,cpy);
  op=cpy;
  }

 r=(Z)(((BP)op)-dst);
 if(dbytes) { *dbytes=r; }
 return RET_YES;
 _output_error:
 r=(Z)(-(((BP)ip)-src));
 if(dbytes) { *dbytes=r; }
 return RET_FAILED;
 }








/*-----------------------------------------------------------------------*/




 B aaMiniQueInit                       (_minique*minique)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 minique->magic=aa_MINIQUE_MAGIC;
 minique->head=minique->tail=minique->bytes=0;
 minique->left=sizeof(minique->buf)-minique->bytes;
 return RET_YES;
 }




 B aaMiniQueWrite                      (_minique*minique,H bytes,VP data)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { oof; return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>minique->left) { return RET_BOUNDS; }
 aaCast(bp,BP,data);
 for(off=0;off<bytes;off++)
  {
  minique->buf[minique->head]=bp[off];
  minique->head++;
  minique->head%=sizeof(minique->buf);
  minique->bytes++;
  minique->left--;
  }
 return RET_YES;
 }




 B aaMiniQueRead                       (_minique*minique,H bytes,VP data)
 {
 BP bp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) {  return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>minique->bytes) { return RET_BOUNDS; }
 aaCast(bp,BP,data);
 for(off=0;off<bytes;off++)
  {
  bp[off]=minique->buf[minique->tail];
  minique->tail++;
  minique->tail%=sizeof(minique->buf);
  minique->bytes--;
  minique->left++;
  }
 return RET_YES;
 }




 B aaMiniQuePeek                       (_minique*minique,H offset,H bytes,VP data)
 {
 H off,allow,tt;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { aaNote(0,"fl;as %i %i",minique->magic,aa_MINIQUE_MAGIC);    return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(offset>=minique->bytes) { return RET_BOUNDS; }
 allow=minique->bytes-offset;
 if(bytes==F32) { bytes=allow; }
 if(bytes>allow) { return RET_BOUNDS; }
 if(bytes==F32) { bytes=allow; }
 if(bytes>allow) { return RET_BOUNDS; }
 tt=minique->tail+offset;
 tt=tt%sizeof(minique->buf);
 aaCast(bp,BP,data);
 for(off=0;off<bytes;off++)
  {
  bp[off]=minique->buf[tt];
  tt++;
  tt%=sizeof(minique->buf);
  }
 return RET_YES;
 }





 B aaMiniQueDiscard                    (_minique*minique,H bytes)
 {
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { oof; return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==F32) { bytes=minique->bytes; }
 if(bytes>minique->bytes) { return RET_BOUNDS; }
 for(off=0;off<bytes;off++)
  {
  minique->tail++;
  minique->tail%=sizeof(minique->buf);
  minique->bytes--;
  minique->left++;
  }
 return RET_YES;
 }





 B aaMiniQueReturn                     (_minique*minique,H bytes)
 {
 B ret;
 B tmp[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(minique==NULL) { return RET_BADPARM; }
 if(minique->magic!=aa_MINIQUE_MAGIC) { oof; return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==F32) { bytes=minique->bytes; }
 if(bytes>minique->bytes) { return RET_BOUNDS; }
 if((ret=aaMiniQueRead(minique,bytes,tmp))!=RET_YES) { oops; }
 if((ret=aaMiniQueWrite(minique,bytes,tmp))!=RET_YES) { oops; }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/



 B aaMiniStackInit                     (_ministack*ministack)
 {
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 ministack->magic=aa_MINISTACK_MAGIC;
 ministack->bytes=0;
 ministack->height=0;
 len=sizeof(ministack->buf);
 ministack->left=len;
 return RET_YES;
 }




 B aaMiniStackPush                     (_ministack*ministack,H bytes,VP data)
 {
 H len;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 len=sizeof(ministack->buf);
 ministack->left=len-ministack->bytes;
 if((bytes)>ministack->left) {  return RET_BOUNDS; }
 if(data==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,data);
 aaMemoryCopy(&ministack->buf[ministack->bytes],bytes,bp);
 ministack->bytes+=bytes;
 ministack->left-=(bytes);
 ministack->height++;
 return RET_YES;
 }



 B aaMiniStackPushByte                 (_ministack*ministack,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,1,&val));
 }


 B aaMiniStackPushWord                 (_ministack*ministack,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,2,&val));
 }

 B aaMiniStackPushDword                (_ministack*ministack,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,4,&val));
 }

 B aaMiniStackPushQuad                 (_ministack*ministack,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPush(ministack,8,&val));
 }


 B aaMiniStackPushStringf              (_ministack*ministack,VP fmt,...)
 {
 B ret;
 va_list argptr;
 B str[_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 if((sl+4+1)>=ministack->left) { return RET_BOUNDS; }
 if((ret=aaMiniStackPush(ministack,sl+1,str))!=RET_YES) { oops; }
 if((ret=aaMiniStackPushDword(ministack,sl+4+1))!=RET_YES) { oops; }
 return RET_YES;
 }



 B aaMiniStackPushMulti                (_ministack*ministack,VP fmt,...)
 {
 B ret;
 va_list ap;
 BP bp;
 H off;
 B ch;
 B var_b;
 W var_w;
 H var_h;
 Q var_q;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(fmt==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,fmt);
 va_start(ap,fmt);
 off=0;
 while(1)
  {
  ch=bp[off];
  ret=RET_YES;
  if(ch==NULL_CHAR) { break; }
  switch(ch)
   {
   case 'b': case 'B':
   var_b=(B)va_arg(ap,u32);
   ret=aaMiniStackPushByte(ministack,var_b);
   break;
   case 'w': case 'W':
   var_w=(W)va_arg(ap,u32);
   ret=aaMiniStackPushWord(ministack,var_w);
   break;
   case 'h': case 'H':
   var_h=(H)va_arg(ap,u32);
   ret=aaMiniStackPushDword(ministack,var_h);
   break;
   case 'q': case 'Q':
   var_q=(Q)va_arg(ap,u64);
   ret=aaMiniStackPushQuad(ministack,var_q);
   break;
   default:
   ret=RET_BADPARM;
   break;
   }
  if(ret!=RET_YES) { break; }
  off++;
  }
 va_end(ap);
 return ret;
 }




 B aaMiniStackPop                      (_ministack*ministack,H bytes,VP data)
 {
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) {  return RET_BADPARM; }
 if(bytes==F32) { bytes=ministack->bytes; }
 if(bytes>ministack->bytes) {  return RET_BOUNDS; }
 off=ministack->bytes-(bytes);
 aaMemoryCopy(data,bytes,&ministack->buf[off]);
 ministack->bytes-=bytes;
 ministack->left+=bytes;
 ministack->height--;
 return RET_YES;
 }



 B aaMiniStackPopByte                  (_ministack*ministack,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,1,val));
 }


 B aaMiniStackPopWord                  (_ministack*ministack,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,2,val));
 }

 B aaMiniStackPopDword                 (_ministack*ministack,HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,4,val));
 }

 B aaMiniStackPopQuad                  (_ministack*ministack,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPop(ministack,8,val));
 }


 B aaMiniStackPopString                (_ministack*ministack,HP chars,H maxchars,VP str)
 {
 B ret;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars)  { *chars=0; }
 if(str) { aaStringNull(str); }
 if(ministack->height<2) { return RET_NOTFOUND; }
 if((ret=aaMiniStackPeekDword(ministack,0,&sl))!=RET_YES) { return ret; }
 if((sl+4+1)>=ministack->left) { return RET_BOUNDS; }
 sl-=4;
 if(sl>ministack->bytes) { return RET_NOTFOUND; }
 if(chars) *chars=sl-1;
 if(str==NULL) { return RET_YES; }
 if((sl-1)>maxchars) { return RET_BOUNDS; }
 if((ret=aaMiniStackDiscard(ministack,4))!=RET_YES) { oops; return ret; }
 if((ret=aaMiniStackPop(ministack,sl,str))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }

/*
 aaMiniStackInit(&ms);
 aaMiniStackPushMulti(&ms,"hhhw",(H)20,(H)30,(H)40,(W)50);
  aaMiniStackPopMulti(&ms,"hhhw",&h0,&h1,&h2,&w0);
*/


 B aaMiniStackPopMulti                 (_ministack*ministack,VP fmt,...)
 {
 B ret;
 va_list ap;
 BP bp;
 H off,sl;
 B ch;
 B var_b;
 W var_w;
 H var_h;
 Q var_q;
 PP var_ptr_b;
 PP var_ptr_w;
 PP var_ptr_h;
 PP var_ptr_q;
 PP var_ptrptr[32];
 Q var_temp[32];
 H argindex,a;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 //if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(fmt==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,fmt);
 va_start(ap,fmt);
 aaStringLen(fmt,&sl);
 off=0;
 argindex=0;
 while(1)
  {
  ch=bp[sl-off-1];
  ret=RET_YES;
  if(ch==NULL_CHAR) { break; }
  switch(ch)
   {
   case 'b': case 'B':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopByte(ministack,&var_b))!=YES) { oops; break; }
   var_temp[argindex++]=(Q)var_b;
   break;
   case 'w': case 'W':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopWord(ministack,&var_w))!=YES)  { oops; break; }
   var_temp[argindex++]=(Q)var_w;
   break;
   case 'h': case 'H':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopDword(ministack,&var_h))!=YES) { break; }
   var_temp[argindex++]=(Q)var_h;
   break;
   case 'q': case 'Q':
   var_ptrptr[argindex]=va_arg(ap,PP);
   if((ret=aaMiniStackPopQuad(ministack,&var_q))!=YES) { break; }
   var_temp[argindex++]=(Q)var_q;
   break;
   default:
   ret=RET_BADPARM;
   break;
   }
  if(ret!=RET_YES) { oops; break; }
  off++;
  }
 va_end(ap);
 if(ret==RET_YES)
  {
  for(a=0;a<argindex;a++)
   {
   ch=bp[a];//sl-a-1];
   switch(ch)
    {
    case 'b': case 'B':
    var_ptr_b=var_ptrptr[a];
    *(BP)var_ptr_b=var_temp[argindex-a-1];
    break;
    case 'w': case 'W':
    var_ptr_w=var_ptrptr[a];
    *(WP)var_ptr_w=(W)var_temp[argindex-a-1];
    break;
    case 'h': case 'H':
    var_ptr_h=var_ptrptr[a];
    *(HP)var_ptr_h=(H)var_temp[argindex-a-1];
    break;
    case 'q': case 'Q':
    var_ptr_q=var_ptrptr[a];
    *(QP)var_ptr_q=(Q)var_temp[argindex-a-1];
    break;
    default:
    ret=RET_BADPARM;
    break;
    }
   }
  }
 return ret;
 }



 B aaMiniStackPeek                     (_ministack*ministack,H offset,H bytes,VP data)
 {
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==F32) { bytes=ministack->bytes; }
 if(bytes>ministack->bytes) {  return RET_BOUNDS; }
 if((offset+bytes)>ministack->bytes) {  return RET_BOUNDS; }
 off=ministack->bytes-(offset+bytes);
 if(data)  { aaMemoryCopy(data,bytes,&ministack->buf[off]);   }
 return RET_YES;
 }


 B aaMiniStackPeekByte                 (_ministack*ministack,H offset,BP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,1,val));
 }

 B aaMiniStackPeekWord                 (_ministack*ministack,H offset,WP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,2,val));
 }
 B aaMiniStackPeekDword                (_ministack*ministack,H offset,HP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,4,val));
 }
 B aaMiniStackPeekQuad                 (_ministack*ministack,H offset,QP val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaMiniStackPeek(ministack,offset,8,val));
 }


 B aaMiniStackPeekString               (_ministack*ministack,H index,HP chars,H maxchars,VP str)
 {
 B ret;
 H asl,sl,i,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars)  { *chars=0; }
 if(str) { aaStringNull(str); }
 if(ministack->height<(N)((index+1)*2)) { return RET_NOTFOUND; }
 off=0;
 asl=0;
 for(i=0;i<(index+1);i++)
  {
  if((ret=aaMiniStackPeekDword(ministack,off,&sl))!=RET_YES) { return ret; }
  asl+=sl;
  if(asl>=ministack->left) { return RET_BOUNDS; }
  if(i>=index) { break; }
  off=asl;
  }
 sl-=4;
 if(sl>ministack->bytes) { return RET_NOTFOUND; }
 if(chars) *chars=sl-1;
 if(str==NULL) { return RET_YES; }
 if((sl-1)>maxchars) { return RET_BOUNDS; }
 //if((ret=aaMiniStackDiscard(ministack,4))!=RET_YES) { oops; return ret; }
 if((ret=aaMiniStackPeek(ministack,off+4,sl,str))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }

 B aaMiniStackDiscard                  (_ministack*ministack,H bytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ministack==NULL) { return RET_BADPARM; }
 if(ministack->magic!=aa_MINISTACK_MAGIC) { return RET_NOTSTARTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes==F32) { bytes=ministack->bytes; }
 if(bytes>ministack->bytes) { return RET_BOUNDS; }
 ministack->bytes-=bytes;
 ministack->left+=bytes;
 ministack->height--;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

// aa reserved message numbers are 2^31-(2^32-1)

 B aaGeneralEventWaitingGet            (H id,HP count)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count==NULL) { return RET_BADPARM; }
 *count=0;
 if(id>=aa_MAX_GENERAL_QUES) { return RET_BOUNDS; }
 *count=aa.generalevent_system.object[id].waiting;
 return RET_YES;
 }



 B aaGeneralEventWrite                 (H id,H msg,N lparm,H hparm,H bytes,VP data)
 {
 _generalevent ge;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id>=aa_MAX_GENERAL_QUES) { return RET_BOUNDS; }
 if(bytes!=0&&data==NULL) { return RET_BADPARM; }
 if(bytes>sizeof(ge.data)) {  return RET_BOUNDS; }
 aaMemoryFill(&ge,sizeof(_generalevent),0);
 ge.is_ok=YES;
 ge.number=aa.generalevent_system.object[id].counter++;
 aaTimerTikElapsed(aa.generalevent_system.object[id].tik,&ge.ms);
 ge.msg=msg;
 ge.lparm=lparm;
 ge.hparm=hparm;
 ge.bytes=bytes;
 if(bytes) {  aaMemoryCopy(ge.data,bytes,data); }
 aaQueWrite(aa.generalevent_system.object[id].que_handle,sizeof(_generalevent),&ge);
 aa.generalevent_system.object[id].waiting++;
 return RET_YES;
 }




 B aaGeneralEventWritef                (H id,H msg,N lparm,H hparm,VP fmt,...)
 {
 _generalevent ge;
 va_list argptr;
 B str[_8K];
 H sl;

 aaFmt(fmt,argptr,str);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id>=aa_MAX_GENERAL_QUES) { return RET_BOUNDS; }
 aaStringLen(str,&sl);
 if((sl+1)>sizeof(ge.data)) { return RET_BOUNDS; }
 aaMemoryFill(&ge,sizeof(_generalevent),0);
 ge.number=aa.generalevent_system.object[id].counter++;
 aaTimerTikElapsed(aa.generalevent_system.object[id].tik,&ge.ms);
 ge.is_ok=YES;
 ge.msg=msg;
 ge.lparm=lparm;
 ge.hparm=hparm;
 ge.bytes=(sl+1);
 if(ge.bytes>=sizeof(ge.data)) {  return RET_BOUNDS; }
 if(sl!=0) {  aaMemoryCopy(ge.data,sl,str); }
 aaQueWrite(aa.generalevent_system.object[id].que_handle,sizeof(_generalevent),&ge);
 aa.generalevent_system.object[id].waiting++;
 return RET_YES;
 }








 B aaGeneralEventRead                  (H id,_generalevent*genevent)
 {
 H ms;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id>=aa_MAX_GENERAL_QUES) { return RET_BOUNDS; }
 if(genevent==NULL) { return RET_BADPARM; }
 genevent->is_ok=NO;
 genevent->waiting=0;
 if(aa.generalevent_system.object[id].waiting==0) { return RET_NOTREADY; }
 aaQueRead(aa.generalevent_system.object[id].que_handle,sizeof(_generalevent),genevent);
 aaTimerTikElapsed(aa.generalevent_system.object[id].tik,&ms);
 genevent->lag=ms-genevent->ms;
 aa.generalevent_system.object[id].waiting--;
 genevent->waiting=aa.generalevent_system.object[id].waiting;
 return RET_YES;
 }




 B aaGeneralEventPeek                  (H id,H index,_generalevent*genevent)
 {
 H ms;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id>=aa_MAX_GENERAL_QUES) { return RET_BOUNDS; }
 if(genevent==NULL) { return RET_BADPARM; }
 genevent->is_ok=NO;
 genevent->waiting=0;
 if(index>=aa.generalevent_system.object[id].waiting) { return RET_NOTREADY; }
 aaQuePeek(aa.generalevent_system.object[id].que_handle,index*sizeof(_generalevent),sizeof(_generalevent),genevent);
  aaTimerTikElapsed(aa.generalevent_system.object[id].tik,&ms);
 genevent->lag=ms-genevent->ms;
 genevent->waiting=aa.generalevent_system.object[id].waiting;
 return RET_YES;
 }





 B aaGeneralEventDiscard               (H id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id>=aa_MAX_GENERAL_QUES) { return RET_BOUNDS; }
 if(aa.generalevent_system.object[id].waiting==0) { return RET_NOTREADY; }
 aaQueDiscard(aa.generalevent_system.object[id].que_handle,sizeof(_generalevent));
 aa.generalevent_system.object[id].waiting--;
 return RET_YES;
 }


 B aaGeneralEventPurge                 (H id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 while(aaGeneralEventDiscard(id)==YES);
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/






 B aaNetStatus                         (_netstatus*netstatus)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netstatus) { aaMemoryCopy(netstatus,sizeof(_netstatus),&aa.net_system.net_status);  }
 return RET_YES;
 }



 B aaNetLocalIpGet                     (_localip*localip,B getmac,B getbcast)//,B getlist,B gettype,B gettext,B getmac,B getmactext,B getbcast)
 {
 B ret;
 H i,cnt,j,k;
 HP iptr;
//f H iplist[32];
 _netsubnet net_subnet[32];
 _netinfo ni;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(localip==NULL)  { return RET_BADPARM; }
// if(getlis!=YES&&gettype!=YES&&gettext!=YES) { return RET_BADPARM; }
 aaMemoryFill(localip,sizeof(_localip),0);
 aaCast(iptr,HP,localip->ip);

 if((ret=aa_NetSystemLocalHostGet(iptr,31))!=RET_YES) { oops; } // 32nd ip is always 0.0.0.0
 cnt=0;
 for(i=0;i<32;i++)  {   if(iptr[i]!=0) { cnt++; }  }
 for(i=0;i<32;i++)   {   if((ret=aaNetIpTypeGet(iptr[i],&localip->type[i]))!=RET_YES) { oops; }   }
 for(i=0;i<32;i++)   {   aaNetIpToString(iptr[i],&localip->dot[i]);   }
 if(getmac)
  {
  for(i=0;i<32;i++)
   {
   if(localip->ip[i]!=0)
    {
    ret=aaNetMacGet(localip->mac[i],localip->ip[i],localip->mac_dot[i]);
    if(ret!=YES)
     {
     localip->mac[i][0]=localip->mac[i][1]=localip->mac[i][2]=
     localip->mac[i][3]=localip->mac[i][4]=localip->mac[i][5]=0;
     aaStringCopyf(localip->mac_dot[i],"%02X:%02X:%02X:%02X:%02X:%02X",0,0,0,0,0,0);
     }
    //oops; }
    }
   }
  }
 localip->count=(B)cnt;
 if(getbcast)
  {
  if((ret=aaNetInfoGet(&ni))!=RET_YES) { oops; }
  for(k=0;k<aaElementCount(localip->ip);k++)
   {
   for(i=0;i<ni.adapter_count;i++)
     {
     for(j=0;j<ni.adapter[i].address_count;j++)
      {
      if(ni.adapter[i].address[j].ip==localip->ip[k])
       {
       if(localip->ip[k]!=0)
        {
        //localip->bcast_ip[k]=ni.adapter[i].address[j].
        //l=k;
        aaNetSubnetFromIp(&net_subnet[k],localip->ip[k],ni.adapter[i].address[j].subnet);
        localip->bcast_ip[k]=net_subnet[k].broadcast_ip;
        aaNetIpToString(localip->bcast_ip[k],localip->bcast_dot[k]);
        }
       }
      }
     }
    }
   }
 return RET_YES;
 }






 B aaNetInfoGet                        (_netinfo*netinfo)
 {
 HMODULE mod;
 T DWORD (WINAPI*getAdaptersInfo)(PIP_ADAPTER_INFO,PULONG);
 T DWORD (WINAPI*getNetworkParams)(PFIXED_INFO,PULONG);
 getAdaptersInfo myGetAdaptersInfo;
 getNetworkParams myGetNetworkParams;
 PIP_ADAPTER_INFO adapt_ptr;
 PIP_ADDR_STRING  addr_str_ptr;
 ULONG outbuf_len;
 DWORD err,res,adapter_info_size;
 IP_ADDR_STRING*ip_addr_ptr;
 FIXED_INFO*fixed_info_ptr;
 B fixed_info_buf[_1K+sizeof(FIXED_INFO)];
 B fixed_info_was_allocated;
 B adapter_info_buf[_4K];
 B adapter_info_was_allocated;
 PIP_ADAPTER_INFO adapter_info_ptr;
 B fail,first;
 B txt[_1K];
 B str[_1K];
 H sl,j,dapi,adri;
 _netinfoadapter*nidap_ptr;
 _netinfoadapteraddress*nidapadr_ptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(netinfo==NULL) { return RET_BADPARM; }
 aaMemoryFill(netinfo,sizeof(_netinfo),0);
 adapter_info_size=0;
 if((mod=LoadLibrary("Iphlpapi.dll"))==NULL) { return RET_FAILED;  }
 myGetAdaptersInfo=(getAdaptersInfo)GetProcAddress(mod,"GetAdaptersInfo");
 myGetNetworkParams=(getNetworkParams)GetProcAddress(mod,"GetNetworkParams");
 if(myGetNetworkParams==NULL||myGetAdaptersInfo==NULL) { FreeLibrary(mod);  return RET_FAILED;  }
 //----------
  fixed_info_was_allocated=NO;
  fixed_info_ptr=(FIXED_INFO *)fixed_info_buf;
  outbuf_len=sizeof(fixed_info_buf);
  if(myGetNetworkParams(fixed_info_ptr,&outbuf_len)==ERROR_BUFFER_OVERFLOW)
   {
   if(aaMemoryAllocate((VP)&fixed_info_ptr,outbuf_len)!=YES)
    {
    FreeLibrary(mod);
    return RET_FAILED;
    }
   aaMemoryNameSet(fixed_info_ptr,"neifo"); //charlie
   fixed_info_was_allocated=YES;
   }
  fail=YES;
  if((res=myGetNetworkParams(fixed_info_ptr,&outbuf_len))==NO_ERROR)
   {
   fail=NO;
   aaStringCopyf(netinfo->host_name,"%s",fixed_info_ptr->HostName);
   aaStringCopyf(netinfo->domain_name,"%s",fixed_info_ptr->DomainName);
   aaStringCopyfLen(txt,&sl,"%s",fixed_info_ptr->DnsServerList.IpAddress.String);
   first=YES;
   while(1)
    {
    if(sl>=7&&sl<=15)
     {
     if(aaNetIpFromString(txt,&netinfo->dns_server_ip[netinfo->dns_server_count])==YES)
      {
      aaStringCopyf(netinfo->dns_server_dot[netinfo->dns_server_count],"%s",txt);
      netinfo->dns_server_count++;
      if(netinfo->dns_server_count>=aaElementCount(netinfo->dns_server_ip)) { break; }
      }
     }
    if(first==YES) {  ip_addr_ptr=fixed_info_ptr->DnsServerList.Next;    }
    else           {  ip_addr_ptr=ip_addr_ptr->Next;   }
    if(!ip_addr_ptr) { break; }
    aaStringCopyfLen(txt,&sl,"%s",ip_addr_ptr->IpAddress.String);
    first=NO;
    }
   switch (fixed_info_ptr->NodeType)
    {
    case BROADCAST_NODETYPE:    netinfo->is_broadcast_node=YES;  break;
    case PEER_TO_PEER_NODETYPE: netinfo->is_ppp_node=YES;        break;
    case MIXED_NODETYPE:        netinfo->is_mixed_node=YES;      break;
    case HYBRID_NODETYPE:       netinfo->is_hybrid_node=YES;     break;
    default:                    netinfo->is_unknown_node=YES;    break;
    }
   aaStringCopyf(netinfo->dhcp_scope_name,"%s",fixed_info_ptr->ScopeId);
   if(fixed_info_ptr->EnableRouting) netinfo->is_routing_enabled=YES;
   if(fixed_info_ptr->EnableProxy)   netinfo->is_arpproxy_enabled=YES;
   if(fixed_info_ptr->EnableDns)     netinfo->is_dns_enabled=YES;
   }
  if(fixed_info_was_allocated)  {  aaMemoryRelease(fixed_info_ptr);   fixed_info_ptr=NULL;   }
  if(fail)  { FreeLibrary(mod); return RET_FAILED; }
 //----------
  adapter_info_was_allocated=NO;
  adapter_info_size=sizeof(adapter_info_buf);
  adapter_info_ptr=(PIP_ADAPTER_INFO)adapter_info_buf;
  if((err=myGetAdaptersInfo(adapter_info_ptr,&adapter_info_size))!= 0)
   {
   if(err==ERROR_BUFFER_OVERFLOW)
    {
    if((adapter_info_ptr=(PIP_ADAPTER_INFO)GlobalAlloc(GPTR,adapter_info_size))==NULL)
     {
     FreeLibrary(mod);
     return RET_FAILED;
     }
    adapter_info_was_allocated=YES;
    if((err=myGetAdaptersInfo(adapter_info_ptr,&adapter_info_size))!= 0)
     {
     GlobalFree(adapter_info_ptr);
     FreeLibrary(mod);
     return RET_FAILED;
     }
    }
   else
    {
    FreeLibrary(mod);
    return RET_FAILED;
    }
   }
  adapt_ptr=adapter_info_ptr;
  while(adapt_ptr)
   {
   addr_str_ptr=&(adapt_ptr->IpAddressList);
   dapi=netinfo->adapter_count;
   nidap_ptr=(_netinfoadapter*)&netinfo->adapter[dapi];
   while(addr_str_ptr)
    {
    adri=netinfo->adapter[dapi].address_count;
    nidapadr_ptr=(_netinfoadapteraddress*)&nidap_ptr->address[adri];
    if(nidap_ptr->address_count<aaElementCount(nidap_ptr->address))
     {
     aaStringCopyf(nidapadr_ptr->ip_dot,"%s",addr_str_ptr->IpAddress.String);
     aaNetIpFromString(nidapadr_ptr->ip_dot,&nidapadr_ptr->ip);
     aaStringCopyf(nidapadr_ptr->subnet_dot,"%s",addr_str_ptr->IpMask.String);
     aaNetIpFromString(nidapadr_ptr->subnet_dot,&nidapadr_ptr->subnet);
     nidap_ptr->address_count++;
     }
    addr_str_ptr=addr_str_ptr->Next;
    }
   aaStringCopyf(nidap_ptr->description,"%s",adapt_ptr->Description);
   aaStringNull(str);
   for(j=0;j<adapt_ptr->AddressLength;j++)
    {
    if(j==(adapt_ptr->AddressLength-1)) aaStringAppendf(str,"%.2X",(Z)adapt_ptr->Address[j]);
    else                                aaStringAppendf(str,"%.2X-",(Z)adapt_ptr->Address[j]);
    }
   aaStringCopyf(nidap_ptr->physical_address,"%s",str);
   switch(adapt_ptr->Type)
    {
    case MIB_IF_TYPE_OTHER:     nidap_ptr->is_type_other=YES;     break;
    case MIB_IF_TYPE_ETHERNET:  nidap_ptr->is_type_ethernet=YES;  break;
    case MIB_IF_TYPE_TOKENRING: nidap_ptr->is_type_tokenring=YES; break;
    case MIB_IF_TYPE_FDDI:      nidap_ptr->is_type_fddi=YES;      break;
    case MIB_IF_TYPE_PPP:       nidap_ptr->is_type_ppp=YES;       break;
    case MIB_IF_TYPE_LOOPBACK:  nidap_ptr->is_type_loopback=YES;  break;
    case MIB_IF_TYPE_SLIP:      nidap_ptr->is_type_slip=YES;      break;
    default:                    nidap_ptr->is_type_unknown=YES;   break;
    }
   aaStringCopyf(nidap_ptr->gateway_dot,"%s",adapt_ptr->GatewayList.IpAddress.String);
   aaNetIpFromString(nidap_ptr->gateway_dot,&nidap_ptr->gateway);
   addr_str_ptr=adapt_ptr->GatewayList.Next;
   while(addr_str_ptr)    {    addr_str_ptr=addr_str_ptr->Next;    }
   aaStringCopyf(nidap_ptr->dhcp_dot,"%s",adapt_ptr->DhcpServer.IpAddress.String);
   aaNetIpFromString(nidap_ptr->dhcp_dot,&nidap_ptr->dhcp);
   aaStringCopyf(nidap_ptr->primary_wins_dot,"%s",adapt_ptr->PrimaryWinsServer.IpAddress.String);
   aaNetIpFromString(nidap_ptr->primary_wins_dot,&nidap_ptr->primary_wins);
   aaStringCopyf(nidap_ptr->secondary_wins_dot,"%s",adapt_ptr->SecondaryWinsServer.IpAddress.String);
   aaNetIpFromString(nidap_ptr->secondary_wins_dot,&nidap_ptr->secondary_wins);
   netinfo->adapter_count++;
   if(netinfo->adapter_count>=aaElementCount(netinfo->adapter)) { break; }
   adapt_ptr=adapt_ptr->Next;
   }
  if(adapter_info_was_allocated==YES)
   {
   GlobalFree(adapter_info_ptr);
   }
 //----------
 FreeLibrary(mod);
 return RET_YES;
 }







 B aaNetInfoToString                   (_netinfo*netinfo,H maxchars,VP str)
 {
 B txt[_32K];
 H i,c,a,ac,sl;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(netinfo==NULL) { return RET_BADPARM; }
 if(str) { aaStringNull(str); }
 if(maxchars==0) { return RET_BADPARM; }
 aaStringNull(txt);
 if(netinfo->host_name[0]) { aaStringAppendf(txt,"host_name=%s\n",netinfo->host_name); }
 if(netinfo->domain_name[0]) { aaStringAppendf(txt,"domain_name=%s\n",netinfo->domain_name); }
 c=netinfo->dns_server_count;
 for(i=0;i<c;i++)
  {
  aaStringAppendf(txt,"dns_server[%i/%i] %s (%u)\n",i,c,netinfo->dns_server_dot[i],netinfo->dns_server_ip[i]);
  }
 aaStringAppendf(txt,"is_broadcast_node=%i\n",netinfo->is_broadcast_node);
 aaStringAppendf(txt,"is_ppp_node=%i\n",netinfo->is_ppp_node);
 aaStringAppendf(txt,"is_mixed_node=%i\n",netinfo->is_mixed_node);
 aaStringAppendf(txt,"is_hybrid_node=%i\n",netinfo->is_hybrid_node);
 aaStringAppendf(txt,"is_unknown_node=%i\n",netinfo->is_unknown_node);
 if(netinfo->dhcp_scope_name[0]) { aaStringAppendf(txt,"dhcp_scope_name=%s\n",netinfo->dhcp_scope_name); }
 aaStringAppendf(txt,"is_routing_enabled=%i\n",netinfo->is_routing_enabled);
 aaStringAppendf(txt,"is_arpproxy_enabled=%i\n",netinfo->is_arpproxy_enabled);
 aaStringAppendf(txt,"is_dns_enabled=%i\n",netinfo->is_dns_enabled);
 c=netinfo->adapter_count;
 for(i=0;i<c;i++)
  {
  aaStringAppendf(txt,"adapter[%i/%i]\n",i,c);
  //aaStringAppendf(txt,"---------------\n");
  if(netinfo->adapter[i].description[0]) { aaStringAppendf(txt,"description=%s\n",netinfo->adapter[i].description); }
  if(netinfo->adapter[i].physical_address[0]) { aaStringAppendf(txt,"physical_address=%s\n",netinfo->adapter[i].physical_address); }
  aaStringAppendf(txt,"is_type_other=%i\n",netinfo->adapter[i].is_type_other);
  aaStringAppendf(txt,"is_type_ethernet=%i\n",netinfo->adapter[i].is_type_ethernet);
  aaStringAppendf(txt,"is_type_tokenring=%i\n",netinfo->adapter[i].is_type_tokenring);
  aaStringAppendf(txt,"is_type_fddi=%i\n",netinfo->adapter[i].is_type_fddi);
  aaStringAppendf(txt,"is_type_ppp=%i\n",netinfo->adapter[i].is_type_ppp);
  aaStringAppendf(txt,"is_type_loopback=%i\n",netinfo->adapter[i].is_type_loopback);
  aaStringAppendf(txt,"is_type_slip=%i\n",netinfo->adapter[i].is_type_slip);
  aaStringAppendf(txt,"is_type_unknown=%i\n",netinfo->adapter[i].is_type_unknown);
  ac=netinfo->adapter[i].address_count;
  for(a=0;a<ac;a++)
   {
   aaStringAppendf(txt,"address[%i/%i]\n",a,ac);
   //aaStringAppendf(txt,"---------------\n");
   aaStringAppendf(txt,"ip=%s (%u)\n",netinfo->adapter[i].address[a].ip_dot,netinfo->adapter[i].address[a].ip);
   aaStringAppendf(txt,"subnet=%s (%u)\n",netinfo->adapter[i].address[a].subnet_dot,netinfo->adapter[i].address[a].subnet);
   }
  aaStringAppendf(txt,"gateway=%s (%u)\n",netinfo->adapter[i].gateway_dot,netinfo->adapter[i].gateway);
  if(netinfo->adapter[i].dhcp) { aaStringAppendf(txt,"dhcp=%s (%u)\n",netinfo->adapter[i].dhcp_dot,netinfo->adapter[i].dhcp); }
  if(netinfo->adapter[i].primary_wins) { aaStringAppendf(txt,"primary_wins=%s (%u)\n",netinfo->adapter[i].primary_wins_dot,netinfo->adapter[i].primary_wins); }
  if(netinfo->adapter[i].secondary_wins) { aaStringAppendf(txt,"secondary_wins=%s (%u)\n",netinfo->adapter[i].secondary_wins_dot,netinfo->adapter[i].secondary_wins); }
  }
 aaStringLen(txt,&sl);
 if(sl>maxchars)  { txt[maxchars]=NULL_CHAR; sl=maxchars; }
 aaStringNCopy(str,txt,sl,YES);
 return RET_YES;
 }






 B aaNetOnlineStateGet                 (BP state)
 {
 HINSTANCE lib;
 H flags;
 T BOOL(WINAPI*deffunc)(HP,H);
 deffunc func;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state==NULL) { return RET_BADPARM; }
 *state=NO;
 lib=LoadLibrary("wininet.dll");//,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
 if(lib==NULL||lib==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 func=(deffunc)GetProcAddress(lib,"InternetGetConnectedState");
 if(func==NULL)  { FreeLibrary(lib);  return RET_FAILED;  }
 flags=0;
 if(func(&flags,0)!=0) { *state=YES; }
 FreeLibrary(lib);
 return RET_YES;
 }





 B aaNetMacGet                         (VP mac,H ip,VP txt)
 {
 B ret;
 H dwBufLen;
 B dot[33];
 B str[_1K];
 HMODULE mod;
 T BOOL (*_gai) (PIP_ADAPTER_INFO,PULONG);
 _gai gai;
 PIP_ADAPTER_INFO pAdapterInfo=NULL;
 PIP_ADAPTER_INFO pAdapter=NULL;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mac==NULL&&txt==NULL) { return RET_BADPARM; }
 if(mac) { aaMemoryFill(mac,6,0); }
 if(txt) { aaStringNull(txt); }
 aaNetIpToString(ip,dot);
 if((mod=LoadLibrary("iphlpapi.dll"))==NULL) { oof; return RET_FAILED; }
 if((gai=(_gai)GetProcAddress(mod,"GetAdaptersInfo"))==NULL)  { oof; FreeLibrary(mod);   return RET_FAILED; }
 dwBufLen=sizeof(IP_ADAPTER_INFO);
 if(aaMemoryAllocate((VP)&pAdapterInfo,dwBufLen)!=YES) { oof; FreeLibrary(mod);   return RET_FAILED; }
 if(gai(pAdapterInfo,&dwBufLen)==ERROR_BUFFER_OVERFLOW)
  {
  aaMemoryRelease(pAdapterInfo);
  pAdapterInfo=NULL;
  if(aaMemoryAllocate((VP)&pAdapterInfo,dwBufLen)!=YES) { oof; }
  }

 if(gai(pAdapterInfo,&dwBufLen)==NO_ERROR)
  {
  ret=RET_YES;
  pAdapter=pAdapterInfo;
  while(pAdapter)
   {
   aaLog(-777,"li=%i",__LINE__);
   aaLog(-777,"li=%i ip=%u",__LINE__,ip);
   aaLog(-777,"li=%i dot=%s",__LINE__,dot);
   aaLog(-777,"li=%i ipa=%s",__LINE__,pAdapter->IpAddressList.IpAddress);
   aaLog(-777,"li=%i gwa=%s",__LINE__,pAdapter->GatewayList.IpAddress);
   aaLog(-777,"li=%i %s",__LINE__,pAdapter->AdapterName);
   aaLog(-777,"li=%i %s",__LINE__,pAdapter->Description);
   aaLog(-777,"li=%i al=%i",__LINE__,pAdapter->AddressLength);
   aaStringCopyf(str,"%02X:%02X:%02X:%02X:%02X:%02X:%02x:%02x",
   pAdapterInfo->Address[0],pAdapterInfo->Address[1],pAdapterInfo->Address[2],
   pAdapterInfo->Address[3],pAdapterInfo->Address[4],pAdapterInfo->Address[5],
   pAdapterInfo->Address[6],pAdapterInfo->Address[7]);
   str[(pAdapter->AddressLength*3)-1]=NULL_CHAR;
   ///BUG,"[%s]",str);
   //aaStrub
   ///BUG,"index=%i",pAdapter->Index);
   ///BUG,"type=%i",pAdapter->Type);
   ///BUG,"dhcp=%i",pAdapter->DhcpEnabled);
   ///BUG,"habewins=%i",pAdapter->HaveWins);
   if(pAdapter->HaveWins)
    {
    ///BUG,"priwins=%s",pAdapter->PrimaryWinsServer.IpAddress);
    ///BUG,"secwins=%s",pAdapter->SecondaryWinsServer.IpAddress);
    }
   pAdapter=pAdapterInfo->Next;
   }
  }
 else
  {
  ret=RET_FAILED;
  }
 aaLog(-777,"li=%i",__LINE__);
 if(pAdapterInfo) {  aaMemoryRelease(pAdapterInfo); pAdapterInfo=NULL; }
 FreeLibrary(mod);
 return ret;
 }








 B aaNetIpPublicNext                   (HP ip,HP iterator)
 {
 H h,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ip) { *ip=0; }
 if(iterator==NULL)  {  h=aa.net_system.next_public_ip_counter; }
 else                {  h=*iterator; }
 for(i=0;i<aa.net_system.net_status.public_ip_count;i++)
  {
  h++;
  if(h>=aa.net_system.net_status.public_ip_count) { h=0; }
  if(aa.net_system.net_status.public_ip[h]!=0)
   {
   if(ip) { *ip=aa.net_system.net_status.public_ip[h]; }
   if(iterator==NULL)  {  aa.net_system.next_public_ip_counter=h; }
   else                {  *iterator=h; }
   return RET_YES;
   }
  }
 if(iterator==NULL)  {  aa.net_system.next_public_ip_counter=h; }
 else                {  *iterator=h; }
 return RET_NOTFOUND;
 }




 B aaNetIpFromString                   (VP dot,HP bin)
 {
 H addr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bin==NULL)  {  return RET_BADPARM;  }
 *bin=0;
 if(dot==NULL)  {  return RET_BADPARM;  }
 if(aaNetIpIsValid(dot)!=RET_YES) {  return RET_FAILED; }
 if((addr=inet_addr(dot))==INADDR_NONE)  {  return RET_FAILED;  }
 *bin=addr;
 return RET_YES;
 }





 B aaNetIpToString                     (H bin,VP dot)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dot==NULL)  {  return RET_BADPARM;  }
 aaStringNull(dot);
 aaStringCopy(dot,inet_ntoa(*(struct in_addr *)&bin));
 return RET_YES;
 }







 B aaNetIpIsValid                      (VP dot)
 {
 H sl,i,dots,nums,val;
 BP bp;
 B tmp[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(dot==NULL)  {  return RET_BADPARM;  }
 aaStringLen(dot,&sl);
 if(sl<7) { return RET_FAILED; }
 if(sl>15) { return RET_FAILED; }
 aaCast(bp,BP,dot);
 // count total dots
 dots=0;
 for(i=0;i<sl;i++)
  {
  if(bp[i]=='.') { dots++; }
  }
 if(dots!=3) { return RET_FAILED; }
 // check for repeating dots
 for(i=1;i<sl;i++)
  {
  if(bp[i]=='.'&&bp[i-1]=='.') { return RET_FAILED; }
  }
 // check for start and ending dots
 if(bp[0]=='.') { return RET_FAILED; }
 if(bp[sl-1]=='.') { return RET_FAILED; }
 nums=0;
 for(i=0;i<sl;i++)
  {
  if(bp[i]>='0'&&bp[i]<='9') { nums++; }
  else             { nums=0; }
  if(nums>3) { return RET_FAILED; }
  }
 nums=0;
 tmp[0]=NULL_CHAR;
 for(i=0;i<sl;i++)
  {
  if(bp[i]=='.')
   {
   if(tmp[0]==NULL_CHAR) { return RET_FAILED; }
   if(aaStringToNumber(tmp,nums,&val,NULL,0,0)!=YES) { return RET_FAILED; }
   if(val>255) { return RET_FAILED; }
   nums=0;
   tmp[0]=NULL_CHAR;
   continue;
   }
  tmp[nums]=bp[i];
  nums++;
  tmp[nums]=NULL_CHAR;
  }
 if(tmp[0]==NULL_CHAR) { return RET_FAILED; }
 if(aaStringToNumber(tmp,nums,&val,NULL,0,0)!=YES) { return RET_FAILED; }
 if(val>255) { return RET_FAILED; }
 return RET_YES;
 }




 B aaNetIpIsLoopBack                   (H bin)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,&bin);
 if(bp[0]==127) { return RET_YES; } // vpn_a rfc 1918
 return RET_NO;
 }





 B aaNetIpIsInternal                   (H bin)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,&bin);
 if(bp[0]==10) { return RET_YES; } // vpn_a rfc 1918
 if(bp[0]==172&&(bp[1]>=16&&bp[1]<=31)) { return RET_YES; } // vpn_b rfc 1918
 if(bp[0]==192&&bp[1]==168) { return RET_YES; } // vpn_c rfc 1918
 if(bp[0]==169&&bp[1]==254) { return RET_YES; } // APIPA address
 return RET_NO;
 }




 B aaNetIpIsReserved                   (H bin)
 {
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(bp,BP,&bin);
 if(bp[0]==0) { return RET_YES; }
 if(bp[0]==127) { return RET_YES; } // LOOPBACK
 if(bp[0]==192&&(bp[1]==0&&bp[2]==2)) { return RET_YES; } // TEST-NET
 if(bp[0]>=224) { return RET_YES; } // Class D multicast and class E reserved
 return RET_NO;
 }



 B aaNetIpIsPublic                     (H bin)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaNetIpIsReserved(bin)==YES) { return RET_NO; }
 if(aaNetIpIsInternal(bin)==YES) { return RET_NO; }
 if(aaNetIpIsLoopBack(bin)==YES) { return RET_NO; }
 return RET_YES;
 }




 B aaNetIpTypeGet                      (H bin,BP type)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type==NULL) { return RET_BADPARM; }
 *type=NULL_CHAR;
 if(aaNetIpIsLoopBack(bin)==YES) { *type='L'; return RET_YES; }
 if(aaNetIpIsInternal(bin)==YES) { *type='I'; return RET_YES; }
 if(aaNetIpIsReserved(bin)==YES) { *type='R'; return RET_YES; }
 *type='P';
 return RET_YES;
 }




 B aaNetIpToDword                      (H ip,HP val)
 {
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 v=LOBYTE(LOWORD(ip))<<24;
 v+=HIBYTE(LOWORD(ip))<<16;
 v+=LOBYTE(HIWORD(ip))<<8;
 v+=HIBYTE(HIWORD(ip));
 *val=v;
 return RET_YES;
 }




 B aaNetIpClassGet                     (H ip,BP cls)
 {
 B c=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(((H)(ip)&0x80000000)==0) { c='A'; } else
 if((((H)(ip)&0xc0000000)==0x80000000)) { c='B'; } else
 if((((H)(ip)&0xe0000000)==0xc0000000)) { c='C'; } else
 if((((H)(ip)&0xf0000000)==0xe0000000)) { c='D'; } else { c='E'; }
 if(cls) { *cls=c; }
 return RET_YES;
 }







 B aaNetEmailIsValid                   (VP email)
 {
 _parser p;
 H cnt,state,i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(email==NULL) { return RET_BADPARM; }
 aaParserInit(&p,email,0);
 if(p.length<6) { return RET_NO; }
 if(aaStringCountChars(p.bp,p.to_end,&cnt,'@',NO,YES)!=RET_YES) { return RET_NO; }
 if(cnt!=1) { return RET_NO; }
 if(aaStringCountChars(p.bp,p.to_end,&cnt,'.',NO,YES)!=RET_YES) { return RET_NO; }
 if(cnt<1) { return RET_NO; }
 for(i=0;i<p.length;i++)
  {
  if(aaCharIsAlphaNum(p.bp[i])==YES) { continue; }
  if(aaCharIsNum(p.bp[i])==YES) { continue; }
  if(p.bp[i]=='_'||p.bp[i]=='.'||p.bp[i]=='@'||p.bp[i]=='-') { continue; }
  return RET_NO;
  }
 if(aaCharIsAlphaNum(p.bp[0])!=YES&&p.bp[0]!='_') { return RET_NO; }
 if(aaCharIsAlpha(p.bp[p.length-1])!=YES) { return RET_NO; }
 state=0;
 while(1)
  {
  if(p.is_end) break;
  switch(state)
   {
   case 0:
   if(p.ch=='@') { aaParserSeek(&p,1);  state=10; break; }
   if(p.ch=='.') { aaParserSeek(&p,1);  state=10; break; }
   aaParserSeek(&p,1);
   break;

   case 10:
   if(p.ch=='@') {  return RET_NO; }
   if(p.ch=='.') {  return RET_NO; }
   aaParserSeek(&p,1);
   state=0;
   break;
   }
  }
 return RET_YES;
 }







 B aaNetHostToDomain                   (VP host,VP domain)
 {
 B dom[257];
 H cnt,pos,ip;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(domain==NULL) { return RET_BADPARM; }
 aaStringNull(domain);
 if(host==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,host);
 aaStringCopyf(dom,"%s",bp);
 if(aaNetIpFromString(dom,&ip)==YES&&ip!=0)
  {
  aaStringCopyf(dom,".%s",bp);
  }
 else
  {
  aaStringCountChars(dom,0,&cnt,'.',NO,YES);
  if(cnt>1) { aaStringFindChar(bp,0,&pos,'.',YES,0,YES);  aaStringCopyf(dom,"%s",&bp[pos]);  }
  else      { aaStringCopyf(dom,".%s",bp);  }
  }
 aaStringCopy(domain,dom);
 return RET_YES;
 }




 B aaNetRfcCrcGet                      (VP mem,H bytes,WP crc)
 {
 H left =bytes;
 WP wp;
 W answer,u;
 N sum;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(wp,WP,mem);
 sum=0;
 while(left>1)
  {
  sum+=*wp++;
  left-=2;
  }
 if(left==1)
  {
  u=0;
  *(BP)(&u)=*(BP)wp;
  sum+=u;
  }
 sum=(sum>>16)+(sum&F16);
 sum+=(sum>>16);
 answer=(W)(~sum);
 *crc=answer;
 return RET_YES;
 }





 B aaNetBrowserWritef                  (HP hinst,VP fmt,...)
 {
 HINSTANCE h;
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(hinst) *hinst=0;
 if(fmt==NULL)  {  return RET_BADPARM;  }
 h=ShellExecute(NULL,NULL,(CP)txt,NULL,NULL,SW_SHOWNORMAL);
 if(hinst) *hinst=(H)h;
 if((H)h<=32)
  {
  ///aaDebugf("error %s",txt);
  return RET_FAILED;
  }
 return RET_YES;
 }




 B aaNetMimeToExtension                (VP mime,VP extension)
 {
 BP mm;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(extension==NULL) { return RET_BADPARM; }
 aaStringNull(extension);
 if(mime==NULL) { return RET_BADPARM; }
 aaCast(mm,BP,mime);
 if(*mm==NULL_CHAR) {  return RET_FAILED; }
 for(i=0;;i++)
  {
  if(aa_mime_type[i][0][0]==NULL_CHAR) { break; }
  if(aaStringICompare(mm,aa_mime_type[i][1],NULL)!=YES) { continue; }
  aaStringCopy(extension,aa_mime_type[i][0]);
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 B aaNetExtensionToMime                (VP extension,VP mime)
 {
 BP fe;
 H i,sl,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mime==NULL) { return RET_BADPARM; }
 aaStringNull(mime);
 if(extension==NULL) { return RET_BADPARM; }
 aaStringLen(extension,&sl);
 if(sl==0) { return RET_FAILED; }
 off=sl-1;
 aaCast(fe,BP,extension);
 while(1)
  {
  if(fe[off]=='.') { off++; break; }
  if(off==0) { break; }
  off--;
  }
 aaCast(fe,BP,extension);
 fe+=off;
 for(i=0;;i++)
  {
  if(aa_mime_type[i][0][0]==NULL_CHAR) { break; }
  if(aaStringICompare(fe,aa_mime_type[i][0],NULL)!=YES) { continue; }
  aaStringCopy(mime,aa_mime_type[i][1]);
  return RET_YES;
  }
 aaStringCopy(mime,"application/octet-stream");
 return RET_YES;
 }




 B aaNetHostsFileEntryGet              (H index,VP domain,VP dotted,HP ip,BP iscmnt)
 {
 B ret;
 B path[_1K];
 B txt[_4K];
 B tok[_1K];
 H off,pos,flag;
 _parser pa;
 _textreader tr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(domain) { aaStringNull(domain); }
 if(iscmnt) { *iscmnt=NO; }
 if(dotted) { aaStringNull(dotted);  }
 if(ip)     { *ip=0; }
 if(GetSystemDirectory((CP)path,sizeof(path))==0) { return RET_FAILED; }
 aaStringAppendf(path,"\\drivers\\etc\\hosts");
 if((ret=aaTextReaderOpen(&tr,path,0,0))!=YES) { return ret; }
 if((ret=aaTextReaderLineGet(&tr,index,txt))!=YES) {  aaTextReaderDelete(&tr);  return ret;  }

 aaStringReplaceChar(txt,0,HTAB_CHAR,SPACE_CHAR);
 aaStringRemoveSpaces(txt,0,1,1);
 aaStringRemoveMultipleSpaces(txt,0,0);
 aaParserInit(&pa,txt,0);
 ret=RET_NOTFOUND;
 if(aaParserSeekToVisibleChar(&pa,YES)==YES)
  {
  if(pa.ch=='#')    {      if(iscmnt) *iscmnt=YES;       }
  flag=0;
   while(1)
    {
    if(pa.is_end||pa.to_end<7) { break; }
    if(aaParserSeekToNumber(&pa,YES)==YES)
     {
     aaStringFindChar(pa.bp,pa.to_end,&pos,SPACE_CHAR,YES,0,YES); // 7 15
     if(pos==F32) {  pos=pa.to_end; break; }
     if(pos>=7&&pos<=15)
      {
      aaStringNCopy(tok,pa.bp,pos,YES);
      if(aaNetIpIsValid(tok)==YES)
       {
       flag=aaBitSet(flag,0);
       if(dotted) { aaStringCopy(dotted,tok); }
       if(ip)     { aaNetIpFromString(tok,ip); }
       }
      }
     aaParserSeek(&pa,pos);
     if(aaParserSeekToVisibleChar(&pa,YES)==YES)
      {
      off=pa.offset;
      if(aaParserSeekToVisibleChar(&pa,NO)==YES)  {   pos=pa.offset;   aaParserOffsetSet(&pa,off);         }
      else                                        {   aaParserOffsetSet(&pa,off);     pos=pa.to_end;         }
      aaStringNCopy(tok,pa.bp,pos-off,YES);
      flag=aaBitSet(flag,1);
      if(domain) { aaStringCopyf(domain,"%s",tok); }
      ret=RET_YES;
      }
     }
    break;
    }
  }
 aaTextReaderDelete(&tr);
 if(flag==3) {return ret; }
 return RET_NOTFOUND;
 }






 B aaNetHostsFileEntrySet              (H index,VP domain,VP dotted,H ip,B iscmnt)
 {
 B ret;
 B path[_1K];
 B txt[_4K];
 B dot[_1K];
 H i;
 _textreader tr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringNull(dot);
 if(aaStringIsEmpty(domain,YES)!=NO) { return RET_BADPARM; }
 if(aaStringIsEmpty(dotted,YES)!=NO&&ip==0) { return RET_BADPARM; }
 if(aaStringIsEmpty(dotted,YES)==NO) { aaStringCopyf(dot,"%s",dotted); }
 if(aaStringIsEmpty(dot,YES)==YES) { aaNetIpToString(ip,dot); }
 if(GetSystemDirectory((CP)path,sizeof(path))==0) { return RET_FAILED; }
 aaStringAppendf(path,"\\drivers\\etc\\hosts");
 if((ret=aaTextReaderOpen(&tr,path,0,0))!=YES) { return ret; }
 if(index==F32) { index=tr.line_count; }
 else
  {
  if(index>=tr.line_count)
   {
   aaTextReaderDelete(&tr);
   return RET_BOUNDS;
   }
  }
 aaFileDelete(path);

 for(i=0;i<tr.line_count;i++)
  {
  if((ret=aaTextReaderLineGet(&tr,i,txt))!=YES) {  oops; aaTextReaderDelete(&tr);  return ret;  }
  if(i==index)
   {
   if(iscmnt)
    {
    if((ret=aaFileAppendf(path,"#%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }
    }
   else
    {
    if((ret=aaFileAppendf(path,"%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }
    }
   continue;
   }
  if((ret=aaFileAppendf(path,"%s\r\n",txt))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }
  }
 if(i==index)
  {
  if(iscmnt) { if((ret=aaFileAppendf(path,"#%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }  }
  else       { if((ret=aaFileAppendf(path,"%s %s\r\n",dot,domain))!=YES) { oops; aaTextReaderDelete(&tr);  return ret;  }   }
  }

 aaTextReaderDelete(&tr);
 return RET_YES;
 }




 B aaNetIsPortAvailable                (H ip,W port,B isudp)
 {
 SOCKET sock;
 struct sockaddr_in addr;
 N oval,olen;
 UNUSE(oval);
 UNUSE(olen);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0) { return RET_BADPARM; }
 if(isudp==YES)
  {
  if((sock=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP))==INVALID_SOCKET)  {  return RET_FAILED;  }
  //oval=0; olen=sizeof(oval);  if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(CP)&oval,olen)!=0) oof;
  WinSockAddrSet(&addr,AF_INET,ip,htons(port));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr)))  {  closesocket(sock);  return RET_NO;  }
  }
 else
  {
  if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET)   {  return RET_FAILED;   }
  //oval=0; olen=sizeof(oval);  if(setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (CP)&oval, olen)!=0) oof;
  WinSockAddrSet(&addr,AF_INET,ip,htons(port));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr)))  {  closesocket(sock);   return RET_NO;   }
  }
 closesocket(sock);
 return RET_YES;
 }




 B aaNetRandomUser                     (_randomuser*randomuser)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(randomuser==NULL) { return RET_BADPARM; }
 aaMemoryFill(randomuser,sizeof(_randomuser),0);
 if(aaMathRand32(0,1)==0) { randomuser->gender=0; }
 else                     { randomuser->gender=1; }
 aaStringCopy(randomuser->first,aa_common_name[randomuser->gender][aaMathRand32(0,25)]);
 aaStringCopy(randomuser->middle,aa_common_name[aaMathRand32(0,1)][aaMathRand32(0,25)]);
 aaStringCopyf(randomuser->last,"%ssmith",aa_common_name[aaMathRand32(0,1)][aaMathRand32(0,25)]);
 if(randomuser->gender==0) { randomuser->gender='M'; }
 else                      { randomuser->gender='F'; }
 randomuser->dob=aaMathRand32(0,27);
 randomuser->mob=aaMathRand32(0,11);
 randomuser->yob=aaMathRand32(1950,2002);
 aaStringCopy(randomuser->country,aa_geo_country_name[aaMathRand32(1,250)]);
 if(randomuser->gender=='M')
  {
  while(1)
   {
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Mr"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Dr"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Sir"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Prof"); break; }
   }
  }
 else
  {
  while(1)
   {
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Mrs"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Dr"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Lady"); break; }
   if(aaMathRand32(0,2)==0) { aaStringCopyf(randomuser->title,"Prof"); break; }
   }
  }
 aaStringCopyf(randomuser->email,"%s.%s@",randomuser->first,randomuser->last);
 while(1)
  {
  if(aaMathRand32(0,2)==0) { aaStringAppendf(randomuser->email,"gmail.com"); break; }
  if(aaMathRand32(0,2)==0) { aaStringAppendf(randomuser->email,"hotmail.com"); break; }
  if(aaMathRand32(0,2)==0) { aaStringAppendf(randomuser->email,"yahoo.com"); break; }
  }
 aaStringLower(randomuser->email,0,0);
 return RET_YES;
 }




 B aaNetCgiEnvGet                      (_cgienv*cgienv)
 {
 H i;
 C txt[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cgienv==NULL) { return RET_BADPARM; }
 aaMemoryFill(cgienv,sizeof(_cgienv),0);
 i=0;
 cgienv->ptr[i++]=cgienv->server_software; if(GetEnvironmentVariable("SERVER_SOFTWARE",(CP)txt,sizeof(cgienv->server_software))!=0) { aaStringCopy(cgienv->server_software,txt); }
 cgienv->ptr[i++]=cgienv->server_name; if(GetEnvironmentVariable("SERVER_NAME",(CP)txt,sizeof(cgienv->server_name))!=0) { aaStringCopy(cgienv->server_name,txt); }
 cgienv->ptr[i++]=cgienv->gateway_interface; if(GetEnvironmentVariable("GATEWAY_INTERFACE",(CP)txt,sizeof(cgienv->gateway_interface))!=0) { aaStringCopy(cgienv->gateway_interface,txt); }
 cgienv->ptr[i++]=cgienv->server_protocol; if(GetEnvironmentVariable("SERVER_PROTOCOL",(CP)txt,sizeof(cgienv->server_protocol))!=0) { aaStringCopy(cgienv->server_protocol,txt); }
 cgienv->ptr[i++]=cgienv->server_port; if(GetEnvironmentVariable("SERVER_PORT",(CP)txt,sizeof(cgienv->server_port))!=0) { aaStringCopy(cgienv->server_port,txt); }
 cgienv->ptr[i++]=cgienv->request_uri; if(GetEnvironmentVariable("REQUEST_URI",(CP)txt,sizeof(cgienv->request_uri))!=0) { aaStringCopy(cgienv->request_uri,txt); }
 cgienv->ptr[i++]=cgienv->request_method; if(GetEnvironmentVariable("REQUEST_METHOD",(CP)txt,sizeof(cgienv->request_method))!=0) { aaStringCopy(cgienv->request_method,txt); }
 cgienv->ptr[i++]=cgienv->script_name; if(GetEnvironmentVariable("SCRIPT_NAME",(CP)txt,sizeof(cgienv->script_name))!=0) { aaStringCopy(cgienv->script_name,txt); }
 cgienv->ptr[i++]=cgienv->script_filename; if(GetEnvironmentVariable("SCRIPT_FILENAME",(CP)txt,sizeof(cgienv->script_filename))!=0) { aaStringCopy(cgienv->script_filename,txt); }
 cgienv->ptr[i++]=cgienv->url; if(GetEnvironmentVariable("URL",(CP)txt,sizeof(cgienv->url))!=0) { aaStringCopy(cgienv->url,txt); }
 cgienv->ptr[i++]=cgienv->query_string; if(GetEnvironmentVariable("QUERY_STRING",(CP)txt,sizeof(cgienv->query_string))!=0) { aaStringCopy(cgienv->query_string,txt); }
 cgienv->ptr[i++]=cgienv->remote_host; if(GetEnvironmentVariable("REMOTE_HOST",(CP)txt,sizeof(cgienv->remote_host))!=0) { aaStringCopy(cgienv->remote_host,txt); }
 cgienv->ptr[i++]=cgienv->remote_addr; if(GetEnvironmentVariable("REMOTE_ADDR",(CP)txt,sizeof(cgienv->remote_addr))!=0) { aaStringCopy(cgienv->remote_addr,txt); }
 cgienv->ptr[i++]=cgienv->remote_port; if(GetEnvironmentVariable("REMOTE_PORT",(CP)txt,sizeof(cgienv->remote_port))!=0) { aaStringCopy(cgienv->remote_port,txt); }
 cgienv->ptr[i++]=cgienv->instance_id; if(GetEnvironmentVariable("INSTANCE_ID",(CP)txt,sizeof(cgienv->instance_id))!=0) { aaStringCopy(cgienv->instance_id,txt); }
 cgienv->ptr[i++]=cgienv->path_info; if(GetEnvironmentVariable("PATH_INFO",(CP)txt,sizeof(cgienv->path_info))!=0) { aaStringCopy(cgienv->path_info,txt); }
 cgienv->ptr[i++]=cgienv->path_translated; if(GetEnvironmentVariable("PATH_TRANSLATED",(CP)txt,sizeof(cgienv->path_translated))!=0) { aaStringCopy(cgienv->path_translated,txt); }
 cgienv->ptr[i++]=cgienv->auth_type; if(GetEnvironmentVariable("AUTH_TYPE",(CP)txt,sizeof(cgienv->auth_type))!=0) { aaStringCopy(cgienv->auth_type,txt); }
 cgienv->ptr[i++]=cgienv->auth_user; if(GetEnvironmentVariable("AUTH_USER",(CP)txt,sizeof(cgienv->auth_user))!=0) { aaStringCopy(cgienv->auth_user,txt); }
 cgienv->ptr[i++]=cgienv->remote_user; if(GetEnvironmentVariable("REMOTE_USER",(CP)txt,sizeof(cgienv->remote_user))!=0) { aaStringCopy(cgienv->remote_user,txt); }
 cgienv->ptr[i++]=cgienv->remote_ident; if(GetEnvironmentVariable("REMOTE_IDENT",(CP)txt,sizeof(cgienv->remote_ident))!=0) { aaStringCopy(cgienv->remote_ident,txt); }
 cgienv->ptr[i++]=cgienv->server_admin; if(GetEnvironmentVariable("SERVER_ADMIN",(CP)txt,sizeof(cgienv->server_admin))!=0) { aaStringCopy(cgienv->server_admin,txt); }
 cgienv->ptr[i++]=cgienv->http_cookie; if(GetEnvironmentVariable("HTTP_COOKIE",(CP)txt,sizeof(cgienv->http_cookie))!=0) { aaStringCopy(cgienv->http_cookie,txt); }
 cgienv->ptr[i++]=cgienv->https; if(GetEnvironmentVariable("HTTPS",(CP)txt,sizeof(cgienv->https))!=0) { aaStringCopy(cgienv->https,txt); }
 cgienv->ptr[i++]=cgienv->content_length; if(GetEnvironmentVariable("CONTENT_LENGTH",(CP)txt,sizeof(cgienv->content_length))!=0) { aaStringCopy(cgienv->content_length,txt); }
 cgienv->ptr[i++]=cgienv->server_signature; if(GetEnvironmentVariable("SERVER_SIGNATURE",(CP)txt,sizeof(cgienv->server_signature))!=0) { aaStringCopy(cgienv->server_signature,txt); }
 cgienv->ptr[i++]=cgienv->document_root; if(GetEnvironmentVariable("DOCUMENT_ROOT",(CP)txt,sizeof(cgienv->document_root))!=0) { aaStringCopy(cgienv->document_root,txt); }
 cgienv->ptr[i++]=cgienv->http_referer; if(GetEnvironmentVariable("HTTP_REFERER",(CP)txt,sizeof(cgienv->http_referer))!=0) { aaStringCopy(cgienv->http_referer,txt); }
 cgienv->ptr[i++]=cgienv->http_user_agent; if(GetEnvironmentVariable("HTTP_USER_AGENT",(CP)txt,sizeof(cgienv->http_user_agent))!=0) { aaStringCopy(cgienv->http_user_agent,txt); }
 cgienv->ptr[i++]=cgienv->http_host; if(GetEnvironmentVariable("HTTP_HOST",(CP)txt,sizeof(cgienv->http_host))!=0) { aaStringCopy(cgienv->http_host,txt); }
 cgienv->ptr[i++]=cgienv->http_connection; if(GetEnvironmentVariable("HTTP_CONNECTION",(CP)txt,sizeof(cgienv->http_connection))!=0) { aaStringCopy(cgienv->http_connection,txt); }
 cgienv->ptr[i++]=cgienv->http_accept; if(GetEnvironmentVariable("HTTP_ACCEPT",(CP)txt,sizeof(cgienv->http_accept))!=0) { aaStringCopy(cgienv->http_accept,txt); }
 cgienv->ptr[i]=cgienv->content_type; if(GetEnvironmentVariable("CONTENT_TYPE",(CP)txt,sizeof(cgienv->content_type))!=0) { aaStringCopy(cgienv->content_type,txt); }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aa_NetCgiClientUpdate               (H handle)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 H thandle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { oops; return ret; }
 thandle=cgop->thread.handle;
 if(thandle) {}

 ///if((ret=aaThreadLock(thandle,YES))!=YES) oops;
 if(cgop->c2s_que.handle!=0)
  {
  if((ret=aaQueStatus(cgop->c2s_que.handle,&cgop->c2s_que.status))!=YES) { oops; }
  cgop->status.xmit_bytes=cgop->c2s_que.status.bytes;
  cgop->status.total_xmit_bytes=cgop->c2s_que.status.total_bytes_written;//read;
  }
 //if(cgop->pre_que.handle!=0)  {  if((ret=aaQueStatus(cgop->pre_que.handle,&cgop->pre_que.status))!=YES) { oops; }  }
 if(cgop->s2c_que.handle!=0)
  {
  if((ret=aaQueStatus(cgop->s2c_que.handle,&cgop->s2c_que.status))!=YES) { oops; }
  cgop->status.rcve_bytes=cgop->s2c_que.status.bytes;
  cgop->status.total_rcve_bytes=cgop->s2c_que.status.total_bytes_read;
  }
 aaTimerTikElapsed(cgop->ms_root,&cgop->status.ms);
 aaTimerTikElapsed(cgop->inactive_rcve_ms_root,&cgop->status.rcve_inactivity);
 aaTimerTikElapsed(cgop->inactive_xmit_ms_root,&cgop->status.xmit_inactivity);
 if(cgop->status.rcve_bytes==0) { cgop->status.line_inactivity=0;  }
 else                           { aaTimerTikElapsed(cgop->inactive_line_ms_root,&cgop->status.line_inactivity);}
///    if((ret=aaThreadUnLock(thandle))!=YES) oops;
 return RET_YES;
 }




 H aa_NetCgiClientThread               (VP parm)
 {
 B ret;
 _threadunit thu;
 B read_buff[_32K-_1K];
 H handle;
 B doupdate;
 B dolocks;
 _aa_netcgiclientobject*cgop;
 H todo,done,r,avail;
 H thismsg;
 HP hp;
 DWORD mode;
 BOOL rr;

 #if aa_USE_GLOBAL_MUTEX == 1
 EnterCriticalSection(&global_mutex);
 #endif
 hp=(HP)parm;
 handle=(H)&hp[0];
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { oops;  }
 thu.handle=cgop->thread.handle;
 ///thu.handle=thp->handle;
 if((ret=aaThreadStatus(thu.handle,&thu.status))!=YES)
  {
  //aaDebugf("... %s",ret_string[ret]);
  }
 ret=RET_YES;
 cgop->is_running=1;
 cgop->status.is_ready=YES;
 mode=PIPE_READMODE_BYTE|PIPE_NOWAIT;
 if(SetNamedPipeHandleState(cgop->in_write,&mode,0,0)==0) { oof; oow; }
 mode=PIPE_READMODE_BYTE|PIPE_NOWAIT;
 if(SetNamedPipeHandleState(cgop->out_read,&mode,0,0)==0) { oof; oow; }
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 while(1)
  {
  #if aa_USE_GLOBAL_MUTEX == 1
  EnterCriticalSection(&global_mutex);
  #endif
  aa_last_line_executed=__LINE__;
  doupdate=NO;//NO+1;
  dolocks=NO;
  if(aa_is_quit_called)   {   aa_last_line_executed=__LINE__;   break;   }
  if(thu.handle==0)       {   aa_last_line_executed=__LINE__;   break;   }
  aa_last_line_executed=__LINE__;
  if((ret=aaThreadStatus(thu.handle,&thu.status))!=YES)
   {
   aa_last_line_executed=__LINE__;
   }///LAB(180),"%i %i",rand()%10,thu.handle); } //oops; aaNote(0,"%i",thu.handle); }
  aa_last_line_executed=__LINE__;
  if(thu.status.is_exiting)   {   aa_last_line_executed=__LINE__;   break;   }
  if(thu.status.is_exited)    {   aa_last_line_executed=__LINE__;   oof;   break;   }

  //aaSleep(1);
  aa_last_line_executed=__LINE__;
  if(dolocks)
   {
   if((ret=aaThreadLock(thu.handle,YES))!=YES) oops;
   }
  if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES)
   {
   //aaDebugf("%s line=%i (objectcheck) %s",__func__,__LINE__,ret_string[ret]);
   break;
   }
  if((todo=aaNumRoof(cgop->status.xmit_bytes,(sizeof(read_buff)-10)))!=0)//&&cgop->ezy_mutex==0)
   {
   if(aaQuePeek(cgop->c2s_que.handle,0,todo,read_buff)==YES)
    {
    if(WriteFile(cgop->in_write,read_buff,todo,&done,NULL)==0)
     {
     r=GetLastError();
     if(r==ERROR_NO_DATA||r==ERROR_BROKEN_PIPE) { cgop->status.is_exited=YES;  }
     else                                       { cgop->status.is_failed=YES;  }
     }
    else
     {
     if(done>0)
      {
      if(done!=todo)
       {
       //aaDebugf("######## done=%i todo=%i",done,todo);
       }
      if((ret=aaQueDiscard(cgop->c2s_que.handle,done))!=YES) { aaNote(0,"%s have=%i doing=%i",ret_string[ret],cgop->c2s_que.status.bytes,done); }
      aaNetCgiClientInactivityReset(handle,NO,YES);
      doupdate=YES;
      }
     }
    }
   }
  aa_last_line_executed=__LINE__;
   if((rr=PeekNamedPipe(cgop->out_read,0,0,0,&avail,&thismsg))==0)
    {
    cgop->status.is_exited=YES;
    }

   else
    {
//    if(avail!=0||thismsg!=0) { aaLog(-555,"avail=%i this=%i",avail,thismsg); }
     aa_last_line_executed=__LINE__;
    if(avail!=0)
     {
     todo=avail;
     todo=aaNumRoof(todo,(sizeof(read_buff)-1));
     rr=ReadFile(cgop->out_read,read_buff,todo,&done,NULL);
       if(rr==0)
        {
        r=GetLastError();
        if(cgop->status.is_exited==NO)
         {
         if(r==ERROR_BROKEN_PIPE) {  oof;  cgop->status.is_exited=YES;  oof; }         else
         if(r==ERROR_NO_DATA) {  oof; }
         else { oof;  }
         }
        aaNote(0,"lasterr=%i",r);
        oof;
        }
      if(done!=todo) oof;
      if(done==0) oof;
      aa_last_line_executed=__LINE__;
      if((ret=aaQueWrite(cgop->s2c_que.handle,done,read_buff))!=YES) { oops; }
      aaNetCgiClientInactivityReset(handle,YES,NO);
      doupdate=YES;
      }
     }
   aa_last_line_executed=__LINE__;
///=====================================================
   if(dolocks)
    {
    if((ret=aaThreadUnLock(thu.handle))!=YES) oops;
    }

  if(doupdate)
   {
   if(dolocks)
    {
    if((ret=aaThreadLock(thu.handle,YES))!=YES)
     {
     //aaDebugf("failure thu.handle=%x %s",thu.handle,ret_string[ret]);
     break;
     }
    }
    aa_NetCgiClientUpdate(handle);
   if(dolocks)
    {
    if((ret=aaThreadUnLock(thu.handle))!=YES) oops;
    }
   doupdate=NO;
   }
  #if aa_USE_GLOBAL_MUTEX == 1
  LeaveCriticalSection(&global_mutex);
  #endif
  aaSleep(1);
  }
 cgop->is_running=2;
 #if aa_USE_GLOBAL_MUTEX == 1
 LeaveCriticalSection(&global_mutex);
 #endif
 aaThreadQuit(1,RET_YES);
 }








 B aa_NetCgiClientPseudoThread         (H handle)
 {
 B ret;
 B read_buff[_64K-_1K];
 B doupdate;
 _aa_netcgiclientobject*cgop;
 H todo,done,r,avail;
 H thismsg;
 DWORD mode;
 BOOL rr;

 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { oops;  }
 cgop->is_running=1;
 if(cgop->status.is_ready!=YES)
  {
  cgop->status.is_ready=YES;
  mode=PIPE_READMODE_BYTE|PIPE_NOWAIT;
  if(SetNamedPipeHandleState(cgop->in_write,&mode,0,0)==0) { oof; oow; }
  mode=PIPE_READMODE_BYTE|PIPE_NOWAIT;
  if(SetNamedPipeHandleState(cgop->out_read,&mode,0,0)==0) { oof; oow; }
  }
 while(1)
  {
  doupdate=NO;
  UNUSE(doupdate);
  if((todo=aaNumRoof(cgop->status.xmit_bytes,(sizeof(read_buff)-10)))!=0)//&&cgop->ezy_mutex==0)
   {
   if(aaQuePeek(cgop->c2s_que.handle,0,todo,read_buff)==YES)
    {
    if(WriteFile(cgop->in_write,read_buff,todo,&done,NULL)==0)
     {
     r=GetLastError();
     if(r==ERROR_NO_DATA||r==ERROR_BROKEN_PIPE) { cgop->status.is_exited=YES;  }
     else                                       { cgop->status.is_failed=YES;  }
     }
    else
     {
     if(done>0)
      {
      if(done!=todo)
       {
       //aaDebugf("######## done=%i todo=%i",done,todo);
       }
      if((ret=aaQueDiscard(cgop->c2s_que.handle,done))!=YES) { aaNote(0,"%s have=%i doing=%i",ret_string[ret],cgop->c2s_que.status.bytes,done); }
      aaNetCgiClientInactivityReset(handle,NO,YES);
      doupdate=YES;
      }
     }
    }
   }
  if((rr=PeekNamedPipe(cgop->out_read,0,0,0,&avail,&thismsg))==0)
   {
   cgop->status.is_exited=YES;
   }
  else
   {
   if(avail!=0)
    {
    todo=avail;
    todo=aaNumRoof(todo,(sizeof(read_buff)-1));
    rr=ReadFile(cgop->out_read,read_buff,todo,&done,NULL);
    if(rr==0)
     {
     r=GetLastError();
     if(cgop->status.is_exited==NO)
      {
      if(r==ERROR_BROKEN_PIPE) {  oof;  cgop->status.is_exited=YES;  oof; }         else
      if(r==ERROR_NO_DATA) {  oof; }
      else { oof;  }
      }
     aaNote(0,"lasterr=%i",r);
     oof;
     }
    if(done!=todo) oof;
    if(done==0) oof;
    if((ret=aaQueWrite(cgop->s2c_que.handle,done,read_buff))!=YES) { oops; }
    aaNetCgiClientInactivityReset(handle,YES,NO);
    doupdate=YES;
    }
   }
  if(doupdate) { aa_NetCgiClientUpdate(handle);   }
  break;
  }
 cgop->is_running=2;
 return RET_YES;
 }






///=====================================================


 V aa_NetDnsYield                      (PP mem)
 {
 B ret;
 H ip;
 _aa_netdnsobject*narp;
 _DNS_HEADER*dns=NULL;
 _DNS_QUESTION*qinfo=NULL;
 _DNS_SOA dnssoap;
 B tok[_1K];
 BP qname=NULL;
 BP reader;
 H i,j,sl,mod;
 Z stop;
 B rrr[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(narp,_aa_netdnsobject*,*mem);
 aaTimerTikElapsed(narp->ms_tik,&narp->status.ms);
 dns=(_DNS_HEADER *)&narp->buf;

 switch(narp->stage)
  {
  case 100:
  ip=0;
  //if((ret=aaNetUdpCreateAny(&narp->udp.handle,ip,1025,60000))!=YES) oops;
  if((ret=aaNetUdpCreate(&narp->udp.handle,ip,0))!=YES) oops;
  aaNetUdpStatus(narp->udp.handle,&narp->udp.status);
  //BUG,"%i=pn",narp->udp.status.port_number);
  narp->stage=120;
  break;

  case 120:
  narp->status.attempt++;
  narp->id_match=(W)aaMathRand32(0,F16);
  dns->id=narp->id_match;
  dns->qr=0;
  dns->opcode=0;
  dns->aa=0;
  dns->tc=0;
  dns->rd=1;
  dns->ra=0;
  dns->z=0;
  dns->ad=0;
  dns->cd=0;
  dns->rcode=0;
  dns->q_count=htons(1);   //we have only 1 question
  dns->ans_count=0;
  dns->auth_count=0;
  dns->add_count=0;
  qname=(BP)&narp->buf[sizeof(_DNS_HEADER)];
  aaStringCopyf(narp->dnsName,"%s",narp->status.query);//host);
  aaStringLen(narp->dnsName,&narp->dnsName_sl);
  aa_NetDnsToFormat(narp->dnsName);
  aaStringLen(narp->dnsName,&narp->dnsName_sl);
  for(i=0;i<narp->dnsName_sl;i++) { *(qname+i)=narp->dnsName[i]; }
  *(qname+i)=0;
  qinfo=(_DNS_QUESTION*)&narp->buf[sizeof(_DNS_HEADER)+narp->dnsName_sl+1];
  qinfo->qtype=htons(narp->status.mode);//255);
  qinfo->qclass=htons(1);
  narp->stage=140;
  break;

  case 140:
  mod=(narp->status.attempt-1)%4;
  switch(mod)
   {
   case 2:      aaNetIpFromString("8.8.8.8",&ip);        break;
   case 0:      aaNetIpFromString("208.67.222.222",&ip); break;
   case 3:      aaNetIpFromString("8.8.4.4",&ip);        break;
   case 1:      aaNetIpFromString("208.67.220.220",&ip); break;
   }
  //aaNetIpFromString("192.168.0.1",&ip);
  narp->outlen=(H)sizeof(_DNS_HEADER)+narp->dnsName_sl+1+(H)sizeof(_DNS_QUESTION);
  if((ret=aaNetUdpPktSet(&narp->o_pkt,ip,53,0))!=YES) oops;
  if((ret=aaNetUdpPktAppend(&narp->o_pkt,narp->outlen,narp->buf))!=YES) oops;
  if((ret=aaNetUdpPktWrite(narp->udp.handle,&narp->o_pkt))!=YES) { oops; }
  //aaDebugf("dns out %i",narp->o_pkt.data_bytes);
  aaTimerInit(&narp->tm,1);
  narp->stage=160;
  break;

  case 160:
  aaTimerUpdate(&narp->tm,1);
  if(narp->tm.elapsed>=narp->timeout)
   {
   narp->timeout+=250;
   narp->stage=120;
   break;
   }
  if((ret=aaNetUdpStatus(narp->udp.handle,&narp->udp.status))!=YES) oops;
  ret=aaNetUdpPktRead(narp->udp.handle,&narp->i_pkt);
  if(ret==RET_NOTREADY) break;
  if(ret!=YES) { oops; break; }
  //aaDebugf("udp siz=%i",narp->i_pkt.data_bytes);
  narp->stage=180;
  break;

  case 180:
  //aaMemoryCopy(narp->buf,65535,&narp->i_pkt.data[0]);
  //aaFileSaveFromMemory("dms.bom",65535,&narp->i_pkt.data[0]);
  aaMemoryCopy(narp->buf,narp->i_pkt.data_bytes,&narp->i_pkt.data[0]);
//  BUG,"%u %u %u %u",narp->i_pkt.address.ip,narp->o_pkt.address.ip,ntohl(narp->o_pkt.address.ip),ntohl(narp->i_pkt.address.ip));
  if(narp->i_pkt.address.ip!=narp->o_pkt.address.ip)   {   narp->stage=160;   break;   }
  if(dns->id!=narp->id_match)   {   narp->stage=160;   break;   }
  if(dns->rcode==3)
   {
   narp->status.is_inprogress=NO;
   narp->status.is_found=NO;
   narp->status.is_notfound=YES;
   narp->status.is_failed=NO;
   narp->stage=200;
   break;
   }
  reader=&narp->buf[sizeof(_DNS_HEADER)+narp->dnsName_sl+1+sizeof(_DNS_QUESTION)];
  stop=0;
  //aaDebugf("ansco=%i",ntohs(dns->ans_count));
  ///aaFileSaveFromMemory("dms.bom",narp->i_pkt.data_bytes,narp->i_pkt.data);
  for(i=0;i<ntohs(dns->ans_count);i++)
   {
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringCopyf(narp->answers[i].name,"%s",rrr);
   reader=reader+stop;
   narp->answers[i].resource=(_DNS_R_DATA*)(reader);
   reader=reader+sizeof(_DNS_R_DATA);
   narp->answers[i].rdata_off=0;
   //aaDebugf("answer %i oref=%u type=%i _class=%u ttl=%u",i,narp->answers[i].pref,ntohs(narp->answers[i].resource->type),ntohs(narp->answers[i].resource->_class),ntohs(narp->answers[i].resource->ttl));
   switch(ntohs(narp->answers[i].resource->type))
    {
    case 1: //if its an ipv4 address
    aaStringNull(narp->answers[i].rdata);
    for(j=0;j<ntohs(narp->answers[i].resource->data_len);j++)
     {
     narp->answers[i].rdata[narp->answers[i].rdata_off]=reader[j];
     narp->answers[i].rdata_off++;
     }
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;

    case 2: // NS
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringLen(rrr,&sl);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    narp->answers[i].rdata_off+=(sl+1);
    reader=reader+stop;
    break;

    case 5: // cname
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;

    case 6:
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[0],"%s",rrr);
    narp->answers[i].rdata_off+=128;
    reader=reader+stop;
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[128],"%s",rrr);
    reader=reader+stop;
    aaMemoryCopy(&narp->answers[i].rdata[256],sizeof(H)*5,reader);
    break;


    case 15: // mx
    narp->answers[i].pref=reader[1]+256*reader[0];
    reader+=2;
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringLen(rrr,&sl);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    narp->answers[i].rdata_off+=(sl+1);
    reader=reader+(ntohs(narp->answers[i].resource->data_len)-2);
    break;

    case 16: // txt
    aaStringNull(narp->answers[i].rdata);
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringCopyf(&narp->answers[i].rdata[narp->answers[i].rdata_off],"%s",rrr);
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;

    default:
    aaNote(0,"!%s type=%u len=%u stop=%i",narp->answers[i].name,ntohs(narp->answers[i].resource->type),ntohs(narp->answers[i].resource->data_len),stop);
    reader=reader+ntohs(narp->answers[i].resource->data_len);
    break;
    }
   }


  for(i=0;i<ntohs(dns->auth_count);i++)
   {
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringCopyf(narp->auth[i].name,"%s",rrr);
   reader+=stop;
   narp->auth[i].resource=(_DNS_R_DATA*)(reader);
   reader+=sizeof(_DNS_R_DATA);
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringLen(rrr,&sl);
   aaStringCopyf(&narp->auth[i].rdata[narp->auth[i].rdata_off],"%s",rrr);
   narp->auth[i].rdata_off+=(sl+1);
   reader+=stop;
   }


  for(i=0;i<ntohs(dns->add_count);i++)
   {
   aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
   aaStringCopyf(narp->addit[i].name,"%s",rrr);
   reader+=stop;
   narp->addit[i].resource=(_DNS_R_DATA*)(reader);
   reader+=sizeof(_DNS_R_DATA);
   if(ntohs(narp->addit[i].resource->type)==1)
    {
    aaStringNull(narp->addit[i].rdata);
    narp->addit[i].rdata_off=0;
    for(j=0;j<ntohs(narp->addit[i].resource->data_len);j++)
     {
     narp->addit[i].rdata[narp->addit[i].rdata_off]=reader[j];
     narp->addit[i].rdata_off++;
     }
    reader+=ntohs(narp->addit[i].resource->data_len);
    }
   else
    {
    aa_NetDnsReadName(reader,narp->buf,&stop,rrr);
    aaStringLen(rrr,&sl);
    aaStringCopyf(&narp->addit[i].rdata[narp->addit[i].rdata_off],"%s",rrr);
    narp->addit[i].rdata_off+=(sl+1);
    reader+=stop;
    }
   }

  for(i=0;i<ntohs(dns->ans_count);i++)
   {
   switch(ntohs(narp->answers[i].resource->type))
    {
    case 1:  //IPv4 address
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",narp->answers[i].name);
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_A;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    narp->status.ip[narp->status.result_count]=*(HP)&narp->answers[i].rdata[0];
    narp->status.result_count++;
    break;

    case 2: //NS Record
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_NS;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.result_count++;
    break;

    case 5:   //Canonical name for an alias
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_CNAME;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.name[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.result_count++;
    break;

    case 6:
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_SOA;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",&narp->answers[i].rdata[0]);
    aaStringCopyf(narp->status.name[narp->status.result_count],"%s",&narp->answers[i].rdata[128]);
    aaMemoryCopy(&dnssoap.serial,sizeof(H)*5,&narp->answers[i].rdata[256]);
    narp->status.data[narp->status.result_count][0]=ntohl(dnssoap.serial);
    narp->status.data[narp->status.result_count][1]=ntohl(dnssoap.refresh);
    narp->status.data[narp->status.result_count][2]=ntohl(dnssoap.retry);
    narp->status.data[narp->status.result_count][3]=ntohl(dnssoap.expire);
    narp->status.data[narp->status.result_count][4]=ntohl(dnssoap.minimum);
    narp->status.result_count++;
    break;

    case 15: //MX Record
    narp->status.type[narp->status.result_count]=aa_DNS_MODE_MX;
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.host[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.priority[narp->status.result_count]=narp->answers[i].pref;
    narp->status.result_count++;
    break;

    case 16: // txt
    narp->status.ttl[narp->status.result_count]=aaNumSwapDword(narp->answers[i].resource->ttl);
    aaStringCopyf(narp->status.etc[narp->status.result_count],"%s",narp->answers[i].rdata);
    narp->status.result_count++;
    break;

    default:
    aaNote(0,"      res type=%u",ntohs(narp->answers[i].resource->type));
    break;
    }
   if(narp->status.result_count>=aaElementCount(narp->status.ip)) { break; }
   }

  for(i=0;i<ntohs(dns->auth_count);i++)
   {
   aaNote(0,"Nam1: %s",narp->auth[i].name);//.c_str());
   if(ntohs(narp->auth[i].resource->type)==2)
    {
    aaNote(0,"      has authoritative nameserver : %s",narp->auth[i].rdata);//.c_str());
    }
   }

  for(i=0;i<ntohs(dns->add_count);i++)
   {
   aaNote(0,"Nam2: %s ",narp->addit[i].name);
   if(ntohs(narp->addit[i].resource->type)==1)
    {
    aaNetIpToString(*(HP)&narp->addit[i].rdata[0],tok);
    aaNote(0,"      has IPv4 address :  %s",tok);
    }
   }

  narp->status.is_inprogress=NO;
  if(narp->status.result_count==0) { narp->status.is_notfound=YES; narp->status.is_found=NO; }
  else                             { narp->status.is_found=YES; narp->status.is_notfound=NO; }
  narp->status.is_failed=NO;
  narp->stage=200;
  break;

  case 200:
  break;
  }
 }






 V aa_NetDnsReadName                   (BP reader,BP buffer,ZP count,BP name)
 {
 H offset,jumped=0;

 aaStringNull(name);
 *count=1;
 while(*reader!=0)
  {
  if(*reader>=192) {  offset=(*reader)*256+*(reader+1)-49152;  reader=buffer+offset-1;   jumped=1;   }
  else             {  aaStringAppendChar(name,*reader);   }
  reader=reader+1;
  if(jumped==0) *count=*count+1;
  }
 if(jumped==1) *count=*count+1;
 aaStringAppendChar(name,0);
 aa_NetDnsFromFormat(name);
 }






 V aa_NetDnsToFormat                   (VP outdns)
 {
 B txt[_1K];
 BP bp;//,hst;
 H sl,i,o,len,oo,n=0,pos,opos;
 B outp[_1K];

 aaCast(bp,BP,outdns);
 //aaCast(hst,BP,outdns);
 aaStringLen(outdns,&sl);
 oo=i=o=0;
 opos=0;
 aaStringNull(outp);
 while(1)
  {
  if(aaStringFindChar(outdns,sl,&pos,'.',YES,n,YES)!=YES) { oo=(sl-opos)-0; }
  else { oo=pos-opos; }
  aaStringCopyfLen(txt,&len,"%u",oo);
  outp[o]=oo; o++;
  aaStringNCopy(&outp[o],&bp[opos],oo,YES);     o+=oo;
  n++;
  opos+=(oo+1);
  if(pos==F32)  {   outp[o]=0; o++;   break;  }
  }
 aaStringCopyf(outdns,"%s",outp);
 }




 V aa_NetDnsFromFormat                 (VP outhost)
 {
 BP dns;
 H sl,len,i,o;
 B outp[_1K];

 aaCast(dns,BP,outhost);
 aaStringLen(dns,&sl);
 aaStringNull(outp);
 i=o=0;
 while(i<sl)
  {
  len=dns[i];
  if(len==0) break;
  i++;
  aaStringNCopy(&outp[o],&dns[i],len,NO);
  o+=len;
  i+=len;
  if((sl-i)>1) {  outp[o]='.';             o++; }
  outp[o]=0;
  }
 outp[o]=0;
 aaStringCopyf(dns,"%s",outp);
 }




///=====================================================


 B aaNetCgiClientCreate                (HP handle,B hidden,VP env,VP dir,VP processfilename,VP command)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 HANDLE out_read_temp,out_write,input_write_temp,input_read;
 HANDLE error_write;
 SECURITY_ATTRIBUTES sa;
 H err;
 B apcl[_1K];


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(processfilename==NULL) { return RET_BADPARM; }
// if((ret=aaFileExists(processfilename))!=YES) { return ret; } // 2009
 if((ret=aa_ObjectCreate(aa.net_system.cgiclient_object_id,handle,(VP)&cgop))!=RET_YES)  { oops; return ret;  }
 cgop->self_handle=*handle;
 aaTimerTikGet(&cgop->ms_root);
 //cgop->status.line_force_ms=0;
 cgop->inactive_rcve_ms_root=cgop->ms_root;
 cgop->inactive_xmit_ms_root=cgop->ms_root;
 cgop->inactive_line_ms_root=cgop->ms_root;
 cgop->status.ms=0;
 cgop->status.rcve_inactivity=0;
 cgop->status.xmit_inactivity=0;
 cgop->status.line_inactivity=0;
 while(1)
  {
  if((ret=aaQueCreate(&cgop->c2s_que.handle))!=YES) { break;  }
  if((ret=aaQueCreate(&cgop->s2c_que.handle))!=YES) { break;  }
  break;
  }
 if(ret!=YES)
  {
  if(cgop->c2s_que.handle!=0) { aaQueDestroy(cgop->c2s_que.handle); cgop->c2s_que.handle=0;  }
  if(cgop->s2c_que.handle!=0) { aaQueDestroy(cgop->s2c_que.handle); cgop->s2c_que.handle=0;  }
  aa_ObjectDestroy(aa.net_system.cgiclient_object_id,*handle);
  *handle=0;
  return ret;
  }
 sa.nLength= sizeof(SECURITY_ATTRIBUTES);
 sa.lpSecurityDescriptor=NULL;
 sa.bInheritHandle=TRUE;
 err=0;
 while(1)
  {
  if(!CreatePipe(&out_read_temp,&out_write,&sa,0)) { err=1; break;  }
  if(!DuplicateHandle(GetCurrentProcess(),out_write,GetCurrentProcess(),&error_write,0,TRUE,DUPLICATE_SAME_ACCESS)) { err=2; break;}
  if(!CreatePipe(&input_read,&input_write_temp,&sa,0))   { err=3; break;}
  if(!DuplicateHandle(GetCurrentProcess(),out_read_temp,GetCurrentProcess(),&cgop->out_read,0,FALSE,DUPLICATE_SAME_ACCESS))  { err=4; break;}
  if(!DuplicateHandle(GetCurrentProcess(),input_write_temp,GetCurrentProcess(),&cgop->in_write,0,FALSE,DUPLICATE_SAME_ACCESS))    { err=5; break;}
  if(!CloseHandle(out_read_temp)) { err=6; break;} out_read_temp=0;
  if(!CloseHandle(input_write_temp)) { err=7; break;} input_write_temp=0;
  cgop->std_input=GetStdHandle(STD_INPUT_HANDLE);
  if(cgop->std_input==INVALID_HANDLE_VALUE) { oow; err=8; break;}
  ZeroMemory(&cgop->si,sizeof(STARTUPINFO));
  cgop->si.cb=sizeof(STARTUPINFO);
  cgop->si.dwFlags=STARTF_USESTDHANDLES;
  cgop->si.dwFlags|=STARTF_USESHOWWINDOW;
  if(hidden==YES) { cgop->status.is_hidden=YES; cgop->si.wShowWindow=SW_HIDE; }
  else            { cgop->status.is_hidden=NO; cgop->si.wShowWindow=SW_SHOW; }
  cgop->si.hStdOutput=out_write;
  cgop->si.hStdInput =input_read;
  cgop->si.hStdError =error_write;
  aaStringCopyf(apcl,"%s",processfilename);
//  aaStringNull(path);
//  if(aaStringFindChar(apcl,0,&pos,BSLASH_CHAR,YES,0,NO)==YES&&pos!=F32) {   aaStringNCopy(path,apcl,pos,YES);   }
  if(aaStringIsNull(command)==NO) { aaStringAppendf(apcl," %s",command); }
  //CREATE_NEW_CONSOLE
  if(!CreateProcess(0,(CP)apcl,NULL,NULL,TRUE,CREATE_NEW_CONSOLE,env,/*(CP)path*/dir,&cgop->si,&cgop->pi)) { oow; oow; aaNote(0,"%s\n%s",apcl,0); err=9; break;}
  if(!CloseHandle(cgop->pi.hThread)) { err=10; break;}
  if(!CloseHandle(out_write))  { err=11; break;}
  if(!CloseHandle(input_read)) { err=12; break;}
  if(!CloseHandle(error_write)) { err=13; break;}
  CloseHandle(cgop->std_input); cgop->std_input=0;
  cgop->status.tid=cgop->pi.dwThreadId;
  cgop->status.pid=cgop->pi.dwProcessId;
  cgop->status.thread_handle=cgop->pi.hThread;
  cgop->status.process_handle=cgop->pi.hProcess;
  aaQueStatus(cgop->c2s_que.handle,&cgop->c2s_que.status);
  aaQueStatus(cgop->s2c_que.handle,&cgop->s2c_que.status);
  #if aa_USE_CGICLIENT_THREADS ==1
  ret=aaThreadCreate(&cgop->thread.handle,aa_NetCgiClientThread,(H)*handle,NO);
  //ret=aaThreadCreate(&cgop->thread.handle,aa_NetCgiClientThread,(H)cgop,NO);
  if(ret!=YES) oops;
  ///aaDebugf("%s #%i cgihandle=%x thread.handle=%x",__func__,__LINE__,*handle,cgop->thread.handle);
  aaThreadStatus(cgop->thread.handle,&cgop->thread.status);
  #endif
  break;
  }
 if(err!=0)
  {
  aaNote(0,"line=%i err=%i",__LINE__,err);
  cgop->is_running=NO;
  #if aa_USE_CGICLIENT_THREADS ==1
  if(cgop->thread.handle!=0) { aaThreadDestroy(cgop->thread.handle); cgop->thread.handle=0; }
  #endif
  if(cgop->out_read!=0) { if(!cgop->out_read) { oow; } cgop->out_read=0; }
  if(cgop->in_write!=0) { if(!cgop->in_write) { oow; } cgop->in_write=0; }
  if(cgop->std_input!=0) { CloseHandle(cgop->std_input); cgop->std_input=0; }
  aaQueDestroy(cgop->s2c_que.handle);  cgop->s2c_que.handle=0;
  aaQueDestroy(cgop->c2s_que.handle);  cgop->c2s_que.handle=0;
  aa_ObjectDestroy(aa.net_system.cgiclient_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 cgop->obj_handle=*handle;
 return RET_YES;
 }




 B aaNetCgiClientDestroy               (H handle)
 {
 B ret;
 //H i;
 _aa_netcgiclientobject*cgop;
 B isprot;
 B is_attach;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 cgop->is_running=0;
 aaSleep(1);
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadExit(cgop->thread.handle))!=YES) { oops; }
 #endif

 is_attach=NO;
 if(AttachConsole(cgop->status.pid))
  {
  is_attach=YES;
  SetConsoleCtrlHandler(NULL,TRUE);
  GenerateConsoleCtrlEvent(CTRL_C_EVENT,0);
  }

 // aaNote(0,"%i",cgop->is_running);
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadDestroy(cgop->thread.handle))!=YES) { oops; }
 #endif
 if(cgop->out_read!=0) { CloseHandle(cgop->out_read); cgop->out_read=0; }
 if(cgop->in_write!=0) { CloseHandle(cgop->in_write); cgop->in_write=0; }
 if(cgop->std_input!=0)  {  CloseHandle(cgop->std_input);  cgop->std_input=0;  }
 //if(cgop->pre_que.handle!=0) { aaQueDestroy(cgop->pre_que.handle);  }
 if(cgop->s2c_que.handle!=0) { aaQueDestroy(cgop->s2c_que.handle);  }
 if(cgop->c2s_que.handle!=0) { aaQueDestroy(cgop->c2s_que.handle);  }
 if(is_attach)  {  FreeConsole();  SetConsoleCtrlHandler(NULL,FALSE);  }
 if(cgop->status.thread_handle)  { CloseHandle(cgop->status.thread_handle);cgop->status.thread_handle=0; }
 if(cgop->status.process_handle) { CloseHandle(cgop->status.process_handle); cgop->status.process_handle=0; }
 aa_ObjectDestroy(aa.net_system.cgiclient_object_id,handle);
 return RET_YES;
 }






 B aaNetCgiClientStatus                (H handle,_cgiclientstatus*cgiclientstatus)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
// if((ret=aaThreadLock(cgop->thread.handle,YES))!=YES) oops;
 if(cgiclientstatus) {  aaMemoryCopy(cgiclientstatus,sizeof(_cgiclientstatus),&cgop->status);  }
 //if((ret=aaThreadUnLock(cgop->thread.handle))!=YES) oops;
 return RET_YES;
 }





 B aaNetCgiClientWrite                 (H handle,H bytes,VP data)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,0))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadLock(cgop->thread.handle,YES))!=YES) oops;
 #endif
 //cgop->ezy_mutex=1;
 while(1)
  {
  if(cgop->status.is_exited==YES||cgop->status.is_failed==YES) { break; }
  if((ret=aaQueWrite(cgop->c2s_que.handle,bytes,data))!=YES) { oops; }
  break;
  }
 //cgop->ezy_mutex=0;
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadUnLock(cgop->thread.handle))!=YES) oops;
 #endif
 //aa_NetCgiClientUpdate((VP)&cgop);
 if(cgop->status.is_failed==YES) { return RET_FAILED; }
 if(cgop->status.is_exited==YES) { return RET_NOTOPEN; }
 aaNetCgiClientInactivityReset(handle,0,YES);
 aa_NetCgiClientPseudoThread(handle);
 aa_NetCgiClientUpdate(handle);
 return RET_YES;
 }




 B aaNetCgiClientWritef                (H handle,VP fmt,...)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 va_list argptr;
 B txt[_4K];
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,txt);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_CgiWritef))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 if(fmt==NULL)
 { return RET_YES; }
 aaStringLen(tmp,&sl);
 if(sl==0) { return RET_YES; }

 if((ret=aaNetCgiClientWrite(handle,sl,tmp))!=RET_YES) { return ret; }
 return RET_YES;
 }






 B aaNetCgiClientRead                  (H handle,H bytes,VP data)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 if((ret=aaNetCgiClientPeek(handle,0,bytes,data))!=RET_YES) { return ret; }
 if((ret=aaNetCgiClientDiscard(handle,bytes))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 return RET_YES;
 }




 B aaNetCgiClientPeek                  (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 aaStringNull(data);
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 if(bytes==0) { return RET_YES; }
 aa_NetCgiClientUpdate(handle);
 //cgop->ezy_mutex=1;
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadLock(cgop->thread.handle,YES))!=YES) oops;
 #endif
 if(bytes==F32) { bytes=cgop->status.rcve_bytes; }
 bp=(BP)data;
 ret=aaQuePeek(cgop->s2c_que.handle,offset,bytes,bp);
 if(ret==RET_YES)
  {
  //cgop->ezy_mutex=0;
  #if aa_USE_CGICLIENT_THREADS ==1
  if((ret=aaThreadUnLock(cgop->thread.handle))!=YES) oops;
  #endif
  return RET_YES;
  }
 //cgop->ezy_mutex=0;
 #if aa_USE_CGICLIENT_THREADS ==1
 if(aaThreadUnLock(cgop->thread.handle)!=YES) oof;
 #endif
 if(ret==RET_BOUNDS) { ret=RET_NOTREADY; }
 if(ret!=RET_NOTREADY) {  oops;  cgop->status.is_failed=YES; return RET_FAILED; }
 aaNote(0,"######### quepeek (off=%i bytes=%i) ret=%s",offset,bytes,ret_string[ret]);
 return RET_YES;
 }





 B aaNetCgiClientDiscard               (H handle,H bytes)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 aa_NetCgiClientPseudoThread(handle);
 if(bytes==0) { return RET_YES; }
 //cgop->ezy_mutex=1;
 aa_NetCgiClientUpdate(handle);
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadLock(cgop->thread.handle,YES))!=YES) oops;
 #endif
 if(bytes==F32) { bytes=cgop->status.rcve_bytes; }
 if(bytes>cgop->status.rcve_bytes)
  {
  //cgop->ezy_mutex=0;
  #if aa_USE_CGICLIENT_THREADS ==1
  aaThreadUnLock(cgop->thread.handle);
  #endif
  return RET_BOUNDS;
  }
 if((ret=aaQueDiscard(cgop->s2c_que.handle,bytes))!=RET_YES)
  {
  //cgop->ezy_mutex=0;
  #if aa_USE_CGICLIENT_THREADS ==1
  aaThreadUnLock(cgop->thread.handle);
  #endif
  return ret;
  }
 //cgop->ezy_mutex=0;
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadUnLock(cgop->thread.handle))!=YES) oops;
 #endif
 aaNetCgiClientInactivityReset(handle,YES,NO);
 aa_NetCgiClientUpdate(handle);
 aa_NetCgiClientPseudoThread(handle);
 return RET_YES;
 }








 B aaNetCgiClientStringLen             (H handle,HP chars,BP isdossy,BP stringmode)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 H offy,tot,totleft,todo,len,left,ok=0;
 H atatime,sl,i=0;
 Z asca,ascb;
 B block[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(isdossy) *isdossy=0;
 if(chars) *chars=0;
 if(stringmode) { *stringmode=0; }
 aa_NetCgiClientUpdate(handle);
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadLock(cgop->thread.handle,YES))!=YES) oops;
 #endif
 tot=cgop->status.rcve_bytes;
 atatime=_8K;
 offy=len=ok=0;
 while(1)
  {
  asca=ascb=-1;
  ok=0;
  i=0;
  totleft=tot-offy;
  todo=aaNumRoof(totleft,atatime);
  if(todo==0) {  break; }
  if((ret=aaQuePeek(cgop->s2c_que.handle,offy,todo,block))!=YES) oops;
  block[todo]=NULL_CHAR;
  for(i=0;i<todo;i++)
   {
   left=todo-i;
   asca=ascb=-1;
   asca=block[i+0];
   if(left>=2) ascb=block[i+1];
   if(asca==CR_CHAR&&ascb==LF_CHAR) { ok=aa_STRINGMODE_CRLF; break; }
   if(asca==LF_CHAR&&ascb!=-1&&ascb!=CR_CHAR) { ok=aa_STRINGMODE_LF; break; }
   if(asca==CR_CHAR&&ascb!=-1) { ok=aa_STRINGMODE_CR; break; }
   }
  if(i!=todo)   {   break;   }
  offy+=i;
  }
 len=offy+i;
 if(chars) *chars=len;
 if(stringmode) *stringmode=ok;
 if(isdossy&&len>=3)
  {
  //aaLog(-777,"line=%i len=%i",__LINE__,len);
   // was len-1
  aaStringLen(block,&sl);
//  aaLog(-777,"len=%i off=%i i=%i todo=%i sl=%i [%s]",len,offy,i,todo,sl,block);
  if(sl>0)
   {
   if(block[sl-1]=='>'&&aaCharIsAlpha(block[0])&&block[1]==':'&&block[2]==BSLASH_CHAR)
    {
    *isdossy=YES;
    }
   }
  }
 //aaLog(-777,"line=%i",__LINE__);
 #if aa_USE_CGICLIENT_THREADS ==1
 if((ret=aaThreadUnLock(cgop->thread.handle))!=YES) oops;
 #endif
 aa_NetCgiClientUpdate(handle);
 if(ok==0)  {  return RET_NOTREADY;  }
 return RET_YES;
 }





 B aaNetCgiClientStringRead            (H handle,HP chars,BP isdossy,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H len,plus=0;
 B mo,isd;
 BP bp;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(isdossy) { *isdossy=NO; }
 if(stringmode) { *stringmode=0; }
 if(chars) *chars=0;
 //if(buf!=NULL) { aaStringNull(buf); }
 if(buf==NULL) { return RET_BADPARM; }
 aaStringNull(buf);

 ret=aaNetCgiClientStringLen(handle,&len,&isd,&mo);
 if(stringmode) { *stringmode=mo; }
 if(chars) *chars=len;
 if(isdossy) *isdossy=isd;
 if(ret!=RET_NOTREADY&&ret!=RET_YES) { return ret; }
 if(ret==RET_YES)
  {
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { plus=1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { plus=2; }  else { oof; }
  if((len+plus)>maxchars)   {   return RET_BOUNDS;  }
  if((ret=aaNetCgiClientRead(handle,len+plus,buf))!=RET_YES) { oops; }
  aaCast(bp,BP,buf);
  bp[len]=NULL_CHAR;
  aa_NetCgiClientUpdate(handle);
  return RET_YES;
  }
 if(len>maxchars) { return RET_BOUNDS; } //len=maxchars; }
 if(len)
  {
  if((ret=aaNetCgiClientPeek(handle,0,len,buf))!=YES) { oops; }
  aaCast(bp,BP,buf);
  bp[len]=NULL_CHAR;
  }
 return RET_NOTREADY;
 }





 B aaNetCgiClientStringPeek            (H handle,HP chars,BP isdossy,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H len,plus=0;
 B mo,isd;
 BP bp;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(isdossy) { *isdossy=NO; }
 if(stringmode) { *stringmode=0; }
 if(chars) *chars=0;
 //if(buf==NULL) { return RET_BADPARM; }
 if(buf) {  aaStringNull(buf); }
 ret=aaNetCgiClientStringLen(handle,&len,&isd,&mo);
 if(stringmode) { *stringmode=mo; }
 if(chars) *chars=len;
 if(isdossy) *isdossy=isd;
 if(ret!=RET_NOTREADY&&ret!=RET_YES) {  return ret; }
 if(ret==RET_YES)
  {
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { plus=1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { plus=2; }  else { oof; }
  if(buf)
   {
   if((len+plus)>maxchars)   {   return RET_BOUNDS;  }
   if((ret=aaNetCgiClientPeek(handle,0,len+plus,buf))!=RET_YES) { oops; }
   aaCast(bp,BP,buf);
   bp[len]=NULL_CHAR;
   }
  aa_NetCgiClientUpdate(handle);
  return RET_YES;
  }

 if(buf&&len>maxchars) { return RET_BOUNDS; }
 if(len)
  {
  if(buf)
   {
   if((ret=aaNetCgiClientPeek(handle,0,len,buf))!=YES) { oops; }
   aaCast(bp,BP,buf);
   bp[len]=NULL_CHAR;
   }
  }
 return RET_NOTREADY;
 }




 B aaNetCgiClientStringReadQuick       (H handle,H promptms,HP chars,BP isprompt,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H ch,chb;
 B isdossy;
 B smode;
 //B txt[_32K];
 BP txt=NULL_POINTR;
 _aa_netcgiclientobject*cgop;
 _cgiclientstatus status;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) {return ret; }
 if(chars) { *chars=0; }
 if(isprompt) { *isprompt=0; }
 if(stringmode) { *stringmode=0; }
 if(buf) { aaStringNull(buf); }
 if((ret=aa_MemoryTemp((VP)&txt,_256K,aa_MEMORYTEMP_CgiRead))!=RET_YES) { return ret; }
 while(1)
  {
  ret=RET_NOTREADY;
  aaNetCgiClientStatus(handle,&status);
  if(status.rcve_bytes==0) { break; }
  ret=aaNetCgiClientStringPeek(handle,&ch,&isdossy,&smode,0,NULL);
  if(ret!=RET_YES&&ret!=RET_NOTREADY) { oops; break; }
  if(maxchars!=0&&ch>maxchars)
   {
   if(chars) { *chars=ch; }
   return RET_BOUNDS;
   }

  if(ret==RET_NOTREADY)
   {
   if(isdossy==YES&&status.line_inactivity>promptms&&status.rcve_inactivity>promptms)
    {
    if(aaNetCgiClientRead(handle,ch,txt)!=YES) { oof; }
    aaNetCgiClientStatus(handle,&status);
    txt[ch]=NULL_CHAR;
    smode=aa_STRINGMODE_NULL;
    if(isprompt) { *isprompt=YES; }
    if(chars)    { *chars=ch; }
    if(buf)      { aaMemoryCopy(buf,ch+1,txt); }
    if(stringmode)     { *stringmode=smode; }
    return RET_YES;
    }
   //continue;
   break;
   }
  aaStringLengthModeAdjust(smode,ch,YES,&chb);
  aaNetCgiClientRead(handle,chb,txt);
  aaNetCgiClientStatus(handle,&status);
  txt[ch]=NULL_CHAR;
  if(isprompt) { *isprompt=NO; }
  if(chars)    { *chars=ch; }
  if(buf)      { aaMemoryCopy(buf,ch+1,txt); }
  if(stringmode)     { *stringmode=smode; }
  return RET_YES;
  }
 if(ret!=RET_NOTREADY) { oops; }
 return ret;
 }






 B aaNetCgiClientInactivityReset       (H handle,B rflag,B xflag)
 {
 B ret;
 _aa_netcgiclientobject*cgop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 if(rflag)  {  aaTimerTikGet(&cgop->inactive_rcve_ms_root);  cgop->status.rcve_inactivity=0;  }
 if(xflag)  {  aaTimerTikGet(&cgop->inactive_xmit_ms_root);  cgop->status.xmit_inactivity=0;  }
 return RET_YES;
 }




 B aaNetCgiClientChildrenTerminate     (H handle)
 {
 B ret;
 _aa_netcgiclientobject*cgop;
 H lev_thread_id,i,han;
 _processentry pe;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //aaDebugf("%s",__func__);
 if((ret=aa_ObjectCheck(aa.net_system.cgiclient_object_id,handle,(VP)&cgop,NULL))!=RET_YES) { return ret; }
 lev_thread_id=cgop->pi.dwProcessId;
 han=0;
 for(i=0;;i++)
  {
  if((ret=aaProcessList(&han,i,&pe))==RET_FINISHED) { ret=RET_YES; break; }
  if(ret!=YES) { oops; break; }
  if(pe.parent_process_id==lev_thread_id)   {   aaProcessTerminateByPid(pe.process_id,0); break; }
  }
 if(han!=0) { aaProcessListDestroy(han); }
 return ret;
 }


/*-----------------------------------------------------------------------*/


 B aaNetUrlSimplify                    (VP url,H chars,VP ourl)
 {
 CP p,q,q1;
 B out[_4K];
 CP op;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(url==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(url,&chars); }
 if(chars==0)
  {
  if(ourl) { aaStringNull(ourl); }
  return RET_YES;
  }
 aaStringNCopy(out,url,chars,YES);
 op=(CP)out;
 if(ourl) { aaStringNull(ourl); }
 if(!(op[0]&&op[1])||op[0]=='?'||op[1]=='?'||op[2]=='?')
  {
  if(ourl) { aaStringCopyf(ourl,"%s",out);}
  return RET_YES;
  }
 if(strchr(op,FSLASH_CHAR)!=NULL)
  {
   for(p=(op+2);*p;p++)
    {
    if(*p=='?') { break; }
    if(*p==FSLASH_CHAR) {
    if((p[1]=='.')&&(p[2]=='.')&&(p[3]==FSLASH_CHAR||p[3]=='?'||p[3]==NULL_CHAR))
     {
     for(q=(p-1);(q>=op)&&(*q!=FSLASH_CHAR);q--);
     if((q[0]==FSLASH_CHAR)&&(strncmp(q,"/../",4)&&strncmp(q,"/..?",4))&&!((q-1)>op&&q[-1]==FSLASH_CHAR))
      {
      q1=(p+3);
      p=q;
      while(*q1!=NULL_CHAR)    *p++=*q1++;
      *p=NULL_CHAR;
      p=(q-1);
      }
     }
    else
    if(p[1]=='.'&&p[2]==FSLASH_CHAR)
     {
     q=p;
     q1=(p+2);
     while(*q1!=NULL_CHAR)  *q++=*q1++;
     *q=NULL_CHAR;
     p--;
     }
    else
    if(p[1]=='.'&&p[2]=='?')
     {
     q=(p+1);
     q1=(p+2);
     while(*q1!=NULL_CHAR)	*q++=*q1++;
     *q=NULL_CHAR;
     p--;
     }
    else
    if(p[1]=='.'&&p[2]==NULL_CHAR)
     {
     p[1]=NULL_CHAR;
     }
    }
   }
  if(p>=op+2&&*p=='?'&&*(p-1)=='.')
   {
   if(*(p-2)==FSLASH_CHAR)
    {
    q=p-1;
    q1=p;
    while(*q1!=NULL_CHAR)  *q++=*q1++;
    *q=NULL_CHAR;
    }
   else
   if(*(p-2)=='.'&&p>=op+4&&*(p-3)==FSLASH_CHAR&&(*(p-4)!=FSLASH_CHAR||(p>op+4&&*(p-5)!=':')))
    {
    for(q=(p-4);(q>op)&&(*q!=FSLASH_CHAR);q--);
    if(*q==FSLASH_CHAR)
     {
     if(q>op&&*(q-1)==FSLASH_CHAR&&!(q>op+1&&*(q-1)!=':'))
      {
      if(ourl) { aaStringCopyf(ourl,"%s",out); }
      return RET_YES;
      }
     q++;
     }
    if(strncmp(q,"../",3)&&strncmp(q,"./",2))
     {
     q1=p;
     p=q;
     while(*q1!=NULL_CHAR)   *p++=*q1++;
     *p=NULL_CHAR;	/* terminate */
     }
    }
   }
  }
 if(ourl) { aaStringCopyf(ourl,"%s",out); }
 return RET_YES;
 }




 B aaNetUrlDecode                      (VP url,H chars,VP durl)
 {
 H val,count;
 BP sp;
 BP dp;
 B tmp[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(url==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(url,&chars); }
 sp=url;
 dp=tmp;
 if(chars==0) { return RET_BADPARM; }
 while(1)
  {
  if(*sp=='+') { *dp=SPACE_CHAR; }
  else          { *dp=*sp; }
  if(*sp==NULL_CHAR) { break; }
  dp++;
  sp++;
  }
 sp=tmp;
 if(durl==NULL) { dp=url; }
 else           { dp=durl; }
 while(*sp)
  {
  if(*sp=='%')
   {
   sp++;
   if(aaCharIsHex(sp[0])&&aaCharIsHex(sp[1])) { aaStringHexToNumber(sp,2,&val,0,NULL,NULL);  *dp++=(B)val;  sp+=2;  continue;    }
   else                                       { *dp=*sp;  dp++;    continue;    }
   }
  if(*sp=='&'&&*(sp+1)=='#')
   {
   aaStringCountNumbers(&sp[2],0,&count,YES);
   if(count>=1)
    {
    if(aaStringToNumber(&sp[2],count,&val,0,0,0)==YES)
     {
     if(*(sp+2+count)==';')
      {
      if(val<=255)  {  *dp++=(B)val;   sp+=(1+2+count);   continue;       }
      }
     }
    }
   }
  *dp++=*sp++;
  }
 *dp=NULL_CHAR;
 return RET_YES;
 }






 B aaNetUrlPartsGet                    (_urlparts*urlparts,VP url,B spaceplus,B decode)
 {
 B req[_4K];
 B txt[_4K];
 H off,pos,spo;
 B ascii;
 N which;
 H newoff=0;
 B slash_added;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 slash_added=NO;
 if(urlparts==NULL) { return RET_BADPARM; }
 aaMemoryFill(urlparts,sizeof(_urlparts),0);
 if(url==NULL) { return RET_BADPARM; }

 aaStringCopy(urlparts->raw_url,url);
 if(decode) aaNetUrlDecode(urlparts->raw_url,0,urlparts->dec_url);
 else       aaStringCopy(urlparts->dec_url,urlparts->raw_url);

 // if spaceplus, then after decode, convert all spaces to + char
 // e.g if were about to do a httpreq and weve already replaced spaces with pluses
 // in the url, we want to retain them after calling urldecode
 if(spaceplus) { aaStringReplaceChar(urlparts->dec_url,0,32,'+');   }
// aaStringDecode(urlparts->raw_url,0,urlparts->dec_url,YES);
 aaStringCopy(txt,urlparts->dec_url);
// aaStringCopy(txt,url);
 aaStringReplaceChar(txt,0,BSLASH_CHAR,FSLASH_CHAR);
 aaStringIsIStringPartial(txt,&which,"http://","telnet://","https://","ftp://","ws://",NULL);
 if(which!=-1)
  {
  if(which==0) { aaStringCopy(urlparts->scheme,"http");  newoff=3+4; }
  if(which==1) { aaStringCopy(urlparts->scheme,"telnet"); newoff=3+6; }
  if(which==2) { aaStringCopy(urlparts->scheme,"https"); newoff=3+5; }
  if(which==3) { aaStringCopy(urlparts->scheme,"ftp"); newoff=3+3; }
  if(which==4) { aaStringCopy(urlparts->scheme,"ws");  newoff=3+2; }
  aaStringCopyf(req,"%s",txt);
  }
 else
  {
  aaStringCopyf(req,"http://%s",txt);
  newoff=3+4;
  }

 aaStringFindChar(req,0,&off,'?',YES,0,YES);
 if(off!=F32)
  {
  aaStringCopy(urlparts->parms,&req[off]);
  ///aaStringCopy(urlparts->parms,&urlparts->raw_url[off]);
  aaStringCharSet(req,0,off,NULL_CHAR);
  }
 // change bslashes to fslashes  ( todo: %encoded hex codes )
 aaStringReplaceChar(req,0,BSLASH_CHAR,FSLASH_CHAR);
 // remove double slashes
 off=(newoff+1);
 while(1)
  {
  ascii=req[off];
  if(ascii==NULL_CHAR) { break; }
  if(ascii!=FSLASH_CHAR) { off++; continue; }
  if(req[off+1]!=FSLASH_CHAR) { off++; continue; }
  aaStringDeleteChar(req,0,off);
  off++;
  }

 // handle double dot logic - this is just a very rough hack, make sure i fix this to conform to rfc 1830  see in w3clib/library/htparse.c
 // currently all it does is ,, convert /../ to /
 off=(newoff+1);
 while(1)
  {
  ascii=req[off];
  if(ascii==NULL_CHAR) { break; }
  if(ascii!=FSLASH_CHAR) { off++; continue; }
  if(req[off+1]!='.'||req[off+1]==NULL_CHAR) { off++; continue; }
  if(req[off+2]!='.'||req[off+2]==NULL_CHAR) { off++; continue; }
  if(req[off+3]!='/'||req[off+3]==NULL_CHAR) { off++; continue; }
  if(req[off+4]==NULL_CHAR) { off++; continue; }
  aaStringDeleteChars(req,0,off,3);
  }


/// // ends with a slash  ( delete trailing slashes )
//// aaStringCharGet(req,0,-1,&ascii);
///// if(ascii==FSLASH_CHAR||ascii==BSLASH_CHAR) {  aaStringLastCharSet(req,0,0);  }
 aaStringFindChar(req,0,&pos,FSLASH_CHAR,YES,2,YES);
 // find first dot in reverse order
//removed if(pos==F32) {  aaStringAppend(req,"/"); }
//removed retry:
 aaStringCopy(urlparts->absolute,req);
 // change bslashes to fslashes  ( todo: %encoded hex codes )
 aaStringReplaceChar(urlparts->absolute,0,BSLASH_CHAR,FSLASH_CHAR);
 // find first fslash in reverse order
 aaStringFindChar(req,0,&off,FSLASH_CHAR,YES,0,NO);
 // find third fslash in forward order (ignore ://)
 aaStringFindChar(req,0,&pos,FSLASH_CHAR,YES,2,YES);
 // find first dot in reverse order
 aaStringFindChar(req,0,&spo,'.',YES,0,NO);
 aaStringCopy(txt,req);
 if(off==F32||spo==F32||pos==F32)
  {
///  BUG,"%i %i %i",off,spo,pos);
#if 0
  if(aaStringCompare(&txt[newoff],"localhost/",NULL)==YES)
   {
   aaNote(0,"z url=%s)       %i %i %i",txt,newoff,spo,pos);
   return RET_CORRUPTED; // was in side { note() } 2 lines up
   }
   #endif
  }
 if((spo<pos&&spo<off)&&(off!=F32&&pos!=F32&&spo!=F32))
  {
  aaStringCharGet(txt,0,-1,&ascii);
  if(ascii!=FSLASH_CHAR)
   {
   //removed slash_added=YES; aaStringAppend(req,"/"); goto retry;
   }
  }
 aaStringCopy(urlparts->relative,&urlparts->absolute[pos]);
 if(spo!=F32)
  {
  if(spo>off)
   {
   aaStringCopy(urlparts->ext,&txt[spo]);
   }
  }
 if(off!=F32)
  {
  aaStringCopy(urlparts->file,&txt[off+1]);
  if(spo!=F32&&spo>off)
   {
   urlparts->file[(spo-off)-1]=NULL_CHAR;
   }
  }
 if(pos!=F32)
  {
  aaStringNCopy(urlparts->host,&txt[newoff],pos-newoff,YES);
  //urlparts->host[pos-newoff]=NULL_CHAR;
  }
 if((pos!=F32&&off!=F32)&&off>=pos)
  {
  aaStringCopy(&urlparts->path,&txt[pos]);
  urlparts->path[(off-pos)+1]=NULL_CHAR;
  }
 if(aaStringIsNull(urlparts->host)==NO)
  {
  aaStringFindChar(urlparts->host,0,&off,':',YES,0,NO);
  if(off!=F32)
   {
   aaStringLen(&urlparts->host[off+1],&pos);
   aaStringCountNumbers(&urlparts->host[off+1],pos,&spo,YES);
   if((spo==0||spo>5)||(spo!=pos))
    {
//    BUG,"spot=%i pos=%i off=%i host=%s",spo,pos,off,&urlparts->host[off+1]);
//    BUG,"chars after port seperator invalid (%s) (%s)",&urlparts->host[off+1],url);
    return RET_CORRUPTED;
    }
   else
    {
    if(aaStringToNumber(&urlparts->host[off+1],0,&pos,0,0,0)==YES)
     {
     if(pos>65535)
      {
//      BUG,"port is out of range: (%lu)",pos);
      return RET_CORRUPTED;
      }
     else
      {
      urlparts->adr.port=(W)pos;
      urlparts->host[off]=NULL_CHAR;
      }
     }
    }
   }
  }
 if(aaNetIpIsValid(urlparts->host)==YES)
  {
  aaNetIpFromString(urlparts->host,&urlparts->adr.ip);
  }
 aaStringFindChar(urlparts->absolute,0,&off,FSLASH_CHAR,YES,0,NO);
 if(off==F32) { oof; }
 aaStringCopy(urlparts->filename,&urlparts->absolute[off+1]); // was [off] dec 07
// BUG,"slash added =%s",aaBoolString(slash_added));
// BUG,"prerelat=%s (%i)",urlparts->relative,urlparts->relative[1]);
 if(urlparts->relative[1]!=NULL_CHAR)
  {
//  aaStringCharGet(urlparts->relative,0,-1,&ascii);
  aaStringLastCharGet(urlparts->relative,0,&ascii);
  if(ascii==FSLASH_CHAR&&slash_added==YES)
   {
//   if(urlparts->file[0]!=NULL_CHAR||urlparts->parms[0]!=NULL_CHAR)
    {
//    BUG,"relati=%s",urlparts->relative);
    aaStringLastCharSet(urlparts->relative,0,NULL_CHAR,NO);
    }
   }
  }

 return RET_YES;
 }




 B aaNetUrlPartsToString               (_urlparts*urlparts,VP buf)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf==NULL) { return RET_BADPARM; }
 aaStringNull(buf);
 if(urlparts==NULL) { return RET_BADPARM; }
    aaStringAppendf(buf,"sceme=%s\n",urlparts->scheme);
    aaStringAppendf(buf,"real=%s\n",urlparts->dec_url);
    aaStringAppendf(buf,"host=%s\n",urlparts->host);
    aaStringAppendf(buf,"abss=%s\n",urlparts->absolute);
    aaStringAppendf(buf,"rela=%s\n",urlparts->relative);
    aaStringAppendf(buf,"path=%s\n",urlparts->path);
    aaStringAppendf(buf,"fnam=%s\n",urlparts->filename);
    aaStringAppendf(buf,"file=%s\n",urlparts->file);
    aaStringAppendf(buf,"ext=%s\n",urlparts->ext);
    aaStringAppendf(buf,"parms=%s\n",urlparts->parms);
    aaStringAppendf(buf,"adr=%lu %u\n",urlparts->adr.ip,urlparts->adr.port);
 return RET_YES;
 }




 B aaNetUrlToFilename                  (VP rootpath,VP relative,VP filename)
 {
 B ascii;
 B rp[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(relative==NULL) { return RET_BADPARM; }
 if(rootpath==NULL)  {  aaStringCopy(rp,aa.core_system.module_path);  }
 else                {  aaStringCopy(rp,rootpath);  }
 if(filename==NULL) { return RET_BADPARM; }
 aaStringCopyf(filename,"%s",rp);
 aaStringLastCharGet(filename,0,&ascii);
 if(ascii==BSLASH_CHAR) { aaStringLastCharSet(filename,0,0,0); }
 aaStringAppendf(filename,"%s",relative);
 aaStringReplaceChar(filename,0,FSLASH_CHAR,BSLASH_CHAR);
 return RET_YES;
 }




 B aaNetSetCookieDecode                (VP str,H chars,_cookie*cookie)
 {
 _parser pa,pb;
 H pos;
 B buf[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cookie==NULL) { return RET_BADPARM; }
 aaMemoryFill(cookie,sizeof(_cookie),0);
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 aaParserInit(&pa,str,chars);
 while(1)
  {
  aaParserSeekToVisibleChar(&pa,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  aaParserSeekToChar(&pa,'=',YES,YES);
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringCopyf(cookie->name,"%s",buf);
  //aaDebugf("[%s]",buf);
  if(pa.to_end<2) { break; }
  //---
  aaParserSeek(&pa,1);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  //aaDebugf("[%s]",buf);
  aaStringCopyf(cookie->value,"%s",buf);
  if(pa.to_end<2) { break; }
  //---
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=F32)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES)
     {
     aaNote(0,"a %s",&buf[pos+1]);
     }
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }
   }
  if(pa.to_end<2) { break; }
  //----
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=F32)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES) oof;
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }
   }
  if(pa.to_end<2) { break; }
  //----
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=F32)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES) oof;
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }
   }
  if(pa.to_end<2) { break; }
  //----
  aaParserSeek(&pa,2);
  aaParserSeekToVisibleChar(&pa,YES);
  aaParserStackPush(&pa);
  aaParserCopy(&pb,&pa,NO);
  if(aaParserSeekToString(&pa,"; ",YES,YES,PARSERFLAG_SAFE)!=YES)     {     if(aaParserSeek(&pa,pa.to_end)!=YES) oof;     }
  aaParserStackString(&pa,0,sizeof(buf),buf,YES);
  aaStringFindChar(buf,0,&pos,'=',YES,0,YES);
  if(pos!=F32)
   {
   if(aaStringNICompare(buf,"expires",pos,0)==YES)
    {
    aaStringCopyf(cookie->expires_text,"%s",&buf[pos+1]);
    if(aaTimeFromString(&cookie->expires,&buf[pos+1])!=YES) oof;
    }
   else
   if(aaStringNICompare(buf,"path",pos,0)==YES)     {    aaStringCopyf(cookie->path,"%s",&buf[pos+1]);    }
   else
   if(aaStringNICompare(buf,"domain",pos,0)==YES)   {    aaStringCopyf(cookie->domain,"%s",&buf[pos+1]);    }
   }
  else
   {
   if(aaStringICompare(buf,"HttpOnly",0)==YES) { cookie->is_http_only=YES; }
   else
   if(aaStringICompare(buf,"secure",0)==YES) { cookie->is_secure=YES; }

   //else {  aaNote(0,"%s",buf); }
   }
  if(pa.to_end<2) { break; }
  break;
  }
 if(cookie->expires_text[0])
  {
  aaTimeCompare(&cookie->expires,0,&cookie->expires_in);
  if(cookie->expires_in>0)
   {
   cookie->expires_in=aaNumNeg(cookie->expires_in);
   cookie->is_expired=YES;
   }
  else
   {
   cookie->expires_in=aaNumAbs(cookie->expires_in);
   cookie->is_expired=NO;
   }


  }
 return YES;
 }






 B aaNetAdrSet                         (_netadr*netadr,H ip,W port)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 netadr->ip=ip;
 netadr->port=port;
 return RET_YES;
 }




 B aaNetAdrSetFromString               (_netadr*netadr,VP ip,W port)
 {
 B ret;
 H val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 aaNetAdrSet(netadr,0,0);
 if((ret=aaNetIpFromString(ip,&val))!=RET_YES) { return ret; }
 return(aaNetAdrSet(netadr,val,port));
 }





 B aaNetAdrCopy                        (_netadr*netadr,_netadr*snetadr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(snetadr==NULL) { return RET_BADPARM; }
 return(aaNetAdrSet(netadr,snetadr->ip,snetadr->port));
 }




 B aaNetAdrToString                    (_netadr*netadr,VP string)
 {
 B txt[129];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 aaNetIpToString(netadr->ip,txt);
 return(aaStringCopyf(string,"%s:%u",txt,netadr->port));
 }



 B aaNetAdrFromString                  (_netadr*netadr,VP string)
 {
 B txt[129];
 H pos,val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 aaNetAdrSet(netadr,0,0);
 if(string==NULL) {  return RET_BADPARM;  }
 if(aaStringFindChar(string,0,&pos,':',YES,0,YES)!=YES)
  {
  return(aaNetIpFromString(string,&netadr->ip));
  }
 aaStringCopy(txt,string);
 txt[pos]=NULL_CHAR;
 aaNetIpFromString(txt,&netadr->ip);
 if(aaStringToNumber(&txt[pos+1],0,&val,0,0,0)!=YES) { return RET_FAILED; }
 if(val>65535) { return RET_FAILED; }
 netadr->port=(W)val;
 return RET_YES;
 }




 B aaNetAdrEqualsAdr                   (_netadr*netadr,_netadr*netadr2)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM;  }
 if(netadr2==NULL) { return RET_BADPARM;  }
 if(netadr->ip!=netadr2->ip) { return RET_NO; }
 if(netadr->port!=netadr2->port) { return RET_NO; }
 return RET_YES;
 }




 B aaNetAdrToHashGet                   (_netadr*netadr,BP hash)
 {
 H i;
 B b;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hash==NULL) { return RET_BADPARM; }
 *hash=b=0;
 if(netadr==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,hash);
 for(i=0;i<4;i++) { b^=bp[i]; }
 b^=bp[4];
 b^=bp[5];
 *hash=b;
 return RET_YES;
 }



 B aaNetAdrFromFtpAdr                  (_netadr*netadr,VP string)
 {
 _parser pa;
 H sl,cnt,val,num;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netadr==NULL) { return RET_BADPARM; }
 netadr->ip=0;
 netadr->port=0;
 if(string==NULL) { return RET_BADPARM; }
 aaStringLen(string,&sl);
 if(sl<11||sl>23) { return RET_BADPARM; }
 aaParserInit(&pa,string,sl);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaParserSeekToChar(&pa,',',YES,YES);   aaParserSeekToChar(&pa,',',NO,YES);
   aaStringNCopy(txt,&pa.bp[-pa.offset],pa.offset-1,YES);
   aaStringReplaceChar(txt,pa.offset-1,',','.');
   aaStringCountNumbers(pa.bp,pa.to_end,&cnt,YES);
   aaStringToNumber(pa.bp,cnt,&val,0,0,0);
   aaParserSeek(&pa,cnt);
   aaParserSeekToNumber(&pa,YES);
   aaStringCountNumbers(pa.bp,pa.to_end,&cnt,YES);
   aaStringToNumber(pa.bp,cnt,&num,0,0,0);
   val=(val*256)+num;
   aaNetIpFromString(txt,&netadr->ip);
   netadr->port=(W)val;
 return RET_YES;
 }






 B aaNetSubnetFromIp                   (_netsubnet*netsubnet,H ip,H mask)
 {
 H network_address;
 H bcast_ip;
 Z px=0;
 H mini,maxi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netsubnet==NULL) { return RET_BADPARM; }
 network_address=ip&mask;
 bcast_ip=~mask;
 bcast_ip=bcast_ip+network_address;
 mini=aaNumSwapDword(network_address)+1;
 mini=aaNumSwapDword(mini);
 maxi=aaNumSwapDword(bcast_ip)-1;
 maxi=aaNumSwapDword(maxi);
 while(mask) { px+=(mask&0x01); mask>>=1; }
 netsubnet->ip=ip;
 netsubnet->mask=mask;
 netsubnet->prefix=px;
 netsubnet->network_ip=network_address;
 netsubnet->broadcast_ip=bcast_ip;
 netsubnet->min_ip=mini;
 netsubnet->max_ip=maxi;
 return RET_YES;
 }




 B aaNetDnsCreate                      (HP handle,VP address,B mode,B bypass)
 {
 B ret;
 _aa_netdnsobject*narp;
 H bin;
 C ipa[4];
 B fwd;
 //H index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //aaNote(0,"%i",MAXGETHOSTSTRUCT);
 if(address==NULL) { return RET_BADPARM; }
  //BUG,"ZZ  %s",address);
 //if(bypass>3) { return RET_BADPARM; }
 bypass&=1;
 if(aaNetIpFromString(address,&bin)==RET_YES)  {  fwd=YES;  }
 else                                            {  fwd=NO;   }
 if(fwd==NO)
  {
  if(mode==0) { mode=aa_DNS_MODE_A; }
  if(mode!=aa_DNS_MODE_A&&mode!=aa_DNS_MODE_MX&&mode!=aa_DNS_MODE_NS&&mode!=aa_DNS_MODE_SOA&&mode!=aa_DNS_MODE_CNAME&&mode!=aa_DNS_MODE_TXT)
   {
   return RET_BADPARM;
   }
  }
 else
  {
  if(mode!=0) { return RET_BADPARM; }
  bypass=0;
  }
 if((ret=aa_ObjectCreate(aa.net_system.dns_object_id,handle,(VP)&narp))!=RET_YES) { oops;return ret; }
 narp->self_handle=*handle;
 aaMemoryFill(&narp->status,sizeof(_dnsstatus),0);
 aaStringCopy(narp->status.query,address);
 aaTimerTikGet(&narp->ms_tik);
 narp->status.mode=mode;
 narp->status.bypass=bypass;
 if(fwd==YES)
  {
  narp->status.is_forward=fwd;
  narp->status.is_inprogress=YES;
  narp->stage=20;
  (*(HP)&ipa)=bin;
  narp->resolver_handle=WSAAsyncGetHostByAddr(aa.net_system.window,aa.net_system.dns_message_id,ipa,4,AF_INET,(CP)narp->host_ent,MAXGETHOSTSTRUCT);
  if(narp->resolver_handle==NULL) { oof; }
  }
 else
  {
  narp->status.is_forward=fwd;
  narp->status.is_inprogress=YES;
  narp->timeout=300;
  narp->stage=100;
 /// BUG,"dnscreate %s",narp->status.query);
  //narp->resolver_handle=WSAAsyncGetHostByName(aa.net_system.window,aa.net_system.dns_message_id,address,(CP)narp->host_ent,MAXGETHOSTSTRUCT);//,AF_INET,(CP)narp->host_ent,MAXGETHOSTSTRUCT);
  //if(narp->resolver_handle==NULL) { oof; }
  }
 logg("name resolver Create ok");
 return RET_YES;
 }







 B aaNetDnsDestroy                     (H handle)
 {
 B ret;
 _aa_netdnsobject*narp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.dns_object_id,handle,(VP)&narp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(narp->resolver_handle!=NULL&&narp->status.is_inprogress)  {  WSACancelAsyncRequest(narp->resolver_handle); narp->resolver_handle=0; }
 if(narp->resolver_handle!=NULL) { WSACancelAsyncRequest(narp->resolver_handle);  narp->resolver_handle=0; }
 narp->resolver_handle=0;
 if(narp->udp.handle) { aaNetUdpDestroy(narp->udp.handle); narp->udp.handle=0; }
 aa_ObjectDestroy(aa.net_system.dns_object_id,handle);
 return RET_YES;
 }




 B aaNetDnsStatus                      (H handle,_dnsstatus*dnsstatus)
 {
 B ret;
 _aa_netdnsobject*narp;
 struct hostent *hp;
 N i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.dns_object_id,handle,(VP)&narp,NULL))!=RET_YES) { return ret; }
 aa_NetDnsYield((VP)&narp);

 if(narp->stage==3) /// complete
  {
  narp->status.is_inprogress=NO;
  aaCast(hp,struct hostent *,narp->host_ent);
  for(i=0;i<64; i++)
   {
   if(hp->h_addr_list[i]==NULL) break;
   narp->status.type[i]=0;
   narp->status.ip[i]=*(HP)&hp->h_addr_list[i];
   aaStringCopy(narp->status.host[i],hp->h_name);
   }
  narp->status.result_count=i;
  if(i==0)   {   narp->status.is_found=NO;   narp->status.is_notfound=NO;   narp->status.is_failed=YES;  }
  else         {   narp->status.is_found=YES;   narp->status.is_notfound=NO;   narp->status.is_failed=NO;   }
  narp->stage=4;
  }
 else
 if(narp->stage==1)  /// failed
  {
  narp->status.is_inprogress=NO;
  narp->status.is_found=NO;   narp->status.is_notfound=NO;   narp->status.is_failed=YES;
  }
 else
 if(narp->stage==2)  /// not found
  {
  narp->status.is_inprogress=NO;
  narp->status.is_found=NO;   narp->status.is_failed=NO;   narp->status.is_notfound=YES;
  }
 else
 if(narp->stage>=100&&narp->stage<=180)
  {
  //BUGGY;
  }
 if(dnsstatus) { aaMemoryCopy(dnsstatus,sizeof(_dnsstatus),&narp->status); }
 return RET_YES;
 }

///=====================================================






 B aaNetIcmpPktSet                     (_icmppkt*icmppkt,H remoteip,B type,B code,W id,W seq,W databytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 if(remoteip==0) { return RET_BADPARM; }
 if(databytes>65000) { return RET_BADPARM; }
 icmppkt->local_ip=0;
 icmppkt->remote_ip=remoteip;
 icmppkt->type=type;
 icmppkt->code=code;
 icmppkt->data_bytes=databytes;
 icmppkt->id=id;
 icmppkt->seq=seq;
 return RET_YES;
 }





 B aaNetIcmpPktCopy                    (_icmppkt*icmppkt,_icmppkt*sicmppkt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 if(sicmppkt==NULL) { return RET_BADPARM; }
 icmppkt->local_ip=sicmppkt->local_ip;
 icmppkt->remote_ip=sicmppkt->remote_ip;
 icmppkt->type=sicmppkt->type;
 icmppkt->code=sicmppkt->code;
 icmppkt->data_bytes=sicmppkt->data_bytes;
 icmppkt->seq=sicmppkt->seq;
 icmppkt->id=sicmppkt->id;
 return RET_YES;
 }







 B aaNetIcmpCreate                     (HP handle)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 SOCKET sock;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.net_system.icmp_object_id,handle,(VP)&icmpp))!=RET_YES) { oops;return ret; }
 if((ret=aaQueCreate(&icmpp->rcve_que))!=RET_YES)
  {
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 if((ret=aaQueCreate(&icmpp->xmit_que))!=RET_YES)
  {
  aaQueDestroy(icmpp->rcve_que);
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 icmpp->self_handle=*handle;
 sock=socket(AF_INET,SOCK_RAW,IPPROTO_ICMP);
 if(sock==(SOCKET)SOCKET_ERROR) // ningy added (SOCKET)
  {
  aaQueDestroy(icmpp->rcve_que);
  aaQueDestroy(icmpp->xmit_que);
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 icmpp->sock=sock;
 if(WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.icmp_message_id,FD_READ|FD_WRITE))
  {
  closesocket(sock);
  aaQueDestroy(icmpp->rcve_que);
  aaQueDestroy(icmpp->xmit_que);
  aa_ObjectDestroy(aa.net_system.icmp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 aaTimerTikGet(&icmpp->ms_root);
 icmpp->inactive_ms_root=icmpp->ms_root;
// icmpp->status.inactivity=0; // dec08
 return RET_YES;
 }






 B aaNetIcmpDestroy                    (H handle)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(closesocket(icmpp->sock)==SOCKET_ERROR) { aaNote(0,"icmpdest"); }
 aaQueDestroy(icmpp->rcve_que);
 aaQueDestroy(icmpp->xmit_que);
 aa_ObjectDestroy(aa.net_system.icmp_object_id,handle);
 return RET_YES;
 }




 B aaNetIcmpStatus                     (H handle,_icmpstatus*icmpstatus)
 {
 B ret;
 _aa_neticmpobject*icmpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,YES);
 if(icmpstatus) { aaMemoryCopy(icmpstatus,sizeof(_icmpstatus),&icmpp->status); }
 return RET_YES;
 }






 B aaNetIcmpPktWrite                   (H handle,_icmppkt*icmppkt,VP data)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 BP tmp=NULL_POINTR;
 _aa_neticmpheader*icmphdr;
 struct sockaddr_in addr;
 H by;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 if(icmppkt->data_bytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_MemoryTemp((VP)&tmp,_64K+_1K,aa_MEMORYTEMP_IcmpWritef))!=RET_YES) { return ret; }
 WinSockAddrSet(&addr,AF_INET,icmppkt->remote_ip,0);
 aaCast(icmphdr,_aa_neticmpheader*,tmp);
 icmphdr->type=icmppkt->type;
 icmphdr->code=icmppkt->code;
 icmphdr->crc=0;
 icmphdr->seq=icmppkt->seq;
 icmphdr->id=icmppkt->id;
 by=icmppkt->data_bytes;
 aaMemoryCopy(&tmp[sizeof(_aa_neticmpheader)],(H)by,data);
 aaNetRfcCrcGet(tmp,sizeof(_aa_neticmpheader)+by,&icmphdr->crc);
 if((ret=aaQueWrite(icmpp->xmit_que,sizeof(addr),&addr))!=RET_YES)  {  oops; return ret;  }
 if((ret=aaQueWrite(icmpp->xmit_que,4,&by))!=RET_YES)  { oops; return ret;  }
 if((ret=aaQueWrite(icmpp->xmit_que,sizeof(_aa_neticmpheader)+by,tmp))!=RET_YES)  { oops; return ret;  }
 icmpp->status.xmit_pkts_qued++;
 icmpp->status.total_bytes_sent+=(icmppkt->data_bytes+4);
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,YES);
 return RET_YES;
 }






 B aaNetIcmpPktRead                    (H handle,_icmppkt*icmppkt,H maxbytes,VP data)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 _aa_neticmpheader icmphdr;
 struct sockaddr_in addr;
 B tmp[128];
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(icmppkt,sizeof(_icmppkt),0);
 if(maxbytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
 if(icmpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
  if((ret=aaQuePeek(icmpp->rcve_que,0,sizeof(addr)+4+4+1,tmp))!=RET_YES) { return ret; }
 aaMemoryCopy(&addr,sizeof(addr),tmp);
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 icmppkt->remote_ip=(*(HP)&addr.sin_addr);
 icmppkt->data_bytes=(W)(len);
 icmppkt->local_ip=(*(HP)&tmp[sizeof(addr)+4]);
 if(icmppkt->data_bytes>maxbytes) { return RET_BOUNDS; }
 if((ret=aaQueDiscard(icmpp->rcve_que,sizeof(addr)+4+4))!=RET_YES) { return ret; }
 if((ret=aaQueRead(icmpp->rcve_que,sizeof(_aa_neticmpheader),&icmphdr))!=RET_YES) { return ret; }
 if(icmppkt->data_bytes)
  {
  if((ret=aaQueRead(icmpp->rcve_que,icmppkt->data_bytes,data))!=RET_YES) { return ret; }
  }
 icmppkt->type=icmphdr.type;
 icmppkt->code=icmphdr.code;
 icmppkt->seq=icmphdr.seq;
 icmppkt->id=icmphdr.id;
 icmpp->status.total_pkts_received++;
 icmpp->status.rcve_pkts_qued--;
 icmpp->status.total_bytes_received+=(icmppkt->data_bytes+4);
 return RET_YES;
 }







 B aaNetIcmpPktPeek                    (H handle,_icmppkt*icmppkt,H maxbytes,VP data)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 _aa_neticmpheader icmphdr;
 struct sockaddr_in addr;
 B tmp[128];
 H len,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(icmppkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(icmppkt,sizeof(_icmppkt),0);
 if(maxbytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
 if(icmpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
  if((ret=aaQuePeek(icmpp->rcve_que,0,sizeof(addr)+4+4,tmp))!=RET_YES) { return ret; }
 aaMemoryCopy(&addr,sizeof(addr),tmp);
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 icmppkt->remote_ip=(*(HP)&addr.sin_addr);
 icmppkt->data_bytes=(W)(len);
 icmppkt->local_ip=(*(HP)&tmp[sizeof(addr)+4]);
 if(icmppkt->data_bytes>maxbytes) { return RET_BOUNDS; }
 off=sizeof(addr)+4+4;
 if((ret=aaQuePeek(icmpp->rcve_que,off,sizeof(_aa_neticmpheader),&icmphdr))!=RET_YES) { return ret; }
 off+=sizeof(_aa_neticmpheader);
 if(icmppkt->data_bytes)
  {
  if((ret=aaQuePeek(icmpp->rcve_que,off,icmppkt->data_bytes,data))!=RET_YES) { return ret; }
  }
 icmppkt->type=icmphdr.type;
 icmppkt->code=icmphdr.code;
 icmppkt->seq=icmphdr.seq;
 icmppkt->id=icmphdr.id;
 return RET_YES;
 }






 B aaNetIcmpPktDiscard                 (H handle)
 {
 B ret;
 _aa_neticmpobject*icmpp;
 struct sockaddr_in addr;
 B tmp[128];
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.icmp_object_id,handle,(VP)&icmpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessIcmp((VP)&icmpp,YES,NO);
 if(icmpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if((ret=aaQuePeek(icmpp->rcve_que,0,sizeof(addr)+4+4+1,tmp))!=RET_YES) { return ret; }
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 if((ret=aaQueDiscard(icmpp->rcve_que,len+sizeof(_aa_neticmpheader)+sizeof(addr)+4+4+1))!=RET_YES) { return ret; }

 icmpp->status.total_pkts_received++;
 icmpp->status.total_bytes_received+=(len+4);

 icmpp->status.rcve_pkts_qued--;
 if(addr.sin_family!=addr.sin_family) {} // shut warning up about addr not used
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/


// DECLSPEC_IMPORT Z WINAPI WSAIoctl     (SOCKET,DWORD,LPVOID,DWORD,LPVOID,DWORD,LPDWORD,struct _OVERLAPPED*,V (*routine)(DWORD,DWORD,struct _OVERLAPPED*,DWORD));

 B aaNetSniffCreate                  (HP handle,H ip)
 {
 B ret;
 struct sockaddr_in sniff_addr;
 _aa_netsniffobject*snifp;
 SOCKET sock;
 int optval;
 H dwlen,i;
 _localip lip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ip==0)
  {
  if(handle) { *handle=0; }
  aaNetLocalIpGet(&lip,NO,NO);
  for(i=0;i<32;i++) {   if(lip.type[i]=='P') break;   }
  if(i==32)
   {
   for(i=0;i<32;i++) {  if(lip.type[i]=='I') break; }
   }
  if(i!=32) { ip=lip.ip[i]; }
  if(ip==0) { return RET_FAILED; }
  }
 if((ret=aa_ObjectCreate(aa.net_system.sniff_object_id,handle,(VP)&snifp))!=RET_YES) { oops;return ret; }
 if((ret=aaQueCreate(&snifp->rcve_que))!=RET_YES)
  {
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 snifp->self_handle=*handle;
 sock=socket(AF_INET,SOCK_RAW,IPPROTO_IP);
 //sock=socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
 if(sock==(SOCKET)SOCKET_ERROR)
  {
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 snifp->sock=sock;
 WinSockAddrSet(&sniff_addr,AF_INET,ip,0);
 if(bind(snifp->sock,(struct sockaddr*)&sniff_addr,sizeof(sniff_addr))==SOCKET_ERROR)
  {
  oof;
//  oow;
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }

 optval=3; dwlen=4;
 if(WSAIoctl(snifp->sock,/*SIO_RCVALL*/(IOC_IN|(0x18000000)|(1)),&optval,sizeof(optval),NULL,0,&dwlen,NULL,NULL)==SOCKET_ERROR)
  {
  oof;
  oow;
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  oof;
  return RET_FAILED;
  }


 if(WSAAsyncSelect(snifp->sock,aa.net_system.window,aa.net_system.sniff_message_id,FD_READ|FD_ACCEPT|FD_CLOSE|FD_CONNECT))
  {
  closesocket(snifp->sock);
  aaQueDestroy(snifp->rcve_que);
  aa_ObjectDestroy(aa.net_system.sniff_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 optval=_2MEG; dwlen=4;
 if(setsockopt(snifp->sock,SOL_SOCKET,SO_RCVBUF,(CP)&optval,dwlen)!=0) oof;
 aaTimerTikGet(&snifp->ms_root);
 snifp->inactive_ms_root=snifp->ms_root;
 return RET_YES;
 }





 B aaNetSniffDestroy                 (H handle)
 {
 B ret;
 _aa_netsniffobject*snifp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(closesocket(snifp->sock)==SOCKET_ERROR) { aaNote(0,"sniffdest"); }
 aaQueDestroy(snifp->rcve_que);
 aa_ObjectDestroy(aa.net_system.sniff_object_id,handle);
 return RET_YES;
 }



 B aaNetSniffStatus                  (H handle,_sniffstatus*sniffstatus)
 {
 B ret;
 _aa_netsniffobject*snifp;
 H go,prq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 prq=snifp->status.rcve_pkts_qued;
 for(go=0;go<256;go++)
  {
  aa_NetSystemProcessSniff((VP)&snifp);
  if(snifp->status.rcve_pkts_qued==prq) break;
  prq=snifp->status.rcve_pkts_qued;
  }
// if(go>5) appLog(2,"b.. %i %i %i",go,prq,snifp->status.rcve_pkts_qued);
 //aa_NetSystemProcessSniff((VP)&snifp);
 if(sniffstatus) { aaMemoryCopy(sniffstatus,sizeof(_sniffstatus),&snifp->status); }
 return RET_YES;
 }



 B aaNetSniffPktRead                   (H handle,_sniffpkt*sniffpkt)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8];
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sniffpkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(sniffpkt,(sizeof(_sniffpkt)-sizeof(sniffpkt->data)),0);
 //if(maxbytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 aaNetSniffStatus(handle,NULL);
 //aa_NetSystemProcessSniff((VP)&snifp);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(snifp->rcve_que,&qs);
 if((ret=aaQuePeek(snifp->rcve_que,0,8,&ts))!=YES) { oops; return ret; }
 sniffpkt->time_stamp=ts;
 if((ret=aaQuePeek(snifp->rcve_que,8+0,8,lens))!=YES) { oops; return ret; }
 sniffpkt->total_length=lens[0];
 sniffpkt->header_ip_length=lens[1];

 if((ret=aaQuePeek(snifp->rcve_que,8+8,lens[1],&sniffpkt->header_ip))!=YES) { oops; return ret; }
 if(sniffpkt->header_ip.protocol==6)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_tcp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4,lens[2],&sniffpkt->header_tcp))!=YES) { oops; return ret; }
  }
 else
 if(sniffpkt->header_ip.protocol==17)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_udp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4,lens[2],&sniffpkt->header_udp))!=YES) { oops; return ret; }
  }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 sniffpkt->data_length=lens[3];
//  appLog(2,"lens[]={%i,%i,%i,%i}",lens[0],lens[1],lens[2],lens[3]);
 if(sniffpkt->data_length!=0)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2]+4,lens[3],sniffpkt->data))!=YES) { oops; return ret; }
  }
 return(aaNetSniffPktDiscard(handle));
 return RET_YES;
 }




 B aaNetSniffPktPeek                   (H handle,H index,_sniffpkt*sniffpkt,B dataflag)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8],i,po;
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sniffpkt==NULL) { return RET_BADPARM; }
 aaMemoryFill(sniffpkt,(sizeof(_sniffpkt)-sizeof(sniffpkt->data)),0);
 //if(maxbytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 //aa_NetSystemProcessSniff((VP)&snifp);
 aaNetSniffStatus(handle,NULL);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(index>=snifp->status.rcve_pkts_qued) { return RET_BOUNDS; }
 aaQueStatus(snifp->rcve_que,&qs);

 po=0;
 for(i=0;i<index;i++)
  {
  if((ret=aaQuePeek(snifp->rcve_que,po+0,8,&ts))!=YES) { oops; return ret; }
  if((ret=aaQuePeek(snifp->rcve_que,8+po+0,8,lens))!=YES) { oops; return ret; }
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
  po+=8+4+4+lens[1]+4+lens[2]+4+lens[3];
  }

 if((ret=aaQuePeek(snifp->rcve_que,po,8,&ts))!=YES)
  {
  //appLog(2,"index=%i po=%i wsb=%i rpq=%i",index,po,qs.bytes,snifp->status.rcve_pkts_qued);
  oops; return ret;
  }
 if((ret=aaQuePeek(snifp->rcve_que,8+po+0,8,lens))!=YES)
  {
  //appLog(2,"index=%i po=%i wsb=%i rpq=%i",index,po,qs.bytes,snifp->status.rcve_pkts_qued);
  oops; return ret;
  }
  sniffpkt->time_stamp=ts;
 sniffpkt->total_length=lens[0];
 sniffpkt->header_ip_length=lens[1];

 if((ret=aaQuePeek(snifp->rcve_que,8+po+8,lens[1],&sniffpkt->header_ip))!=YES) { oops; return ret; }
 if(sniffpkt->header_ip.protocol==6)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_tcp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4,lens[2],&sniffpkt->header_tcp))!=YES) { oops; return ret; }
  }
 else
 if(sniffpkt->header_ip.protocol==17)
  {
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
  sniffpkt->header_udp_length=lens[2];
  if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4,lens[2],&sniffpkt->header_udp))!=YES) { oops; return ret; }
  }
 if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 sniffpkt->data_length=lens[3];
 if(sniffpkt->data_length!=0)
  {
  if(dataflag)
   {
   if((ret=aaQuePeek(snifp->rcve_que,8+po+8+lens[1]+4+lens[2]+4,lens[3],sniffpkt->data))!=YES) { oops; return ret; }
   }
  }
 return RET_YES;
 }



 B aaNetSniffPktDiscard                (H handle)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8];
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 aaNetSniffStatus(handle,NULL);
 //aa_NetSystemProcessSniff((VP)&snifp);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(snifp->rcve_que,&qs);
 if((ret=aaQuePeek(snifp->rcve_que,0,8,&ts))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+0,8,lens))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 aaQueDiscard(snifp->rcve_que,8+4+4+lens[1]+4+lens[2]+4+lens[3]);//lens[0]+4+4+4);
 snifp->status.rcve_pkts_qued--;
 snifp->status.total_pkts_received++;
 snifp->status.total_bytes_received+=lens[0];
 return RET_YES;
 }




 B aaNetSniffPktReturn                 (H handle)
 {
 B ret;
 _aa_netsniffobject*snifp;
 _questatus qs;
 H lens[8];
 BP tmp=NULL_POINTR;
 Q ts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.sniff_object_id,handle,(VP)&snifp,NULL))!=RET_YES) { return ret; }
 //aa_NetSystemProcessSniff((VP)&snifp);
 aaNetSniffStatus(handle,NULL);
 if(snifp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(snifp->status.rcve_pkts_qued==1) { return RET_YES; }
 aaQueStatus(snifp->rcve_que,&qs);
 if((ret=aaQuePeek(snifp->rcve_que,0,8,&ts))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+0,8,lens))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1],4,&lens[2]))!=YES) { oops; return ret; }
 if((ret=aaQuePeek(snifp->rcve_que,8+8+lens[1]+4+lens[2],4,&lens[3]))!=YES) { oops; return ret; }
 if((ret=aa_MemoryTemp((VP)&tmp,_64K+_1K,aa_MEMORYTEMP_SniffPktRet))!=RET_YES) { return ret; }
 if((ret=aaQueRead(snifp->rcve_que,8+4+4+lens[1]+4+lens[2]+4+lens[3],tmp))!=YES) { oops; }
 if((ret=aaQueWrite(snifp->rcve_que,8+4+4+lens[1]+4+lens[2]+4+lens[3],tmp))!=YES) { oops; }
 aaQueStatus(snifp->rcve_que,&qs);
 //aa_NetSystemProcessSniff((VP)&snifp);
 aaNetSniffStatus(handle,NULL);
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/


 B aaNetServerCreate                   (HP handle,H ip,W port,H maxcalls,H extra)
 {
 B ret;
 H han;
 _aa_netserverobject*srvop;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0) { return RET_BADPARM; }
 if(maxcalls==0) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.net_system.server_object_id,handle,(VP)&srvop))!=RET_YES)
  {
  oops;
  aaNote(0,"net_system.server_object_id=%i",aa.net_system.server_object_id);
  aaNote(0,"%i",aa.net_system.dns_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.sniff_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.icmp_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.udp_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.stunclient_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.tcpport_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.tcpcall_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.client_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.cgiclient_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.server_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.wock_object_id);
 //H yield_tcpport_counter;

  return ret;
  }
 srvop->self_handle=*handle;
 srvop->status.max_calls=maxcalls;
 srvop->status.extra_bytes=extra;
 //aa_last_line_executed=__LINE__;
 if((ret=aaNetTcpPortCreate(&han,ip,port,extra+32))!=YES)
  {
  aa_ObjectDestroy(aa.net_system.server_object_id,*handle);
  *handle=0;
  return ret;
  }
 srvop->status.port.handle=han;
 srvop->status.is_calls_allowed=YES;
// aaTimerTikGet(&srvop->ms_root);
 aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status);
 return RET_YES;
 }





 B aaNetServerDestroy                  (H handle)
 {
 B ret;
 B isprot;
 _aa_netserverobject*srvop;
 _tcpcallunit cu;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 while(1)
  {
  if(srvop->status.port.handle==0) { break; }
  if((ret=aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status))!=YES) { oops; }
  if(srvop->status.port.status.calls_waiting==0&&srvop->status.port.status.calls_answered==0) { break; }
  if((ret=aaNetTcpPortCallNext(srvop->status.port.handle,&cu.handle,&cu.status,0))!=YES)  { oops; continue; }
  if((ret=aaNetTcpCallDestroy(cu.handle))!=YES)  { oops; continue; }
  }
 if(srvop->status.port.handle!=0) {   aaNetTcpPortDestroy(srvop->status.port.handle); }
 aa_ObjectDestroy(aa.net_system.server_object_id,handle);
 return RET_YES;
 }




 B aaNetServerStatus                   (H handle,_serverstatus*serverstatus,_tcpcallunit*tcpcallunit)
 {
 B ret;
 B isprot;
 _aa_netserverobject*srvop;
 _tcpcallunit cu;
 //_timer*tmu;
 BP xtra;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 if(tcpcallunit) tcpcallunit->handle=0;

 cu.handle=0;
 if((ret=aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status))!=YES) { oops;  }
 while(1)
   {
   if(srvop->status.port.status.calls_answered==0&&srvop->status.port.status.calls_waiting==0)  { break; }
   if((ret=aaNetTcpPortCallNext(srvop->status.port.handle,&cu.handle,&cu.status,0))!=YES) { oops; break; }
   if(cu.status.local_adr.port!=srvop->status.port.status.local_adr.port)  { oof; break; }
   if(cu.status.is_incoming==NO||cu.handle==0) { oof; break; }
   if(cu.status.is_connected!=YES)
    {
    if((srvop->status.port.status.calls_answered>=srvop->status.max_calls)||srvop->status.is_calls_allowed==NO)
     {
     if(aaNetTcpCallDestroy(cu.handle)!=YES) { oof; }
     cu.handle=0;
     if(aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status)!=YES) { oof; }
     break;
     }
    if(aaNetTcpCallAnswer(cu.handle)!=YES) { oof; }
    aaNetTcpCallSlicerLengthSet(cu.handle,_8K,_8K);
    aaNetTcpCallBufferLengthSet(cu.handle,_32K,_32K);
    if(aaNetTcpCallStatus(cu.handle,&cu.status)!=YES) { oof; }
    if(aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status)!=YES) { oof; }
    break;
    }

   xtra=cu.status.extra_data;
   xtra+=(cu.status.extra_bytes-32);
   //tmu=(_timer*)&xtra[4];

   #if 0
   if(cu.status.is_closed_by_local)//close_request!=0)
    {
    aaTimerUpdate(tmu,1);//(_timer*)&xtra[4],1);
    //if(aaNetTcpCallClose(cu.handle)!=YES) { oof; }
    //aaNetTcpCallStatus(cu.handle,&cu.status);
    if((tmu->elapsed>=*(HP)&xtra[0])||(cu.status.is_closed_by_remote&&tmu->elapsed>=(*(HP)&xtra[0])/2))//((_timer*)&xtra[4])->elapsed>=*(HP)&xtra[0])//cu.status.local_closed_ms>aaSecs(3))
     {
     if(aaNetTcpCallDestroy(cu.handle)!=YES) { oof; }
     if(aaNetTcpPortStatus(srvop->status.port.handle,&srvop->status.port.status)!=YES) { oof; }
//     aaLog(-777,"clc so des");
     }
    //BUGGY;
    cu.handle=0;
    }
   #endif
   break;
   }

 #if 0
 if(cu.handle==0)
  {
  aaTimerTikElapsed(srvop->ms_root,&srvop->status.inactivity_ms);
  }
 else
  {
  aaTimerTikGet(&srvop->ms_root);
  srvop->status.inactivity_ms=0;
  }
 #endif
 //if(call) { call->handle=cu.handle; aaMemoryCopy(&call->status,sizeof(_tcpcallstatus),&cu.status); }
// if(cu.handle!=0&&extraptr) { *extraptr=cu.status.extra_data; }
 ///aaTimerTikGet(&srvop->ms_root);
 //if(cu.handle!=0)  {   srvop->status.is_call=YES; }
 if(serverstatus) { aaMemoryCopy(serverstatus,sizeof(_serverstatus),&srvop->status); }
 //if(cu.handle==0)  {   return RET_NOTREADY;   }
 if(tcpcallunit&&cu.handle!=0)
  {
  tcpcallunit->handle=cu.handle;
  aaMemoryCopy(&tcpcallunit->status,sizeof(_tcpcallstatus),&cu.status);
  }

 ///rscd=(_rtmpproxyservercalldata*)cu.status.extra_data;
 //rscd->magic=0x29219291;
// rtmpProxyServerCallProcess(rtmpproxyserver);
 return RET_YES;
 }




 B aaNetServerCallsAllow               (H handle,B state)
 {
 B ret;
 B isprot;
 _aa_netserverobject*srvop;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 if(state==YES) { srvop->status.is_calls_allowed=YES; }
 else           { srvop->status.is_calls_allowed=NO; }
 return RET_YES;
 }




#if 0
 B aaNetServerCallClose                (H handle,_tcpcallunit*tcpcallunit,H ms)
 {
 B ret;
 B isprot;
 _aa_netserverobject*srvop;
 BP xtra;
 _timer*tmu;
 //_tcpcallunit cu;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.server_object_id,handle,(VP)&srvop,&isprot))!=RET_YES) { return ret; }
 //if(call) { call->handle=0; }
 //if(extraptr) { *extraptr=NULL; }
 if(tcpcallunit==NULL) { return RET_BADPARM; }
 if(tcpcallunit->handle==0) { return RET_BADHANDLE; }
 if((ret=aaNetTcpCallStatus(tcpcallunit->handle,&tcpcallunit->status))!=YES) { oops; }
 xtra=tcpcallunit->status.extra_data;
 xtra+=(tcpcallunit->status.extra_bytes-32);
 if(ms==0) { oof; return RET_BADPARM; }
 if(*(HP)&xtra[0]!=0) { return RET_YES; }
 if(tcpcallunit->status.is_closed_by_local) { return RET_YES; } //cu.status.is_closed_by_local)//close_request!=0)
 tmu=(_timer*)&xtra[4];
 aaTimerInit(tmu,1);
 *(HP)&xtra[0]=ms;
 aaNetTcpCallClose(tcpcallunit->handle);
 aaNetTcpCallStatus(tcpcallunit->handle,&tcpcallunit->status);
 return RET_YES;
 }


#endif




#if 0
 B aaNetServerFlush                    (H handle,_tcpcallunit*tcpcallunit)
 {
 B ret;
 _serverstatus ss;
 _tcpcallunit call;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tcpcallunit==NULL) { return RET_BADPARM; }
 tcpcallunit->handle=0;
 while(1)
  {
  aaYieldRaw();
  if((ret=aaNetServerStatus(handle,&ss,&call))!=RET_YES) {  break; }

  if(ss.port.status.calls_inuse==0&&ss.port.status.calls_answered==0&&ss.port.status.calls_waiting==0) { ret=RET_FINISHED; break; }
  //if(ss.port.status.calls_inuse==0) { ret=RET_FINISHED; break; }

  if(call.handle==0) { continue; }
  if(call.status.is_connected!=YES) { aaNetServerCallClose(handle,&call,1); continue; }
  if(call.status.is_closed_by_local==YES) { aaNetServerCallClose(handle,&call,1); continue; }
  aaMemoryCopy(tcpcallunit,sizeof(_tcpcallunit),&call);
  return RET_YES;
  }
 return ret;
 }

#endif


/*-----------------------------------------------------------------------*/



 B aaNetWockCreate                     (HP handle,H tcpcallhandle,B inbound,VP fmt,...)
 {
 B ret;
 _aa_netwockobject*wockp;
 _aa_nettcpcallobject*calp;
 va_list argptr;
 B str[_16K];
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 aaFmt(fmt,argptr,str);
 if(inbound) {}
 else
  {
  if(aaStringIsNull(str)!=NO) { return RET_FAILED;  }
  }
 if((ret=aa_ObjectCreate(aa.net_system.wock_object_id,handle,(VP)&wockp))!=RET_YES) { oops;return ret; }
 wockp->self_handle=*handle;
 if(aaStringIsNull(str)==NO)
  {
  aaStringCopyf(wockp->status.url,"%s",str);
  aaStringReplaceChar(wockp->status.url,0,32,'+'); // how do i handle '+' signss ???
  if((ret=aaNetUrlPartsGet(&wockp->status.up,wockp->status.url,YES,YES))!=YES) { oops; }
  }
 wockp->status.stage=0;
 wockp->status.call_handle=tcpcallhandle;
 aaNetTcpCallStatus(wockp->status.call_handle,&wockp->status.call_status);
 wockp->status.close_frame_received=0;
 wockp->status.close_frame_sent=0;
 wockp->status.rcve_pkts=0;
 wockp->status.rcve_pkts_total=0;
 wockp->status.xmit_pkts=0;
 wockp->status.xmit_pkts_total=0;

 aaQueCreate(&wockp->xmit_que.handle);
 aaQueStatus(wockp->xmit_que.handle,&wockp->xmit_que.status);
 aaQueCreate(&wockp->rcve_que.handle);
 aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);

 wockp->status.stage=WOCK_STAGE_HANDSHAKE;
 if(inbound) { wockp->status.is_inbound=YES; }
 else        { wockp->status.is_inbound=NO; }


 aaTimerTikGet(&wockp->ms_root);
 return RET_YES;
 }





 B aaNetWockDestroy                    (H handle)
 {
 B ret;
 B isprot;
 _aa_netwockobject*wockp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if((ret=aaNetWockStatus(handle,0))!=YES) { oops; }
 if(wockp->status.call_status.adoption_handle)
  {
  aaNetTcpCallAdopt(wockp->status.call_handle,0);
  }
 if(wockp->xmit_que.handle!=0) { aaQueDestroy(wockp->xmit_que.handle); wockp->xmit_que.handle=0; }
 if(wockp->rcve_que.handle!=0) { aaQueDestroy(wockp->rcve_que.handle); wockp->rcve_que.handle=0; }
 aa_ObjectDestroy(aa.net_system.wock_object_id,handle);
 return RET_YES;
 }






 B aaNetWockStatus                     (H handle,_wockstatus*wockstatus)
 {
 B ret;
 _aa_netwockobject*wockp;
 _httpresult res;
 _httprequest req;
 _httpheader hed;
 B buf[_16K];
 B str[_4K];
 B txt[_2K];
 B etc[_1K];
 H sl,i,j,todo,len;
 Q qlen;
 _digestunit dig;
 B asca,ascb;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallStatus(wockp->status.call_handle,&wockp->status.call_status))!=YES) { oops; }
 aaTimerTikElapsed(wockp->ms_root,&wockp->status.ms);
 switch(wockp->status.stage)
  {
  case WOCK_STAGE_HANDSHAKE:
  case WOCK_STAGE_OPEN:
  if(wockp->status.call_status.is_connected!=YES)
   {
   break;
   }
  if(wockp->status.is_inbound==YES)
   {
   if((aa_msrunning-wockp->msr)>=100)  { wockp->msr=aa_msrunning;   }
   if(wockp->phaze>=50)
    {
    todo=wockp->xmit_bytes-wockp->xmit_done;
    if(todo==0)
     {
     if(wockp->status.xmit_pkts>0)
      {
      if(aaQueRead(wockp->xmit_que.handle,4,&todo)!=YES)  {   aaNote(0,"%i=%i",wockp->status.xmit_pkts,wockp->xmit_que.status.bytes);      }
      aaQueStatus(wockp->xmit_que.handle,&wockp->xmit_que.status);
      wockp->xmit_bytes=todo;
      wockp->xmit_done=0;
      todo=wockp->xmit_bytes-wockp->xmit_done;
      if(todo==0) oof;
      }
     }
    if(todo>0)
     {
     if(wockp->status.xmit_pkts==0) oof;
     todo=aaNumRoof(todo,_8K);
     if(aaQueRead(wockp->xmit_que.handle,todo,buf)!=YES) oof;
     aaQueStatus(wockp->xmit_que.handle,&wockp->xmit_que.status);
     aaNetTcpCallWrite(wockp->status.call_handle,todo,buf);
     aaNetTcpCallStatus(wockp->status.call_handle,&wockp->status.call_status);
     wockp->xmit_done+=todo;
     todo=wockp->xmit_bytes-wockp->xmit_done;
     if(todo==0) { wockp->status.xmit_pkts--;  wockp->xmit_bytes=wockp->xmit_done=0;  }
     }
    }
   switch(wockp->phaze)
    {
    case 0:
    wockp->phaze=10;
    break;


    case 10:
    if(aaNetHttpRequestRead(wockp->status.call_handle,&req)!=YES) break;
    aaStringCopyf(wockp->status.url,"%s",req.url);
    wockp->phaze=20;
    break;


    case 20:
    if(aaNetHttpHeaderRead(wockp->status.call_handle,&hed)!=YES) break;
    if(hed.field_code==aa_HTTPFIELD_HOST)
     {
     aaStringInsertStringf(wockp->status.url,0,0,YES,"%s",hed.data);
     aaStringInsertStringf(wockp->status.url,0,0,YES,"ws://");
     aaStringReplaceChar(wockp->status.url,0,32,'+'); // how do i handle '+' signss ???
     if((ret=aaNetUrlPartsGet(&wockp->status.up,wockp->status.url,YES,YES))!=YES) { oops; }

     }

    if(aaStringICompare(hed.field,"sec-websocket-key",0)==YES)
     {
     aaStringCopyf(wockp->sec_key,"%s",hed.data);
     aaStringCopyf(txt,"%s258EAFA5-E914-47DA-95CA-C5AB0DC85B11",hed.data);
     if(aaDigestCreate(&dig.handle,aa_DIGESTTYPE_Sha1)!=YES) oof;
     if(aaDigestWrite(dig.handle,0,txt,YES,0,str)!=YES) oof;
     aaDigestDestroy(dig.handle);
     aaStringLen(str,&sl);
     for(i=0;i<sl;i+=2)
      {
      asca=str[i+0]; if(asca>='A'&&asca<='F') asca+=32;
      ascb=str[i+1]; if(ascb>='A'&&ascb<='F') ascb+=32;
      if(asca>='0'&&asca<='9') { asca=asca-'0'; }  else  { asca=(asca-'a')+10;  }
      if(ascb>='0'&&ascb<='9') { ascb=ascb-'0'; }  else  { ascb=(ascb-'a')+10;  }
      etc[i/2]=(asca*16)+ascb;
      }
     if(aaBase64Encode(etc,sl/2,str,&sl)!=YES) oof;
     aaStringCopyf(wockp->out_key,"%s",str);
     }
    if(hed.field_code!=aa_HTTPFIELD_BLANK) break;
    wockp->phaze=40;
    break;

    case 40:
    aaStringCopyf(buf,"HTTP/1.1 101 WebSocket Protocol Handshake\r\n");
    aaStringAppendf(buf,"Upgrade: WebSocket\r\n");
    aaStringAppendf(buf,"Connection: Upgrade\r\n");
    aaStringAppendf(buf,"Sec-WebSocket-Accept: %s\r\n",wockp->out_key);
    aaNetTcpCallWritef(wockp->status.call_handle,"%s\r\n",buf);
    wockp->phaze=45;
    break;

    case 45:
    wockp->status.stage=WOCK_STAGE_OPEN;
    wockp->phaze=50;
    break;

    case 50:
    todo=wockp->status.call_status.rcve_bytes;
    todo=aaNumRoof(todo,16);
    if(todo<2) break;
    if(aaNetTcpCallPeek(wockp->status.call_handle,0,todo,buf)!=YES) oof;
    wockp->pkt_done=0;
    wockp->pkt_bytes=0;
    wockp->data_bytes=0;
    wockp->data_offset=0;
    wockp->size_bytes=0;
    wockp->mask_offset=0;
    wockp->is_fin=aaBitGet(buf[0],7);
    wockp->is_mask=aaBitGet(buf[1],7);
    if(wockp->is_fin!=1) oof;
    //BUG,"opcode=%x",buf[0]);
    wockp->opcode=buf[0]&0x0f;
    len=buf[1]&~128;
    if(len<=125)
     {
     wockp->pkt_bytes=2;
     wockp->size_bytes=0;
     if(wockp->is_mask) { wockp->mask_offset=wockp->pkt_bytes+wockp->size_bytes;  wockp->pkt_bytes+=4; }
     wockp->data_offset=wockp->pkt_bytes+wockp->size_bytes;
     wockp->data_bytes=len;
     wockp->pkt_bytes+=wockp->data_bytes;
     if(todo<wockp->data_offset) break;
     if(wockp->is_mask) {  wockp->mask=*(HP)&buf[wockp->mask_offset]; }
     wockp->pkt_done=wockp->data_offset;
     aaNetTcpCallDiscard(wockp->status.call_handle,wockp->pkt_done);
     aaQueWrite(wockp->rcve_que.handle,1,&buf[0]);
     aaQueWrite(wockp->rcve_que.handle,4,&wockp->data_bytes);
     aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
     wockp->phaze=100;
     break;
     }
    if(len==126)
     {
     wockp->pkt_bytes=2;
     wockp->size_bytes=2;
     wockp->pkt_bytes+=wockp->size_bytes;
     if(wockp->is_mask) { wockp->mask_offset=wockp->pkt_bytes;  wockp->pkt_bytes+=4; }
     wockp->data_offset=wockp->pkt_bytes;
     len=*(WP)&buf[2];
     len=aaNumSwapWord(len);
     wockp->data_bytes=len;
     wockp->pkt_bytes+=wockp->data_bytes;
     if(todo<wockp->data_offset) break;
     if(wockp->is_mask) {  wockp->mask=*(HP)&buf[wockp->mask_offset]; }
     wockp->pkt_done=wockp->data_offset;
     aaNetTcpCallDiscard(wockp->status.call_handle,wockp->pkt_done);
     aaQueWrite(wockp->rcve_que.handle,1,&buf[0]);
     aaQueWrite(wockp->rcve_que.handle,4,&wockp->data_bytes);
     aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
     wockp->phaze=100;
     break;
     }
    if(len==127)
     {
     wockp->pkt_bytes=2;
     wockp->size_bytes=8;
     wockp->pkt_bytes+=wockp->size_bytes;
     if(wockp->is_mask) { wockp->mask_offset=wockp->pkt_bytes;  wockp->pkt_bytes+=4; }
     wockp->data_offset=wockp->pkt_bytes;
     bp=(BP)&buf[2];
     qlen=*(QP)&bp[0];;    qlen=aaNumSwapQuad(qlen);    *(QP)&bp[0]=qlen;
     len=*(HP)&bp[0];       len=aaNumSwapDword(len);    *(HP)&bp[0]=len;
     len=*(HP)&bp[4];       len=aaNumSwapDword(len);    *(HP)&bp[4]=len;
     qlen=*(QP)&bp[0];
     wockp->data_bytes=qlen;
     wockp->pkt_bytes+=wockp->data_bytes;
     if(todo<wockp->data_offset) break;
     if(wockp->is_mask) {  wockp->mask=*(HP)&buf[wockp->mask_offset]; }
     wockp->pkt_done=wockp->data_offset;
     aaNetTcpCallDiscard(wockp->status.call_handle,wockp->pkt_done);
     aaQueWrite(wockp->rcve_que.handle,1,&buf[0]);
     aaQueWrite(wockp->rcve_que.handle,4,&wockp->data_bytes);
     aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
     wockp->phaze=100;
     break;
     }
    aaNote(0,"is_fin=%i is_mask=%i oc=%i pl=%u",wockp->is_fin,wockp->is_mask,wockp->opcode,wockp->data_bytes);
    break;


    case 100:
    todo=wockp->pkt_bytes-wockp->pkt_done;
    //if(todo==0) oof;
    if(todo!=0)
     {
     todo=aaNumRoof(todo,wockp->status.call_status.rcve_bytes);
     todo=aaNumRoof(todo,_4K);
     if(todo==0) break;
     if((ret=aaNetTcpCallRead(wockp->status.call_handle,todo,buf))!=YES) oops;
     }
    aaNetTcpCallStatus(wockp->status.call_handle,&wockp->status.call_status);
    if(wockp->is_mask==YES)
     {
     bp=(BP)&wockp->mask;
     for(i=0;i<todo;i++) { j=wockp->pkt_done+wockp->data_offset+i; buf[i]=buf[i]^bp[j%4];  }
     }
    aaQueWrite(wockp->rcve_que.handle,todo,buf);
    aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
    wockp->pkt_done+=todo;
    if(wockp->pkt_done>wockp->pkt_bytes) { oof; }
    if(wockp->pkt_done!=wockp->pkt_bytes) { break; }
    wockp->status.rcve_pkts++;
    wockp->status.rcve_pkts_total++;
    wockp->phaze=120;
    break;


    case 120:
    if(wockp->opcode==0x08) { wockp->status.close_frame_received=YES; }
    wockp->phaze=50;
    break;
    }
   }
  else
  if(wockp->status.is_inbound==NO)
   {
   if((aa_msrunning-wockp->msr)>=100)  { wockp->msr=aa_msrunning;   }
   if(wockp->phaze>=50)
    {
    todo=wockp->xmit_bytes-wockp->xmit_done;
    if(todo==0)
     {
     if(wockp->status.xmit_pkts>0)
      {
      if(aaQueRead(wockp->xmit_que.handle,4,&todo)!=YES)  {   aaNote(0,"%i=%i",wockp->status.xmit_pkts,wockp->xmit_que.status.bytes);      }
      aaQueStatus(wockp->xmit_que.handle,&wockp->xmit_que.status);
      wockp->xmit_bytes=todo;
      wockp->xmit_done=0;
      todo=wockp->xmit_bytes-wockp->xmit_done;
      if(todo==0) oof;
      }
     }
    if(todo>0)
     {
     if(wockp->status.xmit_pkts==0) oof;
     todo=aaNumRoof(todo,_8K);
     if(aaQueRead(wockp->xmit_que.handle,todo,buf)!=YES) oof;
     aaQueStatus(wockp->xmit_que.handle,&wockp->xmit_que.status);
     aaNetTcpCallWrite(wockp->status.call_handle,todo,buf);
     aaNetTcpCallStatus(wockp->status.call_handle,&wockp->status.call_status);
     wockp->xmit_done+=todo;
     todo=wockp->xmit_bytes-wockp->xmit_done;
     if(todo==0) { wockp->status.xmit_pkts--;  wockp->xmit_bytes=wockp->xmit_done=0;  }
     }
    }
   switch(wockp->phaze)
    {
    case 0:
    wockp->phaze=10;
    break;

    case 10:
    aaMemoryRandomSet(buf,16);
    if(aaBase64Encode(buf,0,str,&sl)!=YES) oof;
    aaStringCopyf(wockp->out_key,"%s",str);
    aaStringCopyf(buf,"%s258EAFA5-E914-47DA-95CA-C5AB0DC85B11",str);
    if(aaDigestCreate(&dig.handle,aa_DIGESTTYPE_Sha1)!=YES) oof;
    if(aaDigestWrite(dig.handle,0,buf,YES,0,txt)!=YES) oof;
    aaDigestDestroy(dig.handle);
    aaStringLen(txt,&sl);
    for(i=0;i<sl;i+=2)
     {
     asca=txt[i+0]; if(asca>='A'&&asca<='F') asca+=32;
     ascb=txt[i+1]; if(ascb>='A'&&ascb<='F') ascb+=32;
     if(asca>='0'&&asca<='9') { asca=asca-'0'; }  else  { asca=(asca-'a')+10;  }
     if(ascb>='0'&&ascb<='9') { ascb=ascb-'0'; }  else  { ascb=(ascb-'a')+10;  }
     str[i/2]=(asca*16)+ascb;
     }
    if(aaBase64Encode(str,sl/2,txt,&sl)!=YES) oof;
    aaStringCopyf(wockp->sec_key,"%s",txt);
    wockp->phaze=15;
    break;

    case 15:
    aaStringNull(buf);
    aaStringAppendf(buf,"GET %s HTTP/1.1\r\n",wockp->status.up.relative);
    aaStringAppendf(buf,"Host: %s:%u\r\n",wockp->status.up.host,wockp->status.call_status.remote_adr.port);
    aaStringAppendf(buf,"Connection: Upgrade\r\n");
    //aaStringAppendf(buf,"Sec-WebSocket-Version: 13\r\n");
    aaStringAppendf(buf,"Sec-WebSocket-Key: %s\r\n",wockp->out_key);
    aaStringAppendf(buf,"Upgrade: websocket\r\n");
    aaStringAppendf(buf,"\r\n");
    if(aaNetTcpCallWritef(wockp->status.call_handle,"%s",buf)!=YES) break;
    wockp->phaze=20;
    break;

    case 20:
    if(aaNetHttpResultRead(wockp->status.call_handle,&res)!=YES) break;
    if(res.code!=101) { wockp->phaze=666; break; }
    wockp->phaze=25;
    break;

    case 25:
    case 26:
    if(aaNetHttpHeaderRead(wockp->status.call_handle,&hed)!=YES) break;
    if(aaStringICompare(hed.field,"sec-websocket-accept",0)==YES)
     {
     if(aaStringCompare(hed.data,wockp->sec_key,0)==YES) { wockp->phaze=26; }
     }
    if(hed.field_code!=aa_HTTPFIELD_BLANK) break;
    if(wockp->phaze!=26) { wockp->phaze=777; break; }
    wockp->phaze=40;
    break;


    case 40:
    wockp->phaze=45;
    break;


    case 45:
    wockp->status.stage=WOCK_STAGE_OPEN;
    wockp->phaze=50;
    break;


    case 50:
    todo=wockp->status.call_status.rcve_bytes;
    todo=aaNumRoof(todo,16);
    if(todo<2) break;
    if(aaNetTcpCallPeek(wockp->status.call_handle,0,todo,buf)!=YES) oof;
    wockp->pkt_done=0;
    wockp->pkt_bytes=0;
    wockp->data_bytes=0;
    wockp->data_offset=0;
    wockp->size_bytes=0;
    wockp->mask_offset=0;
    wockp->is_fin=aaBitGet(buf[0],7);
    wockp->is_mask=aaBitGet(buf[1],7);
    if(wockp->is_fin!=1) oof;
    wockp->opcode=buf[0]&0x0f;
    len=buf[1]&~128;
    if(len<=125)
     {
     wockp->pkt_bytes=2;
     wockp->size_bytes=0;
     if(wockp->is_mask) { wockp->mask_offset=wockp->pkt_bytes+wockp->size_bytes;  wockp->pkt_bytes+=4; }
     wockp->data_offset=wockp->pkt_bytes+wockp->size_bytes;
     wockp->data_bytes=len;
     wockp->pkt_bytes+=wockp->data_bytes;
     if(todo<wockp->data_offset) break;
     if(wockp->is_mask) {  wockp->mask=*(HP)&buf[wockp->mask_offset]; }
     wockp->pkt_done=wockp->data_offset;
     aaNetTcpCallDiscard(wockp->status.call_handle,wockp->pkt_done);
     aaQueWrite(wockp->rcve_que.handle,1,&buf[0]);
     aaQueWrite(wockp->rcve_que.handle,4,&wockp->data_bytes);
     aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
     wockp->phaze=100;
     break;
     }
    if(len==126)
     {
     wockp->pkt_bytes=2;
     wockp->size_bytes=2;
     wockp->pkt_bytes+=wockp->size_bytes;
     if(wockp->is_mask) { wockp->mask_offset=wockp->pkt_bytes;  wockp->pkt_bytes+=4; }
     wockp->data_offset=wockp->pkt_bytes;
     len=*(WP)&buf[2];
     len=aaNumSwapWord(len);
     wockp->data_bytes=len;
     wockp->pkt_bytes+=wockp->data_bytes;
     if(todo<wockp->data_offset) break;
     if(wockp->is_mask) {  wockp->mask=*(HP)&buf[wockp->mask_offset]; }
     wockp->pkt_done=wockp->data_offset;
     aaNetTcpCallDiscard(wockp->status.call_handle,wockp->pkt_done);
      aaQueWrite(wockp->rcve_que.handle,1,&buf[0]);
     aaQueWrite(wockp->rcve_que.handle,4,&wockp->data_bytes);
     aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
     wockp->phaze=100;
     break;
     }
    if(len==127)
     {
     wockp->pkt_bytes=2;
     wockp->size_bytes=8;
     wockp->pkt_bytes+=wockp->size_bytes;
     if(wockp->is_mask) { wockp->mask_offset=wockp->pkt_bytes;  wockp->pkt_bytes+=4; }
     wockp->data_offset=wockp->pkt_bytes;
     bp=(BP)&buf[2];
     qlen=*(QP)&bp[0];;    qlen=aaNumSwapQuad(qlen);    *(QP)&bp[0]=qlen;
     len=*(HP)&bp[0];       len=aaNumSwapDword(len);    *(HP)&bp[0]=len;
     len=*(HP)&bp[4];       len=aaNumSwapDword(len);    *(HP)&bp[4]=len;
     qlen=*(QP)&bp[0];
     wockp->data_bytes=qlen;
     wockp->pkt_bytes+=wockp->data_bytes;
     if(todo<wockp->data_offset) break;
     if(wockp->is_mask) {  wockp->mask=*(HP)&buf[wockp->mask_offset]; }
     wockp->pkt_done=wockp->data_offset;
     aaNetTcpCallDiscard(wockp->status.call_handle,wockp->pkt_done);
     aaQueWrite(wockp->rcve_que.handle,1,&buf[0]);
     aaQueWrite(wockp->rcve_que.handle,4,&wockp->data_bytes);
     aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
     wockp->phaze=100;
     break;
     }
    aaNote(0,"is_fin=%i is_mask=%i oc=%i pl=%u",wockp->is_fin,wockp->is_mask,wockp->opcode,wockp->data_bytes);
    break;


    case 100:
    todo=wockp->pkt_bytes-wockp->pkt_done;
    if(todo==0) { aaNote(0,"todo=0, pkt_bytes=%i",wockp->pkt_bytes); }
    todo=aaNumRoof(todo,wockp->status.call_status.rcve_bytes);
    todo=aaNumRoof(todo,_4K);
    if(todo==0) break;
    if(aaNetTcpCallRead(wockp->status.call_handle,todo,buf)!=YES) oof;
    aaNetTcpCallStatus(wockp->status.call_handle,&wockp->status.call_status);
    if(wockp->is_mask==YES)
     {
     bp=(BP)&wockp->mask;
     for(i=0;i<todo;i++) { j=wockp->pkt_done+wockp->data_offset+i; buf[i]=buf[i]^bp[j%4];  }
     }
    aaQueWrite(wockp->rcve_que.handle,todo,buf);
    aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
    wockp->pkt_done+=todo;
    if(wockp->pkt_done>wockp->pkt_bytes) { oof; }
    if(wockp->pkt_done!=wockp->pkt_bytes) { break; }
    wockp->status.rcve_pkts++;
    wockp->status.rcve_pkts_total++;
    wockp->phaze=120;
    break;
    }
   }
  break;


  default:
  break;
  }
 if(wockstatus) { aaMemoryCopy(wockstatus,sizeof(_wockstatus),&wockp->status); }
 return RET_YES;
 }




 B aaNetWockClose                      (H handle)
 {
 B ret;
 _aa_netwockobject*wockp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,NULL))!=RET_YES) { return ret; }
 if(wockp->status.close_frame_sent==YES) { return RET_YES; }
 aaNetWockPktWrite(handle,WOCK_OPCODE_CLOSE,YES,0,0);
 wockp->status.close_frame_sent=YES;
 return RET_YES;
 }






 B aaNetWockPktWrite                   (H handle,B opc,B fin,H bytes,VP data)
 {
 B ret;
 B buf[_16K];
 H i,j,off,len;
 H mask,todo;
 H pktbytes,pktdone;
 Q qlen;
 BP mbp;
 BP bp;
 _aa_netwockobject*wockp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,NULL))!=RET_YES) { return ret; }
 if(wockp->status.stage!=WOCK_STAGE_OPEN) { return RET_BADSTATE; }
 if(wockp->status.close_frame_sent==YES) { return RET_NOTOPEN; }
 //if(data==NULL) { return RET_BADPARM; }
 mbp=NULL;
 if(opc>15) { oof; }
 if(bytes==0&&opc==1&&data!=NULL) { aaStringLen(data,&bytes); }
 aaMemoryRandomDwordSet(&mask,0x00000001,0xfffffffe);
 i=opc; // 1=text,2=bin,8=close
 if(fin) i=aaBitSet(i,7); else i=aaBitClr(i,7);
 buf[0]=(B)i;
 if(bytes<=125)
  {
  j=bytes;
  if(wockp->status.is_inbound==NO) { j=aaBitSet(j,7); } // mask
  buf[1]=(B)j;
  off=2;
  }
 else
 if(bytes>=126&&bytes<=65536)
  {
  j=126;
  if(wockp->status.is_inbound==NO) { j=aaBitSet(j,7); } // mask
  buf[1]=(B)j;
  j=bytes;
  j=aaNumSwapWord(j);
  *(WP)&buf[2]=j;
  off=4;
  }
 else
  {
  j=127;
  if(wockp->status.is_inbound==NO) { j=aaBitSet(j,7); } // mask
  buf[1]=(B)j;
  qlen=bytes;
  *(QP)&buf[2]=qlen;
  bp=(BP)&buf[2];
  qlen=*(QP)&bp[0];;    qlen=aaNumSwapQuad(qlen);    *(QP)&bp[0]=qlen;
  len=*(HP)&bp[0];       len=aaNumSwapDword(len);    *(HP)&bp[0]=len;
  len=*(HP)&bp[4];       len=aaNumSwapDword(len);    *(HP)&bp[4]=len;
  off=10;
  }
 if(wockp->status.is_inbound==NO)
  {
  *(HP)&buf[off]=mask;
  aaCast(mbp,BP,&mask);
  off+=4;
  }
 pktdone=0;
 pktbytes=off+bytes;
 if((ret=aaQueWrite(wockp->xmit_que.handle,4,&pktbytes))!=YES) oops;
 if(aaQueWrite(wockp->xmit_que.handle,off,buf)!=YES) oof;
 aaQueStatus(wockp->xmit_que.handle,&wockp->xmit_que.status);
 pktdone+=off;
 j=0;
 aaCast(bp,BP,data);
 while(1)
  {
  todo=pktbytes-pktdone;
  if(todo==0) break;
  todo=aaNumRoof(todo,_2K);
  if(wockp->status.is_inbound==NO)
   {
   for(i=0;i<todo;i++) { buf[i]=bp[j]^mbp[j%4]; j++; }
   }
  else
   {
   for(i=0;i<todo;i++) { buf[i]=bp[j]; j++; }
   }
  if(aaQueWrite(wockp->xmit_que.handle,todo,buf)!=YES) oof;
  pktdone+=todo;
  }
 aaQueStatus(wockp->xmit_que.handle,&wockp->xmit_que.status);
 wockp->status.xmit_pkts++;
 wockp->status.xmit_pkts_total++;
 return RET_YES;
 }




 B aaNetWockPktWritef                  (H handle,VP fmt,...)
 {
 B ret;
 _aa_netwockobject*wockp;
 va_list argptr;
 B str[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,NULL))!=RET_YES) { return ret; }
 aaFmt(fmt,argptr,str);
 if(wockp->status.stage!=WOCK_STAGE_OPEN) { return RET_BADSTATE; }
 if(wockp->status.close_frame_sent==YES) { return RET_NOTOPEN; }
 if((ret=aaNetWockPktWrite(handle,WOCK_OPCODE_TEXT,YES,0,str))!=YES) { oops; }
 return RET_YES;
 }






 B aaNetWockPktPeek                    (H handle,HP bytes,H maxbytes,BP opc,BP fin,VP data)
 {
 B ret;
 _aa_netwockobject*wockp;
 B pex[16];
 B opcode;
 H pktbytes;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,NULL))!=RET_YES) { return ret; }
 if(data) { aaStringNull(data); }
 if(wockp->status.stage!=WOCK_STAGE_OPEN) { return RET_BADSTATE; }
 if(opc) *opc=0;
 if(fin) *fin=0;
 if(bytes==NULL) {  return RET_BADPARM; }
 *bytes=0;
 if(wockp->status.rcve_pkts==0) { return RET_NOTREADY; }
 if((ret=aaQuePeek(wockp->rcve_que.handle,0,5,pex))!=YES) { oops; }
 opcode=pex[0];
 pktbytes=*(HP)&pex[1];
 aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
 if((pktbytes+5)>wockp->rcve_que.status.bytes) { oof; }
 *bytes=pktbytes;
 //BUG,"ooo %x %x",opcode,opcode>>4);
 if(aaBitGet(opcode,7)) {  if(fin) *fin=1;  }
 if(opc) *opc=(opcode%16);
 if(data==NULL) {  return RET_YES; }
 if(pktbytes>=maxbytes) { return RET_BOUNDS; }
 if(pktbytes>0)
  {
  if((ret=aaQuePeek(wockp->rcve_que.handle,5,pktbytes,data))!=YES) { oops; }
  aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
  }
 bp=(BP)data;
 bp[pktbytes]=NULL_CHAR;
 return RET_YES;
 }





 B aaNetWockPktRead                    (H handle,HP bytes,H maxbytes,BP opc,BP fin,VP data)
 {
 B ret;
 _aa_netwockobject*wockp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,NULL))!=RET_YES) { return ret; }
 if(data) { aaStringNull(data); }
 if(wockp->status.stage!=WOCK_STAGE_OPEN) { return RET_BADSTATE; }
 if((ret=aaNetWockPktPeek(handle,bytes,maxbytes,opc,fin,data))!=YES) { return ret; }
 if(data==NULL) { return RET_YES; }
 return(aaNetWockPktDiscard(handle));
 }




 B aaNetWockPktDiscard                 (H handle)
 {
 B ret;
 _aa_netwockobject*wockp;
 B pex[16];
 H pktbytes;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.wock_object_id,handle,(VP)&wockp,NULL))!=RET_YES) { return ret; }
 if(wockp->status.stage!=WOCK_STAGE_OPEN) { return RET_BADSTATE; }
 if(wockp->status.rcve_pkts==0) { return RET_NOTREADY; }
 if((ret=aaQuePeek(wockp->rcve_que.handle,0,5,pex))!=YES) { oops; }
 pktbytes=*(HP)&pex[1];
 aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
 if((pktbytes+5)>wockp->rcve_que.status.bytes) { oof; }
 if((ret=aaQueDiscard(wockp->rcve_que.handle,pktbytes+5))!=YES) { oops; }
 aaQueStatus(wockp->rcve_que.handle,&wockp->rcve_que.status);
 wockp->status.rcve_pkts--;
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/


 B aaNetUdpCreate                      (HP handle,H ip,W port)
 {
 B ret;
 _aa_netudpobject*udpp;
 _localip lip;
 SOCKET sock;
 struct sockaddr_in addr;
 N olen,oval;
 N len,k;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(port==0) { return RET_BADPARM; }

 if((ret=aaNetLocalIpGet(&lip,0,1))!=YES) { return ret;  }
 if(ip==0)
  {
  for(k=0;k<(N)aaElementCount(lip.ip);k++)
   {
   if(lip.ip[k]==0) { continue; }
   ip=lip.ip[k];
   break;
   }
  }
 if((ret=aa_ObjectCreate(aa.net_system.udp_object_id,handle,(VP)&udpp))!=RET_YES) { oops;return ret; }
 udpp->self_handle=*handle;
 sock=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP); // was 0 instead of proto_udp
 if(sock==INVALID_SOCKET)
  {
  ///aaNote(0,"%i %i",__LINE__,WSAGetLastError());
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }

 oval=1; olen=sizeof(oval); if(setsockopt(sock,SOL_SOCKET,SO_EXCLUSIVEADDRUSE,(CP)&oval,olen)!=0) oof;
// opt=SO_SYNCHRONOUS_ALERT; olen=4; if(setsockopt(sock,SOL_SOCKET,SO_OPENTYPE,(CP)&opt,olen)!=0) oof;

 WinSockAddrSet(&addr,AF_INET,ip,htons(port));
 if(bind(sock,(struct sockaddr*)&addr,sizeof(addr)))
  {
  oow;
  aaNote(0,"ip=%i port=%i",ip,port);
  aaNote(0,"%i %i",__LINE__,WSAGetLastError());
  closesocket(sock);
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }

 if((ret=aaQueCreate(&udpp->rcve_que))!=RET_YES)
  {
  closesocket(sock);
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 if((ret=aaQueCreate(&udpp->xmit_que))!=RET_YES)
  {
  closesocket(sock);
  aaQueDestroy(udpp->rcve_que);
  aa_ObjectDestroy(aa.net_system.udp_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 //udpp->status.port_number=port;
 udpp->sock=sock;
 udpp->last_total_pkts_sent=F32;
// aaNetUdpBufferLengthSet(*handle,_8K,_8K);
 aaTimerTikGet(&udpp->ms_root);
 udpp->inactive_ms_root=udpp->ms_root;
// udpp->status.inactivity=0; // dec08
 aaTimerProfilerInit(&udpp->recent_profiler,1);
// aaTimerProfilerInit(&udpp->rate_profiler,1);
 olen=sizeof(BOOL);
 oval=0;
 if(getsockopt(udpp->sock,IPPROTO_UDP,1,(VP)&oval,(Z*)&olen)!=SOCKET_ERROR)
  {
  if(oval==TRUE) { udpp->status.is_checksum_set=YES; }
  else           { udpp->status.is_checksum_set=NO; }
  }

  len=sizeof(addr);
  WinSockAddrSet(&addr,AF_INET,0,0);
  if(getsockname(sock,(struct sockaddr *)&addr,(VP)&len)!=SOCKET_ERROR) //(Z FAR*)
   {
   udpp->status.local_adr.port=htons(addr.sin_port);
   }
  else
   {
   oof;
   }
 udpp->status.local_adr.ip=ip;
  udpp->status.user_data=udpp->user_data;
  udpp->status.user_bytes=sizeof(udpp->user_data);


 aaTimerTikGet(&udpp->sub_tik);
  if((ret=aaNetUdpBufferLengthSet(*handle,_512K,_512K))!=RET_YES) { oops; }
  if((ret=aaNetUdpFlowControlSet(*handle,NO))!=RET_YES) { oops;  }
  //if((ret=aaNetUdpPktDirectSet(*handle,YES))!=RET_YES)     { oops;  }
  if((ret=aaNetUdpXmitSpeedSet(*handle,0.00000))!=RET_YES) { oops; }
  if((ret=aaNetUdpChecksumSet(*handle,NO))!=RET_YES) { oops;  }

 oval=1; if(setsockopt(udpp->sock,SOL_SOCKET,SO_BROADCAST,(CP)&oval,sizeof(oval))!=0) oof;
 //oval=1; if(setsockopt(udpp->sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (CP)&oval,sizeof(oval))!=0) oof;
 //oval=0; if(setsockopt(udpp->sock, SOL_SOCKET, SO_REUSEADDR, (CP)&oval,sizeof(oval))!=0) oof;


// if(aaNetLocalIpGet(&lip,0,1)==YES)
//  {
  for(k=0;k<(N)aaElementCount(lip.ip);k++)
   {
   if(lip.ip[k]==0) { continue; }
   if(lip.ip[k]!=udpp->status.local_adr.ip) { continue; }
   if(lip.bcast_ip[k]==0) { continue; }
   udpp->status.bcast_adr.ip=lip.bcast_ip[k];
   udpp->status.bcast_adr.port=udpp->status.local_adr.port;
   break;
   }
//  }


 return RET_YES;
 }




 B aaNetUdpOpen                        (HP handle,H ip,W port)
 {
 H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa_NetSystemFindUdpByAddress(&han,0,ip,port)==YES)
  {
  if(handle) { *handle=han; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }





 B aaNetUdpCreateAny                   (HP handle,H ip,W portstart,W portend)
 {
 B ret;
 H p,han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(portstart==portend)
  {
  if((ret=aaNetIsPortAvailable(ip,portstart,YES))!=YES) { oops; }
  return(aaNetUdpCreate(handle,ip,portstart));
  }
 if(portstart>portend) { return RET_BADPARM; }
 p=(portend-portstart)+1;
 while(1)
  {
  if((ret=aaNetIsPortAvailable(ip,portstart,YES))==YES)
   {
   if((ret=aaNetUdpCreate(&han,ip,portstart))==RET_YES) { *handle=han; return ret; }
   else { oops; }
   }
  p--;
  if(p==0) { break; }
  portstart++;
  }
 return RET_FAILED;
 }








 B aaNetUdpDestroy                     (H handle)
 {
  B ret;
 _aa_netudpobject*udpp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 closesocket(udpp->sock);
 udpp->sock=0;
 aaQueDestroy(udpp->rcve_que);
 aaQueDestroy(udpp->xmit_que);
 if(udpp->status.extra_bytes!=0)       {  if((ret=aaMemoryRelease(udpp->status.extra_data))!=RET_YES) { oops; }  }
 aa_ObjectDestroy(aa.net_system.udp_object_id,handle);
 return RET_YES;
 }







 B aaNetUdpChecksumSet                 (H handle,B state)
 {
  B ret;
 _aa_netudpobject*udpp;
 N optlen;
 BOOL optval;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(state==YES)
  {
  optlen=sizeof(BOOL);
  optval=TRUE;
  }
 else
  {
  optlen=sizeof(BOOL);
  optval=FALSE;
  }
 if(setsockopt(udpp->sock,IPPROTO_UDP,1,(CP)&optval,optlen)!=SOCKET_ERROR)
  {
  optlen=sizeof(BOOL);
  if(getsockopt(udpp->sock,IPPROTO_UDP,1,(CP)&optval,(ZP)&optlen)!=SOCKET_ERROR)
   {
   if(optval==TRUE) { udpp->status.is_checksum_set=YES; }
   else             { udpp->status.is_checksum_set=NO; }
   if(state==YES&&udpp->status.is_checksum_set!=YES) { return RET_FAILED; }
   if(state!=YES&&udpp->status.is_checksum_set==YES) { return RET_FAILED; }
   }
  }
 return RET_YES;
 }




 B aaNetUdpFlowControlSet              (H handle,B state)
 {
  B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(state==YES) { udpp->status.is_flowcontrol_set=YES; }
 else  { udpp->status.is_flowcontrol_set=NO; }
 return RET_YES;
 }





 B aaNetUdpStatus                      (H handle,_udpstatus*udpstatus)
 {
  B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_NetSystemProcessUdp((VP)&udpp))!=RET_YES) { oops; }
 if(udpstatus) { aaMemoryCopy(udpstatus,sizeof(_udpstatus),&udpp->status); }
 return RET_YES;
 }





 B aaNetUdpBufferLengthSet             (H handle,H rbytes,H xbytes)
 {
 N opt,olen;
  B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(rbytes!=udpp->status.rcve_buffer_length)
  {
  opt=rbytes; olen=4;
  if(setsockopt(udpp->sock,SOL_SOCKET,SO_RCVBUF,(CP)&opt,olen)!=0) oof;
  udpp->status.rcve_buffer_length=rbytes;
  }
 if(xbytes!=udpp->status.xmit_buffer_length)
  {
  opt=xbytes; olen=4;
  if(setsockopt(udpp->sock,SOL_SOCKET,SO_SNDBUF,(CP)&opt,olen)!=0) oof;
  udpp->status.xmit_buffer_length=xbytes;
  }
 return RET_YES;
 }





 B aaNetUdpXmitSpeedSet                (H handle,D micro)
 {
 B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(micro<=0.0) { udpp->status.xmit_speed=0.0; }
 else
  {
  udpp->status.xmit_speed=micro;
  aaTimerProfilerInit(&udpp->xmit_profiler,1);
  aaTimerProfilerInit(&udpp->xmit_profiler_direct,1);
  }
 return RET_YES;
 }




 B aaNetUdpExtraDataSet                (H handle,H bytes)
 {
 B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)
  {
  if(udpp->status.extra_bytes!=0)  {   if((ret=aaMemoryRelease(udpp->status.extra_data))!=RET_YES) { oops; }   }
  udpp->status.extra_data=NULL;
  udpp->status.extra_bytes=bytes;
  }
 else
  {
  if(udpp->status.extra_bytes==0) {  udpp->status.extra_data=NULL;   }
  if(udpp->status.extra_bytes!=bytes)
   {
   if((ret=aaMemoryMake((VP)&udpp->status.extra_data,bytes))!=RET_YES) { oops; }
   }
  udpp->status.extra_bytes=bytes;
  }
 return RET_YES;
 }



 B aaNetUdpPktDirectSet                (H handle,B state)
 {
 B ret;
 _aa_netudpobject*udpp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(state==YES)  {  udpp->status.is_direct=YES;  }
 else            {  udpp->status.is_direct=NO;  }
 return RET_YES;
 }





 B aaNetUdpPktWrite                    (H handle,_udppkt*udppkt)
 {
  B ret;
 _aa_netudpobject*udpp;
 B buf[_1K];
 struct sockaddr_in addr;
 H by;
 N len;
 B can_xmit;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(udppkt==NULL) { return RET_BADPARM; }

 WinSockAddrSet(&addr,AF_INET,udppkt->address.ip,htons(udppkt->address.port));
 by=(H)udppkt->data_bytes;

 if(udpp->status.is_direct==YES)
  {
  can_xmit=YES;
  if(udpp->status.xmit_speed!=0.0)
   {
   aaTimerProfilerUpdate(&udpp->xmit_profiler_direct,1);
   if(udpp->xmit_profiler_direct.ms<udpp->status.xmit_speed)
    {
    if(udpp->status.xmit_pkts_total!=udpp->last_total_pkts_sent)
     {
     udpp->status.xmit_direct_misses++;
     udpp->last_total_pkts_sent=udpp->status.xmit_pkts_total;
     }
    can_xmit=NO;
    }
   }
  if(udpp->status.xmit_pkts_qued==0&&can_xmit==YES)
   {
   if((len=sendto(udpp->sock,(CP)&udppkt->data[0],by,0,(struct sockaddr *)&addr,sizeof(addr)))>=0)
    {
    if(len!=(N)by) { oof; return RET_FAILED; } // ningy added (N)
    udpp->status.xmit_bytes_total+=(Q)by;//total_bytes_sent+=by;
    udpp->xmit_bytes_total_recent+=(by+8);
    udpp->xmit_pkts_total_recent++;
    udpp->status.xmit_pkts_total++;
    aa.net_system.net_status.total_udp_packets_sent++;
    if(udpp->status.xmit_speed!=0.0)  {   aaTimerProfilerInit(&udpp->xmit_profiler_direct,1); }
    aa_NetSystemProcessUdp((VP)&udpp);
    return RET_YES;
    }
   }
  }

// aa_NetSystemProcessUdp((VP)&udpp);

 #if 0
 if((ret=aaQueWrite(udpp->xmit_que,sizeof(addr),&addr))!=RET_YES)  {  return ret;  }
 if((ret=aaQueWrite(udpp->xmit_que,4,&by))!=RET_YES)  { return ret;  }
 #else
 aaMemoryCopy(&buf[0],sizeof(addr),&addr);
 *(HP)&buf[sizeof(addr)]=by;
 if((ret=aaQueWrite(udpp->xmit_que,sizeof(addr)+4,buf))!=RET_YES)  { return ret;  }
 #endif

 if(udppkt->data_bytes!=0)
  {
  if((ret=aaQueWrite(udpp->xmit_que,udppkt->data_bytes,udppkt->data))!=RET_YES)  { return ret;  }
  }
 udpp->status.xmit_pkts_qued++;
 aa_NetSystemProcessUdp((VP)&udpp);
 return RET_YES;
 }




 B aaNetUdpPktRead                     (H handle,_udppkt*udppkt)
 {
  B ret;
 _aa_netudpobject*udpp;
 _questatus qs;
 struct sockaddr_in addr;
 B tmp[128];
 H len;
 fd_set set;
 struct timeval tv;
 Z val,flags,bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 udppkt->data_bytes=0;
 udppkt->address.ip=0;
 udppkt->address.port=0;
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }

 if(udpp->status.is_direct==YES)
  {
  if(udpp->status.rcve_pkts_qued==0)
   {
   aa_NetSystemCalculateUdpTimers((VP)&udpp);
   FD_ZERO(&set);
   FD_SET(udpp->sock,&set);
   WSASetLastError(0);
   tv.tv_sec=0;
   tv.tv_usec=0;
   val=select(0,&set,0,0,&tv);
   if(val==SOCKET_ERROR) oof;
   if(val>=1)
    {
    if(FD_ISSET(udpp->sock,&set)!=0)
     {
     len=sizeof(addr);
     flags=0;
     if((bytes=recvfrom(udpp->sock,(CP)&udppkt->data[0],0x10000,flags,(struct sockaddr *)&addr,(ZP)&len))>=0)
      {
      udppkt->address.ip=(*(HP)&addr.sin_addr);
      udppkt->address.port=htons(addr.sin_port);
      udppkt->data_bytes=(W)bytes;
      if(flags==MSG_PEEK) {  recvfrom(udpp->sock,0,0,0,0,0); }
      udpp->status.rcve_bytes_total+=(Q)bytes;
      udpp->rcve_bytes_total_recent+=(bytes+8); // add 8 bytes udp overhead for rate timings
      udpp->rcve_pkts_total_recent++;
      aaTimerTikGet(&udpp->inactive_ms_root);
      udpp->status.inactivity=0;
      udpp->status.rcve_pkts_total++;
      return RET_YES;
      }
     }
    }
   return RET_NOTREADY;
   }
  }

//  if(udpp->status.is_direct==YES) { aaNote(0,"UdpPktRead, in direct mode, but we got here !!"); }

 aa_NetSystemProcessUdp((VP)&udpp);
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(udpp->rcve_que,&qs);
 if(qs.bytes<(sizeof(addr)+4)) { return RET_NOTREADY; }

 if((ret=aaQuePeek(udpp->rcve_que,0,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 if(qs.bytes<(len+sizeof(addr)+4)) { return RET_FAILED; }
 aaMemoryCopy(&addr,sizeof(addr),tmp);
 udppkt->address.ip=(*(HP)&addr.sin_addr);
 udppkt->address.port=htons(addr.sin_port);
 udppkt->data_bytes=(W)len;
 aaQueDiscard(udpp->rcve_que,sizeof(addr)+4);
 if(udppkt->data_bytes!=0)
  {
  if((ret=aaQueRead(udpp->rcve_que,len,udppkt->data))!=RET_YES) { return ret; }
  }
 udpp->status.rcve_pkts_total++;
 udpp->status.rcve_pkts_qued--;
 return RET_YES;
 }









 B aaNetUdpPktPeek                     (H handle,_udppkt*udppkt,H pktoff,H maxbytes)
 {
  B ret;
 _aa_netudpobject*udpp;
 _questatus qs;
 struct sockaddr_in addr;
 B tmp[128];
 H len;
 H from,avail;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 udppkt->data_bytes=0;
 udppkt->address.ip=0;
 udppkt->address.port=0;
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessUdp((VP)&udpp);
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(pktoff>=udpp->status.rcve_pkts_qued) { return RET_NOTREADY; }
 from=0;

 while(1)
  {
  aaQueStatus(udpp->rcve_que,&qs);
  avail=qs.bytes-from;
  if(avail<(sizeof(addr)+4)) { return RET_NOTREADY; }
  if((ret=aaQuePeek(udpp->rcve_que,from,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
  aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
  if(avail<(sizeof(addr)+4+len)) { return RET_FAILED; }
  if(pktoff!=0)
   {
   pktoff--;
   from+=(sizeof(addr)+4+len);
   continue;
   }
  if(maxbytes==F32) { maxbytes=len; }
  if(maxbytes!=0&&len!=0)
   {
   maxbytes=aaNumRoof(maxbytes,len);//maxbytes,len);
   if((ret=aaQuePeek(udpp->rcve_que,from+sizeof(addr)+4,maxbytes,udppkt->data))!=RET_YES) { return ret; }
   }
  aaMemoryCopy(&addr,sizeof(addr),tmp);
  udppkt->address.ip=(*(HP)&addr.sin_addr);
  udppkt->address.port=htons(addr.sin_port);
  udppkt->data_bytes=(W)len;
  break;
  }
 return RET_YES;
 }










 B aaNetUdpPktDiscard                  (H handle)
 {
 B ret;
 _aa_netudpobject*udpp;
 _questatus qs;
 struct sockaddr_in addr;
 B tmp[128];
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 aa_NetSystemProcessUdp((VP)&udpp);
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 aaQueStatus(udpp->rcve_que,&qs);
 if(qs.bytes<(sizeof(addr)+4)) { return RET_NOTREADY; }
 if((ret=aaQuePeek(udpp->rcve_que,0,sizeof(addr)+4,tmp))!=RET_YES) { return ret; }
 aaMemoryPeekDword(&tmp[sizeof(addr)],0,&len);
 if(qs.bytes<(len+sizeof(addr)+4)) { return RET_FAILED; }
 if((ret=aaQueDiscard(udpp->rcve_que,len+sizeof(addr)+4))!=RET_YES) { return ret; }
 udpp->status.rcve_pkts_qued--;
 udpp->status.rcve_pkts_total++;
 if(addr.sin_family!=addr.sin_family) {} // shut warning up about addr not used
 return RET_YES;
 }






 B aaNetUdpPktReturn                   (H handle)
 {
 B ret;
 _aa_netudpobject*udpp;
 struct sockaddr_in addr;
 BP tmp=NULL_POINTR;
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,handle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
 if(udpp->status.rcve_pkts_qued==0) { return RET_NOTREADY; }
 if(udpp->status.rcve_pkts_qued==1) { return RET_YES; }
 if((ret=aa_MemoryTemp((VP)&tmp,_64K+_1K,aa_MEMORYTEMP_UdpPktRet))!=RET_YES) { oops; }
 if((ret=aaQuePeek(udpp->rcve_que,sizeof(addr),4,&len))!=RET_YES) { return ret; }
 if((ret=aaQuePeek(udpp->rcve_que,0,sizeof(addr)+4+len,tmp))!=RET_YES) { return ret; }
 if((ret=aaNetUdpPktDiscard(handle))!=RET_YES) { return ret; }
 if((ret=aaQueWrite(udpp->rcve_que,sizeof(addr)+4+len,tmp))!=RET_YES) { return ret; }
 aa_NetSystemProcessUdp((VP)&udpp);
 if(addr.sin_family!=addr.sin_family) {} // shut warning up about addr not used
 return RET_YES;
 }






 B aaNetUdpPktAllocate                 (_udppkt**udppkt)
 {
 B ret;
 BP mem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 *udppkt=NULL;
 if((ret=aaMemoryAllocate((VP)&mem,sizeof(_udppkt)))!=YES) { return ret; }
 aaMemoryNameSet(mem,"udppkt"); //charlie
 *udppkt=(_udppkt*)mem;
 return RET_YES;
 }




 B aaNetUdpPktRelease                  (_udppkt*udppkt)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 udppkt->address.ip=0;
 udppkt->address.port=0;
 udppkt->data_bytes=0;
 udppkt->data[udppkt->data_bytes]=0;
 if((ret=aaMemoryRelease(udppkt))!=YES) { oops; return ret; }
 return RET_YES;
 }





 B aaNetUdpPktSet                      (_udppkt*udppkt,H remoteip,W remoteport,W databytes)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 if(remoteport==0) { return RET_BADPARM; }
 if(remoteip==0) { return RET_BADPARM; }// remoteip=aaLoopBack; }
 udppkt->address.ip=remoteip;
 udppkt->address.port=remoteport;
 udppkt->data_bytes=databytes;
 return RET_YES;
 }






 B aaNetUdpPktCopy                     (_udppkt*udppkt,_udppkt*sudppkt,B copydata)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sudppkt==NULL) { return RET_BADPARM; }
 if((ret=aaNetUdpPktSet(udppkt,sudppkt->address.ip,sudppkt->address.port,sudppkt->data_bytes))!=RET_YES) { return ret; }
 if(copydata) { aaMemoryCopy(udppkt->data,sudppkt->data_bytes,sudppkt->data); }
 return ret;
 }




 B aaNetUdpPktAppend                   (_udppkt*udppkt,H bytes,VP data)
 {
 N left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 left=sizeof(udppkt->data)-udppkt->data_bytes;
 if(left<0) { return RET_CORRUPTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>(H)left) { return RET_BOUNDS; } // ningy added (H)
 // passing data=null ,just updates the data_bytes, useful, if i write to data[] directly
 if(data!=NULL) {  aaMemoryCopy(&udppkt->data[udppkt->data_bytes],bytes,data);  }
 udppkt->data_bytes+=(W)bytes;
 return RET_YES;
 }





 B aaNetUdpPktByteAppend               (_udppkt*udppkt,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,1,&val));
 }




 B aaNetUdpPktWordAppend               (_udppkt*udppkt,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,2,&val));
 }




 B aaNetUdpPktDwordAppend              (_udppkt*udppkt,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,4,&val));
 }



 B aaNetUdpPktQuadAppend               (_udppkt*udppkt,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetUdpPktAppend(udppkt,8,&val));
 }






 B aaNetUdpPktTrim                     (_udppkt*udppkt,H bytes)
 {
 N left;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(udppkt==NULL) { return RET_BADPARM; }
 left=sizeof(udppkt->data)-udppkt->data_bytes;
 if(left<0) { return RET_CORRUPTED; }
 if(bytes==0) { return RET_YES; }
 if(bytes>udppkt->data_bytes) { return RET_BOUNDS; }
 udppkt->data_bytes-=(W)bytes;
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/

/*
 #define aa_STUN_CMD_BINDREQUEST       0x0001
 #define aa_STUN_CMD_BINDRESPONSE      0x0101
 #define aa_STUN_CMD_BINDERROR         0x0111
 #define aa_STUN_CMD_SHAREDREQUEST     0x0002
 #define aa_STUN_CMD_SHAREDRESPONSE    0x0102
 #define aa_STUN_CMD_SHAREDERROR       0x0112

 #define aa_STUN_ATR_MAPADDRESS        0x0001
 #define aa_STUN_ATR_RESPONSEADDRESS   0x0002
 #define aa_STUN_ATR_CHANGEREQUEST     0x0003
 #define aa_STUN_ATR_SRCADDRESS        0x0004
 #define aa_STUN_ATR_OTHERADDRESS      0x0005
 #define aa_STUN_ATR_USERNAME          0x0006
 #define aa_STUN_ATR_PASSWORD          0x0007
 #define aa_STUN_ATR_MSGINT            0x0008
 #define aa_STUN_ATR_ERRORCODE         0x0009
 #define aa_STUN_ATR_UNKNOWNATTR       0x000a
 #define aa_STUN_ATR_REFLECTEDFROM     0x000b
 #define aa_STUN_ATR_LIFETIME          0x000d
 #define aa_STUN_ATR_ALTERNATESERVER   0x000e
 #define aa_STUN_ATR_MAGICCOOKIE       0x000f
 #define aa_STUN_ATR_BANDWIDTH         0x0010
 #define aa_STUN_ATR_DSTADDRESS        0x0011
 #define aa_STUN_ATR_REMOTEADDRESS     0x0012
 #define aa_STUN_ATR_DATA              0x0013
 #define aa_STUN_ATR_NONCE             0x0014
 #define aa_STUN_ATR_REALM             0x0015
 #define aa_STUN_ATR_REQADDRESSTYPE    0x0016
*/

 B aaNetStunClientCreate               (HP handle,H udphandle,H serverip,W serverport)
 {
 B ret;
 _aa_netstunclientobject*stcp;
 _aa_netudpobject*udpp;
 _localip locip;
 H han,i,myip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }

 aaNetLocalIpGet(&locip,NO,NO);
 for(i=0;i<4;i++)
  {
  if(locip.type[i]!='P') { continue; }
  break;
  }
 if(i==4) { return RET_FAILED; }
 myip=locip.ip[i];//iplist[i];
 if(serverport==0) { serverport=3478; }
 if(serverip==0) { return RET_BADPARM; }
 if(udphandle==0)
  {
  if((ret=aaNetUdpCreateAny(&han,0,49152,65535))!=RET_YES) { return ret; }
  if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,han,(VP)&udpp,NULL))!=RET_YES) { oops; }
  }
 else
  {
  if((ret=aa_ObjectCheck(aa.net_system.udp_object_id,udphandle,(VP)&udpp,NULL))!=RET_YES) { return ret; }
  han=udphandle;
  }
 if((ret=aa_ObjectCreate(aa.net_system.stunclient_object_id,handle,(VP)&stcp))!=RET_YES) {oops; return ret; }
 stcp->self_handle=*handle;
 stcp->stage=10;
 stcp->status.is_inprogress=YES;
 stcp->status.is_complete=NO;
 stcp->status.ms=0;
 aaNetAdrSet(&stcp->status.server_adr,serverip,serverport);
 aaNetAdrSet(&stcp->status.mapped_adr,0,0);
 aaNetAdrSet(&stcp->status.remapped_adr,0,0);
 stcp->status.type=0;
 stcp->attempt=0;
 aaNetRttInit(&stcp->rtt,200,3000,500);
 stcp->test_num=1;
 stcp->udp_handle=han;
 aaNetAdrSet(&stcp->status.local_adr,myip,udpp->status.local_adr.port);//port_number);
 if(udphandle==0) { stcp->is_udp_created=YES; }
 else             { stcp->is_udp_created=NO; }
// BUG,"made %lu %i",stcp->status.local_adr.ip,stcp->status.local_adr.port);
 return RET_YES;
 }





 B aaNetStunClientDestroy              (H handle)
 {
  B ret;
 _aa_netstunclientobject*stcp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.stunclient_object_id,handle,(VP)&stcp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(stcp->is_udp_created==YES)
  {
  if((ret=aaNetUdpDestroy(stcp->udp_handle))!=RET_YES) { oops; }
  }
 aa_ObjectDestroy(aa.net_system.stunclient_object_id,handle);
 return RET_YES;
 }








 B aaNetStunClientStatus               (H handle,_stunclientstatus*stunclientstatus)
 {
 B ret;
 _aa_netstunclientobject*stcp;
 _netadr adr;
 B chip,chport;
 W msg_typ,msg_len;
 W atr_typ,atr_len;
 H off;
 _netadr pkt_adr,map_adr,src_adr,oth_adr;
 B tmp[_1K];
 W pos,mlen;
 H bit;
 B isok;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.stunclient_object_id,handle,(VP)&stcp,NULL))!=RET_YES) { return ret; }

 switch(stcp->stage)
  {
  case 10:
  if(stcp->attempt==4) {  stcp->stage=20; break; }
  switch(stcp->test_num)
   {
   default: oof;
   case 1:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=NO;  chport=NO; break;  // initial check for nat
   case 2:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=YES; chport=YES; break; // nat not detected, check for firewall
   case 3:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=YES; chport=YES; break; // nat detected
   case 4:  aaNetAdrCopy(&adr,&stcp->status.other_adr); chip=NO; chport=NO; break;    // nat detected, server#2 same address/port
   case 5:  aaNetAdrCopy(&adr,&stcp->status.server_adr); chip=NO; chport=YES; break;   // nat detected, IP constant, check restricted type
   }
//  BUG,"performing stun test %i to %lu %u",stcp->test_num,adr.ip,adr.port);
  aaMemoryRandomSet(stcp->tid,16);
  pos=0;
  *(WP)&tmp[pos+0]=aaNumSwapWord(0x0001); // bind request
  mlen=8;
  #if 0
  if(responseadr!=NULL)  { mlen+=(W)12; }
  #endif
  *(WP)&tmp[pos+2]=(W)aaNumSwapWord(mlen);
  aaMemoryCopy(&tmp[pos+4],16,stcp->tid);
  pos+=(W)20;
  // RFC: even if change ip/port are BOTH pos, still include the attribute
  *(WP)&tmp[pos+0]=(W)aaNumSwapWord(0x0003); // change request
  *(WP)&tmp[pos+2]=(W)aaNumSwapWord(4);
  bit=0;
  if(chip)   { bit=(B)aaBitSet(bit,2); }
  if(chport) { bit=(B)aaBitSet(bit,1); }
  *(HP)&tmp[pos+4]=(H)aaNumSwapDword(bit);
  pos+=(W)8;
  #if 0
  if(responseadr!=NULL)
   {
   *(WP)&tmp[pos+0]=aaNumSwapWord(0x0002); // response request
   *(WP)&tmp[pos+2]=aaNumSwapWord(8);
   tmp[pos+4]=0x00;
   tmp[pos+5]=0x01;
   *(WP)&tmp[pos+6]=(W)(aaNumSwapWord(responseadr->port));
   *(HP)&tmp[pos+8]=(H)((responseadr->ip));
   pos+=(W)12;
   }
  #endif
  //BUG,"Sending stun test %i",stcp->test_num);
  aaNetUdpPktSet(&aa.net_system.tmp_udp_pkt,adr.ip,adr.port,0);
  aaNetUdpPktAppend(&aa.net_system.tmp_udp_pkt,pos,tmp);
  aaNetUdpPktWrite(stcp->udp_handle,&aa.net_system.tmp_udp_pkt);
  aaTimerTikGet(&stcp->root_ms);
    stcp->attempt++;
  stcp->stage=30;
  break;


  case 20:
  switch(stcp->test_num)
   {
   default: break;
   case 1:   stcp->status.type=aa_NET_STUN_BLOCKED;            stcp->stage=900;   break;
   case 2:   stcp->status.type=aa_NET_STUN_SYMETRICFIREWALL;   stcp->stage=900;   break;
   case 3:   stcp->attempt=0;   stcp->test_num=4;              stcp->stage=10;   aaNetRttInit(&stcp->rtt,200,3000,500); break;
   case 4:   stcp->status.is_failed=YES;                       stcp->stage=900;   break;
   case 5:   stcp->status.type=aa_NET_STUN_RESTRICTEDPORT;     stcp->stage=900;   break;
   }
  break;


  case 30:
  aaTimerPrimitive(aa.timer_system.last_tik,stcp->root_ms,&stcp->status.ms);
  if(stcp->status.ms>stcp->rtt.timeout) {  aaNetRttUpdate(&stcp->rtt,stcp->status.ms,YES); stcp->stage=10; break; }
  if(aaNetUdpPktPeek(stcp->udp_handle,&aa.net_system.tmp_udp_pkt,0,F32)!=YES) { break; }
  isok=NO;
  while(1)
   {
   if(stcp->status.other_adr.ip!=0)
    {
    if(aa.net_system.tmp_udp_pkt.address.ip==stcp->status.other_adr.ip) { isok=YES; break; }
    }
   if(stcp->status.server_adr.ip!=0)
    {
    if(aa.net_system.tmp_udp_pkt.address.ip==stcp->status.server_adr.ip) { isok=YES; break; }
    }
   break;
   }
  if(isok==NO)
   {
   //aaNetIpToString(aa.net_system.tmp_udp_pkt.address.ip,txt);
//   BUG,"%s",txt);
//   BUG,"stunclientstatus returning udp packet test=%i pktip=%i otherip=%i",stcp->test_num,aa.net_system.tmp_udp_pkt.address.ip,stcp->status.other_adr.ip);
   if(aaNetUdpPktReturn(stcp->udp_handle)!=YES) oof;
// aaNetUdpPktDiscard(stcp->udp_handle);
   break;
   }
  aaNetUdpPktDiscard(stcp->udp_handle);
  if(aa.net_system.tmp_udp_pkt.data_bytes<20) {  break; }
  msg_typ=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[0]);
  msg_len=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[2]);
  if(aa.net_system.tmp_udp_pkt.data_bytes!=(msg_len+20)) {  break; }
  if(aaMemoryCompare(&aa.net_system.tmp_udp_pkt.data[4],16,stcp->tid,NULL)!=YES)  {   break; }
  if(msg_typ==0x0111)    { /* BUG," Stun cmd binderr");*/ break; } // bind error
  if(msg_typ!=0x0101)    { oof;  break; } // bid reply
  off=0;
  ///////////////////////////////
  aaNetAdrSet(&pkt_adr,0,0);   aaNetAdrSet(&map_adr,0,0);   aaNetAdrSet(&src_adr,0,0);   aaNetAdrSet(&oth_adr,0,0);
  while(1)
   {
   if(off>=(H)msg_len) { break; }
   atr_typ=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[20+off]);
   atr_len=(W)aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[22+off]);
   aaNetAdrCopy(&pkt_adr,&aa.net_system.tmp_udp_pkt.address);
   aaNetAdrSet(&adr,(H)((*(HP)&aa.net_system.tmp_udp_pkt.data[20+off+8])),(W)(aaNumSwapWord(*(WP)&aa.net_system.tmp_udp_pkt.data[20+off+6])));
   switch(atr_typ)
    {
    default: oof; break;
    case 0x0001:    if(atr_len!=8) { aaNote(0,"qwe %i %i",atr_typ,atr_len); } aaNetAdrCopy(&map_adr,&adr);       break;
    case 0x0004:    if(atr_len!=8) { aaNote(0,"aqa %i %i",atr_typ,atr_len); } aaNetAdrCopy(&src_adr,&adr);       break;
    case 0x0005:    if(atr_len!=8) { aaNote(0,"qqaz %i %i",atr_typ,atr_len); } aaNetAdrCopy(&oth_adr,&adr);       break;
    }
   off+=(4+atr_len);
   }
  aaNetRttUpdate(&stcp->rtt,stcp->status.ms,NO);

  #if 0
   aaNetAdrToString(&stcp->status.local_adr,&str[0]); ;
   aaNetAdrToString(&stcp->status.server_adr,&str[100]); ;
   aaNetAdrToString(&pkt_adr,&str[200]);
   aaNetAdrToString(&map_adr,&str[300]);
   aaNetAdrToString(&src_adr,&str[400]);
   aaNetAdrToString(&oth_adr,&str[500]);
   aaStringCopyf(info,"Handle reply: test=%i \nLocAdr: %-25s StunSvrAdr: %-25s PktAdr: %-25s\nMapAdr: %-25s SrcAdr:     %-25s OthAdr: %-25s",stcp->test_num,&str[0],&str[100],&str[200],&str[300],&str[400],&str[500]);
//   BUG,"%s",info);
   #endif

  switch(stcp->test_num)
   {
   default:
   break;

   case 1:
   aaNetAdrCopy(&stcp->status.mapped_adr,&map_adr);
   aaNetAdrCopy(&stcp->status.remapped_adr,&map_adr);
   aaNetAdrCopy(&stcp->status.other_adr,&oth_adr);
   stcp->attempt=0;
   if(aaNetAdrEqualsAdr(&map_adr,&stcp->status.local_adr)==YES)    {  stcp->test_num=2;    stcp->stage=10;    }
   else                                                            {  stcp->test_num=3;    stcp->stage=10;    }
   break;

   case 2:
   stcp->status.type=aa_NET_STUN_OPEN;
   stcp->stage=900;
   break;

   case 3:
   stcp->status.type=aa_NET_STUN_FULLCONE;
   stcp->stage=900;
   break;

   case 4:
   stcp->attempt=0;
   aaNetAdrCopy(&stcp->status.remapped_adr,&map_adr);
   if(aaNetAdrEqualsAdr(&stcp->status.mapped_adr,&stcp->status.remapped_adr)==YES)  {    stcp->test_num=5;     stcp->stage=10;     }
   else                                                                             {    stcp->status.type=aa_NET_STUN_SYMETRICNAT;   stcp->stage=900;   }
   break;

   case 5:
   stcp->status.type=aa_NET_STUN_RESTRICTEDCONE;
   stcp->stage=900;
   break;
   }
  break;


  case 900:
  stcp->status.is_inprogress=NO;
  stcp->status.is_complete=YES;
  stcp->stage=1000;
  break;

  default:
  break;
  }


 if(stunclientstatus)
  {
  aaMemoryCopy(stunclientstatus,sizeof(_stunclientstatus),&stcp->status);
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaNetSocksInit                      (_socks*socks,H ip,W port,VP user,VP pass)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(socks==NULL) { return RET_BADPARM; }
 aaMemoryFill(socks,sizeof(_socks),0);
 socks->magic=aaHPP(aaNetSocksInit);
 socks->adr.ip=ip;
 socks->adr.port=port;
 if(user) { aaStringCopyf(socks->user.name,"%s",user); }
 if(pass) { aaStringCopyf(socks->user.pass,"%s",pass); }
 return RET_YES;
 }



 B aaNetSocksHelloWrite                (H tcpcallhandle)
 {
 B ret;
 B buf[_1K];
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 buf[0]=0x05; buf[1]=0x01; buf[2]=0x00;
 return(aaNetTcpCallWrite(tcpcallhandle,3,buf));
 }


 B aaNetSocksConnectIp4Write           (H tcpcallhandle,H ip,W port)
 {
 B ret;
 B buf[_1K];
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 buf[0]=0x05;
 buf[1]=0x01;
 buf[2]=0x00;
 buf[3]=0x01;
 //aaNetIpFromString("122.148.128.190",&i);
 *(HP)&buf[4]=ip;
 *(WP)&buf[8]=aaNumSwapWord(port);
 return(aaNetTcpCallWrite(tcpcallhandle,10,buf));
 }



/*--------------------------------------------*/


 B aaNetTcpPortCreate                  (HP handle,H ip,W port,H extrabytes)
 {
 B ret;
 _aa_nettcpportobject*prtp;
 SOCKET sock;
 struct sockaddr_in addr;
 N oval,olen;
// _netstatus ns;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0)  {  return RET_BADPARM;  }
 if((ret=aa_ObjectCreate(aa.net_system.tcpport_object_id,handle,(VP)&prtp))!=RET_YES) { return ret; }
 prtp->self_handle=*handle;
 if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET) // was 0 instead of proto_tcp
  {
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
 oval=1; olen=sizeof(oval); if(setsockopt(sock,SOL_SOCKET,SO_EXCLUSIVEADDRUSE,(CP)&oval,olen)!=0) { oow; }
 ///oval=1; olen=sizeof(oval); if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(CP)&oval,olen)!=0) { oow; }


 WinSockAddrSet(&addr,AF_INET,ip,htons(port));
 if(bind(sock,(struct sockaddr*)&addr,sizeof(addr)))
  {
//  aaNote(0,"bind line %i %i",__LINE__,WSAGetLastError());
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
//  BUGGY;
  closesocket(sock);
  *handle=0;
  return RET_INUSE;
  }
 prtp->socket_used=YES;
 prtp->sock=sock;
 //prtp->status.max_calls=50000;//F32;
 prtp->status.local_adr.port=port;
 prtp->status.extra_bytes=extrabytes;
 logg("%s:%i about to listen",__func__,__LINE__);
 listen(sock,aa_NET_SOMAXCONN);
 logg("%s:%i about to asyncsel",__func__,__LINE__);
 if(WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_ACCEPT|FD_CLOSE))
  {
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
//  BUGGY;
  closesocket(sock);
  *handle=0;
  return RET_FAILED;
  }
 logg("about to resolve pair");
 if(aa_NetSystemResolveIpPortPair(prtp->sock,&prtp->status.local_adr.ip,&prtp->status.local_adr.port,0,0)!=YES)
  {
  oof; // otherwise callstatus returns localip/port=0.0 remoteip/port=0.0
  }
 aaNetAdrToString(&prtp->status.local_adr,prtp->status.local_dot);
 aa.net_system.net_status.incoming_tcp_ports_inuse++;
 return RET_YES;
 }





#if 0

 B aaNetTcpPortCreate                  (HP handle,H ip,W port,H extrabytes)
 {
 B ret;
 _aa_nettcpportobject*prtp;
 SOCKET sock;
 struct sockaddr_in addr;
 N oval,olen;
// _netstatus ns;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0)  {  return RET_BADPARM;  }
 if((ret=aa_ObjectCreate(aa.net_system.tcpport_object_id,handle,(VP)&prtp))!=RET_YES) { oops;return ret; }
 prtp->self_handle=*handle;
 //aa_last_line_executed=__LINE__;
 if((sock=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))==INVALID_SOCKET) // was 0 instead of proto_tcp
  {
  prtp->self_handle=*handle;
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
  *handle=0;
  return RET_FAILED;
  }
  //aa_last_line_executed=__LINE__;
  prtp->self_handle=*handle;
 oval=1; olen=sizeof(oval); if(setsockopt(sock, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (CP)&oval, olen)!=0) { oow; }
 //oval=0; olen=sizeof(oval);  if(setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(CP)&oval,olen)!=0) oof;

 WinSockAddrSet(&addr,AF_INET,ip,htons(port));
 if(bind(sock, (struct sockaddr *)&addr, sizeof(addr)))
  {
//  aaNote(0,"bind line %i %i",__LINE__,WSAGetLastError());
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
//  BUGGY;
  closesocket(sock);
  *handle=0;
  return RET_INUSE;
  }
 prtp->socket_used=YES;
 prtp->sock=sock;
 //prtp->status.max_calls=50000;//F32;
 prtp->status.local_adr.port=port;
 prtp->status.extra_bytes=extrabytes;
 listen(sock, aa_NET_SOMAXCONN);
 if(WSAAsyncSelect(sock, aa.net_system.window,aa.net_system.tcp_message_id,  FD_ACCEPT | FD_CLOSE ))
  {
  aa_ObjectDestroy(aa.net_system.tcpport_object_id,*handle);
//  BUGGY;
  closesocket(sock);
  *handle=0;
  return RET_FAILED;
  }
 if(aa_NetSystemResolveIpPortPair(prtp->sock,&prtp->status.local_adr.ip,&prtp->status.local_adr.port,0,0)!=YES)
  {
  oof; // otherwise callstatus returns localip/port=0.0 remoteip/port=0.0
  }
 aaNetAdrToString(&prtp->status.local_adr,prtp->status.local_dot);
 aa.net_system.net_status.incoming_tcp_ports_inuse++;
 return RET_YES;
 }




#endif

 B aaNetTcpPortCreateAny               (HP handle,H ip,W portstart,W portend,H extrabytes)
 {
 B ret;
 H p,han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(portstart==portend)
  {
  return(aaNetTcpPortCreate(handle,ip,portstart,extrabytes));
  }
 if(portstart>portend) { return RET_BADPARM; }
 p=(portend-portstart)+1;
 while(1)
  {
  if((ret=aaNetTcpPortCreate(&han,ip,portstart,extrabytes))==RET_YES) { *handle=han; return ret; }
  p--;
  if(p==0) { break; }
  portstart++;
  }
 return RET_NOMEMORY;
 }




 // tcpportdestroy calls tcpcalldestroy,, and tcpcalldestroy calls findsockbyport .... ( re-entrancy issue ?? - check )
 B aaNetTcpPortDestroy                 (H handle)
 {
 B ret;
 _aa_nettcpportobject*prtp;
 H call_handle,go;
 B isprot;
 B junk[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpport_object_id,handle,(VP)&prtp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 logg("destroying calls connected to port %i,, portsock=%i",prtp->status.local_adr.port,prtp->sock);
 while(1)
  {
  if(aa_NetSystemFindCallByPortSock(&call_handle,NULL,prtp->sock)!=YES) { break; }
  aaNetTcpCallDestroy(call_handle);
  logg("destroyed call %i  port.calls_total=%i",call_handle,prtp->status.calls_total);
  }
 if(prtp->status.calls_waiting!=0||prtp->status.calls_answered!=0)
  {
  logg("cw=%i cc=%i",prtp->status.calls_waiting,prtp->status.calls_answered);
  }
  shutdown(prtp->sock,2);
  go=0;
  while(1)
   {
   if(recv(prtp->sock,(CP)junk,576,0)<=0) { break; }
   if(is_aa_quit_posted==YES) {  break; }
   if((go++)>10) { break; }
   }
 closesocket(prtp->sock);
  aa.net_system.net_status.incoming_tcp_ports_inuse--;
 aa_ObjectDestroy(aa.net_system.tcpport_object_id,handle);
 return RET_YES;
 }









 B aaNetTcpPortStatus                  (H handle,_tcpportstatus*tcpportstatus)
 {
 B ret;
 _aa_nettcpportobject*prtp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpport_object_id,handle,(VP)&prtp,NULL))!=RET_YES) { return ret; }
 if(tcpportstatus) { aaMemoryCopy(tcpportstatus,sizeof(_tcpportstatus),&prtp->status); }
 return RET_YES;
 }








 B aaNetTcpPortCallNext                (H handle,HP callhandle,_tcpcallstatus*tcpcallstatus,HP iterator)
 {
 B ret;
 _aa_nettcpportobject*prtp;
  _aa_nettcpcallobject*calp;
// _tcpcallstatus cs;
 H ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(callhandle==NULL) { return RET_BADPARM; }
// BUGGY;
 *callhandle=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpport_object_id,handle,(VP)&prtp,NULL))!=RET_YES) { return ret; }
 if(prtp->status.calls_answered==0&&prtp->status.calls_waiting==0) { return RET_NOTFOUND; } // ashod december dec 09 2009
// if((ret=aa_NetSystemNextTcpCall(&ch,&aa.net_system.next_tcpportcall_next_counter))!=RET_YES) { return ret; }
 if(iterator==NULL)
  {
  if((ret=aa_NetSystemNextTcpCall(&ch,(VP)&calp,prtp->status.local_adr.port,&prtp->next_call_counter))!=RET_YES) { return ret; }
  }
 else
  {
  if((ret=aa_NetSystemNextTcpCall(&ch,(VP)&calp,prtp->status.local_adr.port,iterator))!=RET_YES) { return ret; }
  }
 if(calp->status.is_inprogress==YES)
  {
  if(calp->status.is_incoming==NO)  { return RET_NOTFOUND; }
  if(calp->status.local_adr.port!=prtp->status.local_adr.port)  { oof;  return RET_NOTFOUND;  }
  }
 if(calp->status.is_incoming!=YES) oof;
// if(calp->status.is_connected==NO) oof;
 if(tcpcallstatus)
  {
  aaNetTcpCallStatus(ch,tcpcallstatus);// donky
//  if(tcpcallstatus->is_incoming==NO) { return RET_NOTFOUND; }
//  if(tcpcallstatus->local_adr.port!=prtp->status.local_adr.port)  {  return RET_NOTFOUND;  }
  }
 else
  {
 // aaNetTcpCallStatus(ch,&cs);
 // if(cs.is_incoming==NO) { return RET_NOTFOUND; }
 // if(cs.local_adr.port!=prtp->status.local_adr.port)  {  return RET_NOTFOUND;  }
  }
//  BUGGY;
 *callhandle=ch;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/






 B aaNetTcpCallCreate                  (HP handle,H sip,W sport,VP host,H ip,W port)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H ii;
 BP bp;
 _aa_objectinstanceheader*oih;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(port==0)  {  return RET_BADPARM;  }
 if(ip==0&&aaStringIsNull(host)!=NO) { return RET_BADPARM; }
  //appLog(2,"cll cr %u %i %s",ip,port,host);
 if((ret=aa_ObjectCreate(aa.net_system.tcpcall_object_id,handle,(VP)&calp))!=RET_YES)
  {
  oops;
  aaNote(0,"net_system.server_object_id=%i",aa.net_system.server_object_id);
   aaNote(0,"%i %i",__LINE__,aa.net_system.sniff_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.icmp_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.udp_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.stunclient_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.tcpport_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.tcpcall_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.client_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.cgiclient_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.server_object_id);
 aaNote(0,"%i %i",__LINE__,aa.net_system.wock_object_id);


  return ret;
  }
 calp->self_handle=*handle;
 //calp->status.remote_adr.ip=ip;
 calp->status.remote_adr.port=port;

  calp->status.index=*handle-((aa.net_system.tcpcall_object_id*aa_OBJ_MAX_PER_ID)+aa_OBJ_BASE_HANDLE);
  aaCast(bp,BP,calp);
  bp-=sizeof(_aa_objectinstanceheader);
  aaCast(oih,_aa_objectinstanceheader*,bp);
  calp->status.session=oih->sesh;//.lo;
  calp->status.number=aa.net_system.net_status.total_tcp_call_count;

  aaStringCopyf(calp->status.hancock,"%s",aa_common_name[calp->status.is_incoming][calp->status.number%26]);
  if((calp->status.number/26)>0) aaStringAppendf(calp->status.hancock,"%u",(calp->status.number/26));

  aa.net_system.net_status.total_tcp_call_count++;

  calp->status.is_incoming=NO;
  calp->status.is_inprogress=YES;
 aaTimerTikGet(&calp->ms_root);
 aaStringNull(calp->status.host);
 calp->status.src_adr.ip=sip;
 calp->status.src_adr.port=sport;
 aaNetAdrToString(&calp->status.src_adr,calp->status.src_dot);


 if(aaStringIsNull(host)==NO&&ip==0)
  {
  aaNetIpFromString(host,&ii);
  if(ii==0)
   {
   aaStringCopy(calp->status.host,host);
   if((ret=aaNetDnsCreate(&calp->dns_handle,host,1,0))!=YES) { oops; }
   calp->is_dns=1;
   calp->status.is_resolving=calp->is_dns;
   return RET_YES;
   }
  if(ip!=0) { oof; }
  ip=ii;
  }
 //aaNote(0,"ip=%u %u",ip,port);
 return(aa_NetSystemTcpCallCreate(handle,ip,port,calp->status.src_adr.ip,calp->status.src_adr.port));
 }













 B aaNetTcpCallDestroy                 (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _aa_nettcpportobject*prtp;
 B isprot,id;
 H port_handle,han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 if(calp->status.proc!=NULL) { calp->status.proc(handle); }

 if(calp->status.adoption_handle!=0)
  {
  if((ret=aa_ObjectFromHandle(&id,calp->status.adoption_handle))!=YES) { oops; }
  if(id==aa.net_system.wock_object_id)
   {
   han=calp->status.adoption_handle;
   if((ret=aaNetTcpCallAdopt(handle,0))!=RET_YES) { oops; }
   if((ret=aaNetWockDestroy(han))!=RET_YES) { oops; }
   if(calp->status.adoption_handle!=0) oof;
   }
  }


 if(calp->status.is_incoming==YES)
  {
  if(aa_NetSystemFindPortBySock(&port_handle,(VP)&prtp,calp->port_sock)!=YES) { oof; Boop; }
  if(calp->status.is_connected==YES) { prtp->status.calls_answered--; }
  else                               { prtp->status.calls_waiting--; }
  prtp->status.calls_inuse--;
  }
 else
  {
  if(calp->dns_handle)
   {
   aaNetDnsDestroy(calp->dns_handle);
   calp->dns_handle=0;
   calp->is_dns=0;
   calp->status.is_resolving=calp->is_dns;
   aa_ObjectDestroy(aa.net_system.tcpcall_object_id,handle);
   return RET_YES;
   }
  }
 if(calp->status.is_closed_by_remote==NO)
  {
  calp->status.is_closed_by_local=YES;
  } // i.e who closed first..
 calp->status.is_close_protected=NO;
 aaNetTcpCallClose(handle);
 if(calp->xmit_que!=0)
  {
  if((ret=aaQueDestroy(calp->xmit_que))!=RET_YES) { oops; }
  }
 if(calp->rcve_que!=0)
  {
  if((ret=aaQueDestroy(calp->rcve_que))!=RET_YES) { oops; }
  }
 if(calp->status.is_incoming==NO)  {  aa.net_system.net_status.current_outgoing_tcp_call_count--;  }
 else                                {  aa.net_system.net_status.current_incoming_tcp_call_count--;  }
 if(calp->status.is_connected==YES)  {  aa.net_system.net_status.current_tcp_calls_connected--;  }
 if(calp->status.extra_bytes!=0)       {  if((ret=aaMemoryRelease(calp->status.extra_data))!=RET_YES) { oops; }  }

 if(calp->socket_used)
  {
  Z rr;
  if((rr=closesocket((SOCKET)calp->sock))!=0)
   {
   aaNote(0,"line=%i sock=%x aa.c han=%x %i %i",__LINE__,calp->sock,handle,rr,WSAGetLastError());
   }
  }

 aa_ObjectDestroy(aa.net_system.tcpcall_object_id,handle);
 return RET_YES;
 }





 B aaNetTcpCallDestroyProcSet          (H handle,V(*proc)(H))
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 calp->status.proc=proc;
 return RET_YES;
 }





 B aaNetTcpCallCloseProtect            (H handle,B state)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(state) { calp->status.is_close_protected=YES; }
 else { calp->status.is_close_protected=NO; }
 return RET_YES;
 }




 B aaNetTcpCallClose                   (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B junk[_2K];
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(calp->status.is_close_protected) { return RET_DENIED; }
// if(quick) { calp->is_quick_close=YES; }
// else      { calp->is_quick_close=NO; }
 if((ret=aaNetTcpCallInactivityReset(handle,YES,YES))!=YES) { oops; }
 if(calp->socket_used==YES&&calp->is_shutdown!=YES)
  {
//  BUG,"closing %i %i %i",handle,calp->status.is_closed_by_local,calp->status.is_closed_by_remote);
//  if(is_aa_quit_posted==YES)///|| calp->status.xmit_bytes==0 ) humphrey
   {
   shutdown(calp->sock,2);
   go=0;
   while(1)
    {
    if(recv(calp->sock,(CP)junk,576,0)<=0) { break; }
    if(is_aa_quit_posted==YES) {  break; }
    if((go++)>10) { break; }
    }
   calp->is_shutdown=YES;
   }
  if(calp->status.is_closed_by_local!=YES)
   {
   aaTimerTikGet(&calp->local_closed_ms_root);
   calp->status.local_closed_ms=0;
   calp->status.closed_ms=calp->status.local_closed_ms;
   }
  calp->status.is_closed_by_local=YES;
  }
//  BUGGY;
 return RET_YES;
 }






 B aaNetTcpCallVitalityGet             (H handle,HP state)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H s;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state!=NULL) { *state=0; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(state==NULL) { return RET_BADPARM; }
 s=0;
 if(calp->status.is_connected==YES)         { s=(H)aaBitSet(s,0); }
 if(calp->status.xmit_bytes!=0)             { s=(H)aaBitSet(s,1); }
 if(calp->status.rcve_bytes!=0)             { s=(H)aaBitSet(s,2); }
 if(calp->status.is_closed_by_local==NO)    { s=(H)aaBitSet(s,3); }
 if(calp->status.is_closed_by_remote==NO)   { s=(H)aaBitSet(s,4); }
 if(calp->status.xmit_inactivity<=100)      { s=(H)aaBitSet(s,5); }
 if(calp->status.rcve_inactivity<=100)      { s=(H)aaBitSet(s,6); }
 if(calp->status.xmit_inactivity<=250)      { s=(H)aaBitSet(s,7); }
 if(calp->status.rcve_inactivity<=250)      { s=(H)aaBitSet(s,8); }
 if(calp->status.xmit_inactivity<=500)      { s=(H)aaBitSet(s,9); }
 if(calp->status.rcve_inactivity<=500)      { s=(H)aaBitSet(s,10); }
 if(calp->status.xmit_inactivity<=1000)     { s=(H)aaBitSet(s,11); }
 if(calp->status.rcve_inactivity<=1000)     { s=(H)aaBitSet(s,12); }
 if(calp->status.xmit_inactivity>1000)      { s=(H)aaBitSet(s,13); }
 if(calp->status.rcve_inactivity>1000)      { s=(H)aaBitSet(s,14); }

 *state=s;
 return RET_YES;
 }





 B aaNetTcpCallStatus                  (H handle,_tcpcallstatus*tcpcallstatus)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 F f1;
 _dnsstatus dns_status;
 H i,mip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }

 aaTimerTikElapsed(calp->ms_root,&calp->status.ms);
 if(calp->dns_handle)
  {
  ret=aaNetDnsStatus(calp->dns_handle,&dns_status);
  if(ret!=YES) { oops; }

  if(dns_status.is_inprogress!=YES)
   {
   if(dns_status.is_found)
    {
    for(i=0;i<32;i++)
     {
     if(dns_status.ip[i]==0)
      {
      if(aaStringIsNull(dns_status.host[i])==NO)
       {
       aaNetIpFromString(dns_status.host[i],&mip);
       if(calp->is_dns==1&&(mip!=dns_status.ip[i]||mip==0))
        {
        if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
        calp->is_dns=2;
        calp->dns_handle=0;
        calp->status.is_resolving=calp->is_dns;
        //if((ret=aaNetDnsCreate(&calp->dns_handle,dns_status.host[i],1,0))!=YES) { oops; }
//        BUG,"redirect to %s",dns_status.host[i]);
        if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
        return RET_YES;
        }
       }
      } ////
     }

//     for(i=0;i<64;i++) { if(dns_status.ip[i]==0) continue;       BUG,"%i/%i, t=%c m=%c %s o=%i",i,dns_status.result_count,dns_status.type[i],dns_status.mode,dns_status.host[i],dns_status.priority[i]);  }
    for(i=0;i<32;i++)
     {
     if(dns_status.ip[i]==0) { continue; }
//      BUG,"%i/%i, t=%c m=%c %s",i,dns_status.result_count,dns_status.type[i],dns_status.mode,dns_status.host[i]);
     //if(dns_status.mode!=0&&dns_status.type[i]!=dns_status.mode) { continue; }
     if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
     calp->is_dns=0;
     calp->status.is_resolving=calp->is_dns;
     calp->dns_handle=0;
//     BUG,"call %s",dns_status.host[i]);
//aaDebugf("ok found ");
     if((ret=aa_NetSystemTcpCallCreate(&handle,dns_status.ip[i],calp->status.remote_adr.port,calp->status.src_adr.ip,calp->status.src_adr.port))!=YES) { oops; }
     if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
     return RET_YES;
     }
    dns_status.is_notfound=YES;
    }

   if(dns_status.is_notfound)
    {
    if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
    calp->is_dns=0;
    calp->status.is_resolving=calp->is_dns;
    calp->dns_handle=0;
    calp->status.is_notfound=YES;
    calp->status.is_failed=YES;
    if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
    return RET_YES;
    }
   if(dns_status.is_failed)
    {
    if((ret=aaNetDnsDestroy(calp->dns_handle))!=YES) { oops; }
    calp->is_dns=0;
    calp->status.is_resolving=calp->is_dns;
    calp->dns_handle=0;
    calp->status.is_failed=YES;
    if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
    return RET_YES;
    }
   }
  if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
  return RET_YES;
  }


// calp->status.slow_xmit_down=NO;
 if(calp->status.is_inprogress)
  {
  if(calp->status.is_connected==YES)
   {
   if(calp->status.remote_adr.port==80)
    {
    }

   aa_NetSystemProcessTcp((VP)&calp);
   //aa_NetSystemProcessTcp((VP)&calp);
//   if(calp->status.xmit_buffer_length!=0&&calp->status.xmit_bytes>calp->status.xmit_buffer_length) { calp->status.slow_xmit_down=YES; }
   }
  }

 aaTimerTikElapsed(calp->inactive_xmit_ms_root,&calp->status.xmit_inactivity);
 aaTimerTikElapsed(calp->inactive_rcve_ms_root,&calp->status.rcve_inactivity);

 if(calp->status.ms>0)
  {
  f1=(F)calp->status.ms/1000.0;
  calp->status.rcve_rate=(H)((F)calp->status.rcve_bytes_total/f1);
  calp->status.xmit_rate=(H)((F)calp->status.xmit_bytes_total/f1);
  }


 if(calp->line_chars>_1MEG) { /* BUG,"Peek[%lu] is %lu off=%lu crlfstate=%i",handle,calp->line_chars,calp->line_peek_offset,calp->crlf_state); */ }

 // idea:
 // should i explicitly set extra data on every callstatuscall ?, because it seems i only set it in aaNetTcpCallExtraDataSet

  calp->status.user_data=calp->user_data;
  calp->status.user_bytes=sizeof(calp->user_data);

 if(tcpcallstatus) { aaMemoryCopy(tcpcallstatus,sizeof(_tcpcallstatus),&calp->status); }
 return RET_YES;
 }






 B aaNetTcpCallNext                    (HP handle,_tcpcallstatus*tcpcallstatus,HP iterator)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(iterator==NULL)
  {
  if((ret=aa_NetSystemNextTcpCall(handle,0,0,&aa.net_system.next_tcpcall_counter))!=RET_YES) { return ret; }
  }
 else
  {
  if((ret=aa_NetSystemNextTcpCall(handle,0,0,iterator))!=RET_YES) { return ret; }
  }
 if(tcpcallstatus) { aaNetTcpCallStatus(*handle,tcpcallstatus); }
 return RET_YES;
 }







 B aaNetTcpCallByIndex                 (HP handle,H index,_tcpcallstatus*tcpcallstatus)
 {
 BP bp;
 _aa_objectinstanceheader*oih;
 H base,instance_stride;
 B id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle)  { *handle=0; }
 id=aa.net_system.tcpcall_object_id;
 if(aa.object_system.object[id].instance_limit==0) { return RET_NOTFOUND; }
 if(index>=aa.object_system.object[id].instance_slots) { return RET_BOUNDS; }
 instance_stride=aa.object_system.object[id].instance_bytes+sizeof(_aa_objectinstanceheader);
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 bp=aa.object_system.object[id].instance_mem;
 bp+=(index*instance_stride);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 if(oih->in_use==YES)
  {
  if(handle!=NULL)  { *handle=(base+index); }
  if(tcpcallstatus) { if(aaNetTcpCallStatus((base+index),tcpcallstatus)!=YES) oof; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }





 B aaNetTcpCallOfferWrite              (H handle,H pid,H tcpcallhandle,_tcpcallterms*tcpcallterms)
 {
 B ret;
 BOOL rt;
 _aa_nettcpcallobject*calp;
 _aa_nettcpcallobject*tcalp;
 _str1k guid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if(pid==0) { return RET_BADPARM;   }
 if((ret=aaNetTcpCallStatus(handle,0))!=YES) { return ret; }
 if(tcpcallterms==NULL) { return RET_BADPARM; }

 if(calp->status.is_connected!=YES)  { return RET_BADSTATE; }
 if(calp->status.is_closed)          { return RET_BADSTATE; }

 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&tcalp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if((ret=aaNetTcpCallStatus(tcpcallhandle,0))!=YES) { return ret; }
 if(tcalp->status.is_connected!=YES)  { return RET_BADSTATE; }
 if(tcalp->status.is_closed)          { return RET_BADSTATE; }


 aaMemoryFill(tcpcallterms,sizeof(_tcpcallterms),0);
 tcpcallterms->magic=0x50054004;
 tcpcallterms->pid=pid;
 //tcpcallterms->is_over_tcpcall=YES;
 tcpcallterms->call.handle=handle;//tcpcallhandle;
 aaMemoryCopy(&tcpcallterms->call.status,sizeof(_tcpcallstatus),&calp->status);//tcs);
 //aaMemoryCopy(&tcpcallterms->sock,sizeof(calp->status.sock),&calp->status.sock);

 rt=WSADuplicateSocket(calp->status.sock,pid,&tcpcallterms->prot_info);
 if(rt==SOCKET_ERROR) { oof; }


 aaStringCopyfLen(guid.buf,&guid.len,"6b67718a-8922-4dd8-8d19-ab7ddfd80384");

 aaNetTcpCallWriteDword(tcpcallhandle,guid.len);
      aaNetTcpCallWrite(tcpcallhandle,guid.len,guid.buf);
 aaNetTcpCallWriteDword(tcpcallhandle,sizeof(_tcpcallterms));
      aaNetTcpCallWrite(tcpcallhandle,sizeof(_tcpcallterms),tcpcallterms);
 aaNetTcpCallWriteDword(tcpcallhandle,0);

 if(aaNetTcpCallStatus(tcpcallhandle,0)!=YES) { oof; }
 return RET_YES;
 }





 B aaNetTcpCallOfferRead               (H handle,_tcpcallterms*tcpcallterms)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chunkbytesa;
 H chunkbytesb;
 H chunkbytesc;
 H need;
 _str1k guid;
 H todo,off;
 B tmp[_8K];
 H term_off;
 H term_len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if((ret=aaNetTcpCallStatus(handle,0))!=YES) { return ret; }
 if(calp->dns_handle)   { return RET_BADSTATE; }
 if(tcpcallterms==NULL) { return RET_BADPARM; }
 if(aaNetTcpCallStatus(handle,0)!=YES)  { oof; }

 if(calp->status.is_connected!=YES) { return RET_BADSTATE; }
 if(calp->status.is_closed)  { return RET_BADSTATE; }

 aaStringCopyfLen(guid.buf,&guid.len,"6b67718a-8922-4dd8-8d19-ab7ddfd80384");

 todo=calp->status.rcve_bytes;
 todo=aaNumRoof(todo,sizeof(tmp));
 need=4;
 if(todo<need) { return RET_NOTREADY; }

 aaNetTcpCallPeek(handle,0,todo,tmp);
 off=0;
 chunkbytesa=*(HP)&tmp[off];
 off+=4;
 need+=chunkbytesa;
 if(todo<need) { return RET_NOTREADY; }

 if(aaStringNCompare(&tmp[off],guid.buf,guid.len,0)!=YES) { oof; }
 off+=guid.len;
 need+=4;
 if(todo<need) { return RET_NOTREADY; }

 chunkbytesb=*(HP)&tmp[off];
 off+=4;
 need+=chunkbytesb;
 if(todo<need) { return RET_NOTREADY; }

 need+=4;
 if(todo<need) { return RET_NOTREADY; }
 aaMemoryCopy(tcpcallterms,chunkbytesb,&tmp[off]);
 term_off=off;
 term_len=chunkbytesb;

 off+=chunkbytesb;
 chunkbytesc=*(HP)&tmp[off];
 if(chunkbytesc!=0) { oof; }
 //aaDebugf("chunkc=%i",chunkbytesc);
 off+=4;
 //aaDebugf("final off=%i need=%i",off,need);
 if(todo<need) { return RET_NOTREADY; }

 if(term_len!=sizeof(_tcpcallterms)) { oof; }
 aaMemoryCopy(tcpcallterms,term_len,&tmp[term_off]);

 //aaDebugf("iversion=%i",tcpcallterms->prot_info.iVersion);
 //aaDebugf("iadfamil=%i",tcpcallterms->prot_info.iAddressFamily);
 //aaDebugf("isocktyp=%i",tcpcallterms->prot_info.iSocketType);
 //aaDebugf("iprotoco=%i",tcpcallterms->prot_info.iProtocol);

 //aaDebugf("proto_info=%i terms=%i off=%i todo=%i",sizeof(tcpcallterms->prot_info),sizeof(tcpcallterms),off,todo);

 aaNetTcpCallDiscard(handle,off);
 if(aaNetTcpCallStatus(handle,0)!=YES)  { oof; }

 return RET_YES;
 }





 B aaNetTcpCallOfferAccept             (HP handle,_tcpcallterms*tcpcallterms)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 BP bp;
 _aa_objectinstanceheader*oih;
 SOCKET sock;
 struct sockaddr_in addr;
 H sip;
 W sport;
 D er;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(tcpcallterms==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.net_system.tcpcall_object_id,handle,(VP)&calp))!=RET_YES) { oops;  return ret; }
 calp->self_handle=*handle;

 //calp->status.remote_adr.ip=ip;
 ///calp->status.remote_adr.port=port;
 calp->status.index=*handle-((aa.net_system.tcpcall_object_id*aa_OBJ_MAX_PER_ID)+aa_OBJ_BASE_HANDLE);
 aaCast(bp,BP,calp);
 bp-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 calp->status.session=oih->sesh;//.lo;
 calp->status.number=aa.net_system.net_status.total_tcp_call_count;

  aaStringCopyf(calp->status.hancock,"%s",aa_common_name[calp->status.is_incoming][calp->status.number%26]);
  if((calp->status.number/26)>0) aaStringAppendf(calp->status.hancock,"%u",(calp->status.number/26));

/// aaStringCopyf(calp->status.hancock,"%s%u",aa_common_name[calp->status.number%2][calp->status.number%26],calp->status.number/26);
 aa.net_system.net_status.total_tcp_call_count++;
 calp->status.is_incoming=NO;
 calp->status.is_inprogress=YES;
 aaTimerTikGet(&calp->ms_root);
 aaStringNull(calp->status.host);
 sip=0;
 sport=0;
 calp->status.src_adr.ip=sip;
 calp->status.src_adr.port=sport;

 aaNetAdrToString(&calp->status.src_adr,calp->status.src_dot);
 sock=WSASocket(AF_INET,SOCK_STREAM,IPPROTO_TCP,&tcpcallterms->prot_info,0,0);
 if(sock==INVALID_SOCKET) { aaNote(0,"err=sock=%u",sock); }

 //sock=socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // was zero instead of proto_tcp
 //if(sock==INVALID_SOCKET)  {   aa_ObjectDestroy(aa.net_system.tcpcall_object_id,*handle);  *handle=0;  return RET_FAILED;  }
 if(sip||sport)
  {
  oof;
  WinSockAddrSet(&addr,AF_INET,sip,htons(sport));
  if(bind(sock,(struct sockaddr *)&addr,sizeof(addr))) { oof; }
  }
 calp->socket_used=YES;

 //aaDebugf("i now control ip=%s,port=%u",tcpcallterms->call.status.remote_dot,tcpcallterms->call.status.remote_adr.port);

 WinSockAddrSet(&addr,AF_INET,tcpcallterms->call.status.remote_adr.ip,htons(tcpcallterms->call.status.remote_adr.port));
 while(1)
  {
  er=WSAAsyncSelect(sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CLOSE);
  if(er==SOCKET_ERROR)
   {
   aaNote(0,"winsockerr=%i",WSAGetLastError());
   ret=RET_FAILED;
   break;
   }
//  error=connect(sock, (struct sockaddr *)&addr, sizeof(addr));
///  if(error==0) { oof; ret=RET_FAILED; break; }
/*
  if(error==SOCKET_ERROR)
   {
   error=WSAGetLastError();
   if(error == WSAENOBUFS||error!=WSAEWOULDBLOCK)     {     ret=RET_FAILED;     break;     }
   }
   */
  if((ret=aaQueCreate(&calp->xmit_que))!=RET_YES) {  break; }
  if((ret=aaQueCreate(&calp->rcve_que))!=RET_YES) {  break; }
  break;
  }
 if(ret!=RET_YES) { oops; }
 calp->sock=sock;
 calp->status.sock=sock;
 calp->status.remote_adr.ip=tcpcallterms->call.status.remote_adr.ip;
 calp->status.remote_adr.port=tcpcallterms->call.status.remote_adr.port;

 if((ret=aa_NetSystemResolveIpPortPair(calp->sock,&calp->status.local_adr.ip,&calp->status.local_adr.port,0,0))!=YES) { oops; }
 aaNetAdrToString(&calp->status.remote_adr,calp->status.remote_dot);
 aaNetAdrToString(&calp->status.local_adr,calp->status.local_dot);

 ///aaDebugf("loc_dot=%s, rem_dot=%s",calp->status.local_dot,calp->status.remote_dot);
 calp->inactive_rcve_ms_root=calp->ms_root;
 calp->inactive_xmit_ms_root=calp->ms_root;
 /// calp->status.inactivity=0; // dec08
 aa.net_system.net_status.current_outgoing_tcp_call_count++;
 aa.net_system.net_status.total_outgoing_tcp_call_count++;
 aaNetTcpCallSlicerLengthSet(*handle,_8K,_8K);//512,512);
 aaNetTcpCallBufferLengthSet(*handle,_32K,_32K);
///aaNetTcpCallNoDelaySet(*handle,NO);
 calp->status.user_data=calp->user_data;
 calp->status.user_bytes=sizeof(calp->user_data);

 aa.net_system.net_status.current_tcp_calls_connected++;
 calp->status.is_connected=YES;

 aaStringCopyf(calp->status.host,"%s",tcpcallterms->call.status.host);
 calp->status.rcve_buffer_length=tcpcallterms->call.status.rcve_buffer_length;
 calp->status.xmit_buffer_length=tcpcallterms->call.status.xmit_buffer_length;
 calp->status.rcve_slicer_length=tcpcallterms->call.status.rcve_slicer_length;
 calp->status.xmit_slicer_length=tcpcallterms->call.status.xmit_slicer_length;
 calp->status.stage=tcpcallterms->call.status.stage;

 aaNetTcpCallStatus(*handle,0);
 return RET_YES;
 }







 B aaNetTcpCallAdopt                   (H handle,H adopteehandle)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { aaNote(0,"aax34 %i %s",handle,ret_string[ret]); return ret; }
 calp->status.adoption_handle=adopteehandle;
 return RET_YES;
 }








 B aaNetTcpCallAnswer                  (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _aa_nettcpportobject*prtp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->status.is_incoming==NO)  {  return RET_FAILED;  }
 if(calp->status.is_connected==YES)  {  return RET_ALREADYOPEN; }
// BUGGY;
 if((ret=aa_NetSystemFindPortBySock(NULL,(VP)&prtp,calp->port_sock))!=RET_YES)
  {
  aaNetTcpCallDestroy(handle);
  return ret;
  }
 if(prtp->status.calls_waiting==0)
  {
  //BUGGY;
  aaNetTcpCallDestroy(handle);
  return RET_FAILED;
  }
 if((ret=aaQueCreate(&calp->xmit_que))!=RET_YES)
  {
  logg("oops=%i line=%i",ret,__LINE__);
  aaNetTcpCallDestroy(handle);
  return ret;
  }
 if((ret=aaQueCreate(&calp->rcve_que))!=RET_YES)
  {
  logg("oops=%i line=%i",ret,__LINE__);
  aaNetTcpCallDestroy(handle);
  return ret;
  }
 logg("tcpcallanswwer rcve que handle=%i",calp->rcve_que);
 logg("tcpcallanswwer xmit que handle=%i",calp->xmit_que);
 if(WSAAsyncSelect(calp->sock,aa.net_system.window,aa.net_system.tcp_message_id,FD_CLOSE))//|FD_WRITE|FD_READ))
  {
  aaNetTcpCallDestroy(handle);
  return RET_FAILED;
  }
 prtp->status.calls_waiting--;
 prtp->status.calls_answered++;
 aa.net_system.net_status.current_tcp_calls_connected++;
 calp->status.is_connected=YES;


 #if 1
 aaNetTcpCallSlicerLengthSet(handle,_8K,_8K);
 aaNetTcpCallBufferLengthSet(handle,_32K,_32K);
 ////aaNetTcpCallNoDelaySet(handle,NO);
 #else
 aaNetTcpCallSlicerLengthSet(handle,_8K,_8K);
 aaNetTcpCallBufferLengthSet(handle,_32K,_32K);
 ///aaNetTcpCallNoDelaySet(handle,NO);
 #endif


//  {  L opt,olen;  opt=TRUE; olen=sizeof(BOOL);  if(setsockopt(calp->sock,SOL_SOCKET,SO_DONTLINGER,(CP)&opt,olen)!=0) oof;  }
// {  L opt,olen;  opt=FALSE; olen=sizeof(BOOL);  if(setsockopt(calp->sock,SOL_SOCKET,SO_DONTLINGER,(CP)&opt,olen)!=0) oof;  }
  calp->status.user_data=calp->user_data;
  calp->status.user_bytes=sizeof(calp->user_data);
 if(prtp->status.extra_bytes!=0)
  {
  if((ret=aaNetTcpCallExtraDataSet(handle,prtp->status.extra_bytes))!=YES) { oops; }
  }
 aaNetTcpCallInactivityReset(handle,YES,YES);
 if(calp->status.is_nodelay)
  {
  Z bnod=calp->status.is_nodelay;
  setsockopt(calp->sock,IPPROTO_TCP,TCP_NODELAY,(CP)&bnod,sizeof(Z));
  ///BUG,"nodelay set b=%i",calp->status.is_nodelay);
  }

 aaNetTcpCallStatus(handle,0);
 return RET_YES;
 }




 B aaNetTcpCallWrite                   (H handle,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _questatus qs;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { aaNote(0,"aax4 %i %s",handle,ret_string[ret]); return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aa_NetSystemProcessTcp((VP)&calp); // dont process, cause we might want to call tcpcall 5 times in a row,,
 // caling process tcp might corrupt tcpcallreturn function

 #if 1
 if((ret=aaQueStatus(calp->xmit_que,&qs))!=RET_YES) { oops; }
 if(calp->status.xmit_bytes!=qs.bytes) { oof; } // if this never happens questatus remover donky
 calp->status.xmit_bytes=qs.bytes;
 #endif


 aaCast(bp,BP,data);
 if(bytes==0) oof;
 if((ret=aaQueWrite(calp->xmit_que,bytes,bp))!=RET_YES) { return ret; }
 aa_NetSystemProcessTcp((VP)&calp); // donky done process, cause we might want to call tcpcall 5 times in a row,,
 return RET_YES;
 }







 B aaNetTcpCallWritef                  (H handle,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 va_list argptr;
 B txt[_4K];
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,txt);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_CallWritef))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(fmt==NULL) { return RET_YES; }
 aaStringLen(tmp,&sl);
 if(sl==0) { return RET_YES; }
 if((ret=aaNetTcpCallWrite(handle,sl,tmp))!=RET_YES) { return ret; }
 return RET_YES;
 }






 B aaNetTcpCallWriteByte               (H handle,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,1,&val));
 }



 B aaNetTcpCallWriteWord               (H handle,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,2,&val));
 }


 B aaNetTcpCallWriteDword              (H handle,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,4,&val));
 }


 B aaNetTcpCallWriteQuad               (H handle,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaNetTcpCallWrite(handle,8,&val));
 }


 B aaNetTcpCallRead                    (H handle,H bytes,VP data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,bytes,data))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,bytes))!=RET_YES) { return ret; }
 return RET_YES;
 }



 B aaNetTcpCallReadByte                (H handle,BP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,1,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,1))!=RET_YES) { return ret; }
 return RET_YES;
 }


 B aaNetTcpCallReadWord                (H handle,WP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,2,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,2))!=RET_YES) { return ret; }
 return RET_YES;
 }


 B aaNetTcpCallReadDword               (H handle,HP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,4,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,4))!=RET_YES) { return ret; }
 return RET_YES;
 }

 B aaNetTcpCallReadQuad                (H handle,QP val)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallPeek(handle,0,8,val))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallDiscard(handle,8))!=RET_YES) { return ret; }
 return RET_YES;
 }



 B aaNetTcpCallPeek                    (H handle,H offset,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aa_NetSystemProcessTcp((VP)&calp);
 if((ret=aaQuePeek(calp->rcve_que,offset,bytes,data))!=RET_YES) {  return ret; }
// aa_NetSystemProcessTcp((VP)&calp); // donky
 return RET_YES;
 }






 B aaNetTcpCallDiscard                 (H handle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if((ret=aaQueDiscard(calp->rcve_que,bytes))!=RET_YES) { return ret; }
 calp->crlf_state=0;
 aa_NetSystemProcessTcp((VP)&calp);
 return RET_YES;
 }




 B aaNetTcpCallFindByte                (H handle,H offset,H bytes,HP pos,B ch,B logic,H number)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 return(aaQueFindByte(calp->rcve_que,offset,bytes,pos,ch,logic,number));
 }




#if 0


 if(bytes==F32) { bytes=calp->status.rcve_bytes; }
 if(bytes==0) { return RET_NOTFOUND; }
 f=0;
 if(fwd==YES)
  {
  s=0;
  off=0;
  left=calp->status.rcve_bytes-s;

  while(1)
   {
   bs=aaNumRoof(left,_2K);
   if(bs==0) { break; }
   if((ret=aaQuePeek(calp->rcve_que,off,bs,block))!=RET_YES) {  oops; }
   aaCast(ptr,BP,block);
   while(1)
    {
    if((*ptr==ch&&logic)||(*ptr!=ch&&!logic))
     {
     if(f==number)     {   if(pos) {   *pos=off+s; }   return RET_YES;     }
     f++;
     }
    bs--;
    if(bs==0) { break; }
    ptr++;
    s++;
    }
   bs=aaNumRoof(left,_2K);
   off+=bs;
   left-=bs;
   s=0;
   }
  return RET_NOTFOUND;
  }
 else
  {
  oof;

  }
 return RET_NOTFOUND;
 }


#endif


 B aaNetTcpCallReturn                  (H handle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B block[_4K];
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(bytes>calp->status.rcve_bytes) { return RET_BOUNDS; }
 if(bytes==calp->status.rcve_bytes) { return RET_YES; }
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_4K);
  if((ret=aaNetTcpCallRead(handle,todo,block))!=RET_YES) { oops; }
  if((ret=aaQueWrite(calp->rcve_que,todo,block))!=RET_YES) { oops; }
  bytes-=todo;
  }
 aa_NetSystemProcessTcp((VP)&calp);
 return RET_YES;
 }




 B aaNetTcpCallPush                    (H handle,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H todo;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,data);
 while(1)
  {
  if(bytes==0) { break; }
  todo=aaNumRoof(bytes,_4K);
  if((ret=aaQueWrite(calp->rcve_que,todo,bp))!=RET_YES) { oops; }
  bytes-=todo;
  bp+=todo;
  }
 aa_NetSystemProcessTcp((VP)&calp);
 return RET_YES;
 }



 B aaNetTcpCallRelay                   (H handle,H bytes,H relayhandle,B how)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 _aa_nettcpcallobject*calp_relay;
 H todo;
 B block[_4K],id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectFromHandle(&id,relayhandle))!=YES) { return ret; }

 if(id==aa.net_system.tcpcall_object_id)
  {
  if((ret=aa_ObjectCheck(id,relayhandle,(VP)&calp_relay,NULL))!=RET_YES) { return ret; }

  while(1)
   {
   todo=aaNumRoof(bytes,_2K);
   if(todo==0) { break; }
   if(how==1||how==3)
    {
    if((ret=aaNetTcpCallRead(relayhandle,todo,block))!=YES) { oops; }
    if((ret=aaNetTcpCallWrite(handle,todo,block))!=YES) { oops; }
    }
   if(how==2||how==3)
    {
    if((ret=aaNetTcpCallRead(handle,todo,block))!=YES) { oops; }
    if((ret=aaNetTcpCallWrite(relayhandle,todo,block))!=YES) { oops; }
    }
   bytes-=todo;
   }
  return RET_YES;
  }
 return RET_DENIED;
 }






 B aaNetTcpCallMirror                  (H handle,_tcpcallstatus*callstatus,H bytes,H han2,_tcpcallstatus*callstatus2,VP buf)
  {
 B ret;
 _aa_nettcpcallobject*calp1;
 _aa_nettcpcallobject*calp2;
 BP tmpbuf=NULL_POINTR;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf) { aaStringNull(buf); }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp1,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,han2,(VP)&calp2,NULL))!=RET_YES) { return ret; }
 if(callstatus)  { if((ret=aaNetTcpCallStatus(handle,callstatus))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(handle,0))!=RET_YES) { oops; }  }
 if(callstatus2) { if((ret=aaNetTcpCallStatus(han2,callstatus2))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(han2,0))!=RET_YES) { oops; }  }
 if(bytes==0) { return RET_YES; }
 if(bytes==F32) { bytes=calp1->status.rcve_bytes; }
 if(bytes==0) { return RET_YES; }
 if(bytes>calp1->status.rcve_bytes) { return RET_NOTREADY; }
 if(buf==NULL)
  {
  if(bytes<_128K)
   {
   if((ret=aa_MemoryTemp((VP)&tmpbuf,_128K,aa_MEMORYTEMP_CallMirror))!=RET_YES) { return ret; }
   }
  else
   {
   if((ret=aa_MemoryTemp((VP)&tmpbuf,bytes+_4K,aa_MEMORYTEMP_CallMirror))!=RET_YES) { return ret; }
   }
  }
 else
  {
  tmpbuf=buf;
  }
 if((ret=aaNetTcpCallRead(handle,bytes,tmpbuf))!=RET_YES) { oops; }
 if((ret=aaNetTcpCallWrite(han2,bytes,tmpbuf))!=RET_YES) { oops; }
 //if(buf)  {  aaMemoryCopy(buf,bytes,tmpbuf);  }
 if(callstatus)  { if((ret=aaNetTcpCallStatus(handle,callstatus))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(handle,0))!=RET_YES) { oops; }  }
 if(callstatus2) { if((ret=aaNetTcpCallStatus(han2,callstatus2))!=RET_YES) { oops; }  }
 else            { if((ret=aaNetTcpCallStatus(han2,0))!=RET_YES) { oops; }  }
 return RET_YES;
 }





 B aaNetTcpCallStringLen               (H handle,HP chars,BP stringmode)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H ma,ch;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,0,&ch,&mo,0,0);
 //
 if(stringmode) *stringmode=mo;
 if(chars)
  {
  //if(ret==YES) aaLog(-1,"look ret=%i ch=%i mo=%i",ret,ch,mo);
  if(mo==aa_STRINGMODE_LF)   { ma=1; } else
  if(mo==aa_STRINGMODE_CR)   { ma=1; } else
  if(mo==aa_STRINGMODE_CRLF) { ma=2; } else { ma=0; } //aaNote(0,"mo=%i",mo); }
  ch=ch+ma;
  *chars=ch;
  }
 //if(ret==RET_YES)   aaLog(-1,"sending chars=%i mode=%i",*chars,*stringmode);
 return ret;
 }



 B aaNetTcpCallStringRead              (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H off,len,ma=0;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,&off,&len,&mo,maxchars,buf);
 if(chars) *chars=len;
 if(stringmode) *stringmode=mo;
 if(ret!=YES) { return ret; }
 if(off!=0) { oof; }
 if(mo==aa_STRINGMODE_LF)   { ma=1; } else
 if(mo==aa_STRINGMODE_CR)   { ma=1; } else
 if(mo==aa_STRINGMODE_CRLF) { ma=2; } else { oof; }
 if((ret=aaNetTcpCallDiscard(handle,len+ma))!=YES) { oops; }
 aaNetTcpCallStatus(handle,0);
 return ret;
 }



 B aaNetTcpCallStringPeek              (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,&off,chars,stringmode,maxchars,buf);
 if(ret!=YES) { return ret; }
 //if(off!=0) { oof; }
 //if((ret=aaNetTcpCallDiscard(handle,chars+2))!=YES) { oops; }
 aaNetTcpCallStatus(handle,0);
 return ret;
 }




 B aaNetTcpCallStringLook              (H handle,H fromoff,H index,HP count,HP offset,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H off,cnt,frm;
 H todo,k,sl,to;
 H atatime,prevatatime,have,go,ma;
 B tmp[_16K];
 B was_found;
 _aa_nettcpcallobject*calp;
 BP bp;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(count) *count=0;
 if(offset) *offset=0;
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if(buf) { aaStringNull(buf); }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 prevatatime=atatime=512;//_16K-100;
 aaNetTcpCallStatus(handle,0);
 have=calp->status.rcve_bytes;
 if(fromoff>=have) { return RET_NOTREADY; }
 have-=fromoff;
 off=cnt=frm=0;
 was_found=NO;
 mo=0;
 ma=0;
 go=0;
 while(1)
  {
  todo=have-off;//calp->status.rcve_bytes-off;
  //if(todo<1) break;
  if(todo<2) break;
  todo=aaNumRoof(todo,atatime);
  aaNetTcpCallPeek(handle,fromoff+off,todo,tmp);
  mo=0;
  for(k=0;k<todo-1;k++)
   {
   mo=0;
   if(tmp[k+0]==LF_CHAR&&tmp[k+1]!=CR_CHAR) { mo=aa_STRINGMODE_LF; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]!=LF_CHAR) { mo=aa_STRINGMODE_CR; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]==LF_CHAR) { mo=aa_STRINGMODE_CRLF; ma=2; } else { continue; }
   to=off+k;
   sl=to-frm;
   if(was_found!=YES)
    {
    if(offset) *offset=frm;
    if(chars) *chars=sl;
    if(stringmode) *stringmode=mo;//aa_STRINGMODE_CRLF;
    }
   if(cnt==index)
    {
    was_found=YES;
    if(buf)
     {
     if(sl>=maxchars) { return RET_BOUNDS; }
     if((ret=aaNetTcpCallPeek(handle,fromoff+frm,sl,buf))!=YES) { oops; return ret; }
     bp=(BP)buf;
     bp[sl]=NULL_CHAR;
     if(count==NULL) { return RET_YES; }
     }
    }
   frm=to+ma;
   cnt++;
   off+=(sl+ma);
   break;
   }
  go++;
  if(mo==0)
   {
   atatime=(go+1)*512;
   if(atatime>=_8K) { break; }
   if(go>32) {  break; }
   atatime=aaNumRoof(atatime,_8K);
   aaNetTcpCallStatus(handle,0);
   have=calp->status.rcve_bytes;
   have-=fromoff;
   atatime=aaNumRoof(atatime,have);

   if(atatime==prevatatime)  { break; }
   prevatatime=atatime;
   off=cnt=frm=0;
   mo=0;
   ma=0;
   //,"atatime=%i %i %i ",atatime,go,have);
   continue;
   }

  }
 if(count) { *count=cnt; }
 if(was_found) { return RET_YES; }
 return RET_NOTREADY;
 }






 B aaNetTcpCallStringDiscard           (H handle)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H off,chars,ma=0;
 B mo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 ret=aaNetTcpCallStringLook(handle,0,0,0,&off,&chars,&mo,0,0);
 if(ret!=YES) { return ret; }
 if(off!=0) { oof; }
 if(mo==aa_STRINGMODE_LF)   { ma=1; } else
 if(mo==aa_STRINGMODE_CR)   { ma=1; } else
 if(mo==aa_STRINGMODE_CRLF) { ma=2; } else { oof; }
 if((ret=aaNetTcpCallDiscard(handle,chars+ma))!=YES) { oops; }
 aaNetTcpCallStatus(handle,0);
 return ret;
 }








 B aaNetTcpCallPause                   (H handle,B rstate,B xstate)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(rstate==YES) { calp->status.is_rcve_paused=YES; }
 else            { calp->status.is_rcve_paused=NO; }
 if(xstate==YES) { calp->status.is_xmit_paused=YES; }
 else            { calp->status.is_xmit_paused=NO; }
 //aaDebugf("rcvpau=%i xmitpau=%i",calp->status.is_rcve_paused,calp->status.is_xmit_paused);
 return RET_YES;
 }







 B aaNetTcpCallExtraDataSet            (H handle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)
  {
  if(calp->status.extra_bytes!=0)
   {
   if((ret=aaMemoryRelease(calp->status.extra_data))!=RET_YES) { oops; }
   }
  calp->status.extra_data=NULL;
  calp->status.extra_bytes=bytes;
  }
 else
  {
  if(calp->status.extra_bytes==0)
   {
   calp->status.extra_data=NULL;
   }

  if(calp->status.extra_bytes!=bytes)
   {
   if((ret=aaMemoryMake((VP)&calp->status.extra_data,bytes))!=RET_YES) { oops; }
   aaMemoryNameSet(calp->status.extra_data,"callextra");
   }
  calp->status.extra_bytes=bytes;
  }
 return RET_YES;
 }





 B aaNetTcpCallExtraDataGet            (H handle,HP bytes,PP ptr)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes) { *bytes=0; }
 if(ptr) { *ptr=0; }
 if(calp->status.extra_bytes!=0)
  {
  if(bytes) { *bytes=calp->status.extra_bytes; }
  if(ptr) { *ptr=calp->status.extra_data; }
  }
 return RET_YES;
 }






 B aaNetTcpCallBufferLengthSet         (H handle,H rbytes,H xbytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 N opt,olen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(rbytes!=calp->status.rcve_buffer_length)
  {
  opt=rbytes; olen=4;
  if(setsockopt(calp->sock,SOL_SOCKET,SO_RCVBUF,(CP)&opt,olen)!=0) oof;
  calp->status.rcve_buffer_length=rbytes;
  }
 if(xbytes!=calp->status.xmit_buffer_length)
  {
  opt=xbytes; olen=4;
  if(setsockopt(calp->sock,SOL_SOCKET,SO_SNDBUF,(CP)&opt,olen)!=0) oof;
  calp->status.xmit_buffer_length=xbytes;
  }
 return RET_YES;
 }




 B aaNetTcpCallSlicerLengthSet         (H handle,H rbytes,H xbytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 ///if(calp->dns_handle) { return RET_BADSTATE; }
 calp->status.rcve_slicer_length=aaNumClamp(rbytes,1,_64K);
 calp->status.xmit_slicer_length=aaNumClamp(xbytes,1,_64K);
 return RET_YES;
 }





 B aaNetTcpCallNoDelaySet              (H handle,B state)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B os;
 Z bnod=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 state&=1;
 os=calp->status.is_nodelay;
 if(os==state) { return RET_YES; }
 calp->status.is_nodelay=state;
 if(calp->status.is_connected)
  {
  bnod=(Z)calp->status.is_nodelay;
  setsockopt(calp->sock,IPPROTO_TCP,TCP_NODELAY,(CP)&bnod,sizeof(Z));
  ///BUG,"nodelay set c=%i",calp->status.is_nodelay);
  }
 return RET_YES;
 }





 B aaNetTcpCallStageSet                (H handle,H stage)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 calp->status.stage=stage;
 return RET_YES;
 }





 B aaNetTcpCallMaxRateSet              (H handle,H rrate,H xrate)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 ///if(calp->dns_handle) { return RET_BADSTATE; }
 calp->status.max_xmit_rate=xrate;
 calp->status.max_rcve_rate=rrate;
 if(rrate>=(F32-2000)) { rrate=F32-2000; }
 if(xrate>=(F32-2000)) { xrate=F32-2000; }
 if(rrate==0)
  {
  calp->is_rcve_backoff=NO;
  }
 else
  {
  if(calp->status.rcve_rate>=rrate)
   {
   calp->is_rcve_backoff=YES;
   //aaDebugf("rcvebbackoff");
   }
  }

 if(xrate==0)
  {
  calp->is_xmit_backoff=NO;
  }
 else
  {
  if(calp->status.xmit_rate>=xrate)
   {
   calp->is_xmit_backoff=YES;
   //aaDebugf("xmitbackoff");
   }
  }
 return RET_YES;
 }





 B aaNetTcpCallInactivityReset         (H handle,B rflag,B xflag)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->dns_handle) { return RET_BADSTATE; }
 if(rflag)  {  aaTimerTikGet(&calp->inactive_rcve_ms_root);  calp->status.rcve_inactivity=0;  }
 if(xflag)  {  aaTimerTikGet(&calp->inactive_xmit_ms_root);  calp->status.xmit_inactivity=0;  }
 return RET_YES;
 }




 B aaNetTcpCallProtocolSet             (H handle,H protocol)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 calp->status.protocol=protocol;
 return RET_YES;
 }



#if 0
/*-----------------------------------------------------------------------*/






 B aaNetSocksLoginWrite                (H tcpcallhandle)
 {
 B ret;
 B buf[_1K];
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 buf[0]=0x01; buf[1]=0x00; buf[2]=0x00;
 return(aaNetTcpCallWrite(tcpcallhandle,3,buf));
 }






 B aaNetSocksConnectDomainWrite        (H tcpcallhandle,VP domain,W port)
 {
 B ret;
 B buf[_1K];
 H sl;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 aaStringLen(domain,&sl);
   buf[0]=0x05;
   buf[1]=0x01;
   buf[2]=0x00;
   buf[3]=0x03;
   buf[4]=(B)sl;
   aaStringNCopy(&buf[5],domain,sl,YES);
   //aaMemoryCopy(&buf[5],sl,domain);
   buf[5+sl]=aaNumSwapWord(port);
      aaDebugf("%i=[%s]",sl,domain);
 return(aaNetTcpCallWrite(tcpcallhandle,5+sl+2,buf));
 }

 #endif



/*-----------------------------------------------------------------------*/


 B aaNetHttpHeaderPrepare              (VP str,N result,B close,N cache,B chunked,G conlen,VP contype)
 {
 _systime st;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(result>0&&result<1000) {  aaStringAppendf(str,"HTTP/1.1 %u\r\n",result);  }
// aaTimeLocalGet(&st);
// aaTimeAdjust(&st,0,-(app.si.timezone_bias_total));

 aaTimeSystemGet(&st);
 aaTimeToString(&st,txt,"GMT",0);
 aaStringAppendf(str,"Date: %s\r\n",txt);
 aaStringAppendf(str,"Server: aaBoost\r\n");
 if(close) { aaStringAppendf(str,"Connection: close\r\n"); }
 else      { aaStringAppendf(str,"Connection: keep-alive\r\n"); }
 if(cache>0)   {  aaStringAppendf(str,"Pragma: public\r\nCache-Control: public; max-age=%ld\r\n",cache); }
 else
 if(cache<0)   {  aaStringAppendf(str,"Pragma: no-cache\r\nCache-Control: no-cache, private, no-store; must-revalidate\r\nExpires: 0\r\n"); }
 if(aaStringIsEmpty(contype,YES)==NO) { aaStringAppendf(str,"Content-type: %s\r\n",contype);  }
 if(chunked==YES) { aaStringAppendf(str,"Transfer-Encoding: chunked\r\n");  }
 else             { if(conlen>=0) { aaStringAppendf(str,"Content-length: %I64d\r\n",conlen); }  }
 return RET_YES;
 }





 B aaNetHttpHeaderCookiePrepare        (VP str,B servermode,VP domain,VP path,G expires,VP name,VP fmt,...)
 {
 va_list argptr;
 B out[_4K];
 B txt[_1K];
 B tmp[_4K];
 BP bp;
 H i,sl;
 _systime st;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,tmp);
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(name==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,tmp);
 aaStringLen(bp,&sl);
 if(sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) { oof; return RET_FAILED; } }
 aaCast(bp,BP,name);
 aaStringLen(bp,&sl);
 if(sl==0||sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) {  return RET_FAILED; } }
 if(path!=NULL)   {  aaStringLen(path,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(domain!=NULL)  {  aaStringLen(domain,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(expires!=0) // if expires is 0, then omit this field, meaning to delete cookie on session end -
  {
  if(expires==-1)  {  aaStringCopyf(txt,"Thu, 01-Jan-1970 00:00:00 GMT");  }
  else
   {
   aaTimeSystemGet(&st);
   aaTimeAdjust(&st,&st,expires);
   aaTimeToString(&st,txt,"GMT",0);
   txt[7]='-';
   txt[11]='-';
   }
  aaStringReplaceChar(txt,0,'-',SPACE_CHAR);
  }
 if(servermode) { aaStringCopyf(out,"Set-Cookie: %s=%s;",name,tmp); }
 else           { aaStringCopyf(out,"Cookie: %s=%s;",name,tmp); }
 if(domain!=NULL) {  aaStringAppendf(out," Domain=%s;",domain); }
 if(expires!=0)   { aaStringAppendf(out," Expires=%s;",txt); }
 if(path!=NULL)   {  aaStringAppendf(out," Path=%s;",path); }
 while(1)
  {
  aaStringLastCharGet(out,0,&ascii);
  if(ascii==0) { break; }
  if(ascii==';') { aaStringLastCharSet(out,0,0,NO); continue; }
  if(aaCharIsVisible(ascii)!=YES) { aaStringLastCharSet(out,0,0,NO); continue; }
  break;
  }
 aaStringAppendf(str,"%s\r\n",out);
 return RET_YES;
 }





 B aaNetHttpHeaderFieldCodeGet         (VP str,H chars,NP which,HP len)
 {
 H i;
 S B textual_string[128][64];
 S H textual_chars[128];
 S H textual_count=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textual_count==0)
  {
  aaStringCopy(textual_string[textual_count],"vary:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-ranges:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"location:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"p3p:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-aspnet-version:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-powered-by:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"expires:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"pragma:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"set-cookie:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"etag:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-cache:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"cache-control:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-type:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"last-modified:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"server:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"date:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-length:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-range:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"connection:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"keep-alive:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"host:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"cookie:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"cookie2:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"user-agent:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-encoding:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-language:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept-charset:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"transfer-encoding:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"referer:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"accept:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"If-Modified-Since:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"te:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"via:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"status:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-forwarded-for:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"age:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-pad:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-os:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-cpu:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-pixels:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"ua-color:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"from:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"x-cache-lookup:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"authorization:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"content-transfer-encoding:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"origin:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"Access-Control-Request-Method:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  aaStringCopy(textual_string[textual_count],"Access-Control-Allow-Origin:");  aaStringLen(textual_string[textual_count],&textual_chars[textual_count]); textual_count++;
  }
 if(len) { *len=0; }
 if(which==NULL) { return RET_BADPARM; }
 *which=-1;
 if(str==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(str,&chars); }
 if(chars==0) { *which=aa_HTTPFIELD_BLANK; if(len) { *len=0; } return RET_YES; }
 for(i=0;i<textual_count;i++)
  {
  if(aaStringNICompare(str,textual_string[i],textual_chars[i],0)!=YES) { continue; }
  if(len) { *len=textual_chars[i]; }
  *which=i+aa_HTTPFIELD_VARY;
  return RET_YES;
  }
 if(len)
  {
  aaStringFindChar(str,chars,&i,':',YES,0,YES);
  if(i==F32) { *len=chars; }
  else       { *len=i+1;  }
  }
 *which=aa_HTTPFIELD_UNIMPLEMENTED;
 return RET_NOTFOUND;
 }




/*-----------------------------------------------------------------------*/

 B aaNetHttpResultReadFromString       (_httpresult*httpresult,H bytes,VP str)
 {
// B ret;
 H chars,val;
 B txt[_2K],token[2][_2K];//,mo;
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(httpresult==NULL) { return RET_BADPARM; }
 httpresult->is_success=NO;
 httpresult->is_failed=NO;
 if(str==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(str,&bytes); }
 if(bytes==0) { return RET_BADPARM; }
 chars=bytes;
 aaMemoryFill(httpresult,sizeof(_httpresult),0);
 if(chars>512) { httpresult->is_failed=YES; return RET_YES; }
 aaStringCopy(txt,str);
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }             //GET / HTTP/1.1
//  BUG,"%s %i",txt,chars);
 if(chars<12) {          httpresult->is_failed=YES; return RET_YES; }
 //if(txt[4]!=SPACE_CHAR) {      httpresult->is_failed=YES; return RET_YES; }
 if(txt[8]!=SPACE_CHAR) {      httpresult->is_failed=YES; return RET_YES; }
 if(aaStringIsNumerical(&txt[9],0,0,3)!=RET_YES)  {      httpresult->is_failed=YES;  return RET_YES; }
 aaStringNCopy(&token[0],&txt[0],8,YES);
 aaStringNCopy(&token[1],&txt[9],3,YES);
 aaStringLower(token[0],0,NULL);
 aaStringIsIString(token[0],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { httpresult->is_failed=YES; oof; return RET_YES; }
 httpresult->is_failed=NO;
 if(which==0) { httpresult->version[0]=0; httpresult->version[1]=9; }
 else
 if(which==1) { httpresult->version[0]=1; httpresult->version[1]=0; }
 else
 if(which==2) { httpresult->version[0]=1; httpresult->version[1]=1; }
 else
 if(which==3) { httpresult->version[0]=1; httpresult->version[1]=2; }
 aaStringToNumber(token[1],3,&val,NULL,0,0);
 httpresult->code=val;
 httpresult->is_success=YES;
 return RET_YES;
 }












 B aaNetHttpHeaderReadFromString       (_httpheader*httpheader,H bytes,VP str)
 {
 B ret;
 H chars,sl,o,count;
 B txt[_4K],token[3][_3K];
 B etc[_2K];//,mo;
 N which;
 H pos,off,xl,ul;
 BP bp;
 _stringexplode se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(httpheader==NULL) { return RET_BADPARM; }
 httpheader->field_code=0;
 httpheader->field[0]=NULL_CHAR;
 httpheader->data[0]=NULL_CHAR;
 httpheader->value[0]=F32;
 httpheader->value[1]=F32;
 httpheader->value[2]=F32;
 httpheader->is_success=NO;
 httpheader->is_failed=NO;
 httpheader->bytes=0;
 aaTimeNull(&httpheader->time);
 httpheader->data_bytes=0;
 if(str==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(str,&bytes); }
 if(bytes==0) { return RET_BADPARM; }
 chars=bytes;
 aaStringCopy(txt,str);
// BUG,"?? %i %i %s",mo,chars,txt);
 httpheader->bytes=chars;
 if(chars==0)  {  httpheader->is_success=YES;  httpheader->is_failed=NO;  httpheader->field_code=aa_HTTPFIELD_BLANK;  return RET_YES;  }
 if(chars>1)   {  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);  aaStringRemoveMultipleSpaces(txt,chars,NO);  aaStringLen(txt,&chars);  }
 sl=chars;
 if(aaStringFindChar(txt,0,&o,':',YES,0,YES)!=YES) {  /* BUG,"a %i %s",sl,txt); */ httpheader->is_failed=YES;  return RET_YES; }
 if(o>64) {  return RET_NOTREADY; }

 aaStringNCopy(token[0],&txt[0],o,YES);
 aaCast(bp,BP,&txt[o]);
 sl-=o;
 if(sl<1)   {   httpheader->is_failed=YES;  return RET_YES; }
 bp++;     sl--;
 if(aaStringFindChar(bp,0,&o,SPACE_CHAR,NO,0,YES)!=YES) {  bp[60]=0; /* BUG,"line=%i  chars=%i  %s",__LINE__,chars,bp); */ httpheader->is_failed=YES; return RET_YES;  }
 bp+=o;    sl-=o;
  // following can be caused by long cookies
 if(sl>=1900) {  aaNote(0,"sss sl=%i %s",sl,token[0]);  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
 aaStringNCopy(token[1],bp,sl,YES);
 aaStringCopy(httpheader->data,token[1]);
 aaStringLower(token[0],0,NULL);
 aaStringLen(token[0],&xl);
 if(xl>64)
  {
  //aaNote(0,"field is %lu chars %s",xl,txt);
//  BUG,"mo=%i chhh=%i",mo,chars);
  return RET_NOTREADY;
  }


 aaStringCopy(httpheader->field,token[0]);
 aaStringIsIString(token[0],&which,"vary",         "accept-ranges", "location",      "p3p",           "x-aspnet-version",
                                   "x-powered-by", "expires",       "pragma",        "set-cookie",    "etag",
                                   "x-cache",      "cache-control", "content-type",  "last-modified", "server",
                                   "date",         "content-length","content-range", "connection",    "keep-alive",
                                   "host",         "cookie",        "cookie2",       "user-agent",    "accept-encoding",
                                   "accept-language", "accept-charset","transfer-encoding","referer", "accept",
                                   "If-Modified-Since","te","via","status",    "x-forwarded-for", "age","x-pad",
                                   "ua-os","ua-cpu","ua-pixels","ua-color","from","x-cache-lookup",
                                   "authorization",
                                   "content-transfer-encoding",
                                   "origin",
                                   "Access-Control-Request-Method",
                                   "Access-Control-Allow-Origin",
                                   "Content-Encoding",
                                   NULL);

//                                   BUG,"handled %s: %s",httpheader->field,httpheader->data);
//BUG,"whic=%i",which);
 if(which==-1)
  {
/////// unimplem:
  //logg("<><> %s",httpheader->field);
///  BUG,"<><> %s=%s=%s=%s",httpheader->field,httpheader->data,token[0],token[1]);
//  if(httpheader->field[0]!='x'&&httpheader->field[1]!='-')   {   BUG,"<><> %s=%s ",httpheader->field,httpheader->data);   }
  aaStringCopy(httpheader->field,token[0]); // should check that slen<64
  aaStringCopy(httpheader->data,token[1]); // should check that slen<2k :-)
  httpheader->is_success=YES;
  httpheader->is_failed=NO;
  httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
  return RET_YES;
  } // change this: make field_value=F32; .. but keep tokens, so user parses

 which+=2;
 httpheader->field_code=which;

 if(which==aa_HTTPFIELD_CONTENTTYPE)
  {
  aaStringLen(httpheader->data,&ul);
  while(1)
   {
   aaStringFindFirstIString(httpheader->data,0,"application/x-www-form-urlencoded",0,&pos); if(pos!=F32) {  httpheader->value[0]=aa_HTTPFORM_URLENCODED; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/form-data",0,&pos); if(pos!=F32) {  httpheader->value[0]=aa_HTTPFORM_MULTIPART; break; }
   aaStringFindFirstIString(httpheader->data,0,"text/plain",0,&pos); if(pos!=F32) { httpheader->value[0]=aa_HTTPFORM_PLAIN; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/mixed",0,&pos); if(pos!=F32) {  httpheader->value[0]=aa_HTTPFORM_MULTIPARTMIXED; break; }
   break;
   }
  if(httpheader->value[0]==aa_HTTPFORM_MULTIPART||httpheader->value[0]==aa_HTTPFORM_MULTIPARTMIXED)
   {
   aaStringFindFirstIString(httpheader->data,0,"boundary=",0,&pos);
   if(pos!=F32)
    {
    pos+=9;
    aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,YES,0,YES);
    if(off!=F32)
     {
     pos+=off;
     aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,NO,0,YES);
     if(off!=F32) pos+=off;
     }
    httpheader->value[1]=pos;
    aaStringLen(&httpheader->data[pos],&httpheader->value[2]);
    etc[0]=etc[1]='-';
    etc[2]=0;
    aaStringNCopy(&etc[2],&httpheader->data[httpheader->value[1]],httpheader->value[2],YES); // etc now holds boundaary text
    aaMemoryFill(httpheader->data,ul,0); // zero out data again
    if(httpheader->value[0]==aa_HTTPFORM_MULTIPART) aaStringCopy(httpheader->data,"multipart/form-data");
    else  aaStringCopy(httpheader->data,"multipart/mixed");
    aaStringCopy(&httpheader->data[50],etc); // point the offset markers to the final data offset
    httpheader->value[1]=50;
    httpheader->value[2]+=2;
//      application/x-www-form-urlencoded;",0,&pos); if(pos!=F32) { httpheader->value[0]=0; break; }
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_TE)
  {
  aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos); if(pos!=F32) { httpheader->value[0]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=F32) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=F32) { httpheader->value[2]=1;  }
  }
 else
 if(which==aa_HTTPFIELD_CONNECTION)
  {
  aaStringIsIString(token[1],(NP)&httpheader->value[0],"close","keep-alive",NULL);
  if((N)httpheader->value[0]!=-1) { httpheader->value[0]++; } // make it 1 and 2
  if((N)httpheader->value[0]==-1)
   {
   while(1)
    {
    aaStringFindFirstIString(httpheader->data,0,"close",0,&pos); if(pos!=F32) { httpheader->value[0]=1; break; }
    aaStringFindFirstIString(httpheader->data,0,"keep-alive",0,&pos); if(pos!=F32) { httpheader->value[0]=2; break; }
    break;
    }
   }
  aaStringFindFirstIString(httpheader->data,0,"te",0,&pos);
  if(pos!=F32)
   {
   httpheader->value[1]=1;
   aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos);
   if(pos!=F32) { httpheader->value[2]=1; }
   }
  }
 else
 if(which==aa_HTTPFIELD_EXPIRES||which==aa_HTTPFIELD_LASTMODIFIED||which==aa_HTTPFIELD_DATE||which==aa_HTTPFIELD_IFMODIFIEDSINCE) // expires & last-modified  &  date
  {
  if(which==aa_HTTPFIELD_EXPIRES&&sl<10)
   {
   if(aaStringExplode(token[1],0,&se,SPACE_CHAR)==YES)
    {
    if(se.count==1&&(se.type[0]==1||se.type[0]==2))
     {
     //BUG,"expires: %s %i",aaBoolStrings(se.type[0]==1,"positive","negative"),se.value[0]);
     aaStringCopy(httpheader->field,token[0]); // should check that slen<64
     aaStringCopy(httpheader->data,token[1]); // should check that slen<2k :-)
     httpheader->is_success=YES;
     httpheader->is_failed=NO;
     httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
     aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
     return RET_YES;
     }
    }
   }
  if(aaTimeFromString(&httpheader->time,token[1])!=RET_YES)
   {
//   BUG,"token[1]=");
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_STATUS)
  {
  ret=aaStringCountNumbers(token[1],0,&o,YES);
  if(ret!=YES||o!=3)
   {
   //BUGGY;
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {
   //BUGGY;
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_CONTENTLENGTH)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
//   BUG,">>>%s=%s",httpheader->field,httpheader->data);
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE) // content-length
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  httpheader->is_success=YES;
  return RET_YES;
  }
 else
 if(which==aa_HTTPFIELD_CONTENTRANGE) // content-range
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  aaStringFindFirstString(bp,0,"bytes ",6,&o);
  if(o==F32) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; } //coza
  bp+=(o+6);      sl-=(o+6);
  if(sl<5) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; }//coza
  aaStringFindChar(bp,sl,&o,'-',YES,0,YES);
  if(o==F32||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  if(aaStringIsNumerical(bp,0,0,o)!=YES) {  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {

   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes); //coza
   return RET_YES;
   }
  bp+=o;   sl-=o;
  if(sl<2) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  bp++;  sl--;
  aaStringFindChar(bp,sl,&o,FSLASH_CHAR,YES,0,YES);
  if(o==F32||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[1],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  bp+=o;  sl-=o;
  if(sl<2) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  bp++;  sl--;
  aaStringCountNumbers(bp,sl,&count,YES);
  if(count<1) { /* BUG,"line=%i %i %i ",__LINE__,sl,count);*/ httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  aaStringNCopy(token[2],bp,count,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[2],NULL,0,0)!=RET_YES)
   {
//   BUG,"token[2]");
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_TRANSFERENCODING) // transfer-encoding
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(aaStringFindFirstString(bp,0,"chunked",7,&o)==RET_YES)
   {
   if(o!=F32)
    {
    httpheader->value[0]=1;
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_AUTHORIZATION)
  {
  }

 else
 if(which==aa_HTTPFIELD_REFERER)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(sl>=sizeof(httpheader->data)) {  httpheader->is_failed=YES; }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE)
  {
  aaNote(0,"az  unhandled %s: %s %i %i",httpheader->field,httpheader->data,which,aa_HTTPFIELD_KEEPALIVE);
  }
 else
 if(which==aa_HTTPFIELD_CONXFERENCODING)
  {
  }
 else
 if(which==aa_HTTPFIELD_CONTENTENCODING)
  {
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=F32) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=F32) { httpheader->value[2]=1;  }
  }

 httpheader->is_success=YES;
 aaStringLen(httpheader->data,&httpheader->data_bytes);
 return RET_YES;
 }





 B aaNetHttpRequestReadFromString      (_httprequest*httprequest,H bytes,VP str)
 {
 //B ret;
 B txt[_4K],token[3][_2K];
 B etc[_4K];//,mo;
 H chars,off,sl;
// H len;
 N which;
// BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(httprequest==NULL) { return RET_BADPARM; }
 httprequest->is_success=NO;
 httprequest->is_failed=NO;
 if(str==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(str,&bytes); }
 if(bytes==0) { return RET_BADPARM; }
 chars=bytes;
 aaStringCopy(txt,str);
 aaMemoryFill(httprequest,sizeof(_httprequest),0);
 if(chars>=1500) { /* BUG,"chars>=1500=%i",chars); */ httprequest->is_failed=YES; return RET_YES; }

// chars-=2; txt[chars]=NULL_CHAR;
// BUG,".. %s",txt);
 if(chars==0)
  {
  httprequest->is_success=YES;
  httprequest->is_failed=NO;
  httprequest->method=0;
  return RET_YES;
  }
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(chars<14)
  {
  aaHistory(-1,"got here again");
//  oof;
//  aaNote(0,"%i\n%i\n%s",__LINE__,txt,chars);
//  BUG,".. mo=%i %i %s",mo,chars,txt);
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_YES;
  }

 sl=chars;
 aaStringFindChar(txt,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) {  /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[0],&txt[off]);
 sl-=off;
 aaStringFindChar(token[0],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==F32) {   /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[0][off]);
 token[0][off]=NULL_CHAR;


 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[1],&etc[off]);
 sl-=off;
 aaStringFindChar(token[1],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==F32) {  /* BUG,"******\nciii %i \n*********",__LINE__); */ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[1][off]);
 token[1][off]=NULL_CHAR;

 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[2],&etc[off]);

 aaStringIsIString(token[0],&which,"get","head","post","put","trace","delete","options","connect",NULL);
 if(which==-1)
  {
//  aaNote(0,"aa,c line=%i token=%s",__LINE__,token[0]);
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_FAILED;
  } // change this: make field_value=F32; .. but keep tokens, so user parses
 httprequest->method=(B)(which+1);

 aaStringIsIString(token[2],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { /* BUG,"******\ndiii %s %i \n*********",token[2],__LINE__); */ httprequest->is_failed=YES; return RET_YES; }
 if(which==0) { httprequest->version[0]=0; httprequest->version[1]=9; }
 else
 if(which==1) { httprequest->version[0]=1; httprequest->version[1]=0; }
 else
 if(which==2) { httprequest->version[0]=1; httprequest->version[1]=1; }
 else
 if(which==3) { httprequest->version[0]=1; httprequest->version[1]=2; }

 aaStringCopy(httprequest->url,token[1]);
 if(aaStringNICompare(httprequest->url,"http://",7,0)==YES)
  {
  aaStringFindChar(httprequest->url,0,&off,FSLASH_CHAR,YES,2,YES);
  if(off!=F32)
   {
   aaStringDeleteChars(httprequest->url,0,0,off);
   }
  }
 aaStringLen(httprequest->url,&httprequest->url_chars);
 httprequest->is_success=YES;
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/





 B aaNetHttpRequestWrite               (H tcpcallhandle,VP host,VP path,H start,H end,B condtype,_systime*condtime,B head,N cache,B close,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B txt[_4K],dot[129],str[_1K];
 _systime st;
 BP bp;
 va_list argptr;
 B etc[_8K];


 aaFmt(fmt,argptr,etc);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
// if(keepalive&&close) { return RET_BADPARM; }
 if(condtime!=NULL&&(condtype<aa_HTTPCONDTYPE_IFMODSINCE||condtype>aa_HTTPCONDTYPE_IFRANGE)) { return RET_BADPARM; }
 if(condtime!=NULL)
  {
  if(aaTimeIsValid(condtime)!=RET_YES) {  return RET_BADPARM;   }
  }
 aaStringNull(txt);
 if(path==NULL)        {  aaStringAppendf(txt,"%s / HTTP/1.1\r\n",(head)?"HEAD":"GET");  }
 else
  {
  aaCast(bp,BP,path);
//  BUG,"papath=%s",path);
  if(bp[0]==NULL_CHAR) {  aaStringAppendf(txt,"%s / HTTP/1.1\r\n",(head)?"HEAD":"GET"); }
  else                 {  aaStringAppendf(txt,"%s %s HTTP/1.1\r\n",(head)?"HEAD":"GET",path); }
  }

 if(host==NULL)
  {
  aaNetIpToString(calp->status.remote_adr.ip,dot);
  if(calp->status.remote_adr.port!=80) { aaStringAppendf(txt,"Host: %s:%i\r\n",dot,calp->status.remote_adr.port); }
  else                                 { aaStringAppendf(txt,"Host: %s\r\n",dot); }
  }
 else                                     { aaStringAppendf(txt,"Host: %s\r\n",host);  }
 // add our time useful for analyzing, request/responce delays, or video streaming, frame<>connection rate ratio

 aaStringAppendf(txt,"Accept: */*\r\n");

 aaTimeSystemGet(&st);
 aaTimeToString(&st,str,"GMT",0);
 aaStringAppendf(txt,"Date: %s\r\n",str);

 if(condtime)
  {
  aaTimeToString(condtime,str,"GMT",0);
  if(condtype==aa_HTTPCONDTYPE_IFMODSINCE) {  aaStringAppendf(txt,"If-Modified-Since: %s\r\n",str); }
  else
  if(condtype==aa_HTTPCONDTYPE_IFRANGE)    {  aaStringAppendf(txt,"If-Range: %s\r\n",str);  }
  }
 if(start!=F32&&end==F32) { aaStringAppendf(txt,"Range: bytes=%i-\r\n",start); } // this causes pipelining to stop if start=0
 else
 if(start==F32&&end!=F32) { aaStringAppendf(txt,"Range: bytes=-%i\r\n",end); }
 else
 if(start==F32&&end==F32) {  }
 else                         { aaStringAppendf(txt,"Range: bytes=%i-%i\r\n",start,end); }
// aaStringAppendf(txt,"Referer: http://web.vwho.net/\r\n");
// aaStringAppendf(txt,"User-Agent: aaBoost\r\n");
 //
 ///aaStringAppendf(txt,"User-agent: aaBoost\r\n");
// aaStringAppendf(txt,"User-agent: Mozilla/5.0(Windows; U; Windows NT 5.2; rv:1.9.2) Gecko/20100101 Firefox/3.6\r\n");
 aaStringAppendf(txt,"User-agent: Mozilla/5.0 (Windows NT 6.0; rv:6.0) Gecko/20100101 Firefox/6.0\r\n");
 //aaStringAppendf(txt,"User-agent: \r\n");

 #if 0
 if(aa.net_system.local_email_checked!=YES) {  aa_NetSystemLocalEmailCheck();  }
 for(i=0;i<aa.net_system.local_email_count;i++)
  {
  if(aa.net_system.local_email[i][0]!=NULL_CHAR)
   {
   aaStringAppendf(txt,"x-htv-usermail-%02i: %s\r\n",i,aa.net_system.local_email[i]);
   }
  }
 #endif
 if(cache>0)  {  aaStringAppendf(txt,"Cache-Control: no-cache, private, no-store; must-revalidate\r\nPragma: no-cache\r\nExpires: %ld\r\n",cache);  }
 else
 if(cache<0)       {  aaStringAppendf(txt,"Cache-Control: public; max-age=%ld\r\nPragma: public\r\n",cache);  }

// aaStringAppendf(txt,"Content-Length: 0\r\n");

 if(aaStringIsNull(etc)==NO) { aaStringAppendf(txt,"%s",etc); }
 if(close==YES) {  aaStringAppendf(txt,"Connection: close\r\n"); }
 else
 if(close==NO)  {  aaStringAppendf(txt,"Connection: Keep-Alive\r\n"); }
 aaStringAppendf(txt,"\r\n");
  //aaDebugf("WRITING:\n-------------------------\n%s-----------------------------",txt);
//  BUG,"\n%s\n-----------------------------",txt);
//aaDebugf("\n%s\n-----------------------------",txt);
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%s",txt))!=RET_YES) { return ret; }


 return RET_YES;
 }







 B aaNetHttpResultRead                 (H tcpcallhandle,_httpresult*httpresult)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,val;
 B txt[_2K],token[2][_2K],mo;
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(httpresult==NULL) { return RET_BADPARM; }
 httpresult->is_success=NO;
 httpresult->is_failed=NO;

 if((ret=aaNetTcpCallStringLen(tcpcallhandle,&chars,&mo))!=RET_YES)  {  return ret;  }
///if(ret==RET_YES) { aaLog(-1,"zzz ch=%i %i",chars,mo); }
 aaMemoryFill(httpresult,sizeof(_httpresult),0);
 if(chars>512) { httpresult->is_failed=YES; return RET_YES; }
 //aaLog(-1,"ss ret=%i %i %i",ret,chars,mo);
 if((ret=aaNetTcpCallRead(tcpcallhandle,chars,txt))!=YES) { oops; }
//aaLog(-1,"mp=%i  charrs=%i txt=%x %x %x",mo,chars,txt[chars-3],txt[chars-2],txt[chars-1]);Z
 if(mo==aa_STRINGMODE_CR)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=CR_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_LF)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_CRLF)
  {
  if(chars<2) { oof; }
  if(txt[chars-2]!=CR_CHAR) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=2;
  txt[chars]=0;
 // BUG,"%i %i %s",mo,chars,txt);
  }
 else
  {
  oof;
  }



 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }             //GET / HTTP/1.1
//  BUG,"%s %i",txt,chars);
 if(chars<12) {      httpresult->is_failed=YES; return RET_YES; }
 if(txt[8]!=SPACE_CHAR) {  httpresult->is_failed=YES; return RET_YES; }
 if(txt[12]!=SPACE_CHAR) {  httpresult->is_failed=YES; return RET_YES; }
 if(aaStringIsNumerical(&txt[9],0,0,3)!=RET_YES)  { httpresult->is_failed=YES;  return RET_YES; }
 aaStringNCopy(&token[0],&txt[0],8,YES);
 aaStringNCopy(&token[1],&txt[9],3,YES);
 aaStringLower(token[0],0,NULL);
 aaStringIsIString(token[0],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { httpresult->is_failed=YES; return RET_YES; }
 httpresult->is_failed=NO;
 if(which==0) { httpresult->version[0]=0; httpresult->version[1]=9; }
 else
 if(which==1) { httpresult->version[0]=1; httpresult->version[1]=0; }
 else
 if(which==2) { httpresult->version[0]=1; httpresult->version[1]=1; }
 else
 if(which==3) { httpresult->version[0]=1; httpresult->version[1]=2; }
 aaStringToNumber(token[1],3,&val,NULL,0,0);
 httpresult->code=val;
 httpresult->is_success=YES;
 return RET_YES;
 }








// to include headers use     aaNetHttpResultWrite(ch,404,"not found\r\n%s",buf);
// otherwise for only status     aaNetHttpResultWrite(ch,404,"not found"; or no status at all if you want


 B aaNetHttpResultWrite                (H tcpcallhandle,H code,VP fmt,...)
 {
 va_list argptr;
 B str[_8K];
 B txt[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if(code<100||code>999) { return RET_BADPARM; }
 aaStringCopyf(txt,"HTTP/1.1 %i %s\r\n",code,str);
// BUG,"writing\n%s",txt);
 return(aaNetTcpCallWritef(tcpcallhandle,"%s",txt));
 }







 B aaNetHttpHeaderRead                 (H tcpcallhandle,_httpheader*httpheader)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,sl,o,count;
 B txt[_4K],token[3][_3K];
 B etc[_2K],mo;
 N which;
 H pos,off,xl,ul;
 BP bp;
 _stringexplode se;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(httpheader==NULL) { return RET_BADPARM; }

 httpheader->field_code=0;
 httpheader->field[0]=NULL_CHAR;
 httpheader->data[0]=NULL_CHAR;
 httpheader->value[0]=F32;
 httpheader->value[1]=F32;
 httpheader->value[2]=F32;
 httpheader->is_success=NO;
 httpheader->is_failed=NO;
 httpheader->bytes=0;
 aaTimeNull(&httpheader->time);
 httpheader->data_bytes=0;

 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,&mo,_2K,txt))!=YES)
  {
  if(ret==RET_NOTREADY) { return ret; }
  oof;
// aaNote(0,"%i %i",chars,mode);
  return ret;
  }
// BUG,"?? %i %i %s",mo,chars,txt);
 httpheader->bytes=chars;
 if(chars==0)  {  httpheader->is_success=YES;  httpheader->is_failed=NO;  httpheader->field_code=aa_HTTPFIELD_BLANK;  return RET_YES;  }
 if(chars>1)   {  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);  aaStringRemoveMultipleSpaces(txt,chars,NO);  aaStringLen(txt,&chars);  }
 sl=chars;
 if(aaStringFindChar(txt,0,&o,':',YES,0,YES)!=YES) {  /* BUG,"a %i %s",sl,txt); */ httpheader->is_failed=YES;  return RET_YES; }
 if(o>64) {  return RET_NOTREADY; }
//BUG,"@@ %i %i %s",mo,chars,txt);
 aaStringNCopy(token[0],&txt[0],o,YES);
 aaCast(bp,BP,&txt[o]);
 sl-=o;
 if(sl<1)   {   httpheader->is_failed=YES;  return RET_YES; }
 bp++;     sl--;
 if(aaStringFindChar(bp,0,&o,SPACE_CHAR,NO,0,YES)!=YES) {  bp[60]=0; /* BUG,"line=%i  chars=%i  %s",__LINE__,chars,bp); */ httpheader->is_failed=YES; return RET_YES;  }
 bp+=o;    sl-=o;
  // following can be caused by long cookies
 if(sl>=1900) {  aaNote(0,"sss sl=%i %s",sl,token[0]);  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
 aaStringNCopy(token[1],bp,sl,YES);
 aaStringCopy(httpheader->data,token[1]);
 aaStringLower(token[0],0,NULL);
 aaStringLen(token[0],&xl);
 if(xl>64)
  {
  //aaNote(0,"field is %lu chars %s",xl,txt);
//  BUG,"mo=%i chhh=%i",mo,chars);
  return RET_NOTREADY;
  }


 aaStringCopy(httpheader->field,token[0]);
 aaStringIsIString(token[0],&which,"vary",         "accept-ranges", "location",      "p3p",           "x-aspnet-version",
                                   "x-powered-by", "expires",       "pragma",        "set-cookie",    "etag",
                                   "x-cache",      "cache-control", "content-type",  "last-modified", "server",
                                   "date",         "content-length","content-range", "connection",    "keep-alive",
                                   "host",         "cookie",        "cookie2",       "user-agent",    "accept-encoding",
                                   "accept-language", "accept-charset","transfer-encoding","referer", "accept",
                                   "If-Modified-Since","te","via","status",    "x-forwarded-for", "age","x-pad",
                                   "ua-os","ua-cpu","ua-pixels","ua-color","from","x-cache-lookup",
                                   "authorization",
                                   "content-transfer-encoding",
                                   "origin",
                                   "Access-Control-Request-Method",
                                   "Access-Control-Allow-Origin",
                                   "Content-Encoding",
                                   NULL);

//                                   BUG,"handled %s: %s",httpheader->field,httpheader->data);
//BUG,"whic=%i",which);
 if(which==-1)
  {
/////// unimplem:
  //logg("<><> %s",httpheader->field);
///  BUG,"<><> %s=%s=%s=%s",httpheader->field,httpheader->data,token[0],token[1]);
//  if(httpheader->field[0]!='x'&&httpheader->field[1]!='-')   {   BUG,"<><> %s=%s ",httpheader->field,httpheader->data);   }
  aaStringCopy(httpheader->field,token[0]); // should check that slen<64
  aaStringCopy(httpheader->data,token[1]); // should check that slen<2k :-)
  httpheader->is_success=YES;
  httpheader->is_failed=NO;
  httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
  return RET_YES;
  } // change this: make field_value=F32; .. but keep tokens, so user parses

 which+=2;
 httpheader->field_code=which;

 if(which==aa_HTTPFIELD_CONTENTTYPE)
  {
  aaStringLen(httpheader->data,&ul);
  while(1)
   {
   aaStringFindFirstIString(httpheader->data,0,"application/x-www-form-urlencoded",0,&pos); if(pos!=F32) {  httpheader->value[0]=aa_HTTPFORM_URLENCODED; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/form-data",0,&pos); if(pos!=F32) {  httpheader->value[0]=aa_HTTPFORM_MULTIPART; break; }
   aaStringFindFirstIString(httpheader->data,0,"text/plain",0,&pos); if(pos!=F32) { httpheader->value[0]=aa_HTTPFORM_PLAIN; break; }
   aaStringFindFirstIString(httpheader->data,0,"multipart/mixed",0,&pos); if(pos!=F32) {  httpheader->value[0]=aa_HTTPFORM_MULTIPARTMIXED; break; }
   break;
   }
  if(httpheader->value[0]==aa_HTTPFORM_MULTIPART||httpheader->value[0]==aa_HTTPFORM_MULTIPARTMIXED)
   {
   aaStringFindFirstIString(httpheader->data,0,"boundary=",0,&pos);
   if(pos!=F32)
    {
    pos+=9;
    aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,YES,0,YES);
    if(off!=F32)
     {
     pos+=off;
     aaStringFindChar(&httpheader->data[pos],0,&off,SPACE_CHAR,NO,0,YES);
     if(off!=F32) pos+=off;
     }
    httpheader->value[1]=pos;
    aaStringLen(&httpheader->data[pos],&httpheader->value[2]);
    etc[0]=etc[1]='-';
    etc[2]=0;
    aaStringNCopy(&etc[2],&httpheader->data[httpheader->value[1]],httpheader->value[2],YES); // etc now holds boundaary text
    aaMemoryFill(httpheader->data,ul,0); // zero out data again
    if(httpheader->value[0]==aa_HTTPFORM_MULTIPART) aaStringCopy(httpheader->data,"multipart/form-data");
    else  aaStringCopy(httpheader->data,"multipart/mixed");
    aaStringCopy(&httpheader->data[50],etc); // point the offset markers to the final data offset
    httpheader->value[1]=50;
    httpheader->value[2]+=2;
//      application/x-www-form-urlencoded;",0,&pos); if(pos!=F32) { httpheader->value[0]=0; break; }
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_TE)
  {
  aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos); if(pos!=F32) { httpheader->value[0]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=F32) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=F32) { httpheader->value[2]=1;  }
  }
 else
 if(which==aa_HTTPFIELD_CONNECTION)
  {
  aaStringIsIString(token[1],(NP)&httpheader->value[0],"close","keep-alive",NULL);
  if((N)httpheader->value[0]!=-1) { httpheader->value[0]++; } // make it 1 and 2
  if((N)httpheader->value[0]==-1)
   {
   while(1)
    {
    aaStringFindFirstIString(httpheader->data,0,"close",0,&pos); if(pos!=F32) { httpheader->value[0]=1; break; }
    aaStringFindFirstIString(httpheader->data,0,"keep-alive",0,&pos); if(pos!=F32) { httpheader->value[0]=2; break; }
    break;
    }
   }
  aaStringFindFirstIString(httpheader->data,0,"te",0,&pos);
  if(pos!=F32)
   {
   httpheader->value[1]=1;
   aaStringFindFirstIString(httpheader->data,0,"chunked",0,&pos);
   if(pos!=F32) { httpheader->value[2]=1; }
   }
  }
 else
 if(which==aa_HTTPFIELD_EXPIRES||which==aa_HTTPFIELD_LASTMODIFIED||which==aa_HTTPFIELD_DATE||which==aa_HTTPFIELD_IFMODIFIEDSINCE) // expires & last-modified  &  date
  {
  if(which==aa_HTTPFIELD_EXPIRES&&sl<10)
   {
   if(aaStringExplode(token[1],0,&se,SPACE_CHAR)==YES)
    {
    if(se.count==1&&(se.type[0]==1||se.type[0]==2))
     {
     //BUG,"expires: %s %i",aaBoolStrings(se.type[0]==1,"positive","negative"),se.value[0]);
     aaStringCopy(httpheader->field,token[0]); // should check that slen<64
     aaStringCopy(httpheader->data,token[1]); // should check that slen<2k :-)
     httpheader->is_success=YES;
     httpheader->is_failed=NO;
     httpheader->field_code=aa_HTTPFIELD_UNIMPLEMENTED;
     aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
     return RET_YES;
     }
    }
   }
  if(aaTimeFromString(&httpheader->time,token[1])!=RET_YES)
   {
//   BUG,"token[1]=");
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_STATUS)
  {
  ret=aaStringCountNumbers(token[1],0,&o,YES);
  if(ret!=YES||o!=3)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_CONTENTLENGTH)
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
//   BUG,">>>%s=%s",httpheader->field,httpheader->data);
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE) // content-length
  {
  if(aaStringIsNumerical(token[1],0,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  if(aaStringToNumber(token[1],0,&httpheader->value[0],&httpheader->value[1],0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);//coza
   return RET_YES;
   }
  httpheader->is_success=YES;
  return RET_YES;
  }
 else
 if(which==aa_HTTPFIELD_CONTENTRANGE) // content-range
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  aaStringFindFirstString(bp,0,"bytes ",6,&o);
  if(o==F32) { httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; } //coza
  bp+=(o+6);      sl-=(o+6);
  if(sl<5) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes); return RET_YES; }//coza
  aaStringFindChar(bp,sl,&o,'-',YES,0,YES);
  if(o==F32||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  if(aaStringIsNumerical(bp,0,0,o)!=YES) {  httpheader->is_failed=YES;aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[0],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes); //coza
   return RET_YES;
   }
  bp+=o;   sl-=o;
  if(sl<2) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  bp++;  sl--;
  aaStringFindChar(bp,sl,&o,FSLASH_CHAR,YES,0,YES);
  if(o==F32||o==0) {  httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  aaStringNCopy(token[2],bp,o,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[1],NULL,0,0)!=RET_YES)
   {
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  bp+=o;  sl-=o;
  if(sl<2) { httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  bp++;  sl--;
  aaStringCountNumbers(bp,sl,&count,YES);
  if(count<1) { /* BUG,"line=%i %i %i ",__LINE__,sl,count);*/ httpheader->is_failed=YES; aaStringLen(httpheader->data,&httpheader->data_bytes);return RET_YES; } //coza
  aaStringNCopy(token[2],bp,count,YES);
  if(aaStringToNumber(token[2],0,&httpheader->value[2],NULL,0,0)!=RET_YES)
   {
//   BUG,"token[2]");
   httpheader->is_failed=YES;
   aaStringLen(httpheader->data,&httpheader->data_bytes);
   return RET_YES;
   }
  }
 else
 if(which==aa_HTTPFIELD_TRANSFERENCODING) // transfer-encoding
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(aaStringFindFirstString(bp,0,"chunked",7,&o)==RET_YES)
   {
   if(o!=F32)
    {
    httpheader->value[0]=1;
    }
   }
  }
 else
 if(which==aa_HTTPFIELD_AUTHORIZATION)
  {
  }

 else
 if(which==aa_HTTPFIELD_REFERER)
  {
  aaCast(bp,BP,token[1]);
  aaStringLen(bp,&sl);
  if(sl>=sizeof(httpheader->data)) {  httpheader->is_failed=YES; }
  }
 else
 if(which==aa_HTTPFIELD_KEEPALIVE)
  {
  aaNote(0,"az  unhandled %s: %s %i %i",httpheader->field,httpheader->data,which,aa_HTTPFIELD_KEEPALIVE);
  }
 else
 if(which==aa_HTTPFIELD_CONXFERENCODING)
  {
  }
 else
 if(which==aa_HTTPFIELD_CONTENTENCODING)
  {
  aaStringFindFirstIString(httpheader->data,0,"deflate",0,&pos); if(pos!=F32) { httpheader->value[1]=1;  }
  aaStringFindFirstIString(httpheader->data,0,"gzip",0,&pos); if(pos!=F32) { httpheader->value[2]=1;  }
  }

 httpheader->is_success=YES;
 aaStringLen(httpheader->data,&httpheader->data_bytes);
 return RET_YES;
 }






 B aaNetHttpRequestRead                (H tcpcallhandle,_httprequest*httprequest)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B txt[_4K],token[3][_2K];
 B etc[_4K],mo;
 H chars,off,sl;
// H len;
 N which;
// BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(httprequest==NULL) { return RET_BADPARM; }

 httprequest->is_success=NO;
 httprequest->is_failed=NO;
 if((ret=aaNetTcpCallStringLen(tcpcallhandle,&chars,&mo))!=RET_YES)
  {
  return ret;
  }
 aaMemoryFill(httprequest,sizeof(_httprequest),0);
 if(chars>=1500) { /* BUG,"chars>=1500=%i",chars); */ httprequest->is_failed=YES; return RET_YES; }
 aaNetTcpCallRead(tcpcallhandle,chars,txt);


  if(mo==aa_STRINGMODE_CR)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=CR_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_LF)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_CRLF)
  {
  if(chars<2) { oof; }
  if(txt[chars-2]!=CR_CHAR) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=2;
  txt[chars]=0;
  }
 else
  {
  oof;
  }



// chars-=2; txt[chars]=NULL_CHAR;
// BUG,".. %s",txt);
 if(chars==0)
  {
  httprequest->is_success=YES;
  httprequest->is_failed=NO;
  httprequest->method=0;
  return RET_YES;
  }
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(chars<14)
  {
  aaHistory(-1,"got here again");
//  oof;
//  aaNote(0,"%i\n%i\n%s",__LINE__,txt,chars);
//  BUG,".. mo=%i %i %s",mo,chars,txt);
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_YES;
  }

 sl=chars;
 aaStringFindChar(txt,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) {  /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[0],&txt[off]);
 sl-=off;
 aaStringFindChar(token[0],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==F32) {   /*oof;*/ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[0][off]);
 token[0][off]=NULL_CHAR;


 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[1],&etc[off]);
 sl-=off;
 aaStringFindChar(token[1],0,&off,SPACE_CHAR,YES,0,YES);
 if(off==F32) {  /* BUG,"******\nciii %i \n*********",__LINE__); */ httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(etc,&token[1][off]);
 token[1][off]=NULL_CHAR;

 aaStringLen(etc,&sl);
 aaStringFindChar(etc,0,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) { oof; httprequest->is_failed=YES;  return RET_YES; }
 aaStringCopy(token[2],&etc[off]);

 aaStringIsIString(token[0],&which,"get","head","post","put","trace","delete","options","connect",NULL);
 if(which==-1)
  {
//  aaNote(0,"aa,c line=%i token=%s",__LINE__,token[0]);
  httprequest->is_failed=YES;
  httprequest->method=0;
  return RET_FAILED;
  } // change this: make field_value=F32; .. but keep tokens, so user parses
 httprequest->method=(B)(which+1);

 aaStringIsIString(token[2],&which,"HTTP/0.9","HTTP/1.0","HTTP/1.1","HTTP/1.2",NULL);
 if(which==-1) { /* BUG,"******\ndiii %s %i \n*********",token[2],__LINE__); */ httprequest->is_failed=YES; return RET_YES; }
 if(which==0) { httprequest->version[0]=0; httprequest->version[1]=9; }
 else
 if(which==1) { httprequest->version[0]=1; httprequest->version[1]=0; }
 else
 if(which==2) { httprequest->version[0]=1; httprequest->version[1]=1; }
 else
 if(which==3) { httprequest->version[0]=1; httprequest->version[1]=2; }

 aaStringCopy(httprequest->url,token[1]);
 if(aaStringNICompare(httprequest->url,"http://",7,0)==YES)
  {
  aaStringFindChar(httprequest->url,0,&off,FSLASH_CHAR,YES,2,YES);
  if(off!=F32)
   {
   aaStringDeleteChars(httprequest->url,0,0,off);
   }
  }
 aaStringLen(httprequest->url,&httprequest->url_chars);
 httprequest->is_success=YES;
 return RET_YES;
 }









 B aaNetHttpBasicAuthorizationWrite    (H tcpcallhandle,VP username,VP password)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 B str[_4K];
 H chars;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(username==NULL) { return RET_BADPARM; }
 if(password==NULL) { return RET_BADPARM; }
 if(aaStringIsNull(username)==YES) { return RET_BADPARM; }
 if(aaStringIsNull(password)==YES) { return RET_BADPARM; }
 aaStringCopyf(str,"%s:%s",username,password);
 aaBase64Encode(str,0,&str[_2K],&chars);
 //aaDebugf("is %s",&str[_2K]);

 ret=aaNetTcpCallWritef(tcpcallhandle,"Authorization: Basic %s\r\n",&str[_2K]);
 return ret;
 }







  // remember to put dashes between date, month, year -- not spaces

 B aaNetHttpCookieSet                  (H tcpcallhandle,VP domain,VP path,G expires,VP name,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 va_list argptr;
 B str[_4K];
 B txt[_1K];
 B tmp[_4K];
 BP bp;
 H i,sl;
 _systime st;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,tmp);
 if(name==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 aaCast(bp,BP,tmp);
 aaStringLen(bp,&sl);
 if(sl==0||sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) { return RET_FAILED; } }
 aaCast(bp,BP,name);
 aaStringLen(bp,&sl);
 if(sl==0||sl>255) { return RET_BADPARM; }
 for(i=0;i<sl;i++) { if(bp[i]==';'||bp[i]==SPACE_CHAR||bp[i]==COMMA_CHAR) { return RET_FAILED; } }
 if(path!=NULL)  {  aaStringLen(path,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(domain!=NULL)  {  aaStringLen(domain,&sl); if(sl==0||sl>255) { return RET_BADPARM; }  }
 if(expires!=-1) // if expires is 0, then omit this field, meaning to delete cookie on session end -
  {
  aaTimeSystemGet(&st);
  aaTimeAdjust(&st,&st,expires);
  aaTimeToString(&st,txt,"GMT",0);
  txt[7]='-';
  txt[11]='-';
  }
 aaStringCopyf(str,"Set-Cookie: %s=%s;",name,tmp);
 if(domain!=NULL) {  aaStringAppendf(str," domain=%s;",domain); }
 if(path!=NULL)   {  aaStringAppendf(str," path=%s;",path); }
 if(expires!=-1)   { aaStringAppendf(str," expires=%s;",txt); }
 aaStringLastCharGet(str,0,&ascii); if(ascii==';') { aaStringLastCharSet(str,0,0,NO); }
 return(aaNetTcpCallWritef(tcpcallhandle,"%s\r\n",str));
 }


// aaStringCopyf(str,"%s, %02ld %s %04ld %02ld:%02ld:%02ld\0",aa_timeday[a],stp->date,aa_timemonth[b-1],stp->year,stp->hour,stp->minute,stp->second,stp->ms);
// Wed, 31 Dec 2008 23:22:22 GMT





 B aaNetHttpChunkSizePeek              (H tcpcallhandle,HP bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H by,sz;
 B tmp[_1K];
 B mode;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==NULL) { return RET_BADPARM; }
// *bytes=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallStringPeek(tcpcallhandle,&by,&mode,sizeof(tmp),tmp))!=RET_YES) { return ret; }
 if(by>10) { return RET_CORRUPTED; }
 if(by==0) { return RET_NOTREADY; }
 aaStringHexToNumber(tmp,by,&sz,0,NULL,NULL);
 *bytes=sz;
 return ret;
 }








 B aaNetHttpChunkSizeRead              (H tcpcallhandle,HP bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H by,sz;
 B tmp[_1K];
 B mode;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==NULL) { return RET_BADPARM; }
// *bytes=0;
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&by,&mode,sizeof(tmp),tmp))!=RET_YES) { return ret; }
 if(by>10) { return RET_CORRUPTED; }
 if(by==0) { return RET_NOTREADY; }
 aaStringHexToNumber(tmp,by,&sz,0,NULL,NULL);
 *bytes=sz;
 return ret;
 }








 B aaNetHttpChunkSizeWrite             (H tcpcallhandle,H bytes)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
// return(aaNetTcpCallWritef(tcpcallhandle,"%lx%s",bytes,(bytes==0)?"\r\n\r\n":";\r\n"));
 return(aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n",bytes));
 }





 B aaNetHttpChunkWritef                (H tcpcallhandle,VP fmt,...)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 va_list argptr;
 H bytes;
 B tmp[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,tmp);
 aaStringLen(tmp,&bytes);
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n%s\r\n",bytes,tmp))!=YES) { oops; }
 return RET_YES;
 }




 B aaNetHttpChunkWrite                 (H tcpcallhandle,H bytes,VP data)
 {
 B ret;
 _aa_nettcpcallobject*calp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=0&&data==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(bytes==0&&data==NULL)
  {
  if((ret=aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n",bytes))!=YES) { oops; }
  if((ret=aaNetTcpCallWritef(tcpcallhandle,"\r\n"))!=YES) { oops; }
  return RET_YES;
  }
 if(bytes==0)  {  aaStringLen(data,&bytes);  }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%lx;\r\n",bytes))!=YES) { oops; }
 if((ret=aaNetTcpCallWrite(tcpcallhandle,bytes,data))!=YES) { oops; }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"\r\n"))!=YES) { oops; }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaNetSmtpResultRead                 (H tcpcallhandle,_smtpresult*smtpresult)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,s_code,off,len;
 B txt[_2K],s_txt[_4K],mo;
 _parser sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(smtpresult==NULL) { return RET_BADPARM; }
 smtpresult->code=0;
 smtpresult->is_fold=NO;
 smtpresult->is_failed=NO;
 smtpresult->is_success=NO;
 aaStringNull(smtpresult->text);
 if((ret=aaNetTcpCallStringLen(tcpcallhandle,&chars,&mo))!=RET_YES)  {  return ret;  }
 aaMemoryFill(smtpresult,sizeof(_smtpresult),0);
 if(chars>=_2K) { smtpresult->is_failed=YES; return RET_YES; }
 if((ret=aaNetTcpCallRead(tcpcallhandle,chars,txt))!=RET_YES) oops;

 if(mo==aa_STRINGMODE_CR)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=CR_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_LF)
  {
  if(chars<1) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=1;
  txt[chars]=0;
  }
 else
 if(mo==aa_STRINGMODE_CRLF)
  {
  if(chars<2) { oof; }
  if(txt[chars-2]!=CR_CHAR) { oof; }
  if(txt[chars-1]!=LF_CHAR) { oof; }
  chars-=2;
  txt[chars]=0;
  }
 else
  {
  oof;
  }


// chars-=2; txt[chars]=NULL_CHAR;
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 s_code=0;
 aaStringNull(s_txt);

 aaParserInit(&sp,txt,chars);
 // look for first non-space

 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) { smtpresult->is_failed=YES; return RET_YES; }
 aaParserSeek(&sp,off);
 // count how many consequtive numbers
 aaStringCountNumbers(sp.bp,sp.to_end,&len,YES);
 if(len!=3) { smtpresult->is_failed=YES; return RET_YES; }
 aaStringToNumber(sp.bp,len,&s_code,NULL,0,0);

 if(s_code==0)
  {
  if(chars!=0)
   {
   if(chars>=_2K) { chars=_2K; }
   aaStringNCopy(smtpresult->text,txt,chars,YES);
   }
  smtpresult->is_failed=YES;
  return RET_YES;
  }
 smtpresult->code=s_code;
 // advance to after the number
 aaParserSeek(&sp,3);
 // see if its a space or a hyphon, if so then we treat this as a folded line
 if(*sp.bp=='-')
  {
  smtpresult->is_success=YES;
  smtpresult->is_fold=YES;
  smtpresult->is_failed=NO;
  // if continue mode, make sure that code is same as last line !!
  //continue_mode=YES;
  // find next space
  //aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,YES);
  //aaParserSeek(&sp,off);
  //BUG,".. %s",sp.bp);
  aaStringCopy(smtpresult->text,sp.bp);
  return RET_YES;
  }

 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off!=F32)
  {
  aaParserSeek(&sp,off);
  if(*sp.bp>=33) { aaStringCopy(smtpresult->text,sp.bp); }
  }
 smtpresult->is_success=YES;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaNetFtpResultRead                  (H tcpcallhandle,_ftpresult*ftpresult)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 H chars,s_code,off,len,pos,cnt,i,val;
 B txt[_2K],s_txt[_4K],tok[_2K],mo;
 _parser sp,pa;
 BP byteptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(ftpresult==NULL) { return RET_BADPARM; }
 ftpresult->code=0;
 ftpresult->is_fold=NO;
 ftpresult->is_failed=NO;
 ftpresult->is_success=NO;
 ftpresult->pasv_adr.ip=0;
 ftpresult->pasv_adr.port=0;
 aaStringNull(ftpresult->text);
// if((ret=aaNetTcpCallStringLen(tcpcallhandle,&chars,&mo))!=RET_YES)  {  return ret;  }
// aaMemoryFill(ftpresult,sizeof(_ftpresult),0);
// if(chars>=_2K) { ftpresult->is_failed=YES; return RET_YES; }
 ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,&mo,sizeof(txt),txt);
 if(ret==RET_NOTREADY) { return ret; }
 if(ret!=YES) { oops; }


/// aaLog(-777,"shit %i=[%s]",chars,txt);
 if(chars>1)
  {
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringRemoveMultipleSpaces(txt,chars,NO);
  aaStringLen(txt,&chars);
  }
 if(txt[0]==SPACE_CHAR&&txt[1]==NULL_CHAR&&chars==1)
  {
  return RET_NOTREADY;
  }

// BUG,"... %lu %i %i  %s",tcpcallhandle,chars,txt[0],txt);
 s_code=0;
 aaStringNull(s_txt);

 aaParserInit(&sp,txt,chars);
 // look for first non-space

  if(chars!=0) { if(chars>=_2K) { chars=_2K; } aaStringNCopy(ftpresult->text,txt,chars,YES);   }

 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off==F32) { ftpresult->is_failed=YES; return RET_YES; }
 aaParserSeek(&sp,off);
 // count how many consequtive numbers
 aaStringCountNumbers(sp.bp,sp.to_end,&len,YES);
 if(len!=3) { ftpresult->is_failed=YES; return RET_YES; }
 aaStringToNumber(sp.bp,len,&s_code,NULL,0,0);

 if(s_code==0)
  {
//  if(chars!=0) { if(chars>=_2K) { chars=_2K; } aaStringNCopy(ftpresult->text,txt,chars,YES);   }
  ftpresult->is_failed=YES;
  return RET_YES; ///
  }

 ftpresult->code=s_code;
 // advance to after the number
 aaParserSeek(&sp,3);
 /////////////////////////////

   if(ftpresult->code==227)
    {
    aaParserCopy(&pa,&sp,YES);
    if(aaStringFindChar(pa.bp,pa.to_end,&pos,'(',YES,0,YES)==YES)
     {
     aaParserSeek(&pa,pos);
     if(aaStringFindChar(pa.bp,pa.to_end,&pos,')',YES,0,YES)==YES)
      {
      aaStringNCopy(tok,pa.bp,pos+1,YES);
      tok[0]=tok[pos]=',';
      aaStringCountChars(tok,0,&cnt,',',NO,YES);
      if(cnt==7)
       {
       aaParserInit(&pa,tok,0);
       aaCast(byteptr,BP,&ftpresult->pasv_adr);
       for(i=0;i<6;i++)
        {
        if(aaStringFindChar(pa.bp,pa.to_end,&off,',',YES,i+0,YES)!=YES) { break; }
        if(aaStringFindChar(pa.bp,pa.to_end,&pos,',',YES,i+1,YES)!=YES) { break; }
        off++;
        len=(pos-off);
        if(len>=1&&len<=3)
         {
         aaStringCountNumbers(&pa.bp[off],len,&cnt,NO);
         if(len==cnt)
          {
          aaStringToNumber(&pa.bp[off],len,&val,0,0,0);
          byteptr[i]=(B)val;
          }
         }
        }
       if(i==6) { ftpresult->pasv_adr.port=(W)aaNumSwapWord(ftpresult->pasv_adr.port); }
       else     { aaNetAdrSet(&ftpresult->pasv_adr,0,0); }
//       BUG,"%i:%i",ftpresult->pasv_adr.ip,ftpresult->pasv_adr.port);
       }
      }
     }
    }
   //////////



 // see if its a space or a hyphon, if so then we treat this as a folded line
 if(*sp.bp=='-')
  {
  ftpresult->is_success=YES;
  ftpresult->is_fold=YES;
  // if continue mode, make sure that code is same as last line !!
  //continue_mode=YES;
  // find next space
  //aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,YES);
  //aaParserSeek(&sp,off);
  //BUG,".. %s",sp.bp);
  aaStringCopy(ftpresult->text,sp.bp);
  return RET_YES;    ////
  }

 aaStringFindChar(sp.bp,sp.to_end,&off,SPACE_CHAR,NO,0,YES);
 if(off!=F32)
  {
  aaParserSeek(&sp,off);
  if(*sp.bp>=33) { aaStringCopy(ftpresult->text,sp.bp); }
  }
 ftpresult->is_success=YES;
 return RET_YES;
 }







 B aaNetFtpMlsdRead                    (H tcpcallhandle,_ftpmlsd*ftpmlsd)
 {
 B ret;
 H chars,i,pos,crc,sl,dw;
 B buf[_4K];
 _stringexplode sex;
 B txt[_4K],tok[_4K],key[_2K],val[_2K];
 N which;

 _aa_nettcpcallobject*calp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(ftpmlsd==NULL) { return RET_BADPARM; }
 ftpmlsd->bytes=0;
 ftpmlsd->is_file=NO;
 ftpmlsd->is_dir=NO;
 ftpmlsd->is_parent_dir=NO;
 ftpmlsd->is_current_dir=NO;
 ftpmlsd->type=0;
 ftpmlsd->permission[0]=0;
 ftpmlsd->modified_string[0]=0;
 ftpmlsd->name[0]=0;
 aaTimeNull(&ftpmlsd->modified);
 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,0,sizeof(buf),buf))!=YES) { return ret; }
 if((ret=aaStringExplode(buf,chars,&sex,';'))!=YES) oops;
 for(i=0;i<sex.count;i++)
  {
  if(aaStringExplodeTokenGet(buf,i,&sex,txt)!=YES) continue;
  if(aaStringFindChar(txt,0,&pos,'=',YES,0,YES)==YES&&aaStringSplit(txt,0,pos,NO,&tok[0],&tok[_2K])==YES)
   {
   crc=0;
   aaStringCopyf(key,"%s",&tok[0]);
   aaStringCopyf(val,"%s",&tok[_2K]);
   aaStringHashGet(key,0,&crc,NO);
   if(crc==0x3165b05d)
    {
    aaStringIsIString(val,&which,"file","dir","cdir","pdir",NULL);
    if(which!=-1)
     {
     if(which==0) { ftpmlsd->is_file=YES; }
     else
     if(which==1) { ftpmlsd->is_dir=YES; }
     else
     if(which==2) { ftpmlsd->is_current_dir=YES; }
     else
     if(which==3) { ftpmlsd->is_parent_dir=YES; }
     ftpmlsd->type=(B)(which+1);      continue;
     }
    }
   else
   if(crc==0xc052dea7||crc==0x92e983d5)
    {
    aaStringToNumber(val,0,0,0,0,&ftpmlsd->bytes);
    continue;
    }
   else
   if(crc==0x346708ed)
    {
    aaStringLen(val,&sl);
    if(sl==14)
     {
     if(aaStringIsNumerical(val,0,0,sl)==YES)
      {
      aaStringToNumber(&val[0],4,&dw,0,0,0); ftpmlsd->modified.year=(W)dw;
      aaStringToNumber(&val[4],2,&dw,0,0,0); ftpmlsd->modified.month=(W)dw;
      aaStringToNumber(&val[6],2,&dw,0,0,0); ftpmlsd->modified.date=(W)dw;
      aaStringToNumber(&val[8],2,&dw,0,0,0); ftpmlsd->modified.hour=(W)dw;
      aaStringToNumber(&val[10],2,&dw,0,0,0); ftpmlsd->modified.minute=(W)dw;
      aaStringToNumber(&val[12],2,&dw,0,0,0); ftpmlsd->modified.second=(W)dw;
      }
     }
    continue;
    }
   continue;
   }
  aaStringRemoveSpaces(txt,0,YES,YES);
  aaStringCopyf(txt,"%s",txt);
  aaStringCopyf(ftpmlsd->name,"%s",txt);
  }
 aaTimeToString(&ftpmlsd->modified,ftpmlsd->modified_string,0,0);
 return RET_YES;
 }




//-----------


 B aaNetRedisPacketRead                (H tcpcallhandle,BP type,GP arg,HP chars,H maxchars,VP buf)
 {
 B ret;
 _tcpcallstatus cs;
 //H lines;
 H off,charss,also,need,hash;
 B buff[_4K];
 //H val,need;
 G gval;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type) *type=0;
 if(arg) *arg=0;
 if(chars) *chars=0;
 if(buf) aaStringNull(buf);
 aaCast(bp,BP,buf);
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 if((ret=aaNetTcpCallStringLook(tcpcallhandle,0,0,0,&off,&charss,0,sizeof(buff),buff))!=YES) { return ret; }
 if(charss==0) { oof; return RET_FAILED; }
 //aaDebugf("bug=%s",buff);
 if(buff[0]=='+') ///===================================== STATUS
  {
  if(type) *type=aa_REDISTYPE_Status;
  if(buf)
   {
   also=charss-1;
   if(also>=maxchars) return RET_BOUNDS;
   aaMemoryCopy(bp,also,&buff[1]);
   bp[also]=NULL_CHAR;
   if(chars) *chars=also;
   }
  if(arg)
   {
   if((charss-1)==6) {    if(aaStringNCompare(&buff[1],"QUEUED",6,0)==YES) { *arg=aa_REDISARG_QUEUED; }    }
   else
   if((charss-1)==2) {    if(aaStringNCompare(&buff[1],"OK",2,0)==YES) { *arg=aa_REDISARG_OK; }    }
   }
  aaNetTcpCallStringDiscard(tcpcallhandle);
  return RET_YES;
  }
 if(buff[0]=='-') ///===================================== ERROR
  {
  if(type) *type=aa_REDISTYPE_Error;
  if(buf)
   {
   also=charss-1;
   if(also>=maxchars) return RET_BOUNDS;
   aaMemoryCopy(bp,also,&buff[1]);
   bp[also]=NULL_CHAR;
   if(chars) *chars=also;
   }
  aaNetTcpCallStringDiscard(tcpcallhandle);
  return RET_YES;
  }
 if(buff[0]==':') ///===================================== INTEGER
  {
  also=charss;
//  if(buff[1]=='-') { also-=2; aaStringToNumber(&buff[2],0,&val,0,0,0); val=aaNumNeg(val); }
//  else             { also-=1; aaStringToNumber(&buff[1],0,&val,0,0,0);  }
  if(buff[1]=='-') { also-=2; aaStringToNumber(&buff[2],0,0,0,&gval,0); gval=aaNumNeg(gval); }
  else             { also-=1; aaStringToNumber(&buff[1],0,0,0,&gval,0);  }

  if(type) *type=aa_REDISTYPE_Integer;
  //if(arg) *arg=(Z)val;
  if(arg) *arg=gval;
  aaNetTcpCallStringDiscard(tcpcallhandle);
  return RET_YES;
  }
 if(buff[0]=='$') ///===================================== BULK
  {
//  if(buff[1]=='-') { aaStringToNumber(&buff[2],0,&val,0,0,0); val=aaNumNeg(val); }
//  else             { aaStringToNumber(&buff[1],0,&val,0,0,0);  }
  if(buff[1]=='-') { aaStringToNumber(&buff[2],0,0,0,&gval,0); gval=aaNumNeg(gval); }
  else             { aaStringToNumber(&buff[1],0,0,0,&gval,0);  }

  need=off+charss+2;
  //if((Z)val>=0) need+=(val);
  if(gval>=0) need+=gval;
  need+=2;
  if(cs.rcve_bytes<need) { return RET_NOTREADY;; }
  if(type) *type=aa_REDISTYPE_Bulk;
  //if(arg) *arg=(Z)val;
  ///if(arg) *arg=gval;
  //if((Z)val>0) also=(H)val;
  //else         also=0;
  if(gval>0) also=(H)gval;
  else       also=0;

  if(buf)   {   if(also>=maxchars) return RET_BOUNDS;   }
  if((aaNetTcpCallDiscard(tcpcallhandle,off+charss+2))!=YES) oof;
  if(buf)
   {
   if(also)
    {
    if((aaNetTcpCallRead(tcpcallhandle,also,bp))!=YES) oof;
    bp[also]=NULL_CHAR;
    if(arg)
     {
     hash=0;
     aaStringHashGet(bp,also,&hash,NO);
     *arg=hash;
     }
    if(chars) *chars=also;
    }
   }
  if((aaNetTcpCallDiscard(tcpcallhandle,2))!=YES) oof;
  return RET_YES;
  }
 if(buff[0]=='*') ///===================================== MULTI
  {
//  if(buff[1]=='-') { aaStringToNumber(&buff[2],0,&val,0,0,0); val=aaNumNeg(val); }
//  else             { aaStringToNumber(&buff[1],0,&val,0,0,0);  }
  if(buff[1]=='-') { aaStringToNumber(&buff[2],0,0,0,&gval,0); gval=aaNumNeg(gval); }
  else             { aaStringToNumber(&buff[1],0,0,0,&gval,0);  }

  if(type) *type=aa_REDISTYPE_Multi;
  //if(arg) *arg=(Z)val;
  if(arg) *arg=gval;
  if(aaNetTcpCallStringDiscard(tcpcallhandle)!=YES) oof;
  return RET_YES;
  }
 aaNote(0,"???  %i %i %s",off,charss,buff);
 return RET_FAILED;
 }





 B aaNetRedisPacketWritef              (H tcpcallhandle,VP fmt,...)
 {
 B ret;
 _tcpcallstatus cs;
 B str[_16K];
 B ascii;
 va_list argptr;
 _stringtokermini toker;
 H i,sl;
 B tok[_2K];
 B out[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaFmt(fmt,argptr,str);
 while(1)
  {
  aaStringLastCharGet(str,0,&ascii);
  if(ascii==NULL_CHAR) break;
  if(ascii==CR_CHAR) { aaStringLastCharSet(str,0,0,1); continue; }
  if(ascii==LF_CHAR) { aaStringLastCharSet(str,0,0,1); continue; }
  break;
  }
 if((ret=aaStringTokerMini(str,0,&toker))!=YES) { oops; }
 aaStringNull(out);
 aaStringAppendf(out,"*%i\r\n",toker.count);
 for(i=0;i<toker.count;i++)
  {
  if(toker.sl[i]>=sizeof(tok)) {  oof; }
  sl=toker.sl[i];
  aaStringNCopy(tok,&str[toker.off[i]],sl,YES);
  if(sl>=2)
   {
   if(tok[0]==DQUOTE_CHAR&&tok[sl-1]==DQUOTE_CHAR) { aaStringContract(tok,sl,1); sl-=2; }
   else
   if(tok[0]==QUOTE_CHAR&&tok[sl-1]==QUOTE_CHAR) { aaStringContract(tok,sl,1); sl-=2; }
   }
  aaStringAppendf(out,"$%i\r\n",sl);
  aaStringAppendf(out,"%s\r\n",tok);
  }
 if((ret=aaNetTcpCallWritef(tcpcallhandle,"%s\r\n",out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }



 B aaNetRedisRespBegin                 (H tcpcallhandle,H elcount)
 {
 B ret;
 _tcpcallstatus cs;
 B out[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaStringCopyfLen(out,&sl,"*%u\r\n",elcount);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }


 B aaNetRedisRespBulkAppend            (H tcpcallhandle,H bytes,VP data)
 {
 B ret;
 _tcpcallstatus cs;
 B out[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 if(data!=NULL)
  {
  if(bytes==0) { aaStringLen(data,&bytes); }
  }
 aaStringCopyfLen(out,&sl,"$%u\r\n",bytes);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 if(bytes)
  {
  if((ret=aaNetTcpCallWrite(tcpcallhandle,bytes,data))!=YES) { return ret; }
  aaStringCopyfLen(out,&sl,"\r\n");
  if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
  }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }




 B aaNetRedisRespBulkAppendf           (H tcpcallhandle,VP fmt,...)
 {
 B ret;
 B str[_4K];
 va_list argptr;
 _tcpcallstatus cs;
 B out[_4K];
 H sl,bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&bytes);
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaStringCopyfLen(out,&sl,"$%u\r\n",bytes);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 if((ret=aaNetTcpCallWrite(tcpcallhandle,bytes,str))!=YES) { return ret; }
 out[0]=CR_CHAR; out[1]=LF_CHAR;
 if((ret=aaNetTcpCallWrite(tcpcallhandle,2,out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }


 B aaNetRedisRespIntegerAppend         (H tcpcallhandle,G val)
 {
 B ret;
 _tcpcallstatus cs;
 B out[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 aaStringCopyfLen(out,&sl,":%I64d\r\n",val);
 if((ret=aaNetTcpCallWrite(tcpcallhandle,sl,out))!=YES) { return ret; }
 return(aaNetTcpCallStatus(tcpcallhandle,0));
 }

/*-----------------------------------------------------------------------*/


 B aaNetSsDbSizeRead                   (H tcpcallhandle,HP size)
 {
 B ret;
 B buf[_1K];
 H chars,val;
 B mode;
 _tcpcallstatus cs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(size==NULL) { return RET_BADPARM; }
 *size=0;
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 if(cs.rcve_bytes==0) { return RET_NOTREADY; }
 if((ret=aaNetTcpCallPeek(tcpcallhandle,0,1,buf))!=YES) { oops; }
 if(buf[0]==LF_CHAR)  {  aaNetTcpCallDiscard(tcpcallhandle,1);  return RET_YES;  }
 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,&mode,sizeof(buf),buf))!=RET_YES) {  oops;  return ret;  }
 if((ret=aaStringIsNumerical(buf,NO,NO,chars))!=RET_YES) { aaNote(0,"func=%s line=%i chars=%i buf=%s mode=%i %s",__func__,__LINE__,chars,buf,mode,arets); }
 aaStringToNumber(buf,chars,&val,0,0,0);
 *size=val+1;
 return RET_YES;
 }




 B aaNetSsDbPacketWrite                (H tcpcallhandle,VP fmt,...)
 {
 B ret;
 B tok[_8K];
 B out[_8K];
 H i,tl;
 _stringtokermini tokermini;
 _tcpcallstatus cs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaVargsf4K(fmt);
 if((ret=aaNetTcpCallStatus(tcpcallhandle,&cs))!=YES) { return ret; }
 if((ret=aaStringTokerMini(str4k.buf,str4k.len,&tokermini))!=YES) { oops; }
 if(tokermini.count==0) { oof; return RET_FAILED; }
 aaStringNull(out);
 for(i=0;i<tokermini.count;i++)
  {
  if((ret=aaStringTokerMiniStringGet(tok,i,sizeof(tok),&tokermini))!=YES) { oops; break; }
  aaStringLen(tok,&tl);
  //if(tl==2&&tok[0]==DQUOTE_CHAR&&tok[1]==DQUOTE_CHAR)   {   tl=1; tok[0]=32; tok[1]=0;   }
  aaStringAppendf(out,"%u\n%s\n",tl,tok);
  }
  //aaDebugf("[%s]",out);
 aaNetTcpCallWritef(tcpcallhandle,"%s\n",out);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaNetIrcAdrToParts                  (VP address,_ircadrparts*ircadrparts)
 {
 B flag;
 B tok[_4K];
 B etc[_4K];
 H off,pos,ooo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(address==NULL) { return RET_BADPARM; }
 aaMemoryFill(ircadrparts,sizeof(_ircadrparts),0);
 if(aaStringIsEmpty(address,YES)!=NO) { return RET_BADPARM; }
 aaStringCopyf(ircadrparts->address,"%s",address);
 flag=0;
 aaStringCopyf(tok,"%s",address);
 aaStringNull(&etc[_0K]);  aaStringNull(&etc[_1K]);   aaStringNull(&etc[_2K]);   aaStringNull(&etc[_3K]);
 off=0;
 while(1)
  {
  if(aaStringFindFirstIString(&tok[off],0,"!",0,&pos)!=YES) { break; }
  aaStringNCopy(&etc[_0K],&tok[off],pos,YES); off+=(pos+1);
  if(aaStringFindFirstIString(&tok[off],0,"@",0,&pos)!=YES) { break; }
  aaStringNCopy(&etc[_1K],&tok[off],pos,YES); off+=(pos+1);

  aaStringCopy(&etc[_2K],&tok[off]);
  //BUG,"cac=[%s][%s][%s]",&etc[_0K],&etc[_1K],&etc[_2K]);
  if(aaNetIpIsValid(&etc[_2K])==YES)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  if(aaStringFindCharList(&etc[_2K],0,&ooo,":",YES,0,NO)==YES)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  if(aaStringFindCharList(&etc[_2K],0,&pos,"./",YES,0,YES)==YES)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  //BUG,"could=[%s]",&etc[_2K]);
  if(aaStringIsEmpty(&etc[_2K],YES)==NO)
   {
   flag=aaBitSet(flag,0);
   break;
   }
  break;
  }
 if(aaBitGet(flag,0)!=YES) { return RET_FAILED; }
 aaStringCopyf(ircadrparts->nick,"%s",&etc[_0K]);
 aaStringCopyf(ircadrparts->user,"%s",&etc[_1K]);
 aaStringCopyf(ircadrparts->host,"%s",&etc[_2K]);
 return RET_YES;
 }



 B aaNetIrcMsgRead                     (H tcpcallhandle,_ircmsg*ircmsg,VP raw)
 {
 B ret;
 _aa_nettcpcallobject*calp;
 BP bp;
 B buf[_8K];
 B prefix[_1K];
 B trailer[_1K];
 B command[_1K];
 B params[_1K];
 B midsec[_4K];
 B tok[_2K];
 _parser pa,pb,pc;
 H mid_pos,i,j;
 H pos,hh,chars;
 _stringtokermini toker_mini;
// _ircadrparts iparts;
 //B flag;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,tcpcallhandle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(ircmsg==NULL) { return RET_BADPARM; }
 if(raw) { aaStringNull(raw); }

 aaStringNull(prefix);
 aaStringNull(command);
 aaStringNull(params);
 aaStringNull(midsec);
 aaStringNull(trailer);

 ircmsg->is_failed=NO;
 ircmsg->is_success=NO;
 ircmsg->is_prefix=NO;
 ircmsg->prefix_is_adr=NO;
 ircmsg->is_command=NO;
 ircmsg->command_is_num=NO;
 ircmsg->is_target=NO;
 ircmsg->is_params=NO;
 ircmsg->is_trailer=NO;
 ircmsg->trailer_is_adr=NO;
 ircmsg->command_code=0;

 aaStringNull(ircmsg->prefix);
  ircmsg->prefix_adr.address[0]=NULL_CHAR;
  ircmsg->prefix_adr.nick[0]=NULL_CHAR;
  ircmsg->prefix_adr.user[0]=NULL_CHAR;
  ircmsg->prefix_adr.host[0]=NULL_CHAR;

 aaStringNull(ircmsg->command);
 aaStringNull(ircmsg->target);
 aaStringNull(ircmsg->params);
 ircmsg->param_count=0;
 for(i=0;i<aaElementCount(ircmsg->param_offlen);i++)
  {
  ircmsg->param_offlen[i][0]=ircmsg->param_offlen[i][1]=0;
  ircmsg->param_is_adr[i]=NO;
  ircmsg->param[i][0]=NULL_CHAR;
  ircmsg->param_adr[i].address[0]=NULL_CHAR;
  ircmsg->param_adr[i].nick[0]=NULL_CHAR;
  ircmsg->param_adr[i].user[0]=NULL_CHAR;
  ircmsg->param_adr[i].host[0]=NULL_CHAR;
  }
 aaStringNull(ircmsg->trailer);
 ircmsg->trailer_is_adr=NO;
  ircmsg->trailer_adr.address[0]=NULL_CHAR;
  ircmsg->trailer_adr.nick[0]=NULL_CHAR;
  ircmsg->trailer_adr.user[0]=NULL_CHAR;
  ircmsg->trailer_adr.host[0]=NULL_CHAR;


 if((ret=aaNetTcpCallStringRead(tcpcallhandle,&chars,0,sizeof(buf),buf))!=YES) return ret;
 //BUG,"raw: ??%s??",buf);
 if(raw) { aaStringCopy(raw,buf); }
 aaCast(bp,BP,buf);
 aaParserInit(&pa,bp,0);
 aaParserInit(&pc,bp,0);
 if(aaParserSeekToVisibleChar(&pa,YES)!=YES) oof;
 if(pa.bp[0]==':')
  {
  aaParserSeek(&pa,1);
  aaParserCopy(&pb,&pa,NO);
  if(aaStringFindChar(pa.bp,pa.to_end,&pos,32,YES,0,YES)!=YES) { oof; }
  aaStringNCopy(prefix,pa.bp,pos,YES);
  aaParserSeek(&pa,pos);
  if(aaParserSeekToVisibleChar(&pa,YES)!=YES) oof;
  }
 mid_pos=pa.offset;
 aaParserSeek(&pc,mid_pos);
 aaStringNCopy(midsec,pc.bp,pc.to_end,YES);
 aaStringFindFirstIString(pa.bp,pa.to_end," :",0,&pos);
 if(pos!=F32)  {  midsec[pos]=0;  }
 if(pos!=F32)
  {
  aaParserCopy(&pb,&pa,NO);
  aaParserSeek(&pa,pos+2);
  if(pa.to_end>0)   {   aaStringNCopy(trailer,pa.bp,pa.to_end,YES);   }
  aaParserCopy(&pa,&pb,NO);
  }
 if(aaStringFindChar(midsec,0,&pos,SPACE_CHAR,YES,0,YES)==YES)
  {
  aaStringCopyf(params,"%s",&midsec[pos+1]);
  midsec[pos]=0;
  aaStringCopyf(command,"%s",midsec);
  }
 else
  {
  aaStringCopyf(command,"%s",midsec);
  }
 ircmsg->is_failed=NO;
 ircmsg->is_success=YES;
 if(aaStringIsEmpty(prefix,YES)==NO) { ircmsg->is_prefix=YES; aaStringCopyf(ircmsg->prefix,"%s",prefix); }
 if(aaStringIsEmpty(command,YES)==NO) { ircmsg->is_command=YES; aaStringCopyf(ircmsg->command,"%s",command); }
 if(aaStringIsEmpty(params,YES)==NO) { ircmsg->is_params=YES; aaStringCopyf(ircmsg->params,"%s",params); }
 if(aaStringIsEmpty(trailer,YES)==NO) { ircmsg->is_trailer=YES; aaStringCopyf(ircmsg->trailer,"%s",trailer); }

 if(ircmsg->is_prefix)
  {
  if(aaNetIrcAdrToParts(ircmsg->prefix,&ircmsg->prefix_adr)==YES)
   {
   ircmsg->prefix_is_adr=YES;
   }
  }

 if(ircmsg->is_command)
  {
  hh=0;
  if(aaStringIsNumerical(command,0,0,0)==YES)
   {
   ircmsg->command_is_num=YES;
   if(aaStringToNumber(command,0,&hh,0,0,0)!=YES) { oof; }
   ircmsg->command_code=hh;
   }
  else
   {
   hh=0;
   if(aaStringHashGet(command,0,&hh,NO)!=YES) oof;
   ircmsg->command_code=hh;
   }
  }

 if(aaStringIsEmpty(ircmsg->params,YES)==NO)
  {
  if((ret=aaStringTokerMini(ircmsg->params,0,&toker_mini))!=YES)  {  aaNote(0,"hocket=[%s]",ircmsg->params); oops;  }
  if(ircmsg->command_is_num==YES) { j=1; }
  else                            { j=0; }

  if(ircmsg->command_is_num==YES)
   {
   aaStringNCopy(tok,&ircmsg->params[toker_mini.off[0]],toker_mini.sl[0],YES);
   aaStringCopyf(ircmsg->target,"%s",tok);
   ircmsg->is_target=YES;
   }

  ircmsg->param_count=toker_mini.count-j;
  for(i=0;i<ircmsg->param_count;i++)
   {
   ircmsg->param_offlen[i][0]=toker_mini.off[i+j];
   ircmsg->param_offlen[i][1]=toker_mini.sl[i+j];
   //aaStringNCopy(tok,&ircmsg->params[toker_mini.off[i+j]],toker_mini.sl[i+j],YES);
   aaStringNCopy(ircmsg->param[i],&ircmsg->params[toker_mini.off[i+j]],toker_mini.sl[i+j],YES);
   if(aaNetIrcAdrToParts(ircmsg->param[i],&ircmsg->param_adr[i])==YES)
    {
    ircmsg->param_is_adr[i+j]=YES;
    }
   }



  if(ircmsg->command_is_num==YES&&aaStringIsEmpty(ircmsg->target,YES)==NO&&ircmsg->param_count!=0)
   {
   pos=ircmsg->param_offlen[0][0];
   aaStringDeleteChars(ircmsg->params,0,0,pos);
   for(i=0;i<ircmsg->param_count;i++)
    {
    ircmsg->param_offlen[i][0]-=pos;
    //ircmsg->param_offlen[i][1]=ircmsg->param_offlen[i+1][1];
    ircmsg->param_is_adr[i]=ircmsg->param_is_adr[i+1];
    }
   }
  }

 if(ircmsg->is_trailer)
  {
  if(aaNetIrcAdrToParts(ircmsg->trailer,&ircmsg->trailer_adr)==YES) {  ircmsg->trailer_is_adr=YES;   }
  }
 return RET_YES;
 }




 B aaNetIrcMsgToString                 (_ircmsg*ircmsg,VP raw,VP str)
 {
 H i;
 B txt[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str) { aaStringNull(str); }
 if(ircmsg==NULL) { return RET_BADPARM; }
 aaStringNull(txt);
 if(aaStringIsEmpty(raw,YES)==NO)
  {
  aaStringAppendf(txt,"          raw=[%s]\r\n",raw);
  }
 if(ircmsg->is_prefix)
  {
  aaStringAppendf(txt,"       prefix=[%s]\r\n",ircmsg->prefix);
  }
 if(ircmsg->prefix_is_adr)
  {
//  aaStringAppendf(txt,"      ispfadr=%i\r\n",ircmsg->prefix_is_adr);
  //if(aaNetIrcAdrToParts(ircmsg->prefix,&iparts)!=YES)  { oof; }
  //aaStringAppendf(txt,"       .parts=[%s] [%s] [%s]\r\n",iparts.nick,iparts.user,iparts.host);
  aaStringAppendf(txt,"             =[%s] [%s] [%s]\r\n",ircmsg->prefix_adr.nick,ircmsg->prefix_adr.user,ircmsg->prefix_adr.host);
//  aaStringAppendf(txt,"        .nick=[%s]\r\n",iparts.nick);
//  aaStringAppendf(txt,"        .user=[%s]\r\n",iparts.user);
//  aaStringAppendf(txt,"        .host=[%s]\r\n",iparts.host);
  }
 if(ircmsg->is_command)
  {
  if(ircmsg->command_is_num)
   {
   aaStringAppendf(txt," command_code=%u\r\n",ircmsg->command_code);
   }
  else
   {
   aaStringAppendf(txt,"      command=[%s]\r\n",ircmsg->command);
   aaStringAppendf(txt," command_code=0x%08x\r\n",ircmsg->command_code);
   }
  }
// if(aaStringIsEmpty(ircmsg->target,YES)==NO)
 if(ircmsg->is_target)//..prefix_is_adr)
  {
  //aaStringAppendf(txt,"       target=[%s]\r\n",ircmsg->target);
  aaStringAppendf(txt,"       target=[%s]\r\n",ircmsg->target);
  }
 //aaStringAppendf(txt," comand_is_nm=[%i]\r\n",ircmsg->command_is_num);
 if(ircmsg->is_params)
 {
 if(ircmsg->param_count!=0)
  {
  aaStringAppendf(txt,"       params=[%s]\r\n",ircmsg->params);
  }
 //aaStringAppendf(txt," param_a_cont=%u\r\n",ircmsg->param_arg_count);
 for(i=0;i<ircmsg->param_count;i++)
  {
  //aaStringNCopy(str,&ircmsg->params[ircmsg->param_offlen[index][0]],ircmsg->param_offlen[index][1],YES);
///  aaNetIrcMsgParamToString(ircmsg,i,tom[i]);//           (_ircmsg*ircmsg,H index,VP str)
  ///aaStringNCopy(tom[i],&ircmsg->params[ircmsg->param_arg_offlen[i][0]],ircmsg->param_arg_offlen[i][1],YES);
  ///aaStringAppendf(txt," paramarg[%02i]=[%s]\r\n",i,tom[i]);
  aaStringAppendf(txt,"    param[%02i]=[%s]\r\n",i,ircmsg->param[i]);//tom[i]);
  if(ircmsg->param_is_adr[i])
   {
   ///aaStringAppendf(txt,"    ispadr[%i]=%i\r\n",i,ircmsg->param_arg_is_adr[i]);
   //if(aaNetIrcAdrToParts(tom[i],&iparts)!=YES)  { oof; }
   //aaStringAppendf(txt,"       .parts=[%s] [%s] [%s]\r\n",iparts.nick,iparts.user,iparts.host);
   aaStringAppendf(txt,"             =[%s] [%s] [%s]\r\n",ircmsg->param_adr[i].nick,ircmsg->param_adr[i].user,ircmsg->param_adr[i].host);
   //aaStringAppendf(txt,".nick=[%s] .user=[%s] .host=[%s]\r\n",iparts.nick,iparts.user,iparts.host);
//   aaStringAppendf(txt,"        .nick=[%s]\r\n",iparts.nick);
//   aaStringAppendf(txt,"        .user=[%s]\r\n",iparts.user);
//   aaStringAppendf(txt,"        .host=[%s]\r\n",iparts.host);
   }
  }
 }
 if(ircmsg->is_trailer)
  {
  aaStringAppendf(txt,"      trailer=[%s]\r\n",ircmsg->trailer);
  if(ircmsg->trailer_is_adr)
   {
  //aaStringAppendf(txt,"      istradr=%i\r\n",ircmsg->trailer_is_adr);
  //if(aaNetIrcAdrToParts(ircmsg->trailer,&iparts)!=YES)  { oof; }
  aaStringAppendf(txt,"             =[%s] [%s] [%s]\r\n",ircmsg->trailer_adr.nick,ircmsg->trailer_adr.user,ircmsg->trailer_adr.host);
  //aaStringAppendf(txt,".nick=[%s] .user=[%s] .host=[%s]\r\n",iparts.nick,iparts.user,iparts.host);
//  aaStringAppendf(txt,"        .nick=[%s]\r\n",iparts.nick);
//  aaStringAppendf(txt,"        .user=[%s]\r\n",iparts.user);
//  aaStringAppendf(txt,"        .host=[%s]\r\n",iparts.host);
   }
  }
 //aaStringAppendf(txt," ");

 aaStringLastCharNonVisibleRemove(txt,0);
 if(str) { aaStringCopyf(str,"%s",txt); }
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/


 B aaNetPortListRead                   (_netportlist*netportlist)
 {
 B ret,flag;
 HINSTANCE mod;
 BP mem;
 MIB_TCPTABLE*TcpTable;
 MIB_UDPTABLE*UdpTable;
 H i,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(netportlist==NULL) { return RET_BADPARM; }
 aaMemoryFill(netportlist,sizeof(_netportlist),0);
 if(aa.net_system.port_list.is_open==YES)
  {
  if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
  aa.net_system.port_list.mem=NULL;
  aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
  aaMemoryFill(&aa.net_system.port_list.list,sizeof(_netportlist),0);
  }
 else
  {
  aaMemoryFill(&aa.net_system.port_list,sizeof(_aa_netportlist),0);
  if((mod=LoadLibrary("iphlpapi.dll"))==NULL) { return RET_FAILED; }
  aa.net_system.port_list.GetTcpTable=(VP)GetProcAddress(mod,"GetTcpTable");
  aa.net_system.port_list.GetUdpTable=(VP)GetProcAddress(mod,"GetUdpTable");
  if(aa.net_system.port_list.GetTcpTable==NULL||aa.net_system.port_list.GetUdpTable==NULL)  { FreeLibrary(mod);  return RET_FAILED;  }
  aa.net_system.port_list.module_handle=mod;
  aa.net_system.port_list.is_open=YES;
  }
 flag=NO;
 while(1)
  {
  ret=RET_FAILED;
  if(aa.net_system.port_list.GetTcpTable(NULL,&aa.net_system.port_list.t_len,TRUE)!=ERROR_INSUFFICIENT_BUFFER) { break; }
  if(aa.net_system.port_list.GetUdpTable(NULL,&aa.net_system.port_list.u_len,TRUE)!=ERROR_INSUFFICIENT_BUFFER) { break; }
  i=aa.net_system.port_list.t_len+aa.net_system.port_list.u_len*4; // so we can add our own entries
  if((ret=aaMemoryAllocate((VP)&mem,i))!=RET_YES) { break; }
  aaMemoryNameSet(mem,"netprtlistent");
  aa.net_system.port_list.mem=mem;
  flag=YES;
  break;
  }
 if(flag==NO)
  {
  if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
  aa.net_system.port_list.mem=NULL;
  aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
  FreeLibrary(aa.net_system.port_list.module_handle);
  aaMemoryFill(&aa.net_system.port_list.list,sizeof(_netportlist),0);
  aa.net_system.port_list.is_open=NO;
  return ret;
  }
 aaCast(TcpTable,MIB_TCPTABLE*,&aa.net_system.port_list.mem[0]);
 aaCast(UdpTable,MIB_UDPTABLE*,&aa.net_system.port_list.mem[aa.net_system.port_list.t_len]);
 flag=NO;
 while(1)
  {
  if(aa.net_system.port_list.GetTcpTable(TcpTable,&aa.net_system.port_list.t_len,TRUE)) { break; }
  if(aa.net_system.port_list.GetUdpTable(UdpTable,&aa.net_system.port_list.u_len,TRUE)) { break; }
  flag=YES;
  break;
  }
 if(flag==NO)
  {
  if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
  aa.net_system.port_list.mem=NULL;
  aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
  FreeLibrary(aa.net_system.port_list.module_handle);
  aaMemoryFill(&aa.net_system.port_list.list,sizeof(_netportlist),0);
  aa.net_system.port_list.is_open=NO;
  return RET_FAILED;
  }
 aa.net_system.port_list.list.udp_entries=UdpTable->dwNumEntries;
 aa.net_system.port_list.list.tcp_entries=TcpTable->dwNumEntries;
 aa.net_system.port_list.list.total_entries=aa.net_system.port_list.list.udp_entries+aa.net_system.port_list.list.tcp_entries;

 off=aa.net_system.port_list.t_len+aa.net_system.port_list.u_len;
 aaCast(aa.net_system.port_list.list.tcp_entry,_netportlistentry*,&aa.net_system.port_list.mem[off]);
 off+=aa.net_system.port_list.list.tcp_entries*sizeof(_netportlistentry);
 aaCast(aa.net_system.port_list.list.udp_entry,_netportlistentry*,&aa.net_system.port_list.mem[off]);

 for(i=0;i<aa.net_system.port_list.list.udp_entries;i++)
  {
  aa.net_system.port_list.list.udp_entry[i].state=0;
  aaNetAdrSet(&aa.net_system.port_list.list.udp_entry[i].local_adr,UdpTable->table[i].dwLocalAddr,(W)UdpTable->table[i].dwLocalPort);
  }
 for(i=0;i<aa.net_system.port_list.list.tcp_entries;i++)
  {
  aaNetAdrSet(&aa.net_system.port_list.list.tcp_entry[i].local_adr,TcpTable->table[i].dwLocalAddr,(W)TcpTable->table[i].dwLocalPort);
  aaNetAdrSet(&aa.net_system.port_list.list.tcp_entry[i].remote_adr,TcpTable->table[i].dwRemoteAddr,(W)TcpTable->table[i].dwRemotePort);
  aa.net_system.port_list.list.tcp_entry[i].state=TcpTable->table[i].dwState;
  }
 if(netportlist) { aaMemoryCopy(netportlist,sizeof(_netportlist),&aa.net_system.port_list.list); }
 return RET_YES;
 }





 B aaNetPortListStop                   (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.net_system.port_list.is_open!=YES) { return RET_NOTOPEN; }
 if(aa.net_system.port_list.mem) { aaMemoryRelease(aa.net_system.port_list.mem); }
 aa.net_system.port_list.mem=NULL;
 aa.net_system.port_list.u_len=aa.net_system.port_list.t_len=0;
 FreeLibrary(aa.net_system.port_list.module_handle);
 aa.net_system.port_list.is_open=NO;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaNetRttInit                        (_netrtt*rtt,H mintimeout,H maxtimeout,H initialtimeout)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rtt==NULL) { return RET_BADPARM; }
 if(mintimeout>maxtimeout) { return RET_BADPARM; }
 if(maxtimeout>aaSecs(60)) { return RET_BOUNDS; }
 if(initialtimeout==0) { initialtimeout=mintimeout+((maxtimeout-mintimeout)/2); }
 initialtimeout=aaNumClamp(initialtimeout,mintimeout,maxtimeout);
 aaMemoryFill(rtt,sizeof(_netrtt),0);
 rtt->magic=aa_RTT_MAGIC;
 rtt->timeout=initialtimeout;
 rtt->min_timeout=mintimeout;
 rtt->max_timeout=maxtimeout;
 return RET_YES;
 }




 B aaNetRttUpdate                      (_netrtt*rtt,H ms,B lost)
 {
 H swap,n;
 H minrtt,maxrtt,prevrtt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rtt==NULL) { return RET_BADPARM; }
 if(rtt->magic!=aa_RTT_MAGIC) { return RET_NOTSTARTED; }
 minrtt=rtt->min_timeout;
 maxrtt=rtt->max_timeout;
 prevrtt=rtt->timeout;
 if(lost)
  {
  n=(prevrtt+(prevrtt>>2));
  if(minrtt>maxrtt) { swap=minrtt; minrtt=maxrtt; maxrtt=swap; }
  }
 else
  {
  n=(((prevrtt>>3)*7)+(ms>>2)); // was ms>>3 , but duplicates happend, as ms was too small
  if(minrtt>maxrtt) { swap=minrtt; minrtt=maxrtt; maxrtt=swap; }
  }
 n=aaNumClamp(n,minrtt,maxrtt);
 rtt->timeout=n;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaNetChunkReaderNew                 (_chunkreader*chunkreader,H tcpcallhandle)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 aaMemoryFill(chunkreader,sizeof(_chunkreader),0);
 chunkreader->magic=aaHPP(aaNetChunkReaderNew);
 //if((ret=aaNetTcpCallStatus(tcpcallhandle,&chunkreader->call.status))!=YES) { return ret;  }
 if((ret=aaNetTcpCallStatus(tcpcallhandle,0))!=YES) { return ret;  }
 chunkreader->call_handle=tcpcallhandle;
 chunkreader->chunk_size=-1;
 chunkreader->chunk_done=-1;
 ret=aaMemoryUnitAllocate(&chunkreader->chunk,_1K);
 if(ret!=RET_YES) { aaMemoryFill(chunkreader,sizeof(_chunkreader),0); return ret; }
 return RET_YES;
 }







 B aaNetChunkReaderDelete              (_chunkreader*chunkreader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 if(chunkreader->magic!=aaHPP(aaNetChunkReaderNew)) { return RET_NOTINITIALIZED; }
 //aaDebugf("%s %u",__func__,__LINE__);
 if(chunkreader->chunk.bytes!=0)
  {
  ///aaDebugf("%s %u",__func__,__LINE__);
  aaMemoryUnitRelease(&chunkreader->chunk);
  }
 aaMemoryFill(chunkreader,sizeof(_chunkreader),0);
 return RET_YES;
 }






 B aaNetChunkReaderYield               (_chunkreader*chunkreader)
 {
 B ret;
 H todo;
 _tcpcallstatus cs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 if(chunkreader->magic!=aaHPP(aaNetChunkReaderNew)) { return RET_NOTINITIALIZED; }
 if(chunkreader->is_ready!=YES)
  {
  //aaNetTcpCallStatus(chunkreader->call.handle,&chunkreader->call.status);
  //aaNetTcpCallStatus(chunkreader->call_handle,&cs);//chunkreader->call.status);
  if(chunkreader->chunk_size==-1)
   {
   if(aaNetHttpChunkSizeRead(chunkreader->call_handle,(HP)&chunkreader->chunk_size)==YES)
    {
    if((H)(chunkreader->chunk_size+_2K)>(H)chunkreader->chunk.bytes)
     {
     if((ret=aaMemoryUnitReAllocate(&chunkreader->chunk,chunkreader->chunk_size+_2K))!=YES) { oops; }
     }
    //aaNetTcpCallStatus(chunkreader->call_handle,&cs);//chunkreader->call.status);
    }
   chunkreader->chunk_done=0;
   }

  if(chunkreader->chunk_size!=-1)
   {
   aaNetTcpCallStatus(chunkreader->call_handle,&cs);//chunkreader->call.status);
   if((todo=chunkreader->chunk_size-chunkreader->chunk_done)!=0)
    {
    todo=aaNumRoof(todo,_8K);
    if((todo=aaNumRoof(todo,cs.rcve_bytes))!=0)//chunkreader->call.status.rcve_bytes))!=0)
     {
     if(aaNetTcpCallRead(chunkreader->call_handle,todo,&chunkreader->chunk.mem[chunkreader->chunk_done])!=YES) oof;
     //aaNetTcpCallStatus(chunkreader->call.handle,&chunkreader->call.status);
     chunkreader->chunk_done+=todo;
     }
    }
   if(chunkreader->chunk_done==chunkreader->chunk_size)
    {
    chunkreader->chunk.mem[chunkreader->chunk_size]=0;
    chunkreader->is_ready=YES;
    }
   }
  }
 if(chunkreader->is_ready!=YES) { return RET_NOTREADY; }
 return RET_YES;
 }





 B aaNetChunkReaderDiscard             (_chunkreader*chunkreader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(chunkreader==NULL) { return RET_BADPARM;  }
 if(chunkreader->magic!=aaHPP(aaNetChunkReaderNew)) { return RET_NOTINITIALIZED; }
 if(chunkreader->is_ready!=YES) { return RET_NOTREADY; }
 chunkreader->chunk_size=-1;
 chunkreader->chunk_done=-1;
 chunkreader->is_ready=NO;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aaRedcallNew                        (_redcall*redcall,VP host,W port,VP auth,B(*proc)(_redcall*,Q,B,B,_redcallpkt*))
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 aaMemoryFill(redcall,sizeof(_redcall),0);
 redcall->magic=aaHPP(aaRedcallNew);
 if(aaStringIsEmpty(host,YES)==NO) { aaStringCopyf(redcall->host,"%s",host); }
 else                              { aaStringCopyf(redcall->host,"127.0.0.1"); }
 if(port!=0) { redcall->port=port; }
 else        { redcall->port=6379; }
 if(aaStringIsEmpty(auth,YES)==NO) { aaStringCopyf(redcall->auth,"%s",auth); }
 if(aaMemoryUnitAllocate(&redcall->rpkt.mu,_64K)!=YES) { oof; }
 redcall->rpkt_seq_prev=F64;
 redcall->stage=100;
 redcall->proc=proc;
 return RET_YES;
 }





 B aaRedcallDelete                     (_redcall*redcall)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(redcall->tcpcall.handle!=0) { aaNetTcpCallDestroy(redcall->tcpcall.handle); }
 if(redcall->rpkt.mu.bytes) { aaMemoryUnitRelease(&redcall->rpkt.mu); }
 aaMemoryFill(redcall,sizeof(_redcall),0);
 return RET_YES;
 }




 B aaRedcallYield                      (_redcall*redcall,QP seq,BP isnew,BP isend)
 {
 B ret;
 B isn,ise;
 Q sq;
 B(*proc)(_redcall*,Q,B,B,_redcallpkt*);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(seq) { *seq=0; }
 if(isnew) { *isnew=0; }
 if(isend) { *isend=0; }

 switch(redcall->stage)
  {
  case 100:
  aaNetTcpCallCreate(&redcall->tcpcall.handle,0,0,redcall->host,0,redcall->port);
  redcall->stage=120;
  break;

  case 120:
  aaNetTcpCallStatus(redcall->tcpcall.handle,&redcall->tcpcall.status);
  if(redcall->tcpcall.status.is_connected!=YES) { break; }
  if(aaStringIsEmpty(redcall->auth,YES)==NO) { redcall->stage=140; break; }
  //redcall->is_ready=YES;
  redcall->stage=200;
  break;


  case 140:
  aaNetRedisPacketWritef(redcall->tcpcall.handle,"auth %s",redcall->auth);
  aaNetTcpCallStatus(redcall->tcpcall.handle,&redcall->tcpcall.status);
  redcall->stage=160;
  //break;


  case 160:
  ret=aaNetRedisPacketRead(redcall->tcpcall.handle,&redcall->rpkt.type,&redcall->rpkt.arg,&redcall->rpkt.chars,redcall->rpkt.mu.bytes,redcall->rpkt.mu.mem);
  if(ret==RET_NOTREADY) { break; }
  if(ret!=RET_YES)
   {
   //aaDebugf("z %s",ret_string[ret]);
   }
  switch(redcall->rpkt.type)
   {
   case aa_REDISTYPE_Status:
   if(redcall->rpkt.arg==aa_REDISARG_OK)
    {
    redcall->is_ready=YES;
    redcall->stage=200;
    break;
    }
   break;


   case aa_REDISTYPE_Error:
   redcall->stage=666;
   break;


   default:
   oof;
   break;
   }
  break;



  case 200:
  ret=aaNetRedisPacketRead(redcall->tcpcall.handle,&redcall->rpkt.type,&redcall->rpkt.arg,&redcall->rpkt.chars,redcall->rpkt.mu.bytes,redcall->rpkt.mu.mem);
  if(ret==RET_NOTREADY) { break; }
  if(ret!=RET_YES)
   {
   //aaDebugf("q %s",ret_string[ret]);
   }
  redcall->rpkt.seq=redcall->rpkt_seq;
  if(redcall->rpkt.type==aa_REDISTYPE_Multi)
   {
   redcall->rpkt_multi_left=redcall->rpkt.arg;
   }
  if(redcall->rpkt_multi_left==0) { redcall->rpkt_seq++; }
 // else                            { redcall->rpkt_multi_left--; }
  redcall->stage=220;
  break;


  case 220:
  isn=ise=NO;
  if(redcall->rpkt.seq!=redcall->rpkt_seq_prev) { isn=YES; }
  if(redcall->rpkt_multi_left==0) { ise=YES; }
  sq=redcall->rpkt.seq;
  if(redcall->proc)
   {
   proc=redcall->proc;
   ret=proc(redcall,redcall->rpkt.seq,isn,ise,&redcall->rpkt);
   if(ret==RET_YES)    {    aaRedcallPktDiscard(redcall);    }
   }
  if(isnew) { *isnew=isn; }
  if(isend) { *isend=ise; }
  if(seq)   { *seq=sq; }
  break;
  }
 return RET_YES;
 }





 B aaRedcallPktWritef                  (_redcall*redcall,QP seq,VP fmt,...)
 {
 B str[_8K];
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 aaFmt(fmt,argptr,str);
 if(seq) *seq=redcall->xpkt_seq;
 aaNetRedisPacketWritef(redcall->tcpcall.handle,"%s",str);
 redcall->xpkt_seq++;
 return RET_YES;
 }




 B aaRedcallPktPeek                    (_redcall*redcall,QP seq,BP isnew,BP isend)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if((ret=aaRedcallYield(redcall,seq,isnew,isend))!=RET_YES) { oops; return ret; }
// if(isnew) { *isnew=NO; }
 //if(isend) { *isend=NO; }
 if(redcall->stage!=220)  { return RET_NOTREADY; }
 #if 0
 if(redcall->rpkt.seq!=redcall->rpkt_seq_prev)
  {
  if(isnew) { *isnew=YES; }
  }
 if(redcall->rpkt_multi_left==0)
  {
  if(isend) { *isend=YES; }
  }
 if(seq) { *seq=redcall->rpkt.seq; }
 #endif
 return RET_YES;
 }




 B aaRedcallPktDiscard                 (_redcall*redcall)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(redcall->stage==220||redcall->stage==220)
  {
  if(redcall->stage==220)  {  redcall->stage=200;   }
  redcall->rpkt_seq_prev=redcall->rpkt.seq;
  if(redcall->rpkt_multi_left!=0) { redcall->rpkt_multi_left--; }
  return RET_YES;
  }
 return RET_NOTREADY;
 }




 B aaRedcallPktBug                     (_redcall*redcall)
 {
 B ret;
 B txt[_1K];
 B str[_2K];
 H count;
 //B isnew;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(redcall==NULL) { return RET_BADPARM; }
 if(redcall->magic!=aaHPP(aaRedcallNew)) { return RET_NOTINITIALIZED; }
 if(redcall->proc==NULL) // prevent yield proc, calling bug which calls yield
  {
  if((ret=aaRedcallPktPeek(redcall,0,0,0))!=RET_YES) { return ret; }
  }
// if(isnew) {}
// if(isnew)  {  aaDebugf("-----");  }
 aaStringNull(txt);
 switch(redcall->rpkt.type)
  {
  case aa_REDISTYPE_Status:  aaStringCopyf(txt,"Status"); break;
  case aa_REDISTYPE_Error:   aaStringCopyf(txt,"Error"); break;
  case aa_REDISTYPE_Integer: aaStringCopyf(txt,"Intger"); break;
  case aa_REDISTYPE_Bulk:    aaStringCopyf(txt,"Bulk"); break;
  case aa_REDISTYPE_Multi:   aaStringCopyf(txt,"Multi"); break;
  }
 aaStringCopyf(str,"%-8I64d %-7s  ",redcall->rpkt.seq,txt);
 //aaStringAppendf(str,"l=%-8I64d ",redcall->rpkt_multi_left);
 if(redcall->rpkt.type!=aa_REDISTYPE_Bulk)
  {
  aaStringAppendf(str,"arg=%-10I64d  ",redcall->rpkt.arg);
  }
 else
  {
  aaStringAppendf(str,"arg=0x%-8I64X  ",redcall->rpkt.arg);
  }
 aaStringAppendf(str,"chars=%-7u ",redcall->rpkt.chars);
 if(redcall->rpkt.chars!=0)
  {
  aaStringCountChars(redcall->rpkt.mu.mem,redcall->rpkt.chars,&count,LF_CHAR,NO,YES);
  if(count>0) { aaStringAppendf(str,"\n"); }
  else        { aaStringAppendf(str," ");  }
  }
 //aaDebugf("%s%s",str,redcall->rpkt.mu.mem);
 return RET_YES;
 }



 B aaRedcallProc                       (_redcall*redcall,Q seq,B isnew,B isend,_redcallpkt*redcallpkt)
 {
 UNUSE(seq);
 UNUSE(redcallpkt);
 if(isnew)
  {
  //aaDebugf("----");
  }
 aaRedcallPktBug(redcall);
 if(isend)
  {
  //aaDebugf("....");
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aa_SsDbClientTransmiter             (_ssdbclient*ssdbclient)
 {
 H bytes;
 Q seq;
 B in[_8K];
 B buf[_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 if(ssdbclient->is_ready!=YES) { return RET_NOTREADY; }
 if(ssdbclient->xmit_msges_waiting==0) { return RET_NOTREADY; }
 //aaNetTcpCallStatus(ssdbclient->call.handle,&ssdbclient->call.status);
 if(aaQueStatus(ssdbclient->xmit_que.handle,&ssdbclient->xmit_que.status)!=YES) oof;
 if(ssdbclient->xmit_que.status.bytes<12) { oof; }
 if(aaQuePeek(ssdbclient->xmit_que.handle,0,12,in)!=YES) { oof; }
 bytes=*(HP)&in[0];
 seq=*(QP)&in[4];
 if(seq) {}

 if(ssdbclient->xmit_que.status.bytes<bytes) { aaNote(0,"xb=%i eb=%i",ssdbclient->xmit_que.status.bytes,bytes); }
 aaQueRead(ssdbclient->xmit_que.handle,12,in);
 bytes-=8;
 aaQueRead(ssdbclient->xmit_que.handle,bytes,buf);
 //aaQueStatus(ssdbclient->xmit_que.handle,&ssdbclient->xmit_que.status);
 buf[bytes]=NULL_CHAR;
 ssdbclient->xmit_msges_waiting--;
 if(aaNetSsDbPacketWrite(ssdbclient->call.handle,"%s",buf)!=YES) { oof; }
 aaNetTcpCallStatus(ssdbclient->call.handle,&ssdbclient->call.status);
 aaQueStatus(ssdbclient->xmit_que.handle,&ssdbclient->xmit_que.status);
 return RET_YES;
 }






 B aa_SsDbClientReceiver               (_ssdbclient*ssdbclient)
 {
 B ret;
 BP tmp;
 BP bp;
 B out[_2K];
 _aa_nettcpcallobject*calp;
 H i,len,count,val,pos,go,left;
 H by,off;
 Q sq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 if(ssdbclient->is_ready!=YES) { return RET_NOTREADY; }
 if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,ssdbclient->call.handle,(VP)&calp,NULL))!=RET_YES) { return ret; }
 if(calp->status.rcve_bytes==0) {  return RET_NOTREADY; }
 go=0;
 while((go++)<10)
  {
  aaNetTcpCallStatus(ssdbclient->call.handle,&ssdbclient->call.status);

  switch(ssdbclient->rcve_stage)
   {
   case 0:
   case 3:
   if(ssdbclient->call.status.rcve_bytes==0) { return RET_NOTREADY; }

   ret=aaNetTcpCallFindByte(ssdbclient->call.handle,0,F32,&pos,LF_CHAR,YES,0);
   if(ret!=RET_YES) { oops;  }

   len=pos+1;

   ret=aaMemoryTemp((VP)&tmp,len);
   if(ret!=RET_YES) { oops;  }

   ret=aaNetTcpCallRead(ssdbclient->call.handle,len,tmp);
   if(ret!=RET_YES) { oops;  }
   tmp[len]=NULL_CHAR;
   aaNetTcpCallStatus(ssdbclient->call.handle,&ssdbclient->call.status);

   if(len>=2)
    {
    if(tmp[len-2]==CR_CHAR&&tmp[len-1]==LF_CHAR) { tmp[len-2]=NULL_CHAR; len-=2; } else
    if(tmp[len-1]==LF_CHAR)                      { tmp[len-1]=NULL_CHAR; len-=1; } else { oof; }
    }
   else
   if(len>=1)
    {
    if(tmp[len-1]==LF_CHAR)                      { tmp[len-1]=NULL_CHAR; len-=1; }
    else { oof; }
    }

   if(len==0)
    {
    if(ssdbclient->rcve_stage==0)
     {
     bp=ssdbclient->rcve_mem.mem;
     off=0;
     for(i=0;i<ssdbclient->rcve_lines;i++)
      {
      by=*(HP)&bp[off]; off+=4;
      sq=*(QP)&bp[off]; off+=8;
      *(HP)&out[0]=(by-12)+20;
      *(QP)&out[4]=sq;
      *(HP)&out[12]=i;
      *(HP)&out[16]=ssdbclient->rcve_lines;
      aaQueWrite(ssdbclient->rcve_que.handle,20,out);
      if((by-12)!=0) { aaQueWrite(ssdbclient->rcve_que.handle,(by-12),&bp[off]); }
      off+=(by-12);
      }
     aaQueStatus(ssdbclient->rcve_que.handle,&ssdbclient->rcve_que.status);
     ssdbclient->rcve_msges_waiting++;
     ssdbclient->rcve_seq++;
     ssdbclient->rcve_lines=0;
     ssdbclient->rcve_mem.used=0;
     }
    ssdbclient->rcve_stage=0;
    break;
    }

   if((ret=aaStringCountNumbers(tmp,len,&count,YES))!=RET_YES) { oops; }
   if(count==0) { aaNote(0,"count=%i len=%i [%s]",count,len,tmp);  }
   if(count!=len) { oof; }
   if((ret=aaStringToNumber(tmp,count,&val,0,0,0))!=RET_YES) { oops; }
   if(val==0) { oof; }
   ssdbclient->rcve_bytes=val;
   if(ssdbclient->rcve_bytes==0) oof;
   ssdbclient->rcve_stage=2;
   if(ssdbclient->call.status.rcve_bytes<ssdbclient->rcve_bytes) { return RET_NOTREADY; }
   break;


   case 2:
   if(ssdbclient->call.status.rcve_bytes<ssdbclient->rcve_bytes) { return RET_NOTREADY; }
   len=ssdbclient->rcve_bytes;

   ret=aaMemoryTemp((VP)&tmp,len);
   if(ret!=RET_YES) { oops;  }

   ret=aaNetTcpCallRead(ssdbclient->call.handle,len,tmp);
   if(ret!=RET_YES) { oops;  }
   tmp[len]=NULL_CHAR;
   aaNetTcpCallStatus(ssdbclient->call.handle,&ssdbclient->call.status);

   left=ssdbclient->rcve_mem.bytes-ssdbclient->rcve_mem.used;
   if((12+len+_2K)>=left)
    {
    if((ret=aaMemoryUnitReAllocate(&ssdbclient->rcve_mem,ssdbclient->rcve_mem.bytes+12+len+_8K))!=RET_YES) { oops; }
    }
   *(HP)&out[0]=12+len;
   *(QP)&out[4]=ssdbclient->rcve_seq;

   aaMemoryCopy(&ssdbclient->rcve_mem.mem[ssdbclient->rcve_mem.used],12,out);
   ssdbclient->rcve_mem.used+=12;
   if(len!=0)
    {
    aaMemoryCopy(&ssdbclient->rcve_mem.mem[ssdbclient->rcve_mem.used],len,tmp);
    ssdbclient->rcve_mem.used+=len;
    }

   ssdbclient->rcve_lines_waiting++;
   ssdbclient->rcve_lines++;
   ssdbclient->rcve_stage=3;
   if(ssdbclient->call.status.rcve_bytes==0) { return RET_NOTREADY; }
   break;
   }
  }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 B aaSsDbClientNew                     (_ssdbclient*ssdbclient,VP host,W port,VP auth)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(ssdbclient==NULL) { return RET_BADPARM; }
 aaMemoryFill(ssdbclient,sizeof(_ssdbclient),0);
 ssdbclient->magic=aaHPP(aaSsDbClientNew);
 if(aaStringIsEmpty(host,YES)==NO) { aaStringCopyf(ssdbclient->host,"%s",host); }
 else                              { aaStringCopyf(ssdbclient->host,"127.0.0.1"); }
 if(aaStringICompare(ssdbclient->host,"localhost",0)==YES) { aaStringCopyf(ssdbclient->host,"127.0.0.1"); }
 if(port!=0) { ssdbclient->port=port; }
 else        { ssdbclient->port=8888; }
 if(aaStringIsEmpty(auth,YES)==NO) { aaStringCopyf(ssdbclient->auth,"%s",auth); }
 ssdbclient->xmit_seq=1;
 ssdbclient->rcve_seq=1;
 ssdbclient->stage=100;
 aaQueCreate(&ssdbclient->xmit_que.handle);
 aaQueCreate(&ssdbclient->rcve_que.handle);
 aaQueStatus(ssdbclient->xmit_que.handle,&ssdbclient->xmit_que.status);
 aaQueStatus(ssdbclient->rcve_que.handle,&ssdbclient->rcve_que.status);
 aaMemoryUnitAllocate(&ssdbclient->rcve_mem,_64K);
 aaMemoryNameSet(ssdbclient->rcve_mem.mem,"ssdbrmem");
 aaListNew(&ssdbclient->rcve_list);
 return RET_YES;
 }



 B aaSsDbClientDelete                  (_ssdbclient*ssdbclient)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 if(ssdbclient->call.handle!=0) { aaNetTcpCallDestroy(ssdbclient->call.handle); }
 if(ssdbclient->rcve_mem.bytes) { aaMemoryUnitRelease(&ssdbclient->rcve_mem); }
 if(ssdbclient->xmit_que.handle) { aaQueDestroy(ssdbclient->xmit_que.handle); }
 if(ssdbclient->rcve_que.handle) { aaQueDestroy(ssdbclient->rcve_que.handle); }
 if(ssdbclient->rcve_list.magic) { aaListDelete(&ssdbclient->rcve_list); }
 aaMemoryFill(ssdbclient,sizeof(_ssdbclient),0);
 return RET_YES;
 }







 B aaSsDbClientYield                   (_ssdbclient*ssdbclient)
 {
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 go=0;
 while((go++)<3)
  {
  switch(ssdbclient->stage)
   {
   case 100:
   aaNetTcpCallCreate(&ssdbclient->call.handle,0,0,ssdbclient->host,0,ssdbclient->port);
   ssdbclient->stage=150;
   break;

   case 150:
   aaNetTcpCallStatus(ssdbclient->call.handle,&ssdbclient->call.status);
   if(ssdbclient->call.status.is_connected!=YES) { break; }
   //aaDebugf("connected to %s:%u",ssdbclient->host,ssdbclient->port);
   ssdbclient->stage=170;
   break;


   case 170:
   if(aaStringIsEmpty(ssdbclient->auth,YES)==YES)
    {
    //aaDebugf("no authentication used, therefor is_ready=YES");
    ssdbclient->is_ready=YES;
    ssdbclient->stage=300;
    break;
    }
   ssdbclient->stage=200;
   break;


   case 200:
   oof;
   aa_SsDbClientReceiver(ssdbclient);
   break;


   case 300:
   aa_SsDbClientReceiver(ssdbclient);
   if(ssdbclient->xmit_msges_waiting>0) { aa_SsDbClientTransmiter(ssdbclient); }
   break;
   }
  }
 return RET_YES;
 }






 B aaSsDbClientWrite                   (_ssdbclient*ssdbclient,QP seq,VP fmt,...)
 {
 Q sq;
 B out[_8K];
 H left,todo,off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }

 sq=ssdbclient->xmit_seq;
 if(seq) { *seq=sq; }

 aaVargsf(fmt);
 if(str64k.len==0) { oof; }

 off=0;
 *(HP)&out[0]=8+str64k.len;
 *(QP)&out[4]=sq;

 left=4+8+str64k.len;
 todo=aaNumRoof(left,(sizeof(out)-8-4));
 aaMemoryCopy(&out[12],todo,&str64k.buf[off]);
 if(aaQueWrite(ssdbclient->xmit_que.handle,todo,out)!=YES) { oof; }
 aaQueStatus(ssdbclient->xmit_que.handle,&ssdbclient->xmit_que.status);
 left-=todo;
 off+=todo;
 while(1)
  {
  if(left==0) { break; }
  todo=aaNumRoof(left,sizeof(out));
  aaMemoryCopy(out,todo,&str64k.buf[off]);
  if(aaQueWrite(ssdbclient->xmit_que.handle,todo,out)!=YES) { oof; }
  left-=todo;
  off+=todo;
  }
 aaQueStatus(ssdbclient->xmit_que.handle,&ssdbclient->xmit_que.status);
 ssdbclient->xmit_seq++;
 ssdbclient->xmit_msges_waiting++;
 aaSsDbClientYield(ssdbclient);
 return RET_YES;
 }





 B aaSsDbClientRead                    (_ssdbclient*ssdbclient,QP seq,HP bytes,HP lineidx,HP linecnt,NP code,H maxbytes,VP buf)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 if((ret=aaSsDbClientPeek(ssdbclient,seq,bytes,lineidx,linecnt,code,maxbytes,buf))!=YES) { return ret; }
 if((ret=aaSsDbClientDiscard(ssdbclient))!=YES) { oops; }
 return RET_YES;
 }





 B aaSsDbClientPeek                    (_ssdbclient*ssdbclient,QP seq,HP bytes,HP lineidx,HP linecnt,NP code,H maxbytes,VP buf)
 {
 BP bp;
 H by;
 Q sq;
 H li,lc;
 B in[_2K];
 N which;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 if(ssdbclient->rcve_msges_waiting==0) { return RET_NOTREADY; }
 if(ssdbclient->rcve_lines_waiting==0) { return RET_NOTREADY; }
 if(ssdbclient->rcve_que.status.bytes<20) { return RET_NOTREADY; }
 aaQueStatus(ssdbclient->rcve_que.handle,&ssdbclient->rcve_que.status);
 aaQuePeek(ssdbclient->rcve_que.handle,0,20,in);
 by=*(HP)&in[0];
 sq=*(QP)&in[4];
 li=*(HP)&in[12];
 lc=*(HP)&in[16];
 if(by<20) { oof; }
 by-=20;
 if(seq)     { *seq=sq; }
 if(bytes)   { *bytes=by; }
 if(lineidx) { *lineidx=li; }
 if(linecnt) { *linecnt=lc; }
 if(code)    { *code=0; }
 if((by+20)>ssdbclient->rcve_que.status.bytes) { oof; }
 if(by>=maxbytes)
  {
  by=maxbytes;
  if(maxbytes) { aaQuePeek(ssdbclient->rcve_que.handle,20,maxbytes,buf);   }
  bp=(BP)buf;
  bp[maxbytes]=NULL_CHAR;
  return RET_BOUNDS;
  }
 if(by) { aaQuePeek(ssdbclient->rcve_que.handle,20,by,buf);   }
 bp=(BP)buf;
 bp[by]=NULL_CHAR;
 if(li==0&&code)
  {
  aaStringIsIString(bp,&which,"ok","not_found","error","fail","client_error",0);
  *code=which+1;
  }
 return RET_YES;
 }







 B aaSsDbClientDiscard                 (_ssdbclient*ssdbclient)
 {
 //B ret;
 B in[_4K];
// Q sq;
 H by,li,lc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 if(ssdbclient->rcve_msges_waiting==0) { return RET_NOTREADY; }
 if(ssdbclient->rcve_lines_waiting==0) { return RET_NOTREADY; }
 if(ssdbclient->rcve_que.status.bytes<20) { return RET_NOTREADY; }
 aaQuePeek(ssdbclient->rcve_que.handle,0,20,in);
 by=*(HP)&in[0];
// sq=*(QP)&in[4];
 li=*(HP)&in[12];
 lc=*(HP)&in[16];
 aaQueDiscard(ssdbclient->rcve_que.handle,by);
 aaQueStatus(ssdbclient->rcve_que.handle,&ssdbclient->rcve_que.status);
 ssdbclient->rcve_lines_waiting--;
 if((li+1)==lc) { ssdbclient->rcve_msges_waiting--; }
 aaSsDbClientYield(ssdbclient);
 return RET_YES;
 }






 B aaSsDbClientListReceive             (_ssdbclient*ssdbclient,QP seq)
 {
 B ret;
 B buf[_8K];
 Q sq;
 H bytes,li,lc,sl,off;
 N which;
 _ssdblistentry*ssle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 while(1)
  {
  aaSsDbClientYield(ssdbclient);
  off=sizeof(_ssdblistentry);
  if(aaSsDbClientPeek(ssdbclient,&sq,&bytes,&li,&lc,&which,sizeof(buf)-off,&buf[off])!=YES) { break; }
  aaSsDbClientDiscard(ssdbclient);
  if(li==0)
   {
   aaListReset(&ssdbclient->rcve_list);
   }
  //aaStringReplaceChar(&buf[off],bytes,LF_CHAR,SPACE_CHAR);
  //aaStringCleanup(&buf[off],bytes,YES,&sl);
  sl=bytes;
    ssle=(_ssdblistentry*)&buf[0];
    ssle->seq=sq;
    ssle->line_index=li;
    ssle->line_count=lc;
    ssle->code=which;
    ssle->bytes=sl;
    ssle->is_number=0;
    ssle->number=0;
    if(aaStringIsNumerical(ssle->data,0,0,ssle->bytes)==YES)
     {
     aaStringToNumber(ssle->data,ssle->bytes,0,0,&ssle->number,0);
     ssle->is_number=1;
     }



  if((ret=aaListAppend(&ssdbclient->rcve_list,0,0,off+sl,buf))!=YES) { oops; }
  if((li+1)==lc)
   {
   if(seq) { *seq=sq; }
   return RET_YES;
   }
  }
 return RET_NOTREADY;
 }




 B aaSsDbClientListEntryGet            (_ssdbclient*ssdbclient,H index,_ssdblistentry*ssdblistentry)
 {
 B ret;
 BP kp;
 _ssdblistentry*sle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ssdbclient==NULL) { return RET_BADPARM; }
 if(ssdbclient->magic!=aaHPP(aaSsDbClientNew)) { return RET_NOTINITIALIZED; }
 if((ret=aaListPointerGet(&ssdbclient->rcve_list,index,(VP)&kp,(VP)&sle))!=YES) { return ret; }

 if(ssdblistentry)
  {
  aaMemoryCopy(ssdblistentry,sizeof(_ssdblistentry)+sle->bytes,sle);
  ssdblistentry->data[sle->bytes]=NULL_CHAR;
  } // *ssdblistentry=sle; }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/

 B aaTorProcessSnapshot                (_list*list)
 {
 B ret;
 _processlist proc_list;
 _stringtokermini toker;
 _stringtokermini tokerb;
 H i,j,k,l,state,val,count,sl;
 B tok[2][_2K];
 B txt[_2K];
 //B str[_2K];
 N which;
 _fileparts fp;
 _torprocessentry tpe;
 //_fileinformation fin;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(list==NULL) { return RET_BADPARM; }
 ret=aaListReset(list);
 if(ret==RET_NOTINITIALIZED) { ret=aaListNew(list); }
 if(ret!=RET_YES)            { oops; return ret; }
 if((ret=aaProcessListGather(&proc_list))!=YES) { oops; return ret; }
 for(i=0;i<proc_list.entries;i++)
  {
  if(aaStringICompare(proc_list.entry[i].exe_file,"tor.exe",0)!=YES) { continue; }
  aaMemoryFill(&tpe,sizeof(tpe),0);
  ret=aaStringTokerMini(proc_list.entry[i].cmd_line,0,&toker);
  if(ret!=YES) { continue; }
  j=0;
  state=0;
  while(1)
   {
   if(j>=toker.count) { break; }
   if((ret=aaStringTokerMiniStringGet(tok[state],j,sizeof(tok[state]),&toker))!=YES) { oops; break; }
   if(j==0)
    {
    aaStringCopyf(tpe.exe_file,"%s",tok[0]);
    j++;
    continue;
    }
   if(state==0)
    {
    aaStringIsIString(tok[state],&which,"--StrictNodes","--ExcludeNodes","--ExcludeExitNodes","--RunAsDaemon",
                                        "--CookieAuthentication","--HashedControlPassword","--PidFile",
                                        "--DataDirectory","--SocksPort","--ControlPort",
                                        "--NewCircuitPeriod","--MaxCircuitDirtiness",NULL);
    state=1;
    j++;
    continue;
    }
   switch(which)
    {
    case 0:
    if(aaStringICompare(tok[1],"1",0)==YES) { tpe.is_strict_nodes=YES; }
    break;

    case 1:
    aaStringReplaceChar(tok[1],0,'{',SPACE_CHAR);
    aaStringReplaceChar(tok[1],0,'}',SPACE_CHAR);
    aaStringReplaceChar(tok[1],0,',',SPACE_CHAR);
    aaStringRemoveMultipleSpaces(tok[1],0,YES);
    aaStringRemoveSpaces(tok[1],0,YES,YES);
    aaStringCountChars(tok[1],0,&count,SPACE_CHAR,0,YES);
    tpe.exclude_nodes_count=count+1;
    if((ret=aaStringTokerMini(tok[1],0,&tokerb))!=YES) { oops; }
    if(tokerb.count!=tpe.exclude_nodes_count) { oof; }
    for(l=0;l<tokerb.count;l++)
     {
     if((ret=aaStringTokerMiniStringGet(txt,l,sizeof(txt),&tokerb))!=YES) { oops; break; }
     aaStringLen(txt,&sl);
     if(sl>=sizeof(tpe.exclude_nodes[0])) { oof; }
     aaStringCopyf(tpe.exclude_nodes[l],"%s",txt);
     }
    break;

    case 2:
    aaStringReplaceChar(tok[1],0,'{',SPACE_CHAR);
    aaStringReplaceChar(tok[1],0,'}',SPACE_CHAR);
    aaStringReplaceChar(tok[1],0,',',SPACE_CHAR);
    aaStringRemoveMultipleSpaces(tok[1],0,YES);
    aaStringRemoveSpaces(tok[1],0,YES,YES);
    aaStringCountChars(tok[1],0,&count,SPACE_CHAR,0,YES);
    tpe.exclude_exit_nodes_count=count+1;
    if((ret=aaStringTokerMini(tok[1],0,&tokerb))!=YES) { oops; }
    if(tokerb.count!=tpe.exclude_exit_nodes_count) { oof; }
    for(l=0;l<tokerb.count;l++)
     {
     if((ret=aaStringTokerMiniStringGet(txt,l,sizeof(txt),&tokerb))!=YES) { oops; break; }
     aaStringLen(txt,&sl);
     if(sl>=sizeof(tpe.exclude_exit_nodes[0])) { oof; }
     aaStringCopyf(tpe.exclude_exit_nodes[l],"%s",txt);
     }
    break;

    case 3:
    if(aaStringICompare(tok[1],"1",0)==YES) { tpe.is_daemon=YES; }
    break;

    case 4:
    if(aaStringICompare(tok[1],"1",0)==YES) { tpe.is_cookie_authentication=YES; }
    break;

    case 5:
    aaStringDeleteChar(tok[1],0,0);
    aaStringLastCharSet(tok[1],0,0,1);
    aaStringCopyf(tpe.hashed_control_password,"%s",tok[1]);
    break;

    case 6:
    if((ret=aaFilePartsGet(tok[1],&fp))!=YES)  { oops; }
    aaStringCopyf(tpe.pid_path,"%c:/",fp.drive);
    for(k=0;k<fp.path_count;k++)
     {
     aaStringAppendf(tpe.pid_path,"%s/",fp.path[k]);
     }
    aaStringPathSanitize(tpe.pid_path,0,0);
    aaStringCopyf(tpe.pid_file,"%s",fp.filename);
    break;

    case 7:
    aaStringCopyf(tpe.data_path,"%s",tok[1]);
    break;

    case 8:
    aaStringToNumber(tok[1],0,&val,0,0,0);
    tpe.s_port=(W)val;
    break;

    case 9:
    aaStringToNumber(tok[1],0,&val,0,0,0);
    tpe.c_port=(W)val;
    break;

    case 10:
    aaStringToNumber(tok[1],0,&val,0,0,0);
    tpe.new_circuit_period=val;
    break;

    case 11:
    aaStringToNumber(tok[1],0,&val,0,0,0);
    tpe.max_circuit_dirtiness=val;
    break;

    default:
    //aaDebugf("%i [%s] [%s]",which,tok[0],tok[1]);
    break;
    }
   which=-1;
   state=0;
   j++;
   }
  tpe.pid=proc_list.entry[i].process_id;
  if((ret=aaListAppend(list,0,0,sizeof(_torprocessentry),&tpe))!=YES) { oops; }
  }
 aaProcessListRelease(&proc_list);
 return RET_YES;
 }


 B aaTorProcessEntryGet                (_list*list,H index,_torprocessentry**tpep)
 {
 B ret;
 BP kp,vp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(list==NULL) { return RET_BADPARM; }
 if(list->magic==0) { return RET_NOTINITIALIZED; }
 if(index>=list->count) { return RET_BOUNDS; }
 if((ret=aaListPointerGet(list,index,(VP)&kp,(VP)&vp))!=YES) { oops; }
 if(tpep) { *tpep=(_torprocessentry*)vp; }
 return RET_YES;
 }




 B aaTorProcessKill                    (_list*list,H index)
 {
 B ret;
 _torprocessentry*tpe;
 BP kp,vp;
 H todo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(list==NULL) { return RET_BADPARM; }
 if(list->magic==0) { return RET_NOTINITIALIZED; }
 if(index!=F32&&index>=list->count) { return RET_BADHANDLE; }
 if(list->count==0) { return RET_YES; }
 if(index==F32) { todo=list->count; index=0; }
 else           { todo=1; }
 while(1)
  {
  if(todo==0) { break; }
  ret=aaListPointerGet(list,index,(VP)&kp,(VP)&vp);
  if(ret!=YES) { oops; }
  tpe=(_torprocessentry*)vp;
  if(tpe->pid==0) { oof; break; }
  //aaDebugf("kill %i %i %i",tpe->pid,tpe->c_port,tpe->s_port);
  if((ret=aaProcessTerminateByPid(tpe->pid,0))!=YES) { oops; }
  todo--;
  index++;
  }
 return RET_YES;
 }




 B aaTorProcessLaunch                  (W cport,W sport,H maxage,VP exefile,...)
 {
 B ret;
 B str[_4K];
 B dat_path[_1K];
 B cmd_line[_1K];
 H i,han,pid;
 va_list argptr;
 _fileparts fp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cport==0)      { return RET_BADPARM; }
 if(sport==0)      { return RET_BADPARM; }
 if(cport==sport)  { return RET_BADPARM; }
 if(exefile==NULL) { return RET_BADPARM; }
 aaFmt(exefile,argptr,str);
 //aaVargsf(exefile);
 if((ret=aaFileExists("%s",str))!=RET_YES)
  {
  //aaDebugf("%s [%s]",arets,str);
  return RET_NOTFOUND;
  }
 if((ret=aaFilePartsGet(str,&fp))!=RET_YES) { oops; return ret; }
 aaStringCopyf(dat_path,"%c:/",fp.drive);
 for(i=0;i<fp.path_count;i++)
  {
  aaStringAppendf(dat_path,"%s/",fp.path[i]);
  }
 aaStringPathSanitize(dat_path,0,0);
 aaStringAppendf(dat_path,"/datafolder");
 aaFileFolderCreate("%s",dat_path);
 aaStringAppendf(dat_path,"/%i",cport);
 aaFileFolderCreate("%s",dat_path);
 aaStringNull(cmd_line);
 if(0) { aaStringAppendf(cmd_line,"--StrictNodes 0 "); }
 if(0) { aaStringAppendf(cmd_line,"--ExcludeNodes {CH},{DE},{HO},{KO},{RO},{UA} "); }
 if(0) { aaStringAppendf(cmd_line,"--ExcludeNodes {CH},{DE},{HO},{KO},{RO},{UA} "); }
 if(0) { aaStringAppendf(cmd_line,"--ExcludeSingleHopRelays 1 ");    }
 if(0) { aaStringAppendf(cmd_line,"--ExcludeExitNodes {US} "); }
 aaStringAppendf(cmd_line,"--RunAsDaemon 1 ");
 aaStringAppendf(cmd_line,"--CookieAuthentication 0 ");
 aaStringAppendf(cmd_line,"--HashedControlPassword \"\" ");
 aaStringAppendf(cmd_line,"--PidFile %s/pid.pid ",dat_path);
 aaStringAppendf(cmd_line,"--DataDirectory %s ",dat_path);
 aaStringAppendf(cmd_line,"--SocksPort %u ",sport);
 aaStringAppendf(cmd_line,"--ControlPort %u ",cport);
 aaStringAppendf(cmd_line,"--NewCircuitPeriod %u ",maxage);
 aaStringAppendf(cmd_line,"--MaxCircuitDirtiness %u",maxage);
 if((ret=aaProcessLaunch(str,cmd_line,dat_path,SW_HIDE,&han,&pid))!=YES) { oops;  }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/


 B aaMySqlNew                          (_mysql*mysql,_options*options,B(*proc)(_mysql*,Q,H,H,H,H,H,VP))
 {
 BP ptr;
 D dub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(mysql==NULL) { return RET_BADPARM; }
 aaMemoryFill(mysql,sizeof(_mysql),0);
 mysql->magic=aaHPP(aaMySqlNew);

 if(options)
  {
  ptr=(BP)aaOptionsGet(options,&dub,"host");
  if(ptr!=NULL)
   {
   aaStringCopyf(mysql->host,"%s",ptr);
   }
  if(aaNetIpIsValid(mysql->host)==RET_YES)
   {
   aaNetIpFromString(mysql->host,&mysql->ip);
   }
  //if(mysql->ip==0) { mysql->ip=aaLoopBack; }

  ptr=(BP)aaOptionsGet(options,&dub,"ip");
  if(ptr!=NULL)
   {
   aaNetIpFromString(ptr,&mysql->ip);
   }
  ptr=(BP)aaOptionsGet(options,&dub,"port");
  if(ptr!=NULL)
   {
   mysql->port=(W)dub;
   }
  ptr=(BP)aaOptionsGet(options,&dub,"user");
  if(ptr!=NULL)
   {
   aaStringCopyf(mysql->user.name,"%s",ptr);
   }
  ptr=(BP)aaOptionsGet(options,&dub,"pass");
  if(ptr!=NULL)
   {
   aaStringCopyf(mysql->user.pass,"%s",ptr);
   }
  ptr=(BP)aaOptionsGet(options,&dub,"maxits");
  if(ptr!=NULL)
   {
   mysql->max_its=(H)dub;
   }

  if(mysql->max_its==0) { mysql->max_its=1; }
  if(mysql->host[0]==NULL_CHAR)
   {
   if(mysql->ip==0) { mysql->ip=aaLoopBack; }
   }
  if(mysql->port==0) { mysql->port=3306; }

  }
 //aaDebugf("ip=%u port=%u host=%s name=%s pass=%s",mysql->ip,mysql->port,mysql->host,mysql->user.name,mysql->user.pass);
 aaQueCreate(&mysql->query_que.handle);
 aaQueStatus(mysql->query_que.handle,&mysql->query_que.status);
 aaQueCreate(&mysql->response_que.handle);
 aaQueStatus(mysql->response_que.handle,&mysql->response_que.status);

/// aaListNew(&mysql->list);
 mysql->proc=proc;
 mysql->stage=500;
 return RET_YES;
 }





 B aaMySqlNewEx                        (_mysql*mysql,VP host,W port,VP user,VP pass,B(*proc)(_mysql*,Q,H,H,H,H,H,VP))
 {
 B ret;
 _options opts;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 aaOptionsNew(&opts);
 if(host) { aaOptionsSet(&opts,"host=%s",host); }
 if(port) { aaOptionsSet(&opts,"port=%u",port); }
 if(user) { aaOptionsSet(&opts,"user=%s",user); }
 if(pass) { aaOptionsSet(&opts,"pass=%s",pass); }
 aaOptionsSet(&opts,"maxits=50");
 ret=aaMySqlNew(mysql,&opts,proc);
 aaOptionsDelete(&opts);
 return ret;
 }




 B aaMySqlDelete                       (_mysql*mysql)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(mysql->call.handle!=0) { aaNetTcpCallDestroy(mysql->call.handle); }
 if(mysql->query_que.handle) { aaQueDestroy(mysql->query_que.handle); }
 if(mysql->response_que.handle) { aaQueDestroy(mysql->response_que.handle); }
 if(mysql->b!=NULL) { aaMemoryRelease(mysql->b); }
 if(mysql->beautifier.list.magic!=0) { aaListDelete(&mysql->beautifier.list);  }
/// if(mysql->list.magic) { aaListDelete(&mysql->list); }
 aaMemoryFill(mysql,sizeof(_mysql),0);
 return RET_YES;
 }




//https://www.briandunning.com/error-codes/?source=MySQL

 B aaMySqlYield                        (_mysql*mysql)
 {
 B ret;
 H todo,go,sl;
 B temp[20];
 B resp[20];
 B buf[_2K];
 B str[_8K];
 W e_code;
 B x_code[6];
 B e_text[_1K];
 B err;
 BP challenge;
 B(*proc)(_mysql*,Q,H,H,H,H,H,VP);
 B mqdata[_32K];
 H bytes;
 _mysqlentry*mqlep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 UNUSE(str);
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }

 go=0;
 while(1)
  {
  mysql->io_dif=mysql->queries_sent-mysql->responses_received;
  //if(mysql->io_dif==0) { mysql->is_prompt=YES; }
  //else                 { mysql->is_prompt=NO; }
  //if(mysql->is_authenticated!=YES) { mysql->is_prompt=NO; }

  switch(mysql->stage)
   {
   case 500:
//   mysql->is_list_fin=NO;
   if(mysql->call.handle==0)    {    mysql->stage=1000;    break;    }
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   if(mysql->query_que.status.bytes<4) { break; }
   aaQuePeek(mysql->query_que.handle,0,4,&todo);
   if(mysql->query_que.status.bytes<(4+todo)) { break; }
   aaQueDiscard(mysql->query_que.handle,4);
   aaQueRead(mysql->query_que.handle,todo,buf);
   buf[todo]=NULL_CHAR;
   aaQueStatus(mysql->query_que.handle,&mysql->query_que.status);
   aaStringCopy(mysql->cmd,buf);
   aaStringReplaceChar(mysql->cmd,0,CR_CHAR,SPACE_CHAR);
   aaStringReplaceChar(mysql->cmd,0,LF_CHAR,SPACE_CHAR);
   aaStringRemoveSpaces(mysql->cmd,0,YES,YES);
   aaStringRemoveMultipleSpaces(mysql->cmd,0,YES);

//   mysql->is_prompt=NO;
   mysql->stage=1000;
 break; //apr19


   case 1000:
   mysql->no=20;
   if(mysql->call.handle==0) {  mysql->stage=1050;  }
   else                      {  mysql->stage=1100; break; }
 break; //apr19



   case 1050:
   if(mysql->b!=NULL) { oof; }
   aaMemoryAllocate((VP)&mysql->b,_256K);//_16MEG);
   //aaDebugf("host=%s",mysql->host);
   //aaDebugf("up=%u",mysql->ip);
   //aaDebugf("prt=%u",mysql->port);
   if(aaNetTcpCallCreate(&mysql->call.handle,0,0,(mysql->host[0]==0)?0:mysql->host,mysql->ip,mysql->port)!=YES) oof;
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   mysql->stage=1060;
 break; //apr19




   case 1060:
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   if(mysql->call.status.is_connected!=YES) { break; }
   if(mysql->ip==0) { mysql->ip=mysql->call.status.remote_adr.ip; }
   mysql->stage=1070;
 break; //apr19


   case 1070:
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   if(mysql->call.status.is_closed)
    {
    bytes=mysql->call.status.rcve_bytes;
    aaNetTcpCallDestroy(mysql->call.handle);
    mysql->call.handle=0;
    if(aaNetTcpCallCreate(&mysql->call.handle,0,0,(mysql->host[0]==0)?0:mysql->host,mysql->ip,mysql->port)!=YES) oof;
    aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
    mysql->is_ready=NO;
    if(bytes) {}
    //aaDebugf("recalling %i",bytes);
    break;
    }
   if(mysql->call.status.is_connected!=YES) { break; }

   if((todo=mysql->call.status.rcve_bytes)==0) { break; }
   if(todo<64) { break; }
   aaNetTcpCallRead(mysql->call.handle,todo,mysql->b);
   mysql->i=todo;
   if(mysql->b[4]<10) { aaNote(0,"todo=%i b[4]=%i",todo,mysql->b[4]);  }
   //aaDebugf("%i %i",todo,mysql->b[4]);

   aaStringLen(mysql->b+5,&sl);
   sl+=10;
   challenge=(BP)mysql->b+sl;
   aaMemoryCopy(challenge+8,13,challenge+27);
   if(!CryptAcquireContext(&mysql->prov,0,0,PROV_RSA_FULL,0))  { CryptAcquireContext(&mysql->prov,0,0,PROV_RSA_FULL,CRYPT_NEWKEYSET);   }
   CryptCreateHash(mysql->prov,CALG_SHA1,0,0,&mysql->hash);
   aaStringLen(mysql->user.pass,&sl);
   CryptHashData(mysql->hash,mysql->user.pass,sl,0);
   CryptGetHashParam(mysql->hash,HP_HASHVAL,temp,&mysql->no,0);
   CryptDestroyHash(mysql->hash);
   CryptCreateHash(mysql->prov,CALG_SHA1,0,0,&mysql->hash);
   CryptHashData(mysql->hash,temp,20,0);
   CryptGetHashParam(mysql->hash,HP_HASHVAL,resp,&mysql->no,0);
   CryptDestroyHash(mysql->hash);
   CryptCreateHash(mysql->prov,CALG_SHA1,0,0,&mysql->hash);
   CryptHashData(mysql->hash,challenge,20,0);
   CryptHashData(mysql->hash,resp,20,0);
   CryptGetHashParam(mysql->hash,HP_HASHVAL,resp,&mysql->no,0);
   CryptDestroyHash(mysql->hash);
   CryptReleaseContext(mysql->prov,0);

   mysql->d=mysql->b+4;
   *(ZP)mysql->d=1<<2|1<<9|1<<15|1;
   mysql->d+=4;
   *(ZP)mysql->d=1<<24;
   mysql->d+=4;
   *mysql->d=8;
   mysql->d+=24;
   aaStringCopy(mysql->d,mysql->user.name);
   aaStringLen(mysql->user.name,&sl);
   mysql->d+=1+sl;
   *mysql->d=20;
   mysql->d+=1;
   for(mysql->i=0;mysql->i<20;mysql->i++) { mysql->d[mysql->i]=resp[mysql->i]^temp[mysql->i]; }
   mysql->d+=22;
   *(ZP)mysql->b=(mysql->d-mysql->b-4)|(1<<24);
   aaNetTcpCallWrite(mysql->call.handle,mysql->d-mysql->b,mysql->b);
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   mysql->stage=1080;
   break; //apr19




   case 1080:
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   if(mysql->call.status.rcve_bytes<4) { break; }
   aaNetTcpCallRead(mysql->call.handle,4,&mysql->no);
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   mysql->i=4;
   mysql->no&=(1<<24)-1;
   mysql->stage=1090;
 break; //apr19




   case 1090:
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   todo=mysql->call.status.rcve_bytes;
   todo=aaNumRoof(todo,mysql->no);
   if(todo==0) { break; }
   aaNetTcpCallRead(mysql->call.handle,todo,mysql->b);
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   mysql->i=todo;
   if(mysql->i==-1||*mysql->b)   { oof; }
   mysql->is_ready=YES;
   if(mysql->cmd[0]==NULL_CHAR) { mysql->stage=500; break; }
   mysql->stage=1100;
 break; //apr19




   case 1100: ///=== send query
   aaStringLen(mysql->cmd,&sl);
   ret=RET_YES;
   if((proc=mysql->proc)!=NULL)
    {
    ret=proc(mysql,mysql->seq_o,MYSQL_QRY,0,0,0,sl,mysql->cmd);
    }
   if(ret==RET_YES)
    {
    mqlep=(_mysqlentry*)&mqdata[0];
    mqlep->msg=MYSQL_QRY;
    mqlep->seq=mysql->seq_o;
    mqlep->row=mqlep->col=mqlep->code=0;
    mqlep->len=sl;
    aaMemoryCopy(mqlep->data,mqlep->len,mysql->cmd);
    mqlep->data[mqlep->len]=NULL_CHAR;
///    if((ret=aaListAppend(&mysql->list,0,0,sizeof(_mysqlentry)+mqlep->len,mqlep))!=YES) { oops; }
    aaQueWriteDword(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len);
    aaQueWrite(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len,mqlep);
    aaQueStatus(mysql->response_que.handle,&mysql->response_que.status);
    mysql->entry_count++;
    }
   mysql->seq_o++;
   mysql->d[4]=0x3;
   aaStringCopy(mysql->d+5,mysql->cmd);
   aaStringLen(mysql->d+5,&sl);
   *(ZP)mysql->d=sl+1;
   todo=4+*(ZP)mysql->d;
   aaNetTcpCallWrite(mysql->call.handle,todo,mysql->d);
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   mysql->i=todo;
   mysql->p=mysql->b,
   mysql->txt[0]=0;
   mysql->typ[0]=0;
   mysql->fields=mysql->field=mysql->value=mysql->row=mysql->exit=mysql->rc=0;
   mysql->stage=1200;
 break; //apr19




   case 1200:
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   if(mysql->call.status.rcve_bytes<4) { break; }
   aaNetTcpCallRead(mysql->call.handle,4,&mysql->no);
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   mysql->i=4;
   mysql->rc=0;
   mysql->no&=0xffffff;
   mysql->stage=1210;
 break; //apr19




   case 1210:
   if(mysql->rc>=(Z)mysql->no) { mysql->stage=1220; break; }
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   todo=mysql->call.status.rcve_bytes;
   todo=aaNumRoof(todo,mysql->no-mysql->rc);
   if(todo==0) { break; }
   aaNetTcpCallRead(mysql->call.handle,todo,mysql->b+mysql->rc);
   aaNetTcpCallStatus(mysql->call.handle,&mysql->call.status);
   mysql->i=todo;
   mysql->rc+=mysql->i;
   if(mysql->rc!=mysql->i) oof;
   mysql->stage=1220;
 break; //apr19





   case 1220:
   if(mysql->i<1)                        { mysql->stage=1600; break; } // con lost
   err=*(BP)mysql->b;

   //aaDebugf("err=0x%02x %x",err,1146);
   //aaDebugf("err=%x no=%i ex=%i",err,mysql->no,mysql->exit);

   if(err==0x00&&!mysql->exit)  // success
    {
    mysql->stage=1450;
    break;
    }

   if(err==0xff&&!mysql->exit)  /// failure
    {
    sl=mysql->rc;
    mysql->b[sl]=NULL_CHAR;
    e_code=*(WP)&mysql->b[1];
    aaStringNCopy(x_code,&mysql->b[4],5,YES);
    aaStringNCopy(e_text,&mysql->b[9],sl-9,YES);
    ret=RET_YES;
    if((proc=mysql->proc)!=NULL)
     {
     ret=proc(mysql,mysql->seq_i,MYSQL_RES,0,0,e_code,sl-9,e_text);
     }
    if(ret==RET_YES)
     {
     mqlep=(_mysqlentry*)&mqdata[0];
     mqlep->msg=MYSQL_RES;
     mqlep->seq=mysql->seq_i;
     mqlep->row=mqlep->col=0;
     mqlep->code=e_code;
     mqlep->len=sl-9;
     aaMemoryCopy(mqlep->data,mqlep->len,e_text);
     mqlep->data[mqlep->len]=NULL_CHAR;
///     if((ret=aaListAppend(&mysql->list,0,0,sizeof(_mysqlentry)+mqlep->len,mqlep))!=YES) { oops; }
     aaQueWriteDword(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len);
     aaQueWrite(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len,mqlep);
     aaQueStatus(mysql->response_que.handle,&mysql->response_que.status);
     mysql->entry_count++;
     }
    mysql->stage=2000;
    break;
    }

   if(!mysql->fields)
    {
    aaMemoryCopy(&mysql->fields,mysql->no,mysql->b);
    ///memcpy(&mysql->fields,mysql->b,mysql->no);
    mysql->field=mysql->fields;
    mysql->stage=1200;
    break;
    }

   if(err==0xfe&&mysql->no<9)
    {
    if(mysql->exit++) { mysql->stage=1450; break; }
    else              { mysql->stage=1200; break; }
    }
   mysql->stage=1250;
 break; //apr19




   case 1250: ///=== the values
   if(!mysql->value) { mysql->stage=1400; break; }
   mysql->txt[0]=NULL_CHAR;
   mysql->i=mysql->fields-mysql->value;
   mysql->len=1;
   mysql->g=*(BP)mysql->p;
   mysql->g=(mysql->g==0||mysql->g==251)?0:(mysql->g==252)?2:(mysql->g==253)?3:(mysql->g==254)?8:1;
   if(mysql->g>1)    { mysql->p++; }
   aaMemoryCopy(&mysql->len,mysql->g,mysql->p);
   mysql->p+=mysql->g;
   if(mysql->g) { aaMemoryCopy(mysql->txt,mysql->len,mysql->p);  }
   mysql->txt[mysql->len]=NULL_CHAR;
   if(mysql->txt[0]==0) { mysql->len=0; } // adde
   ret=RET_YES;
   if((proc=mysql->proc)!=NULL)
    {
    ret=proc(mysql,mysql->seq_i,MYSQL_VAL,mysql->row,mysql->i,(H)mysql->typ[mysql->i],(H)mysql->len,mysql->txt);
    }
   if(ret==RET_YES)
    {
    mqlep=(_mysqlentry*)&mqdata[0];
    mqlep->msg=MYSQL_VAL;
    mqlep->seq=mysql->seq_i;
    mqlep->row=mysql->row;
    mqlep->col=mysql->i;
    mqlep->code=(H)mysql->typ[mysql->i];
    mqlep->len=(H)mysql->len;
    aaMemoryCopy(mqlep->data,mqlep->len,mysql->txt);
    mqlep->data[mqlep->len]=NULL_CHAR;

    //aaDebugf("msg=%i %i [%s]",mqlep->msg,mysql->len,mqlep->data);
    /*
     //added
      aaStringLen(mqlep->data,&sl);
      mqlep->len=sl;
      mqlep->data[mqlep->len]=NULL_CHAR;
      */


///    if((ret=aaListAppend(&mysql->list,0,0,sizeof(_mysqlentry)+mqlep->len,mqlep))!=YES) { oops; }
    aaQueWriteDword(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len);
    aaQueWrite(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len,mqlep);
    aaQueStatus(mysql->response_que.handle,&mysql->response_que.status);
    mysql->entry_count++;
    }
   mysql->p+=mysql->len;
   if(!--mysql->value)  { mysql->row++; mysql->value=mysql->fields; mysql->p=mysql->b; mysql->stage=1400; break;  }
   break;


   case 1400: ///=== the fields
   if(!mysql->field) { mysql->stage=1200; break; }
   mysql->i=mysql->fields-mysql->field;
   mysql->cat=mysql->p;                   mysql->p+=1+*mysql->p; *mysql->cat++=0;
   mysql->db=mysql->p;                    mysql->p+=1+*mysql->p; *mysql->db++=0;
   mysql->table=mysql->p;                 mysql->p+=1+*mysql->p; *mysql->table++=0;
   mysql->table_=mysql->p;                mysql->p+=1+*mysql->p; *mysql->table_++=0;
   mysql->name=mysql->p;                  mysql->p+=1+*mysql->p; *mysql->name ++=0;
   mysql->name_=mysql->p;                 mysql->p+=1+*mysql->p; *mysql->name_++=0; *mysql->p++=0;
   mysql->charset=*(WP)mysql->p;          mysql->p+=2;
   mysql->length=*(NP)mysql->p;           mysql->p+=4;
   mysql->typ[mysql->i]=*(BP)mysql->p;    mysql->p+=1;
   mysql->flags=*(WP)mysql->p;            mysql->p+=2;
   mysql->digits=*(BP)mysql->p;           mysql->p+=3;
   if(!--mysql->field)  { mysql->value=mysql->fields; }
   mysql->p=mysql->b;


   aaStringLen(mysql->name,&sl);
   if((G)sl>mysql->length) { mysql->length=sl; }

   mysql->length=aaNumClamp(mysql->length,2,512);
   ret=RET_YES;
   if((proc=mysql->proc)!=NULL)
    {
    ret=proc(mysql,mysql->seq_i,MYSQL_FLD,mysql->row,mysql->i,0,mysql->length,mysql->name);
    }
   if(ret==RET_YES)
    {
    mqlep=(_mysqlentry*)&mqdata[0];
    mqlep->msg=MYSQL_FLD;
    mqlep->seq=mysql->seq_i;
    mqlep->row=mysql->row;
    mqlep->col=mysql->i;
    mqlep->code=0;
    mqlep->len=(H)mysql->length;


      //aaDebugf("<%s> %i, %I64d %i",mysql->name,sl,mysql->len,mysql->length);
    aaMemoryCopy(mqlep->data,mqlep->len,mysql->name);
    mqlep->data[mqlep->len]=NULL_CHAR;

    //aaDebugf("msg=%i %i %I64d [%s]",mqlep->msg,mysql->length,mysql->len,mqlep->data);
     //added
      aaStringLen(mqlep->data,&sl);
      mqlep->len=sl;
      mqlep->data[mqlep->len]=NULL_CHAR;


///    if((ret=aaListAppend(&mysql->list,0,0,sizeof(_mysqlentry)+mqlep->len,mqlep))!=YES) { oops; }
    aaQueWriteDword(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len);
    aaQueWrite(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len,mqlep);
    aaQueStatus(mysql->response_que.handle,&mysql->response_que.status);
    mysql->entry_count++;
    }
   mysql->stage=1200;
   break;




   case 1450:
   mysql->txt[0]=NULL_CHAR;
   ret=RET_YES;
   if((proc=mysql->proc)!=NULL)
    {
    ret=proc(mysql,mysql->seq_i,MYSQL_RES,mysql->row,mysql->i,0,0,mysql->txt);
    }
   if(ret==RET_YES)
    {
    mqlep=(_mysqlentry*)&mqdata[0];
    mqlep->msg=MYSQL_RES;
    mqlep->seq=mysql->seq_i;
    mqlep->row=mysql->row;
    mqlep->col=mqlep->code=0;
    aaStringCopyfLen(mqlep->data,&mqlep->len,"OK");
///    if((ret=aaListAppend(&mysql->list,0,0,sizeof(_mysqlentry)+mqlep->len,mqlep))!=YES) { oops; }
    aaQueWriteDword(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len);
    aaQueWrite(mysql->response_que.handle,sizeof(_mysqlentry)+mqlep->len,mqlep);
    aaQueStatus(mysql->response_que.handle,&mysql->response_que.status);
    mysql->entry_count++;
    }
   //mysql->seq_i++;
   mysql->stage=2000;
 break; //apr19



   case 2000:
//   if(mysql->list.count!=0) {     mysql->is_list_fin=YES; }
   mysql->seq_i++;
   mysql->responses_received++;
   mysql->stage=500;
   //break;
   return RET_YES;


   case 1600:
   break;


   }

  go++;
  if(mysql->stage>=1200&&mysql->stage<=1450&&go<mysql->max_its)
   {
   if(mysql->stage==1200&&mysql->call.status.rcve_bytes<4)  { break; }
   if(mysql->stage==1210&&mysql->call.status.rcve_bytes==0) { break; }
   continue;
   }
  break;
  }
 return RET_YES;
 }








 B aaMySqlQuery                        (_mysql*mysql,QP seq,VP fmt,...)
 {
 va_list argptr;
 B str[_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 aaQueWriteDword(mysql->query_que.handle,sl);
 aaQueWrite(mysql->query_que.handle,sl,str);
 aaQueStatus(mysql->query_que.handle,&mysql->query_que.status);
 if(seq) { *seq=mysql->queries_sent; }
 mysql->queries_sent++;
 mysql->io_dif=mysql->queries_sent-mysql->responses_received;
 return RET_YES;
 }



 B aaMySqlPeek                         (_mysql*mysql,H indexoff,H maxbytes,VP data)
 {
 B ret;
 H len,i,off;
 _mysqlentry*msen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(maxbytes<sizeof(_mysqlentry)) { return RET_BOUNDS; }
 if(data==NULL) { return RET_BADPARM; }
 if(mysql->entry_count==0) { return RET_NOTREADY; }
 aaMemoryFill(data,sizeof(_mysqlentry),0);
 if(indexoff>=mysql->entry_count) { return RET_BOUNDS; }
 i=0;
 off=0;
 while(1)
  {
  if(mysql->response_que.status.bytes<(off+4+sizeof(_mysqlentry))) { return RET_NOTREADY; }
  if((ret=aaQuePeek(mysql->response_que.handle,off,4,&len))!=RET_YES) { oops;  }
  if(len>maxbytes)
   {
   if((ret=aaQuePeek(mysql->response_que.handle,off+4,sizeof(_mysqlentry),data))!=RET_YES) { oops;  }
   return RET_BOUNDS;
   }
  if((ret=aaQuePeek(mysql->response_que.handle,off+4,sizeof(_mysqlentry),data))!=RET_YES) { oops;  }
  if(i==indexoff)
   {
   if((ret=aaQuePeek(mysql->response_que.handle,off+4,len,data))!=RET_YES) { oops;  }
   break;
   }
  msen=(_mysqlentry*)data;
  off+=4;
  off+=sizeof(_mysqlentry);
  off+=msen->len;
  i++;
  }
 msen=(_mysqlentry*)data;
 msen->data[msen->len]=0;
 return RET_YES;
 }



 B aaMySqlDiscard                      (_mysql*mysql)
 {
 B ret;
 H len;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(mysql->response_que.status.bytes<4) { return RET_NOTREADY; }
 if((ret=aaQuePeek(mysql->response_que.handle,0,4,&len))!=RET_YES) { oops;  }
 if((len+4)>mysql->response_que.status.bytes) { return RET_NOTREADY; }
 if((ret=aaQueDiscard(mysql->response_que.handle,4+len))!=RET_YES) { oops;  }
 aaQueStatus(mysql->response_que.handle,&mysql->response_que.status);
 mysql->entry_count--;
 return RET_YES;
 }




 B aaMySqlRead                         (_mysql*mysql,H maxbytes,VP data)
 {
 B ret;

 if((ret=aaMySqlPeek(mysql,0,maxbytes,data))!=RET_YES) { return ret; }
 if((ret=aaMySqlDiscard(mysql))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }




 B aaMySqlQueryExInit                  (_mysql*mysql)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 aaStringNull(mysql->qry_buf);
 return RET_YES;
 }





 B aaMySqlQueryExMore                  (_mysql*mysql,VP fmt,...)
 {
 va_list argptr;
 B str[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(aaStringIsEmpty(fmt,YES)!=NO) { return RET_BADPARM; }
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 if(sl==0) { return RET_BOUNDS; }
 aaStringAppendf(mysql->qry_buf,"%s ",str);
 return RET_YES;
 }




 B aaMySqlQueryExExec                  (_mysql*mysql,QP seq)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(aaStringIsEmpty(mysql->qry_buf,YES)!=NO) { return RET_NOTINITIALIZED; }
 return(aaMySqlQuery(mysql,seq,"%s",mysql->qry_buf));
 }


 B aaMySqlBeautifierReset              (_mysql*mysql)
 {
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(mysql->beautifier.magic!=aaHPP(aaMySqlBeautifierReset))
  {
  aaMemoryFill(&mysql->beautifier,sizeof(_mysqlbeautifier),0);
  mysql->beautifier.magic=aaHPP(aaMySqlBeautifierReset);
  }
 if(mysql->beautifier.list.magic==0) { aaListNew(&mysql->beautifier.list); }
 aaListReset(&mysql->beautifier.list);
 mysql->beautifier.stage=10;
 return RET_YES;
 }




 B aaMySqlBeautifierRead               (_mysql*mysql,H maxchars,VP str)
 {
 B ret;
 H mc,i,c,go;
 H cs[128];
 BP kp,vp;
 _mysqlentry*mqentry;
 B txt[_4K];
 B etc[_4K];

 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(str==NULL) { return RET_BADPARM;  }
 if(maxchars==0) { return RET_BOUNDS; }
 if(mysql->beautifier.magic!=aaHPP(aaMySqlBeautifierReset))
  {
  if((ret=aaMySqlBeautifierReset(mysql))!=RET_YES) { oops; return ret; }
  }
 if(mysql->beautifier.list.magic!=aaHPP(aaListNew)) {  return RET_NOTINITIALIZED; }
 aaStringNull(str);

 switch(mysql->beautifier.stage)
  {
  default:
  return RET_NOTINITIALIZED;


  case 10:
  for(go=0;go<20;go++)
   {
   aaMySqlYield(mysql);
   mysql->beautifier.result=0;
   if((ret=aaMySqlRead(mysql,sizeof(etc),etc))==RET_NOTREADY) { return ret; }
   if(ret!=RET_YES) { oops; }
   mqentry=(_mysqlentry*)etc;
   if(mqentry->msg==MYSQL_QRY) { aaListReset(&mysql->beautifier.list); }
   if((ret=aaListAppend(&mysql->beautifier.list,0,0,sizeof(_mysqlentry)+mqentry->len,mqentry))!=YES) { oops; }
   ///if(mqentry->msg!=MYSQL_RES) { return RET_NOTREADY; }
   if(mqentry->msg==MYSQL_RES) { break; } //return RET_NOTREADY; }
   }
  if(mqentry->msg!=MYSQL_RES) { return RET_NOTREADY; }
  //if(go==10) { return RET_NOTREADY; }


  mc=0;
  aaMemoryFill(cs,sizeof(cs),0);
  for(i=0;i<mysql->beautifier.list.count;i++)
   {
   if(aaListPointerGet(&mysql->beautifier.list,i,(VP)&kp,(VP)&vp)!=YES) oof;
   mqentry=(_mysqlentry*)vp;
//   aaDebugf("msg=%i i=%i l=%i %s",mqentry->msg,i,mqentry->len,mqentry->data);

   if(mqentry->msg==MYSQL_RES) {  mysql->beautifier.result=mqentry->code;   continue; }
   if(mqentry->msg==MYSQL_QRY)        { continue; }
//if(mqentry->col==1) { aaDebugf("msg=%i i=%i l=%i %s",mqentry->msg,i,mqentry->len,mqentry->data); }
   if(mqentry->len>=cs[mqentry->col]) { cs[mqentry->col]=mqentry->len;  }
   if(mqentry->col>=mc)               { mc=mqentry->col; }
   }
  mc++;
  mysql->beautifier.col_count=mc;
  for(i=0;i<128;i++)   {   mysql->beautifier.col_size[i]=cs[i];   }
  for(i=0;i<mysql->beautifier.col_count;i++)
   {
   aaStringCopyf(mysql->beautifier.fmt[i],"%%-%is ",mysql->beautifier.col_size[i]+3);
   }
  mysql->beautifier.iter_i=0;
  mysql->beautifier.iter_c=0;
  mysql->beautifier.stage=30;
//  break;




  case 30:
  aaStringNull(txt);
  i=mysql->beautifier.iter_i;
  c=mysql->beautifier.iter_c;
  while(1)
   {
   if(i>=mysql->beautifier.list.count)    {    oof;    mysql->beautifier.stage=10;    break;    }
   if(aaListPointerGet(&mysql->beautifier.list,i,(VP)&kp,(VP)&vp)!=YES) oof;
   mqentry=(_mysqlentry*)vp;
   if(mqentry->msg==MYSQL_QRY||mqentry->msg==MYSQL_RES)
    {
    aaStringCopyf(str,"%s",mqentry->data);
    mysql->beautifier.seq=mqentry->seq;
    mysql->beautifier.msg=mqentry->msg;
    mysql->beautifier.row=mqentry->row;
    i++;
    mysql->beautifier.iter_i=i;
    if(i>=mysql->beautifier.list.count)  {     mysql->beautifier.stage=10; }
    return RET_YES;
    }
   i++;
   if(c==0)
    {
    mysql->beautifier.seq=mqentry->seq;
    mysql->beautifier.msg=mqentry->msg;
    mysql->beautifier.row=mqentry->row;
    }
   aaStringAppendf(txt,mysql->beautifier.fmt[c],mqentry->data);
   c++;
   if(c>=mysql->beautifier.col_count)
    {
    aaStringCopyf(str,"%s",txt);
    c=0;
    mysql->beautifier.iter_i=i;
    mysql->beautifier.iter_c=c;
    if(i>=mysql->beautifier.list.count)  {     mysql->beautifier.stage=10; }
    return RET_YES;
    }
   }
  break;
  }

 return RET_NOTREADY;
 }



  #if 0

 B aaMySqlToList                       (_mysql*mysql,_list*list,HP colcount,H maxcols,HP colwidth,HP result)
 {
 B ret;
 H mc,i;
 H cs[128];
 BP kp,vp;
 _mysqlentry*mqentry;
 B str[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mysql==NULL) { return RET_BADPARM; }
 if(mysql->magic!=aaHPP(aaMySqlNew)) { return RET_NOTINITIALIZED; }
 if(result) { *result=0; }
 if((ret=aaMySqlRead(mysql,sizeof(str),str))==RET_NOTREADY) { return ret; }
 if(ret!=RET_YES) { oops; }
 mqentry=(_mysqlentry*)str;
 if(mqentry->msg==MYSQL_QRY) { aaListReset(list); }
 if((ret=aaListAppend(list,0,0,sizeof(_mysqlentry)+mqentry->len,mqentry))!=YES) { oops; }
 if(mqentry->msg!=MYSQL_RES) { return RET_NOTREADY; }
 mc=0;
 aaMemoryFill(cs,sizeof(cs),0);
 for(i=0;i<list->count;i++)
  {
  if(aaListPointerGet(list,i,(VP)&kp,(VP)&vp)!=YES) oof;
  mqentry=(_mysqlentry*)vp;
  if(mqentry->msg==MYSQL_RES)
   {
   if(result) { *result=mqentry->code; }
   }
  if(mqentry->msg==MYSQL_QRY) { continue; }
  if(mqentry->len>=cs[mqentry->col]) { cs[mqentry->col]=mqentry->len;  }
  if(mqentry->col>=mc) { mc=mqentry->col; }
  }
 mc++;
 if(colcount)   { *colcount=mc; }
 for(i=0;i<maxcols;i++)
  {
  if(colwidth) { colwidth[i]=cs[i];  }
  }
 return RET_YES;
 }


#endif

/*

 B aaMySqlProc                         (_mysql*mysql,Q seq,H msg,H row,H col,H code,H len,VP data)
 {
 B ret;
 BP kp,vp;
 H i;
 _mysqlentry*mqlep;
 B str[_4K];

 switch(msg)
  {
  default: oof; break;

  case MYSQL_QRY:
  aaListReset(&mysql->list);
  //aaDebugf("------");
  //aaDebugf(">>> %i %s",strlen(data),data);
  break;

  case MYSQL_FLD:
  //aaDebugf("FLD %-4i:%-4i       [%s]",row,col,data);
  break;

  case MYSQL_VAL:
  //aaDebugf("VAL %-4i:%-4i 0x%02x  [%s]",row,col,code,data);
  break;

  case MYSQL_ERR:
  //aaDebugf("ERR err=%-5i       [%s]",code,data);
  break;

  case MYSQL_FIN:
  aaDebugf("got fin,, list is %i",mysql->list.count);
  for(i=0;i<mysql->list.count;i++)
   {
   if(aaListPointerGet(&mysql->list,i,(VP)&kp,(VP)&mqlep)!=YES) oof;
   aaDebugf("%-4i seq=%I64d msg=%i %-4i:%-4i code=%-5i len=%-4i data=[%s]",i,mqlep->seq,mqlep->msg,mqlep->row,mqlep->col,mqlep->code,mqlep->len,mqlep->data);
   //aaStringHexDump(str,1,mysql->list.entry[i].val_len,16,1,1,mqlep,"xxx");
   //aaDebugf("%s",str);
   }

  return RET_NO;
  break;
  }

 return RET_YES;
 }



 B aaMySqlProc                         (_mysql*mysql,H msg,H row,H col,H code,H len,VP data)
 {
 B ret;
 BP kp,vp;
 H i;
 _mysqlentry*mqlep;
 B str[_4K];

 switch(msg)
  {
  default: oof; break;

  case MYSQL_QRY:
  aaListReset(&mysql->list);
  //aaDebugf("------");
  //aaDebugf(">>> %i %s",strlen(data),data);
  break;

  case MYSQL_FLD:
  //aaDebugf("FLD %-4i:%-4i       [%s]",row,col,data);
  break;

  case MYSQL_VAL:
  //aaDebugf("VAL %-4i:%-4i 0x%02x  [%s]",row,col,code,data);
  break;

  case MYSQL_ERR:
  //aaDebugf("ERR err=%-5i       [%s]",code,data);
  break;

  case MYSQL_FIN:
  aaDebugf("got fin,, list is %i",mysql->list.count);
  for(i=0;i<mysql->list.count;i++)
   {
   if(aaListPointerGet(&mysql->list,i,(VP)&kp,(VP)&mqlep)!=YES) oof;
   aaDebugf("%-4i seq=%I64d msg=%i %-4i:%-4i code=%-5i len=%-4i data=[%s]",i,mqlep->seq,mqlep->msg,mqlep->row,mqlep->col,mqlep->code,mqlep->len,mqlep->data);
   //aaStringHexDump(str,1,mysql->list.entry[i].val_len,16,1,1,mqlep,"xxx");
   //aaDebugf("%s",str);
   }

  return RET_NO;
  break;
  }

 return RET_YES;
 }

 B aaMySqlProc                         (_mysql*mysql,H msg,H row,H col,H code,H len,VP data)
 {
 switch(msg)
  {
  default: oof; break;

  case MYSQL_QRY:
  aaDebugf("------");
  aaDebugf(">>> %s",data);
  break;

  case MYSQL_FLD:
  aaDebugf("FLD %-4i:%-4i       [%s]",row,col,data);
  break;

  case MYSQL_VAL:
  aaDebugf("VAL %-4i:%-4i 0x%02x  [%s]",row,col,code,data);
  break;

  case MYSQL_ERR:
  aaDebugf("ERR err=%-5i       [%s]",code,data);
  break;

  case MYSQL_FIN:
  break;
  }

 return RET_YES;
 }


*/


/*-----------------------------------------------------------------------*/

 B aaShellNew                          (_shell*shell,VP fmt,...)
 {
 B ascii;
 B str[_4K];
 va_list argptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 aaMissingParm(fmt);
 aaFmt(fmt,argptr,str);
 aaMemoryFill(shell,sizeof(_shell),0);
 shell->magic=aaHPP(aaShellNew);
 aaStringCopyf(shell->cmd,"%s",str);
 while(1)
  {
  aaStringLastCharGet(shell->cmd,0,&ascii);
  if(ascii==CR_CHAR||ascii==LF_CHAR)
   {
   aaStringLastCharSet(shell->cmd,0,0,1);
   continue;
   }
  break;
  }
 if(shell->cmd[0]==NULL_CHAR) { return RET_BADPARM; }
 shell->stage=100;
 return RET_YES;
 }


 B aaShellDelete                       (_shell*shell)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 if(shell->magic!=aaHPP(aaShellNew)) { return RET_NOTINITIALIZED; }
 if(shell->cgi.handle!=0) { aaNetCgiClientDestroy(shell->cgi.handle); }
 if(shell->line.magic) { aaListDelete(&shell->line); }
 aaMemoryFill(shell,sizeof(_shell),0);
 return RET_YES;
 }



 B aaShellYield                        (_shell*shell,H iterations)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 if(shell->magic!=aaHPP(aaShellNew)) { return RET_NOTINITIALIZED; }
 while(1)
 {
 switch(shell->stage)
  {
  case 100:
  if((ret=aaNetCgiClientCreate(&shell->cgi.handle,1,0,0,"cmd.exe",0))!=YES) { oops; }
  aaNetCgiClientStatus(shell->cgi.handle,&shell->cgi.status);
  aaListNew(&shell->line);
  shell->stage=120;
  shell->next=200;
  break;


  case 120:
  while(1)
   {
   ret=aaNetCgiClientStringReadQuick(shell->cgi.handle,30,&shell->chars,&shell->is_prompt,NULL,_4K,shell->txt);
   if(ret==RET_NOTREADY) { break; }
   if(shell->is_prompt==YES) {  shell->stage=shell->next; break; }
   if((ret=aaListAppendf(&shell->line,0,0,"%s\r\n",shell->txt))!=YES) { oops; }
   if(shell->chars==0)      { continue; }
   }
  break;


  case 200:
  if(shell->cmd[0]!=NULL_CHAR)
   {
   if((ret=aaNetCgiClientWritef(shell->cgi.handle,"%s\r\n",shell->cmd))!=YES) { oops; }
   aaNetCgiClientStatus(shell->cgi.handle,&shell->cgi.status);
   shell->stage=120;
   shell->next=300;
   }
  else  {   oof;   shell->stage=300;   }
  break;

  case 300:
  return RET_YES;
  }
 if(iterations==0) { break; }
 iterations--;
 }

 return RET_NOTREADY;
 }





 B aaShellLinePointer                  (_shell*shell,H line,HP chars,PP ptr)
 {
 H ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMissingParm(shell);
 if(shell->magic!=aaHPP(aaShellNew)) { return RET_NOTINITIALIZED; }
 if(chars) { *chars=0; }
 if(ptr)   { *ptr=NULL; }
 if(line>=shell->line.count) { return RET_BOUNDS; }
 ch=shell->line.entry[line].val_len;
 if(chars) { *chars=ch; }
 if(aaListPointerGet(&shell->line,line,0,ptr)!=YES) { oof; }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 B aaColorHalfToneGet                  (_rgba*rgba,B index)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(rgba==NULL) { return RET_BADPARM; }
 if(index<216) { aaRgbaCopy(rgba,&aa.color_system.half_pal[index]);  }
 else            { aaRgbaSet(rgba,0,0,0,0); }
 return RET_YES;
 }




 B aaColorHalfToneCalculate            (_rgba*rgba,_cord*cord,BP index,_rgba*orgba)
 {
 N r,g,b,x,y,i;
 N rtmp,gtmp,btmp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(rgba==NULL) { return RET_BADPARM; }
 if(index==NULL&&orgba==NULL) { return RET_BADPARM; }
 r=rgba->r;  g=rgba->g;  b=rgba->b;
 x=cord->x;  y=cord->y;
 rtmp=(r/51)+((r%51)>aa_halftone8x8[(x%8)*8+y%8]);
 gtmp=(g/51)+((g%51)>aa_halftone8x8[ (x%8)*8+y%8]);
 btmp=(b/51)+((b%51)>aa_halftone8x8[(x%8)*8+y%8]);
 i=rtmp+(gtmp*6)+(btmp*36);
 if(index) { *index=(B)i; }
 if(orgba) { aaRgbaCopy(orgba,&aa.color_system.half_pal[i]);  }
 return RET_YES;
 }






/*-----------------------------------------------------------------------*/


 B aaFontCreate                        (HP handle,VP facettf,N logw,N logh,B weight,B italic,B underline,B prefmono,B smoothed,H charset)
 {
 B ret;
 _aa_fontobject*fntp;
 HGDIOBJ oldobj=NULL;
 HFONT hfnt;
 HBITMAP hbmp=NULL;
 HDC dc=NULL;
 BITMAPINFO bitmapinfo;
 //H max_wid;
 TEXTMETRIC textmetrics;
 BP dib_data;
 H dib_offset;
 H img_offset;
 H grid_width=0;
 H grid_offset;
 N font_width=0,font_height=0;
 N x_pos,y_pos,dif;
 N i,w1,w2;
 ABC charABCWidth[256];
 N charWidth[256];
 B fail_state;
 W weyght;
 N res;
 B LOAD_MODE;
 H sl,bytes_loaded;
 B is_folder,found;
 BP file_mem;
 B ot[4];
 _aa_ttfoffsettable     ttf_ofsettable;
 _aa_ttftabledirectory  ttf_tabledir;
 _aa_ttfnametableheader ttf_nametablehdr;
 _aa_ttfnamerecord      ttf_namerecord;
 H cc,npos;
 C facetext[257];
 W v1;
 H h1,fon_off;
 BOOL was_smooth;
 B lum;
 N alpha;
 D luminance;
 BP bp;
 BP facettfptr;
 HANDLE memfont_resource_handle=0;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }
 if(facettf==NULL) { return RET_BADPARM; }
 aaCast(facettfptr,BP,facettf);


 /* don't change these, even if docs say so */
 if(charset==1) { charset=DEFAULT_CHARSET; }
 else
 if(charset==0) { charset=ANSI_CHARSET; }

 LOAD_MODE=0;
 aaStringLen(facettf,&sl);
 if(sl>=5)
  {
   aaStringIsIString(&facettfptr[sl-4],&dif,".ttf",".fon",NULL);
   if(dif==0||dif==1)
    {
    if((ret=aaFileInfoGet(facettfptr,0,&is_folder,0,0,0))!=YES) {   return ret; }
    if(is_folder==YES) { return RET_FAILED; }
    LOAD_MODE=(B)(dif+1);
    }
  }


 if((ret=aa_ObjectCreate(aa.font_system.object_id,handle,(VP)&fntp))!=RET_YES) { oops; return ret; }
 fntp->self_handle=*handle;
 weyght=(W)(weight<<2);
 weyght=(W)aaNumRoof(weyght,999);
 if(italic) { fntp->status.is_italic=YES; }
 if(underline) { fntp->status.is_underline=YES; }


 if(LOAD_MODE==0) ///================================ PRE-INSTALLED FONT
  {
  aaStringLen(facettfptr,&sl);
  if(sl==0||sl>32)
   {
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_NOTFOUND;
   }
  for(cc=0;cc<sl;cc++)
   {
   if(facettfptr[cc]=='\\'||facettfptr[cc]=='/'||facettfptr[cc]<32||facettfptr[cc]>126)
    {
    aa_ObjectDestroy(aa.font_system.object_id,*handle);
    *handle=0;
    return RET_NOTFOUND;
    }
   }
  aaStringCopy(facetext,facettfptr);
  }
 else
 if(LOAD_MODE==1) ///======================================= TTF FILE
  {
  if((ret=aaFileLoadToMemory(facettfptr,0,F32,(VP)&file_mem,&bytes_loaded))!=RET_YES)
   {
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return ret;
   }
  cc=0;
  aaMemoryCopy(&ttf_ofsettable,sizeof(ttf_ofsettable),&file_mem[cc]);
  cc+=sizeof(ttf_ofsettable);
  ttf_ofsettable.num_tables =(W)aaNumSwapWord(ttf_ofsettable.num_tables);
  ttf_ofsettable.maj_ver=(W)aaNumSwapWord(ttf_ofsettable.maj_ver);
  ttf_ofsettable.min_ver=(W)aaNumSwapWord(ttf_ofsettable.min_ver);
  if(ttf_ofsettable.maj_ver!=1||ttf_ofsettable.min_ver!=0)
   {
   aa_MemoryRelease(file_mem);
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  found=NO;
  for(i=0;i<ttf_ofsettable.num_tables;i++)
   {
   aaMemoryCopy(&ttf_tabledir,sizeof(ttf_tabledir),&file_mem[cc]);
   cc+=sizeof(ttf_tabledir);
   aaStringNICompare(ttf_tabledir.tag,"name",4,&dif);
   if(dif==0)
    {
    found=YES;
    ttf_tabledir.len=aaNumSwapDword(ttf_tabledir.len);
    ttf_tabledir.off=aaNumSwapDword(ttf_tabledir.off);
    break;
    }
   }
  if(found!=YES)
   {
   aa_MemoryRelease(file_mem);
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  //move to offset we got from Offsets Table
  cc=ttf_tabledir.off;
  aaMemoryCopy(&ttf_nametablehdr,sizeof(ttf_nametablehdr),&file_mem[cc]);
  cc+=sizeof(ttf_nametablehdr);
  ttf_nametablehdr.count=(W)aaNumSwapWord(ttf_nametablehdr.count);
  ttf_nametablehdr.offset= (W)aaNumSwapWord(ttf_nametablehdr.offset);
  found=NO;
  for(i=0;i<ttf_nametablehdr.count; i++)
   {
   aaMemoryCopy(&ttf_namerecord,sizeof(ttf_namerecord),&file_mem[cc]);
   cc+=sizeof(ttf_namerecord);
   ttf_namerecord.name_id= (W)aaNumSwapWord(ttf_namerecord.name_id);
   //1 says that this is font name. 0 for example determines copyright info
   if(ttf_namerecord.name_id==1)
    {
    ttf_namerecord.str_len=(W)aaNumSwapWord(ttf_namerecord.str_len);
    ttf_namerecord.str_off=(W)aaNumSwapWord(ttf_namerecord.str_off);
    //save file position, so we can return to continue with search
    npos=cc;
    cc=ttf_tabledir.off+ttf_namerecord.str_off+ttf_nametablehdr.offset;
    aaStringNull(facetext);
    if(ttf_namerecord.str_len>0&&ttf_namerecord.str_len<32)
     {
     aaMemoryCopy(facetext,ttf_namerecord.str_len,&file_mem[cc]);
     facetext[ttf_namerecord.str_len]=NULL_CHAR;
     aaStringLen(facetext,&sl);
     if(sl>0&&sl<32) { found=YES; break; }
     }
    cc=npos;
    }
   }
  aa_MemoryRelease(file_mem);
  if(found==NO) {   aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;}
  if(AddFontResource((CP)facettfptr)==0)   {  aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;   }
  }
 else
 if(LOAD_MODE==10)
  {
  }
 else
 if(LOAD_MODE==2) ///================================== WTF ?????
  {
  if((ret=aaFileLoadToMemory(facettfptr,0,F32,(VP)&file_mem,&bytes_loaded))!=RET_YES)
   {
   aa_ObjectDestroy(aa.font_system.object_id,*handle);
   *handle=0;
   return ret;
   }
  if(bytes_loaded<300)  {  aa_MemoryRelease(file_mem); aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;   }
  fon_off=60; // look for NE location in MZ header
  aaMemoryPeekWord(&file_mem[fon_off],0,&v1);
  fon_off=(H)v1;
  fon_off+=(22*2); // find start of font header in NE header
  aaMemoryPeekDword(&file_mem[fon_off],0,&h1);
  fon_off=h1;
  aaStringFindChar(&file_mem[fon_off],0,&h1,':',YES,0,YES); // font name after ':'
  if(h1==F32) {  aa_MemoryRelease(file_mem); aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;   }
  fon_off+=(h1+1);
  if(fon_off>=bytes_loaded) {  aa_MemoryRelease(file_mem); aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;   }
  aaStringLen(&file_mem[fon_off],&sl);
  if(sl==0||sl>32)   {   aa_MemoryRelease(file_mem); aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED; }
  aaStringCopy(facetext,&file_mem[fon_off]);
  aa_MemoryRelease(file_mem);
  if(AddFontResource((CP)facettfptr)==0)   {  aa_ObjectDestroy(aa.font_system.object_id,*handle); *handle=0; return RET_FAILED;   }
  }


 font_width=logw;
 font_height=logh;


 fail_state=100;
 //aaDebugf("%s,, %i,%i  ,, %i , %i",facettf,font_height,font_width,logw,logh);

 while(1)
  {
  SystemParametersInfo(SPI_GETFONTSMOOTHING,0,&was_smooth,0);
  if(was_smooth==FALSE&&smoothed) {  SystemParametersInfo(SPI_SETFONTSMOOTHING,TRUE,NULL,0); }//SPIF_UPDATEINIFILE|SPIF_SENDCHANGE) }
  if((hfnt=CreateFont(font_height,font_width,0,0,weyght,(italic==YES)?TRUE:FALSE,(underline==YES)?TRUE:FALSE,0,
                      charset,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,
                      // cleartype_comatiblity 6
                      // cleartype 5
                      // ANTIALIASED 4
                      // non-antialis 3
                      (smoothed)?5:3,
                      (prefmono)?(FIXED_PITCH|FF_DONTCARE):(DEFAULT_PITCH|FF_DONTCARE),facetext))==NULL) { fail_state=0;break; }
  if((dc=CreateCompatibleDC(aa.core_system.display_dc))==NULL)  { fail_state=2; break; }
  if((oldobj=SelectObject(dc,hfnt))==0)                   { fail_state=3; break; }
  if(GetTextFace(dc,32,fntp->status.face_name)==0)        { fail_state=4; break; }
  aaStringICompare(facetext,fntp->status.face_name,&res);
  if(res!=0)                                              { fail_state=4; break; }

  if(GetCharABCWidths(dc,0,255,charABCWidth)==FALSE)
   {
   if(GetCharWidth(dc,0,255,(LPINT)charWidth)==0) {   fail_state=5;   break; }
   for(i=0;i<256;i++)
    {
    fntp->char_lead[i]=fntp->char_gap[i]=0;
    fntp->char_width[i]=(B)charWidth[i];
    }
   }
  else
   {
   for(i=0;i<256;i++)
    {
    fntp->char_lead[i]=(I)charABCWidth[i].abcA;
    fntp->char_width[i]=(I)charABCWidth[i].abcB;
    fntp->char_gap[i]=(I)charABCWidth[i].abcC;
    //fntp->char_lead[i]=0;
    //fntp->char_gap[i]=0;
    }
   }

  if(GetTextMetrics(dc,&textmetrics)==0)     { fail_state=6; break; }

  //max_wid=textmetrics.tmMaxCharWidth;
  fntp->status.size.w=textmetrics.tmMaxCharWidth;//+32;
  fntp->status.size.h=textmetrics.tmHeight;

  if(prefmono)   {   }
  WinBmpInfoSet(&bitmapinfo,(fntp->status.size.w)*16,((fntp->status.size.h)*16),24,YES);
  if((hbmp=CreateDIBSection(NULL,(LPBITMAPINFO)&bitmapinfo,DIB_RGB_COLORS,(PP)&dib_data,NULL,0))==NULL) { fail_state=7; break; }
  if(SelectObject(dc,hbmp)==0) { fail_state=8; break; }
  grid_width=16*(fntp->status.size.w);

  for(i=0;i<256;i++)
   {
   y_pos=(i/16)*(fntp->status.size.h);
   x_pos=(i%16)*(fntp->status.size.w);

   ot[0]=i;
   ot[1]=32;
   if(TextOut(dc,x_pos+0,y_pos,(CP)ot,2)==FALSE) { fail_state=9; break; }
   }

  break;
  }



 if(fail_state!=100)
  {
  aaNote(0,"fs=%i",fail_state);
  if(fail_state>=4) SelectObject(dc,oldobj);
  if(fail_state>=1) DeleteObject(hfnt);
  if(fail_state>=8) DeleteObject(hbmp);
  if(fail_state>=3) {}//DeleteDC(dc);
  aa_ObjectDestroy(aa.font_system.object_id,*handle);
  if(LOAD_MODE!=0)
   {
   if(LOAD_MODE==10) { RemoveFontMemResourceEx(memfont_resource_handle); }
   else              { RemoveFontResource((CP)facettfptr);  }
   }
  if(was_smooth==FALSE&&smoothed) { SystemParametersInfo(SPI_SETFONTSMOOTHING,FALSE,NULL,0);}//SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);  }
  *handle=0;
  return RET_FAILED;
  }


 w1=fntp->char_lead['.']+fntp->char_width['.']+fntp->char_gap['.'];
 for(i=0;i<256;i++)
  {
  w2=fntp->char_lead[i]+fntp->char_width[i]+fntp->char_gap[i];
  if(i>32&&w1!=w2)   {   break;   }
  }
 if(i>=127) fntp->status.is_mono_width=YES;
 fntp->status.charset=charset;


 if((ret=aa_MemoryAllocate((VP)&fntp->img,(((fntp->status.size.w)*16)*(fntp->status.size.h))*16,"FontImg",NO))!=RET_YES)
  {
  SelectObject(dc,oldobj);
  DeleteObject(hfnt);
  DeleteObject(hbmp);
  aa_ObjectDestroy(aa.font_system.object_id,*handle);
  if(LOAD_MODE!=0)
   {
   if(LOAD_MODE==10) { RemoveFontMemResourceEx(memfont_resource_handle);  }
   else              { RemoveFontResource((CP)facettfptr); }
   }
  if(was_smooth==FALSE&&smoothed) { SystemParametersInfo(SPI_SETFONTSMOOTHING,FALSE,NULL,0); }//SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);  }
  *handle=0;
  return ret;
  }


 if(smoothed) { lum=smoothed;   }
 else         { lum=1; }
// aaDebugf("smoothed=%i lum=%i weift=%i",smoothed,lum,weyght);
 for(i=0;i<255;i++) // <256 sometimes causes leaks,, i need to recheck this whole func
  {
  grid_offset=(i/16)*(grid_width*(fntp->status.size.h));
  grid_offset+=((i%16)*(fntp->status.size.w));
  for(y_pos=0;y_pos<(N)fntp->status.size.h;y_pos++) // ningy added (N)
   {
   img_offset=grid_offset+(grid_width*y_pos);
   aaCast(bp,BP,&fntp->img[img_offset]);
   dib_offset=(grid_offset*3)+(y_pos*(((fntp->status.size.w)*16)*3));
   for(x_pos=0;x_pos<(N)fntp->status.size.w;x_pos++) // ningy added (N)
    {
    //luminance=((dib_data[dib_offset]+dib_data[dib_offset+1]+dib_data[dib_offset+2])/3);
    luminance=dib_data[dib_offset]+dib_data[dib_offset+1]+dib_data[dib_offset+2];
    luminance=luminance/3.0;
    alpha=(N)luminance;
    if(weyght==1000&&alpha!=0&&alpha!=255) { alpha=0; }
    if(alpha!=0&&alpha!=255&&lum!=1)       { alpha/=lum; alpha*=lum; }
    if(alpha<0)   { alpha=0;   }   else
    if(alpha>255) { alpha=255; }
    *bp++=(B)(255-alpha);
    #if 0
    if(weyght==1000) { if(luminance!=0&&luminance!=255) luminance=0; }
    else
     {
     if(lum!=1&&luminance!=0&&luminance!=255) { luminance/=lum; luminance*=lum; }
     }
    *bp++=(B)(255-luminance);
    #endif


    #if 0
    luminance=dib_data[dib_offset]+dib_data[dib_offset+1]+dib_data[dib_offset+2];
    luminance=luminance/3.0;
    alpha=(N)luminance;
    if(weyght==1000)
     {
     if(alpha!=0&&alpha!=255) { alpha=0;  }
     }
    else
     {
     if(alpha!=0&&alpha!=255)
      {
      if(lum!=1)
       {
       luminance=luminance/(D)lum;
       luminance=luminance*(D)lum;
       alpha=(N)luminance;
       }
      }
     }
    //alpha=luminance;
    if(alpha<0)   { alpha=0;   }   else
    if(alpha<255) { alpha=255; }
    *bp++=(B)(255-(B)alpha);
    #endif
    dib_offset+=3;
    }
   }
  }

 SelectObject(dc,oldobj);
 DeleteObject(hfnt);
 DeleteObject(hbmp);


// DeleteDC(dc);
 if(LOAD_MODE!=0)
  {
  if(LOAD_MODE==10) { RemoveFontMemResourceEx(memfont_resource_handle); }
  else              { RemoveFontResource((CP)facettfptr); }
  }
 if(was_smooth==FALSE&&smoothed) { SystemParametersInfo(SPI_SETFONTSMOOTHING,FALSE,NULL,0); }//SPIF_UPDATEINIFILE|SPIF_SENDCHANGE);  }
 fntp->status.curr_mono_size.w=0;
 for(i=0;i<127;i++)
  {
  w1=fntp->char_lead[i]+fntp->char_width[i]+fntp->char_gap[i];
  if(w1>=(W)fntp->status.curr_mono_size.w) { fntp->status.curr_mono_size.w=w1; fntp->status.mono_char=(B)i; } // ningy added (W)
  }
 fntp->status.curr_mono_size.h=fntp->status.size.h;
 fntp->status.logw=logw;
 fntp->status.logh=logh;
 aaSizeCopy(&fntp->status.init_mono_size,&fntp->status.curr_mono_size);
 return RET_YES;
 }






 B aaFontCreateUsingResource           (HP handle,H resnum,N logw,N logh,B weight,B italic,B underline,B prefmono,B smoothed,H charset)
 {
 B ret;
 B path[MAX_PATH];
 B file[33];
 B filename[MAX_PATH];
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 GetTempPath(MAX_PATH,(CP)path);
 while(1)
  {
  aaStringRandomSet(file,8,YES,NO,YES,YES);
  aaStringCopyf(filename,"%s%s.ttf",path,file);
  if(aaFileInfoGet(filename,NULL,NULL,NULL,NULL,NULL)==RET_NOTFOUND) { break; }
  break;
  }
 if((ret=aaResourceToFile(resnum,&bytes,filename))!=RET_YES) {  return ret; }
 return(aaFontCreate(handle,filename,logw,logh,weight,italic,underline,prefmono,smoothed,charset));
 }




 B aaFontCreateFixedWidth              (HP handle,N logw,N logh,B weight,B italic,B underline,B smoothed,H charset)
 {
 B ret;
 H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 while(1)
  {
  if((ret=aaFontCreate(&han,"lucida console",logw,logh,weight,italic,underline,YES,smoothed,charset))==YES) {  break; }
  if((ret=aaFontCreate(&han,"lucida sans",logw,logh,weight,italic,underline,YES,smoothed,charset))==YES) {  break; }
  if((ret=aaFontCreate(&han,"courier new",logw,logh,weight,italic,underline,YES,smoothed,charset))==YES) { break; }
  if((ret=aaFontCreate(&han,"trebuchet ms",logw,logh,weight,italic,underline,YES,smoothed,charset))==YES) {  break; }
  if((ret=aaFontCreate(&han,"microsoft sans serif",logw,logh,weight,italic,underline,YES,smoothed,charset))==YES) { break; }
  break;
  }
 if(ret!=YES) { return ret; }
 aaFontMonoForceSet(han,YES);
 *handle=han;
 return RET_YES;
 }





 B aaFontDestroy                       (H handle)
 {
 B ret;
 _aa_fontobject*fntp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 aa_MemoryRelease(fntp->img);
 aa_ObjectDestroy(aa.font_system.object_id,handle);
 return RET_YES;
 }




 B aaFontMonoForceSet                  (H handle,B state)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(state==YES) { fntp->status.is_mono_forced=YES; }
 else           { fntp->status.is_mono_forced=NO; }
 return RET_YES;
 }




 B aaFontMonoForceSizeSet              (H handle,_size*size)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(size==NULL)
  {
  aaSizeCopy(&fntp->status.curr_mono_size,&fntp->status.init_mono_size);
  }
 else
  {
  if(size->w!=0) fntp->status.curr_mono_size.w=size->w;
  if(size->h!=0) fntp->status.curr_mono_size.h=size->h;
  fntp->status.curr_mono_size.w=aaNumFloor(fntp->status.curr_mono_size.w,1);
  fntp->status.curr_mono_size.h=aaNumFloor(fntp->status.curr_mono_size.h,1);
  }
 return RET_YES;
 }




 B aaFontStatus                        (H handle,_fontstatus*fontstatus)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(fontstatus) { aaMemoryCopy(fontstatus,sizeof(_fontstatus),&fntp->status); }
 return RET_YES;
 }






 B aaFontStringSizeGet                 (H handle,_size*size,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 va_list argptr;
 B ch,txt[_64K];
 H sl;
 N s,newwid,wid;
 H lines;
 H bigwid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if((ret=aaFontStatus(handle,0))!=RET_YES) { oops; }
 if(size==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(maxchars==0) { maxchars=sl; }
 if(maxchars>sl) { maxchars=sl; }
 sl=maxchars;
 if(sl==0)   {   aaSizeSet(size,0,0); return RET_YES;   }
 wid=0;
 lines=1;
 bigwid=0;
 for(s=0;s<(N)sl;s++) // ningy added (N)
  {
  ch=(B)txt[s];
  if(ch==10) { lines++; wid=0; }//f ( wid>bigwid) { bigwid=wid; wid=0; lines++; } }
  else
  if(ch>=32)
   {
   if(fntp->status.is_mono_forced==NO)
    {
    newwid=(fntp->char_lead[ch]+fntp->char_width[ch])+fntp->char_gap[ch];
    }
   else
    {  // use 'W' spacing,, ceprintf,, takes this into consideration as its stride
    newwid=fntp->status.curr_mono_size.w;//(fntp->char_lead[aa_FONT_MONO_CHAR]+fntp->char_width[aa_FONT_MONO_CHAR]+fntp->char_gap[aa_FONT_MONO_CHAR]);
    }
   wid+=newwid;
   if(wid>(N)bigwid) { bigwid=wid; } // ningy added (N)
   }
  }
 aaSizeSet(size,bigwid,(fntp->status.size.h+0)*lines); // feb2016: added +1

 return RET_YES;
 }




 B aaFontStringSizeFit                 (H handle,_size*size,_size*rsize,VP rstr,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 B str[_32K];
 B linstr[_32K];
 va_list argptr;
 H fh,lines,off,li;
 H sc,tc,ok,pos,sl;
 _size sz1;
 _rect rc1;
 _fontstatus fs;
 _size szreq;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(size) { aaSizeCopy(&szreq,size); }
 else     { return RET_BADPARM; }
 if(szreq.w==0) { return RET_BADPARM; }
 if(szreq.h==0) { return RET_BADPARM; }
 if(rstr!=NULL) { aaStringNull(rstr); }
 fh=handle;
 aaFontStatus(fh,&fs);
 rego:
  while(1)
   {
   aaFontStringSizeGet(fh,&sz1,0,"%s",str);
   aaRectSet(&rc1,0,0,szreq.w,szreq.h);
   if(rc1.w>=sz1.w) { break; }
   aaStringLineCountGet(str,0,&lines);
   lines++;
   off=0;
   for(li=0;li<lines;li++)
    {
    if(aaStringLineGet(&str[off],0,&sc,0,&tc,0)!=YES) { break; }
    if(tc==0) { break; }
    if(sc==0) { off+=tc; continue; }
    aaStringNCopy(linstr,&str[off],sc,YES);
    ok=0;
    while(1)
     {
     if((ret=aaFontStringSizeGet(fh,&sz1,0,"%s",linstr))!=YES) { oops; }
     aaRectSet(&rc1,0,0,szreq.w,szreq.h);
     if(rc1.w>=sz1.w) { break; }
     if(aaStringFindCharVisible(linstr,0,&pos,NO,0,NO)!=YES)
      {
      aaStringLen(linstr,&sl);
      pos=sl/2;
      //aaNote(0,"lin=[%s]",linstr);
      //off+=tc;
      //break;
      }
     ok++;
     linstr[pos]=NULL_CHAR;
     }
    if(ok) { str[off+pos]=LF_CHAR; goto rego; }
    off+=tc;
    }
   break;
   }
 if(rsize==NULL) { aaSizeSet(size,szreq.w,sz1.h); }
 else            { aaSizeSet(rsize,szreq.w,sz1.h); }
 if(rstr) { aaStringCopy(rstr,str); }
 return RET_YES;
 }





 B aaFontCharRectGet                   (H handle,_rect*rect,B ch)
 {
 B ret;
 _aa_fontobject*fntp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { return RET_BADPARM; }
 aaRectSet(rect,0,0,0,fntp->status.size.h+0);
 if(fntp->status.is_mono_forced) { rect->w=fntp->status.curr_mono_size.w;   }
 else                            { rect->w=(fntp->char_lead[ch]+fntp->char_width[ch])+fntp->char_gap[ch];   }
 return RET_YES;
 }






 B aaFontStringCharRectsGet            (H handle,H maxrects,_rect*rects,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 va_list argptr;
 B ch,txt[_64K];
 H sl;
 N x,s,newwid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rects==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(maxchars==0)  { maxchars=sl; }
 if(maxchars>sl)  { maxchars=sl; }
 sl=maxchars;
 aaRectSet(&rects[0],0,0,0,fntp->status.size.h+0); // feb2016: added +1
 if(sl==0)   {    return RET_YES;   }
 x=0;
 for(s=0;s<(N)sl;s++) // ningy added (N)
  {
  ch=(B)txt[s];
  if(fntp->status.is_mono_forced) { newwid=fntp->status.curr_mono_size.w;   }
  else                            { newwid=(fntp->char_lead[ch]+fntp->char_width[ch])+fntp->char_gap[ch];   }
  aaRectSet(&rects[s],x,0,newwid,fntp->status.size.h+0); // feb2016: added +1
  if((H)s>=maxrects) { break; }
  x+=newwid;
  }
 aaRectSet(&rects[s],x,0,0,fntp->status.size.h+0); // feb2016: added +1
 return RET_YES;
 }






 B aaFontStringCharRectGet             (H handle,_rect*rect,H pos,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_fontobject*fntp;
 va_list argptr;
 B ch,txt[_64K];
 H sl;
 N x,s,newwid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==0) {  handle=aa.font_system.font_8x8;  }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,handle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { return RET_BADPARM; }
 aaStringLen(txt,&sl);
 if(maxchars==0)  { maxchars=sl; }
 if(maxchars>sl)  { maxchars=sl; }
 sl=maxchars;
 if(pos>sl) { pos=sl; }
 aaRectSet(rect,0,0,1,fntp->status.size.h+0);// feb2016: added +1
// rect->h+=fntp->status.v_bias;
 if(sl==0)   {    return RET_YES;   }
 x=0;
 newwid=fntp->status.curr_mono_size.w;
 for(s=0;s<(N)sl;s++) // ningy added (N)
  {
  ch=(B)txt[s];
  if(fntp->status.is_mono_forced==NO)
   {
   newwid=(fntp->char_lead[ch]+fntp->char_width[ch])+fntp->char_gap[ch];
   }
  else
   {
   // see prev function for more info
   newwid=fntp->status.curr_mono_size.w;//(fntp->char_lead[aa_FONT_MONO_CHAR]+fntp->char_width[aa_FONT_MONO_CHAR]+fntp->char_gap[aa_FONT_MONO_CHAR]);
   }
  if(s==(N)pos) { break; } // ningy added (N)
  x+=newwid;
  }
 aaRectSet(rect,x,0,newwid,fntp->status.size.h+0);// feb2016: added +1
// rect->h+=fntp->status.v_bias;
 if(pos==sl) rect->w=1;
 return RET_YES;
 }











 B aaFontFamilyList                    (_data*data)
 {
 B ret;
 HDC dc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(data==NULL) { return RET_BADPARM; }
 if((ret=aaDataAllocate(data))!=YES) { oops; }
 dc=GetDC(GetDesktopWindow());
 EnumFontFamilies(dc,NULL,(FONTENUMPROC)aa_FontCallBack,(LPARAM)data);
 ReleaseDC(GetDesktopWindow(),dc);
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aaPixelStyleInit                    (_pixelstyle*pixelstyle)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(pixelstyle);
 aaMemoryFill(pixelstyle,sizeof(_pixelstyle),0);
 return RET_YES;
 }




 B aaPixelStyleSet                     (_pixelstyle*pixelstyle,H setbit,B mode,N np0,N np1,N np2,N np3,D dp0,D dp1,H applyhandle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 aaMissingParm(pixelstyle);
 if(aaBitGet(setbit,0)) { pixelstyle->mode=mode;  }
 if(aaBitGet(setbit,1)) { pixelstyle->nparm0=np0; }
 if(aaBitGet(setbit,2)) { pixelstyle->nparm1=np1; }
 if(aaBitGet(setbit,3)) { pixelstyle->nparm2=np2; }
 if(aaBitGet(setbit,4)) { pixelstyle->nparm3=np3; }
 if(aaBitGet(setbit,5)) { pixelstyle->dparm0=dp0; }
 if(aaBitGet(setbit,6)) { pixelstyle->dparm1=dp1; }
 if(applyhandle)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,applyhandle,(VP)&surp,NULL))!=RET_YES) { oops; return ret; }
  if((ret=aaSurfacePixelStyleSet(applyhandle,pixelstyle))!=YES) { oops; }
  }

 return RET_YES;
 }



/*-----------------------------------------------------------------------*/


 // surface is created full transparent,, i.e allocated surface memory is zerod

 B aaSurfaceCreate                     (HP handle,_size*size)
 {
 B ret;
 _aa_surfaceobject*surp;
 H bytes;
 BP mem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=RET_YES) { return RET_BADPARM; }
 logg("Creating a surface %ix%i",size->w,size->h);
 bytes=(size->w*sizeof(_rgba)*size->h);
 if((ret=aa_MemoryAllocate((VP)&mem,bytes,"Surface",NO))!=RET_YES) { oops; return ret; }
 if((ret=aa_ObjectCreate(aa.surface_system.object_id,handle,(VP)&surp))!=RET_YES)
  {
  oops;
  aa_MemoryRelease(mem);
  return ret;
  }
 surp->self_handle=*handle;
 surp->status.self_handle=*handle;
 aaSizeCopy(&surp->status.initial_size,size);
 aaSizeCopy(&surp->status.size,size);
 aaSizeCopy(&surp->status.initial_size,size);
 aaRectSet(&surp->status.rect,0,0,size->w,size->h);
 aaRectCopy(&surp->status.viewport_rect,&surp->status.rect);///0,0,size->w,size->h);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 surp->status.pixel_count=size->w*size->h;
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 aaCast(surp->status.mem,_rgba*,mem);
 aaSurfaceBlendSet(*handle,YES);
 aaSurfaceAlphaSet(*handle,0);
 aaSurfaceUpdateAreaReset(*handle);
 aaSurfaceMinMaxSizeSet(*handle,size,size);
 aaSurfaceCaretReset(*handle);
 aaSurfaceCaretSpeedSet(*handle,aa.surface_system.caret_speed);
 return RET_YES;
 }



 B aaSurfaceMinMaxCreate               (HP handle,_size*size,_size*minsize,_size*maxsize)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 if(size==NULL) { return RET_BADPARM; }
 if(minsize==NULL) { return RET_BADPARM; }
 if(maxsize==NULL) { return RET_BADPARM; }
 if(aaSizeIsValid(size)!=YES) { return RET_BADPARM; }
 if(aaSizeIsValid(minsize)!=YES) { return RET_BADPARM; }
 if(aaSizeIsValid(maxsize)!=YES) { return RET_BADPARM; }
 if(minsize->w>maxsize->w) { return RET_BOUNDS; }
 if(minsize->h>maxsize->h) { return RET_BOUNDS; }
 if(size->w>maxsize->w) { return RET_BOUNDS; }
 if(size->h>maxsize->h) { return RET_BOUNDS; }
 if(minsize->w>size->w) { return RET_BOUNDS; }
 if(minsize->h>size->h) { return RET_BOUNDS; }
 if((ret=aaSurfaceCreate(handle,maxsize))!=YES) { return ret; }
 if(aaSurfaceMinMaxSizeSet(*handle,minsize,maxsize)!=YES) oof;
 if(aaSurfaceSizeSet(*handle,size)!=YES) oof;
 return RET_YES;
 }





 B aaSurfaceMake                       (HP handle,_size*size,VP mem)
 {
 B ret;
 _aa_surfaceobject*surp;
// H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=RET_YES) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
// bytes=(size->w*sizeof(_rgba)*size->h);
 if((ret=aa_ObjectCreate(aa.surface_system.object_id,handle,(VP)&surp))!=RET_YES)  { oops; return ret;  }
 surp->self_handle=*handle;
 surp->status.self_handle=*handle;
 aaSizeCopy(&surp->status.initial_size,size);
 aaSizeCopy(&surp->status.size,size);
 aaRectSet(&surp->status.rect,0,0,size->w,size->h);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 aaCast(surp->status.mem,_rgba*,mem);
 surp->status.pixel_count=size->w*size->h;
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 surp->status.is_made=YES;
 aaSurfaceBlendSet(*handle,YES);
 aaSurfaceAlphaSet(*handle,0);
 aaSurfaceUpdateAreaReset(*handle);
 return RET_YES;
 }




 B aaSurfaceReMake                     (H handle,_size*size,VP mem)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=RET_YES) { return RET_BADPARM; }
 if(mem==NULL) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_made==NO) { return RET_FAILED; }
 aaSizeCopy(&surp->status.size,size);
 aaSizeCopy(&surp->status.initial_size,size);
 aaRectSet(&surp->status.rect,0,0,size->w,size->h);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 surp->status.pixel_count=size->w*size->h;
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 aaCast(surp->status.mem,_rgba*,mem);
 aaSurfaceUpdateAreaReset(handle);
 return RET_YES;
 }





 B aaSurfaceLoadFromMemory             (HP handle,H bytes,VP mem,VP useextension)
 {
 B ret;
 H filebytes;
 BP filemem;
 BP bp;
 H off,len;
 _aa_surfacebmpfilehdr bmpfilehdr;
 _aa_surfacebmpinfohdr bmpinfohdr;
 _aa_surfacewinbmpinfohdr winbmpinfohdr;
 _aa_surfaceos2bmpinfohdr os2bmpinfohdr;
// BITMAPINFOHEADER bih;
 H bisize;
 //_rect r1,r2;
 N b,i,ncol,y,nbytes;
 _size sz;
 _rgba pal[256];
 H ih;
 _surfacestatus surface_status;
 BP imem;
 H dw,temp;
 B bit_state[32];
 _aa_pen16*p16;
 _aa_pen24*p24;
 _rgba*p32=0;
 //H sl;
 B txt[_1K];
 N type;
 _aa_surfacejpegdecoder jpg;
 B tiff[8];
 W tiff_byte_order;
 W tiff_id_42;
 H tiff_offset;
 B data_code;
 H data_bytes,count;
 B comps;
 W table,val,index;
 N table_id,table_class;
 N qt_num,qtables_found[2]={0,0};
 N j,bit_len[16];
 N x,hue;
 N dc_y,dc_cb,dc_cr;
 N y1[64],y2[64],y3[64],y4[64],cb[64],cr[64];
 _cord cd;
 _rgba p1;
 _aa_surfacetgahdr tgahdr;
 B is_bottom_up;
 B interlace_type;
 B is_rle;
 B source_pixel_size;
 N block_count;  // # of pixels remaining in RLE block
 N dup_pixel_count; // # of times to duplicate previous pixel
 H zerocount; // hack: for 32bit bmps' that entire alphas are 0, then reverse
 upng_t*upng;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;

 #if 1
 #endif

 if(useextension)
  {
  if(aaStringIsIString(useextension,&type,"bmp","jpg","tga","ico","png",NULL)!=YES)
   {
   if(aaStringIsIString(useextension,&type,".bmp",".jpg",".tga","ico","png",NULL)!=YES) { return RET_FAILED; }
   }
  }
 else
  {
  if(aaStringIsIString(txt,&type,"bmp","jpg","tga","ico","png",NULL)!=YES) { return RET_FAILED; }
  }

 filemem=mem;
 filebytes=bytes;


// if((ret=aaFileLoadToMemory(filename,0,F32,(VP)&filemem,&filebytes))!=RET_YES) { return ret; }
 aaCast(bp,BP,filemem);
 off=0;

 if(type==0) //////// BMP
  {
  len=sizeof(_aa_surfacebmpfilehdr);
  aaMemoryCopy(&bmpfilehdr,len,&bp[off]);
  off+=len;
  if(bmpfilehdr.type!=19778)  {   return RET_FAILED;  }
  len=sizeof(H);
  aaMemoryCopy(&bisize,len,&bp[off]);
  off+=len;
  if(bisize==40)
   {
   len=sizeof(_aa_surfacewinbmpinfohdr);
   aaMemoryCopy(&winbmpinfohdr,len,&bp[off]);
   off+=len;
   bmpinfohdr.width=winbmpinfohdr.width;
   bmpinfohdr.height=winbmpinfohdr.height;
   bmpinfohdr.bits=winbmpinfohdr.bits;
   bmpinfohdr.compression=winbmpinfohdr.compression;
   ncol=(bmpfilehdr.off_bits-54)/4;
   for(i=0;i<ncol;i++)
    {
    len=sizeof(_rgba);
    aaMemoryCopy(&pal[i],len,&bp[off]);
    off+=len;
    pal[i].a=0;
    }
   }
  else
  if(bisize==12)
   {
   len=sizeof(_aa_surfaceos2bmpinfohdr);
   aaMemoryCopy(&os2bmpinfohdr,len,&bp[off]);
   off+=len;
   bmpinfohdr.width=os2bmpinfohdr.width;
   bmpinfohdr.height=os2bmpinfohdr.height;
   bmpinfohdr.bits=os2bmpinfohdr.bits;
   bmpinfohdr.compression=0;
   ncol=(bmpfilehdr.off_bits-26)/3;
   for(i=0;i<ncol;i++)
    {
    len=sizeof(_rgba)-1;
    aaMemoryCopy(&pal[i],len,&bp[off]);
    off+=len;
    pal[i].a=0;
    }
   }
  else {  return RET_FAILED;  }
  aaSizeSet(&sz,bmpinfohdr.width,bmpinfohdr.height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)
   {
   return ret;
   }
  aaSurfaceStatus(ih,&surface_status);
  aaCast(imem,BP,surface_status.mem);
//  aaLog(-1,"%i",bmpinfohdr.bits);
  switch (bmpinfohdr.compression)
  {
  case 0: // birgb
  zerocount=0;
  for(y=0;y<(N)bmpinfohdr.height;y++)// ningy added (N)
   {
   if(bmpinfohdr.bits==1)
   {
   for(i=0;i<(N)bmpinfohdr.width;i++)// ningy added (N)
    {
    if((i%32)==0)
     {
     aaMemoryCopy(&dw,sizeof(H),&bp[off]);
     dw=aaNumSwapDword(dw);
     off+=4;
     for(b=0; b<32; b++)
      {
      bit_state[31-b]=(B)(dw&1);
      dw=dw>>1;
      }
     }
    if(bit_state[i%32]==YES)
     {
     aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&col_black);
     }
    else
     {
     aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&col_white);
     }
    }
   }
  else
  if(bmpinfohdr.bits==4)
   {
   for(i=0;i<(N)bmpinfohdr.width;i++) // ningy added (N)
    {
    if((i%8)==0)
     {
     aaMemoryCopy(&dw,sizeof(H),&bp[off]);
     off+=4;
     for(b=0;b<4;b++)
      {
      temp=dw&255;
      bit_state[b*2+1]=(B)(temp&15);
      temp=temp>>4;
      bit_state[b*2]=(B)(temp&15);
      dw=dw>>8;
      }
     }
    aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&pal[bit_state[i%8]]);
    }
   }
  else
  if(bmpinfohdr.bits==8)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++) // ningy added (N)
    {
    aaMemoryCopy(&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)],sizeof(_rgba),&pal[bp[off]]);
    off++;
    nbytes+=1;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  else
  if(bmpinfohdr.bits==16)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++) // ningy added (N)
    {
    len=2;
    aaCast(p16,_aa_pen16*,&bp[off]);
    aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
    p32->r=(B)(p16->r<<3);
    p32->g=(B)(p16->g<<3);
    p32->b=(B)(p16->b<<3);
    off+=len;
    p32->a=255;
    nbytes+=2;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  else
  if(bmpinfohdr.bits==24)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++)// ningy added (N)
    {
    len=3;
    aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
    p32->r=bp[off+2];
    p32->g=bp[off+1];
    p32->b=bp[off+0];
    p32->a=255;
    off+=len;
    nbytes+=3;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  else
  if(bmpinfohdr.bits==32)
   {
   nbytes=0;
   for(i=0;i<(N)bmpinfohdr.width;i++)// ningy added (N)
    {
    len=4;
    aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
///    aaCast(p32,_rgba*,&imem[(y*bmpinfohdr.width*4)+(i*4)]);
    p32->r=bp[off+2];
    p32->g=bp[off+1];
    p32->b=bp[off+0];
    p32->a=bp[off+3];//128;//(B)(255-bp[off+3]);
    if(p32->a==0) zerocount++;
    off+=len;
    nbytes+=4;
    }
   nbytes=nbytes%4;
   if(nbytes!=0)
    {
    for(i=nbytes;i<4;i++)
     {
     off++;
     }
    }
   }
  }

  /// HACK due to blaze, not handling bmp24->bmp32 correctly,, ( forgets to set alpha on 32 to 255 )
  if(bmpinfohdr.bits==32)
   {
   if(zerocount==(bmpinfohdr.width*bmpinfohdr.height))
    {
    for(y=0;y<(N)bmpinfohdr.height;y++)// ningy added (N)
     {
     for(i=0;i<(N)bmpinfohdr.width;i++)// ningy added (N)
      {
      aaCast(p32,_rgba*,&imem[(((bmpinfohdr.height-y)-1)*bmpinfohdr.width*4)+(i*4)]);
      p32->a=255;
      }
     }
    }
   }
  break;

  case 1: // rle8
  //  read_RLE8_compressed_image(f, bmp, &bmpinfoheader);
  logg("Bitmap is rle8");
  aaSurfaceDestroy(ih);
  return RET_FAILED;

  case 2: // rle4
  //  read_RLE4_compressed_image(f, bmp, &bmpinfoheader);
  logg("Bitmap is rle4");
  aaSurfaceDestroy(ih);
  return RET_FAILED;

  default:
  logg("Bitmap is other compression=%i",bmpinfohdr.compression);
  aaSurfaceDestroy(ih);
  return RET_FAILED;
  }
 *handle=ih;
 }
else
 if(type==1) ///////// jpeg
  {
  aaMemoryFill(&jpg,sizeof(_aa_surfacejpegdecoder),0);
  jpg.data_start=(BP)filemem;
  jpg.data=jpg.data_start;
  while(!jpg.is_failed)
   {
   if(jpg.data>jpg.data_start+_64K||jpg.is_sos) break;
   data_code=*jpg.data++;
   if(data_code!=F8) continue;
   data_code=*jpg.data;
//     BUG,"dc=%02x",data_code);
   switch(data_code)
    {
    case 0xc0: // start of frame 0
    case 0xc1: // start of frame 1
//    log(code: 0x%02x sof",data_code);
    jpg.is_sof0=YES;
    jpg.data++;
    data_bytes=((*(&jpg)->data<<8)|(*((&jpg)->data+1)));
    if(data_bytes<2) {  jpg.is_failed=YES; oof; break; }
    jpg.data+=2;
    if(*jpg.data!=8) { jpg.is_failed=YES; oof;  break; }   // Only 8 bits/sample supported
    jpg.data++;
    jpg.height=((*(jpg).data<<8)|(*((jpg).data+1)));
    jpg.data+=2;
    jpg.width=((*(jpg).data<<8)|(*((jpg).data+1)));
    jpg.data+=2;
    comps=*jpg.data++;
    for(i=0;i<comps;i++)
     {
     switch (*jpg.data)
      {
      case 1:
      jpg.data++;
      jpg.samples_y=(*jpg.data&0xf)*(*jpg.data>>4);
      jpg.data++;
      jpg.quant_y=*jpg.data++;
      break;

      case 2:
      case 3:
      jpg.data+=2;
      jpg.quant_cbcr=*jpg.data++;
      break;

      default:
      break;
      }
     }
    break;

    case 0xc4: // huffman table
//    log(code: 0x%02x dht",data_code);
    jpg.is_dht=YES;
    jpg.data++;
    data_bytes=((*(&jpg)->data<<8)|(*((&jpg)->data+1)));
    jpg.data+=2;
    count=2;
    do
     {
     table_id=*jpg.data&0x1;
     table_class=(*jpg.data&0x10)>>4;
     table=(W)((table_class<<9)|(table_id<<8));
     jpg.data++;
     count++;
     for(i=0;i<16;i++,count++)
      {
      bit_len[i]=*jpg.data++;
      }
     val=0;
     index=-1;
     for(i=0;i<16;i++)
      {
      for(j=0;j<bit_len[i];j++)
       {
       index++;
       count++;
       jpg.huffman_node[table|index].code=*jpg.data++;
       jpg.huffman_node[table|index].index=val;
       jpg.huffman_node[table|index].length=i+1;
       val++;
       }
      val<<=1;
      }
     }
    while(count<data_bytes);
    break;

    case 0xd8: // soi
//    log(code: 0x%02x SOI",data_code);
    jpg.is_soi=YES;
    jpg.data++;
    break;

    case 0xda: // sos
//    log(code: 0x%02x sos",data_code);
    jpg.is_sos=YES;
    jpg.data+=3;
    jpg.component_count=*jpg.data++;
    if((jpg.component_count!=1)&&(jpg.component_count!=3)) { oof; jpg.is_failed=YES; break; }    // Only 1 or 3 components supported
    for(i=0;i<jpg.component_count;i++)
     {
     switch(*jpg.data)
      {
      case 1:
      jpg.data++;
      jpg.ac_y=*jpg.data&0xf;
      jpg.dc_y=*jpg.data>>4;
      jpg.data++;
      break;

      case 2:
      case 3:
      jpg.data++;
      jpg.ac_cbcr=*jpg.data&0xf;
      jpg.dc_cbcr=*jpg.data>>4;
      jpg.data++;
      break;

      default:
      oof;
      jpg.is_failed=YES;
      break;
      }
     if(jpg.is_failed) { oof; break; }
     }
    jpg.data+=3;
    break;

    case 0xdb: // dqt quantise table
//    log(code: 0x%02x dqt",data_code);
    jpg.is_dqt=YES;
    jpg.data++;
    data_bytes=((*(&jpg)->data<<8)|(*((&jpg)->data+1)));
    jpg.data+=2;
    count=2;
    do
     {
     qt_num=(*jpg.data&0xf);
     if(qt_num>1) {  oof; jpg.is_failed=YES; break; }    // Illegal dequantization table number
     if(*jpg.data&0xf0) { oof; jpg.is_failed=YES; break; }         // Only 8 bit dequantization table precision supported
     if(qtables_found[qt_num]==1) { oof; jpg.is_failed=YES;break; }
     qtables_found[qt_num]=1;
     jpg.data++;
     count++;
     for(i=0;i<64;i++,count++)
      {
      jpg.dequant[(qt_num<<6)|i]=*jpg.data++;
      }
     }
    while(count<data_bytes);
    if(qtables_found[0]==0&&qtables_found[1]==0) { oof; jpg.is_failed=YES; }
    break;


    case 0xdd: // dri
//    log(code: 0x%02x dri",data_code);
    jpg.is_dri=YES;
    jpg.data+=5;
    break;

    case 0xe1: // exif
//    log(code: 0x%02x zif",data_code);
    jpg.data++;
    data_bytes=((*(&jpg)->data<<8)|(*((&jpg)->data+1)));
    if(data_bytes<2)  { oof; jpg.is_failed=YES; break; }
    jpg.data+=2;
    data_bytes-=2;
    if(data_bytes<6)  { oof; jpg.is_failed=YES; break; }
    if(jpg.data[0]=='E'&&jpg.data[1]=='x'&&jpg.data[2]=='i'&&jpg.data[3]=='f'&&jpg.data[4]==0&&jpg.data[5]==0)
     {
     jpg.data+=6;
     data_bytes-=6;
     }
    else
     {
     jpg.data+=6;
//ashod     data_bytes-=6;

//     jpg.is_failed=YES;
     break;
     }
    if(data_bytes<8) { oof; jpg.is_failed=YES; break;}
    aaMemoryCopy(&tiff,8,jpg.data);
    aaMemoryPeekWord(&tiff[0],0,&tiff_byte_order);
    aaMemoryPeekWord(&tiff[2],0,&tiff_id_42);
    aaMemoryPeekDword(&tiff[4],0,&tiff_offset);
    if(tiff_byte_order!=VAL_II&&tiff_byte_order!=VAL_MM) { oof; jpg.is_failed=YES; break; }
    if(tiff_byte_order==VAL_MM) tiff_id_42=htons(tiff_id_42);
    if(tiff_id_42!=42)        { oof; jpg.is_failed=YES; break; }
    if(tiff_byte_order==VAL_MM) tiff_offset=htonl(tiff_offset);
    if(tiff_offset<8||tiff_offset>16) { oof; jpg.is_failed=YES; break; }
    jpg.data+=8; data_bytes-=8;
    jpg.data+=data_bytes;
    jpg.is_app0=YES;
    break;


    case 0xe0: // app0
//    log(code: 0x%02x ap0",data_code);
    jpg.is_app0=YES;
    jpg.data++;
    data_bytes=((*(&jpg)->data<<8)|(*((&jpg)->data+1)));
    if(data_bytes<2)      { oof; jpg.is_failed=YES; break; }
    data_bytes-=2;
    if(data_bytes<14) { oof; jpg.is_failed=YES; break; }
    jpg.data+=2;
    if(jpg.data[0]=='J'&&jpg.data[1]=='F')
     {
     if(jpg.data[2]=='I'&&jpg.data[3]=='F') { jpg.data+=5; }
     else
     if(jpg.data[2]=='X'&&jpg.data[3]=='X') { jpg.data+=6; }
     }
    else { oof; jpg.is_failed=YES; break; }
    jpg.data+=7;
    count=(*jpg.data)*(*(jpg.data+1)); // skip thumbnails
    jpg.data+=2+(count*3); // 3=RGB
    break;

    default:
    jpg.data++;
    data_bytes=((*(&jpg)->data<<8)|(*((&jpg)->data+1)));
    jpg.data+=data_bytes;
    break;
    }
   }
  if(jpg.is_failed==YES)//||jpg.is_sof0==NO||jpg.is_dht==NO||jpg.is_soi==NO||jpg.is_sos==NO||jpg.is_dqt==NO||jpg.is_app0==NO)
   {
   ///aaDebugf("jpg.. line=%i %i %i %i %i %i %i %i",__LINE__,jpg.is_failed==YES , jpg.is_sof0==NO , jpg.is_dht==NO , jpg.is_soi==NO , jpg.is_sos==NO , jpg.is_dqt==NO , jpg.is_app0);
   return RET_FAILED;
   }
  aaSizeSet(&sz,jpg.width,jpg.height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)
   {
   return ret;
   }
  aaSurfaceStatus(ih,&surface_status);

  x=y=0;
  dc_y=dc_cb=dc_cr=0;
  jpg.bits=8;
  jpg.byte=*jpg.data;

  switch(jpg.component_count)
   {
   default:
   break;

   case 3:  //  Image has three components (1 for luminance and 2 for chrominance);  this means it's a colored image.
   switch(jpg.samples_y)
    {
   default:
   break;

   case 4:
    do
     {
     // 1st case:* chrominance is taken every two pixels (horizontally and vertically), and luminance for every pixel.
     aa_SurfaceDecodeJpegBlock(&jpg,y1,jpg.dc_y,jpg.ac_y,jpg.quant_y,&dc_y);
     aa_SurfaceDecodeJpegBlock(&jpg,y2,jpg.dc_y,jpg.ac_y,jpg.quant_y,&dc_y);
     aa_SurfaceDecodeJpegBlock(&jpg,y3,jpg.dc_y,jpg.ac_y,jpg.quant_y,&dc_y);
     aa_SurfaceDecodeJpegBlock(&jpg,y4,jpg.dc_y,jpg.ac_y,jpg.quant_y,&dc_y);
     aa_SurfaceDecodeJpegBlock(&jpg,cb,jpg.dc_cbcr,jpg.ac_cbcr,jpg.quant_cbcr,&dc_cb);
     aa_SurfaceDecodeJpegBlock(&jpg,cr,jpg.dc_cbcr,jpg.ac_cbcr,jpg.quant_cbcr,&dc_cr);
     cd.y=y;

     for(i=0;i<8;i++)
      {
      if(cd.y>=jpg.height) break;
      cd.x=x;
      for(j=0;j<8;j++)
       {
       if(cd.x>=jpg.width) break;
       aaRgbaYuvaSet(&p1,(B)y1[(i<<3)|j],(B)cb[((i>>1)<<3)|(j>>1)],(B)cr[((i>>1)<<3)|(j>>1)],255);
///       off=(((surp->status.size.h-y)-1)*surp->status.size.w)+x; }
       surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
       cd.x++;
       }
      cd.y++;
      }
     cd.y=(y);
     for(i=0;i<8;i++)
      {
      if(cd.y>=jpg.height) break;
      cd.x=(x+8);
      for(j=0;j<8;j++)
       {
       if(cd.x>=jpg.width) break;
       aaRgbaYuvaSet(&p1,(B)y2[(i<<3)|j],(B)cb[((i>>1)<<3)|((j>>1)+4)],(B)cr[((i>>1)<<3)|((j>>1)+4)],255);
       surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
       cd.x++;
       }
      cd.y++;
      }
     cd.y=(y+8);
     for(i=0;i<8;i++)
      {
      if(cd.y>=jpg.height) break;
      cd.x=x;
      for(j=0;j<8;j++)
       {
       if(cd.x>=jpg.width) break;
       aaRgbaYuvaSet(&p1,(B)y3[(i<<3)|j],(B)cb[(((i>>1)+4)<<3)|(j>>1)],(B)cr[(((i>>1)+4)<<3)|(j>>1)],255);
       surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
       cd.x++;
       }
      cd.y++;
      }
     cd.y=(y+8);
     for(i=0;i<8;i++)
      {
      if(cd.y>=jpg.height) break;
      cd.x=(x+8);
      for(j=0;j<8;j++)
       {
       if(cd.x>=jpg.width) break;
       aaRgbaYuvaSet(&p1,(B)y4[(i<<3)|j],(B)cb[(((i>>1)+4)<<3)|((j>>1)+4)],(B)cr[(((i>>1)+4)<<3)|((j>>1)+4)],255);
       surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
       cd.x++;
       }
      cd.y++;
      }
     x+=16;
     if(x>=jpg.width)
      {
      x=0;
      y+=16;
      if(jpg.is_dri) { dc_y=dc_cb=dc_cr=0; jpg.data+=2; jpg.bits=0; }
      }
     }
    while(y<jpg.height);
    break;

    case 2: //{ oof; Boop; }
    do
     {
     // 2nd case: chrominance is taken every two pixels (only horizontally) and luminance every pixel.
     aa_SurfaceDecodeJpegBlock(&jpg,y1,jpg.dc_y,jpg.ac_y,jpg.quant_y,&dc_y);
//     aa_SurfaceDecodeJpegBlock(&jpg, y2, jpg.dc_y, jpg.ac_y, jpg.quant_y,&dc_y);

     aa_SurfaceDecodeJpegBlock(&jpg,cb,jpg.dc_cbcr,jpg.ac_cbcr,jpg.quant_cbcr,&dc_cb);
     aa_SurfaceDecodeJpegBlock(&jpg,cr,jpg.dc_cbcr,jpg.ac_cbcr,jpg.quant_cbcr,&dc_cr);
     cd.y=(y);
     for(i=0;i<8;i++)
      {
      if(cd.y>=jpg.height) break;
      cd.x=(x);
      for(j=0;j<8;j++)
       {
       if(cd.x>=jpg.width) break;
       //SetDotYuv(tmp,&sz,&cord,y1[(i<<3)|j],   cb[(i<<3)|(j>>1)],    cr[(i<<3)|(j>>1)]);
       aaRgbaYuvaSet(&p1,(B)y1[(i<<3)|j],(B) cb[(i<<3)|(j>>1)],(B)cr[(i<<3)|(j>>1)],255);
       surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
       cd.x++;
       }
      cd.y++;
      }
     cd.y=(y);
     for(i=0;i<8;i++)
      {
      if(cd.y>=jpg.height) break;
      cd.x=(x+8);
      for(j=0;j<8;j++)
       {
       if(cd.x>=jpg.width) break;
       //SetDotYuv(tmp,&sz,&cord,y2[(i<<3)| j], cb[(i<<3)| ((j>>1) + 4)], cr[(i<<3)| ((j>>1) + 4)]);
       aaRgbaYuvaSet(&p1,(B)y2[(i<<3)|j],(B)cb[(i<<3)|((j>>1)+4)],(B)cr[(i<<3)|((j>>1)+4)],255);
       surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
       cd.x++;
       }
      cd.y++;
      }
     x+=16;
     if(x>=jpg.width)
      {
      x=0;
      y+=8;
      if(jpg.is_dri) { dc_y=dc_cb=dc_cr=0; jpg.data+=2; jpg.bits=0; }
      }
     }
    while(y<jpg.height);
    break;

    case 1:   //{ Boop; }
    do
     {
     // 3rd case: chrominance and luminance are taken every pixel.
     aa_SurfaceDecodeJpegBlock(&jpg,y1,jpg.dc_y,jpg.ac_y,jpg.quant_y,&dc_y);
     aa_SurfaceDecodeJpegBlock(&jpg,cb,jpg.dc_cbcr,jpg.ac_cbcr,jpg.quant_cbcr,&dc_cb);
     aa_SurfaceDecodeJpegBlock(&jpg,cr,jpg.dc_cbcr,jpg.ac_cbcr,jpg.quant_cbcr,&dc_cr);
     cd.y=(y);
     for(i=0;i<8;i++)
      {
      if(cd.y>=jpg.height) break;
      cd.x=(x);
      for(j=0;j<8;j++)
       {
       if(cd.x>=jpg.width) break;
       aaRgbaYuvaSet(&p1,(B)y1[(i<<3)|j],(B)cb[(i<<3)|j],(B)cr[(i<<3)|j],255);
       surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
       //SetDotYuv(tmp,&sz,&cord,  y1[(i<<3)| j],   cb[(i<<3)| j],   cr[(i<<3)| j]);
       cd.x++;
       }
      cd.y++;
      }
     x+=8;
     if(x>=jpg.width)
      {
      x=0;
      y+=8;
      if(jpg.is_dri) { dc_y=dc_cb=dc_cr=0;  jpg.data+=2;  jpg.bits=0;   }
      }
     }
    while(y<jpg.height);
    ///added during gcc warning hunt, - put back if fails break;
    }
   break;

   case 1: {oof; Boop; } // Image has just one component (luminance) taken every pixel; we  have a grayscaled picture.
   do
    {
    aa_SurfaceDecodeJpegBlock(&jpg,y1,jpg.dc_y,jpg.ac_y,jpg.quant_y,&dc_y);
    cd.y=(y);
    for(i=0;i<8;i++)
     {
     if(cd.y>=jpg.height) break;
     cd.x=(x);
     for(j=0; j<8; j++)
      {
      if(cd.x>=jpg.width) break;
      hue=aaNumMid(0,y1[(i<<3)|j],255);
      aaRgbaSet(&p1,(B)hue,(B)hue,(B)hue,255);
     // aaSurfacePixelSet(ih,&cd,&p1);
//      surface_status.mem[(cd.y*jpg.width)+cd.x]=p1;
      surface_status.mem[(((jpg.height-cd.y)-1)*jpg.width)+cd.x]=p1;
      cd.x++;
      }
     cd.y++;
     }
    x+=8;
    if(x>=jpg.width)
     {
     x=0;
     y+=8;
     if(jpg.is_dri) { dc_y=0; jpg.data+=2;  jpg.bits=0;   }
     }
    }
   while(y<jpg.height);
   break;
   }

  *handle=ih;
  }
 else
 if(type==2) ///////// tga
  {
  if(filebytes<sizeof(tgahdr)) {  return RET_FAILED; }
  off=0;
  aaMemoryCopy(&tgahdr,sizeof(_aa_surfacetgahdr),&filemem[off]);
  if(tgahdr.bpp==15) tgahdr.bpp=16;
  source_pixel_size=(B)(tgahdr.bpp/7);
  off=sizeof(_aa_surfacetgahdr);
  is_bottom_up=(B)((tgahdr.flags&0x20)==0);
  interlace_type=(B)(tgahdr.flags>>6);
  // tgahdr.pal_type must be 0 or 1, and not be interlaced  ( will handle in future )
  if(tgahdr.pal_type>1||source_pixel_size<1||source_pixel_size>4||((tgahdr.flags&7)!=0)||interlace_type!=0)
   {
   return RET_FAILED;
   }
  block_count=dup_pixel_count=0;
  if(tgahdr.img_type>8) { is_rle=YES; tgahdr.img_type-=(B)8; }
  else                  { is_rle=NO; }
 // Now should have tgahdr.img_type 1, 2, or 3
  switch (tgahdr.img_type)
   {
   case 1:   // Colormapped image
   logg("tga image type=%i",tgahdr.img_type);
   return RET_FAILED;

   case 2:   // RGB image
   switch (source_pixel_size)
    {
    case 2: // source->get_pixel_rows=get_16bit_row;
 //   break;
    case 3: // source->get_pixel_rows=get_24bit_row;
 ///   break;
    case 4: // source->get_pixel_rows=get_32bit_row;
    break;
    default:
    logg("tga image type=2 ,pixel size=%i",source_pixel_size);
    return RET_FAILED;
    }
   break;
   case 3:   // Grayscale image
   logg("tga image type=%i",tgahdr.img_type);
   return RET_FAILED;
   default:
   logg("tga image type=%i",tgahdr.img_type);
   return RET_FAILED;
   }
  while(tgahdr.id_length--)
   {
   off++;
   }
 if(tgahdr.pal_colors>0)
  {
  if(tgahdr.pal_colors>256||tgahdr.first_color!=0)
   {
   return RET_FAILED;
   }
  }
 else
  {
  if(tgahdr.pal_type)
   {
   return RET_FAILED;
   }
  }
 aaSizeSet(&sz,tgahdr.width,tgahdr.height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)
   {
   return ret;
   }
  aaSurfaceStatus(ih,&surface_status);
  aaCast(imem,BP,surface_status.mem);
 if(is_rle==NO)
  {
  if(source_pixel_size==2)
   {
   oof;
   Boop;
   aaCast(p16,_aa_pen16*,&filemem[off]);
   for(y=0;y<(N)sz.h;y++)// ningy added (N)
    {
    if(is_bottom_up) cd.y=(sz.h-y)-1;
    else               cd.y=y;
    cd.x=0;
    for(x=0;x<(N)sz.w;x++) // ningy added (N)
     {
     p32->r=(B)(p16->r<<3);
     p32->g=(B)(p16->g<<3);
     p32->b=(B)(p16->b<<3);
     p32->a=255;
     p16++;
     cd.x++;
     }
    }
   }
  else
  if(source_pixel_size==3)
   {
//   oof;
   Boop;
   aaCast(p24,_aa_pen24*,&filemem[off]);
   for(y=0;y<(N)sz.h;y++) // ningy added (N)
    {
    if(is_bottom_up) cd.y=(sz.h-y)-1;
    else             cd.y=y;
    cd.x=0;
    for(x=0;x<(N)sz.w;x++) // ningy added (N)
     {
     p32->r=p24->r;
     p32->g=p24->g;
     p32->b=p24->b;
     p32->a=255;
     p24++;
     cd.x++;
     }
    }
   }
  else
  if(source_pixel_size==4)
   {
   for(y=0;y<(N)sz.h;y++)// ningy added (N)
    {
    if(is_bottom_up) cd.y=(sz.h-y)-1;
    else             cd.y=y;
    aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
    for(x=0;x<(N)sz.w;x++)// ningy added (N)
     {
     p32->r=bp[off+2];
     p32->g=bp[off+1];
     p32->b=bp[off+0];
     p32->a=255;
     p32++;
     off+=4;
     }
    }
   }
  }
 else /// handle rle
  {
  Boop;
  for(y=0;y<(N)sz.h;y++)  // ningy added (N)
   {
   if(is_bottom_up) cd.y=(sz.h-y)-1;
   else             cd.y=y;
   aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
   for(x=0;x<(N)sz.w;x++) // ningy added (N)
    {
    aa_SurfaceDecodeTgaRle(&dup_pixel_count,&block_count,&off,filemem,tgahdr.bpp,&p1);
    p32->r=p1.r;
    p32->g=p1.g;
    p32->b=p1.b;
    p32->a=255;
    p32++;
    off+=4;
    }
   }
  }
  *handle=ih;
  }
 else
 if(type==3) ///////// ico
  {
  oof;
  }
 else
 if(type==4) /// png
  {
  //oof;
  upng=aa_PngNewFromBytes(mem,bytes);
  if(upng==NULL) { return RET_FAILED; }
  aaSizeSet(&sz,upng->width,upng->height);
  if((ret=aaSurfaceCreate(&ih,&sz))!=RET_YES)  {   aa_PngFree(upng);   return ret;   }
  aaSurfaceStatus(ih,&surface_status);
  aaCast(imem,BP,surface_status.mem);
  if(upng->color_type==PNG_RGBA&&upng->components==4&&upng->bpp==32&&upng->color_depth==8&&upng->format==PNG_RGBA8)
   {
   off=0;
   for(y=0;y<(N)sz.h;y++)
    {
    cd.y=sz.h-y-1; // was cd.y=y;
    cd.y=y;
    off=(cd.y*sz.w*4);
    off=(sz.h-y-1)*sz.w*4;
    aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
    for(x=0;x<(N)sz.w;x++)
     {
     p32->r=upng->buffer[off+0];
     p32->g=upng->buffer[off+1];
     p32->b=upng->buffer[off+2];
     p32->a=upng->buffer[off+3];
     off+=4;
     p32++;
     }
    }
   }
  else
  if(upng->color_type==PNG_RGB&&upng->components==3&&upng->bpp==24&&upng->color_depth==8&&upng->format==PNG_RGB8)
   {
   off=0;
   for(y=0;y<(N)sz.h;y++)
    {
    //cd.y=y;
    cd.y=sz.h-y-1; // was cd.y=y;
    cd.y=y;
    off=(cd.y*sz.w*3);
    off=(sz.h-y-1)*sz.w*3;
    //aaCast(p24,_aa_pen24*,&imem[(cd.y*sz.w*3)]);
    aaCast(p32,_rgba*,&imem[(cd.y*sz.w*4)]);
    for(x=0;x<(N)sz.w;x++)
     {
     p32->r=upng->buffer[off+0];
     p32->g=upng->buffer[off+1];
     p32->b=upng->buffer[off+2];
     p32->a=255;
     off+=3;
     p32++;
     }
    }
   }

  else
   {
   aaSurfaceDestroy(ih);
   aa_PngFree(upng);
   return RET_NOTSUPPORTED;
//   aaNote(0,"png %i %i %i %i %i",upng->color_type,upng->components,upng->bpp,upng->color_depth,upng->format);
   }
  //aaRectSet(&r1,0,0,sz.w,sz.h);
  //aaRectSet(&r2,0,0,sz.w,sz.h);
  //aaSurfaceImageDraw(ih,&sz,&r1,upng->buffer,&r2,0,0,0);
  aa_PngFree(upng);
  *handle=ih;
  return RET_YES;
  //aaSurfaceStatus(ih,&surface_status);
  }
 return RET_YES;
 }





 B aaSurfaceLoad                       (HP handle,VP filename,VP useextension)
 {
 B ret;
 H filebytes;
 BP filemem;
// BP bp;
 H sl,off;
 B txt[_1K];
 N type;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if((ret=aaStringLen(filename,&sl))!=RET_YES) {  return ret; }
 if(sl>_1K) { return RET_BADPARM; }
 if(useextension)
  {
  if(aaStringIsIString(useextension,&type,"bmp","jpg","tga","ico","png",NULL)!=YES)
   {
   if(aaStringIsIString(useextension,&type,".bmp",".jpg",".tga","ico","png",NULL)!=YES) { return RET_FAILED; }
   }
  switch(type)
   {
   default: oof; break;
   case 0:   aaStringCopy(txt,"bmp"); break;
   case 1:   aaStringCopy(txt,"jpg"); break;
   case 2:   aaStringCopy(txt,"tga"); break;
   case 3:   aaStringCopy(txt,"ico"); break;
   case 4:   aaStringCopy(txt,"png"); break;
   }
  }
 else
  {
  aaStringCopy(txt,filename);
  aaStringReverse(txt,0,0,0);
  aaStringLower(txt,0,0);
  if(aaStringFindChar(txt,0,&off,'.',YES,0,YES)!=YES) {  return RET_FAILED; }
  aaStringReverse(txt,off,0,YES);
  if(aaStringIsIString(txt,&type,"bmp","jpg","tga","ico","png",NULL)!=YES) { return RET_FAILED; }
  }
 if((ret=aaFileLoadToMemory(filename,0,F32,(VP)&filemem,&filebytes))!=RET_YES) { return ret; }
 ret=aaSurfaceLoadFromMemory(handle,filebytes,filemem,txt);
 aaMemoryRelease(filemem);
 return ret;
 }






 B aaSurfaceLoadUsingResource          (HP handle,H resnum,VP useextension)
 {
 B ret;
 BP mem;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if((ret=aaResourceToMemory(resnum,&bytes,(VP)&mem))!=RET_YES) { return ret; }
 if((ret=aaSurfaceLoadFromMemory(handle,bytes,mem,useextension))!=RET_YES) { oops; }
 if((ret=aaMemoryRelease(mem))!=RET_YES) { oops; }
 return ret;
 }







 B aaSurfaceDuplicate                  (HP handle,H shandle)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,shandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aaSurfaceCreate(handle,&surp->status.initial_size))!=RET_YES) { return ret; }
 if((ret=aaSurfaceSizeSet(*handle,&surp->status.size))!=RET_YES) { return ret; }
 if((ret=aaSurfaceViewportSet(*handle,&surp->status.viewport_rect))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,*handle,(VP)&psurp,NULL))!=RET_YES) { return ret; }
 aaMemoryCopy(psurp->status.mem,psurp->status.pixel_count*sizeof(_rgba),surp->status.mem);
 return RET_YES;
 }




 B aaSurfaceFindByHwnd                 (HP handle,HWND hwnd)
 {
 _aa_surfaceobject*surp;
 H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }
 if(hwnd==NULL) { return RET_BADPARM; }
 if(aa_SurfaceSystemFindSurfaceByHwnd(&han,(VP)&surp,hwnd)==YES)
  {
  if(handle) { *handle=han; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 B aaSurfaceSave                       (H handle,_rect*r1,B flip,VP filename)
 {
 B ret;
 _aa_surfaceobject*surp;
 _jpegctx jpegctx;
 //_aa_surfacebmpfilehdr bmpfilehdr;
/// _aa_surfacewinbmpinfohdr winbmpinfohdr;
 N type;
// B flag;
 H file_handle;
 H outbytes;
 H y,c;
 B block[_16K];
 H sl;
 BP fnp;
// _rgba*pn;
_memoryunit men;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 aaCast(fnp,BP,filename);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
// if(ctrl1==ctrl2==ctrl3) {} // prev warn

 aaStringLen(fnp,&sl);
 if(aaStringIsIString(&fnp[sl-3],&type,"bmp","jpg","ico","png",NULL)!=YES)
  {
  if(aaStringIsIString(&fnp[sl-4],&type,".bmp",".jpg",".ico",".png",NULL)!=YES)
   {
   type=-1;
   }
  }
 file_handle=0;
 if(type!=1&&type!=2&&type!=3)  {  oof;  return RET_NOTSUPPORTED;  }

 if(type==1)
  {
  if((ret=aa_JpegNew(&jpegctx))!=YES) { oops; }
  if((ret=aa_JpegCompress(&jpegctx,surp->status.size.w,surp->status.size.h,surp->status.mem))!=YES) { oops; }
  if((ret=aaFileSaveFromMemory(filename,(H)jpegctx.out_len,jpegctx.out.mem))!=YES) { oops; }
  if((ret=aa_JpegDelete(&jpegctx))!=YES) { oops; }
  return RET_YES;
  }

 if(type==2) //===ico
  {
  if(r1!=NULL) { oof; }
  if((ret=aaFileStreamCreate(&file_handle,fnp,YES,3,3,0,NO))!=RET_YES) {   return ret; }
  sl=0;
  *(WP)&block[sl]=0; sl+=2; //zero
  *(WP)&block[sl]=1; sl+=2; //tyoe
  *(WP)&block[sl]=1; sl+=2; //icon count
  *(BP)&block[sl]=(B)surp->status.size.w; sl++; // B wid
  *(BP)&block[sl]=(B)surp->status.size.h; sl++; // B hit
  *(BP)&block[sl]=0; sl++;  //zero
  *(BP)&block[sl]=0; sl++;  //zero
  *(WP)&block[sl]=1; sl+=2; //planes
  *(WP)&block[sl]=32;   sl+=2; // bits
  *(HP)&block[sl]=(surp->status.size.w*surp->status.size.h*4)+40; sl+=4;  //bytes //48x48x4=9216  ,, 424
  *(HP)&block[sl]=22; sl+=4;  // off
  *(HP)&block[sl]=40; sl+=4;  // size of struct
  *(HP)&block[sl]=surp->status.size.w;   sl+=4; // wid
  *(HP)&block[sl]=surp->status.size.h*2; sl+=4; // hit*2
  *(WP)&block[sl]=1;  sl+=2; // planes
  *(WP)&block[sl]=32; sl+=2; // bits
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  aaFileStreamWrite(file_handle,sl,block);
  if(flip!=YES) {  c=0; }
  else          {  c=surp->status.size.h-1; }
  for(y=0;y<surp->status.size.h;y++)
   {
   aaFileStreamWrite(file_handle,surp->status.size.w*4,&surp->status.mem[c*surp->status.size.w]);
   if(flip!=YES) { c++; }
   else          { c--; }
   }
  aaFileStreamDestroy(file_handle);
  return RET_YES;
  }

  #if 0
 else
 if(type==0) //==== bmp
  {
  if((ret=aaFileStreamCreate(&file_handle,fnp,YES,3,3,0,NO))!=RET_YES) {   return ret; }
  aaMemoryFill(&bmpfilehdr,sizeof(bmpfilehdr),0);
  aaMemoryFill(&winbmpinfohdr,sizeof(winbmpinfohdr),0);
  if(r1==NULL)
   {
   bmpfilehdr.type=19778;
   bmpfilehdr.size=54+(surp->status.size.w*surp->status.size.h*4);
   bmpfilehdr.off_bits=54;
   winbmpinfohdr.width=surp->status.size.w;
   winbmpinfohdr.height=surp->status.size.h;
   winbmpinfohdr.planes=1;
   winbmpinfohdr.bits=32;
   winbmpinfohdr.compression=BI_RGB;
   winbmpinfohdr.imgsize=surp->status.size.w*surp->status.size.h*4;
   aaFileStreamWrite(file_handle,sizeof(bmpfilehdr),&bmpfilehdr);
   c=40;
   aaFileStreamWrite(file_handle,sizeof(H),&c);
   aaFileStreamWrite(file_handle,sizeof(winbmpinfohdr),&winbmpinfohdr);
   if(flip==YES) {  c=0; }
   else          {  c=surp->status.size.h-1; }
   for(y=0;y<surp->status.size.h;y++)
    {
    aaMemoryCopy(block,surp->status.size.w*4,&surp->status.mem[c*surp->status.size.w]);
    aaFileStreamWrite(file_handle,surp->status.size.w*4,block);
    if(flip==YES) { c++; }
    else          { c--; }
    }
   }
  else
   {
    if(r1->w==0||r1->h==0) { aaFileStreamDestroy(file_handle); aaFileDelete(fnp); return RET_FAILED; }
   // add more sanitychecks
   bmpfilehdr.type=19778;
   bmpfilehdr.size=54+(r1->w*r1->h*4);
   bmpfilehdr.off_bits=54;
   winbmpinfohdr.width=r1->w;
   winbmpinfohdr.height=r1->h;
   winbmpinfohdr.planes=1;
   winbmpinfohdr.bits=32;
   winbmpinfohdr.compression=BI_RGB;
   winbmpinfohdr.imgsize=r1->w*r1->h*4;
   aaFileStreamWrite(file_handle,sizeof(bmpfilehdr),&bmpfilehdr);
   c=40;
   aaFileStreamWrite(file_handle,sizeof(H),&c);
   aaFileStreamWrite(file_handle,sizeof(winbmpinfohdr),&winbmpinfohdr);
   //c=surp->status.size.h-(surp->status.size.h-r1->h)-1;
   if(flip==YES) {  c=r1->y; }
   else          {  c=(r1->y+r1->h)-1; }
   for(y=0;y<r1->h;y++)
    {
    aaMemoryCopy(block,r1->w*4,&surp->status.mem[(c*surp->status.size.w)+(r1->x)]);
    aaFileStreamWrite(file_handle,r1->w*4,block);
    if(flip==YES) { c++; }
    else          {  c--; }
    }
   }
  }
 else
 #endif

 if(type==3) //====png
  {
  ret=aaMemoryUnitAllocate(&men,(sizeof(aa_png_header)+(((N)surp->status.size.w*4+6)*(N)surp->status.size.h)+8+sizeof(aa_png_trailer)));
  if(ret!=YES) { oops; }
  ret=aa_PngFromImage(surp->status.mem,surp->status.size.w,surp->status.size.h,surp->status.size.w,men.mem,men.bytes,&outbytes);
  if(ret!=YES) { oops; }
  ret=aaFileSaveFromMemory(filename,outbytes,men.mem);
  if(ret!=YES) { oops; }
  aaMemoryUnitRelease(&men);
  return RET_YES;
  }

 oof;
/// if(file_handle!=0) { aaFileStreamDestroy(file_handle); }
 return RET_YES;
 }








 B aaSurfaceSaveToMemory               (H handle,_rect*r1,B flip,VP useextension,HP bytes,H maxbytes,VP mem)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfacebmpfilehdr bmpfilehdr;
 _aa_surfacewinbmpinfohdr winbmpinfohdr;
 _jpegctx jpegctx;
 N type;
 H y,c,sl;
 B block[_16K];
// BP fnp;
 _dynbufunit du;
 _memoryunit men;
 H outbytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes==NULL) { return RET_BADPARM; }
 *bytes=0;
 //aaCast(fnp,BP,filename);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(useextension==NULL) {return RET_BADPARM; }
 if(maxbytes!=0&&mem==NULL) { return RET_BADPARM; }

 if(aaStringIsIString(useextension,&type,"bmp","jpg","ico","png",NULL)!=YES)
  {
  if(aaStringIsIString(useextension,&type,".bmp",".jpg",".ico",".png",NULL)!=YES) { return RET_FAILED; }
  }

 if(type==2)
  {
  return RET_NOTSUPPORTED;
  }

 if(type==1)
  {
  if((ret=aa_JpegNew(&jpegctx))!=YES) { oops; }
  if((ret=aa_JpegCompress(&jpegctx,surp->status.size.w,surp->status.size.h,surp->status.mem))!=YES) { oops; }
  if(bytes) { *bytes=(H)jpegctx.out_len; }
  if((H)jpegctx.out_len>maxbytes)
   {
   if((ret=aa_JpegDelete(&jpegctx))!=YES) { oops; }
   return RET_BOUNDS;
   }
  if(mem!=NULL) { aaMemoryCopy(mem,(H)jpegctx.out_len,jpegctx.out.mem); }
  if((ret=aa_JpegDelete(&jpegctx))!=YES) { oops; }
  return RET_YES;
  }


 if(type==3)
  {
  ret=aaMemoryUnitAllocate(&men,(sizeof(aa_png_header)+(((N)surp->status.size.w*4+6)*(N)surp->status.size.h)+8+sizeof(aa_png_trailer)));
  if(ret!=YES) { oops; }
  ret=aa_PngFromImage(surp->status.mem,surp->status.size.w,surp->status.size.h,surp->status.size.w,men.mem,men.bytes,&outbytes);
  if(ret!=YES) { oops; }
  if(bytes) { *bytes=outbytes; }
  if(outbytes>maxbytes)
   {
   aaMemoryUnitRelease(&men);
   return RET_BOUNDS;
   }
  if(mem!=NULL) { aaMemoryCopy(mem,outbytes,men.mem); }
  aaMemoryUnitRelease(&men);
  return RET_YES;
  }




 if(type==2)
  {
  if(r1!=NULL) { oof; }
  aaDynbufCreate(&du.handle);
  sl=0;
  *(WP)&block[sl]=0; sl+=2; //zero
  *(WP)&block[sl]=1; sl+=2; //tyoe
  *(WP)&block[sl]=1; sl+=2; //icon coupixelnt
  *(BP)&block[sl]=(B)surp->status.size.w; sl++; // B wid
  *(BP)&block[sl]=(B)surp->status.size.h; sl++; // B hit
  *(BP)&block[sl]=0; sl++;  //zero
  *(BP)&block[sl]=0; sl++;  //zero
  *(WP)&block[sl]=1; sl+=2; //planes
  *(WP)&block[sl]=32;   sl+=2; // bits
  *(HP)&block[sl]=(surp->status.size.w*surp->status.size.h*4)+40; sl+=4;  //bytes //48x48x4=9216  ,, 424
  *(HP)&block[sl]=22; sl+=4;  // off
  *(HP)&block[sl]=40; sl+=4;  // size of struct
  *(HP)&block[sl]=surp->status.size.w;   sl+=4; // wid
  *(HP)&block[sl]=surp->status.size.h*2; sl+=4; // hit*2
  *(WP)&block[sl]=1;  sl+=2; // planes
  *(WP)&block[sl]=32; sl+=2; // bits
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  *(HP)&block[sl]=0; sl+=4;
  aaDynbufAppend(du.handle,sl,block);
  if(flip!=YES) {  c=0; }
  else          {  c=surp->status.size.h-1; }
  for(y=0;y<surp->status.size.h;y++)
   {
   aaDynbufAppend(du.handle,surp->status.size.w*4,&surp->status.mem[c*surp->status.size.w]);
   if(flip!=YES) { c++; }
   else          { c--; }
   }
  aaDynbufStatus(du.handle,&du.status);
  if(bytes) { *bytes=du.status.bytes_used; }
  if(du.status.bytes_used>maxbytes) { aaDynbufDestroy(du.handle); return RET_BOUNDS; }
  if(mem!=NULL) { aaMemoryCopy(mem,du.status.bytes_used,du.status.mem); }
  aaDynbufDestroy(du.handle);
  return RET_YES;
  }

 aaDynbufCreate(&du.handle);
 aaMemoryFill(&bmpfilehdr,sizeof(bmpfilehdr),0);
 aaMemoryFill(&winbmpinfohdr,sizeof(winbmpinfohdr),0);
 if(r1==NULL)
  {
  bmpfilehdr.type=19778;
  bmpfilehdr.size=54+(surp->status.size.w*surp->status.size.h*4);
  bmpfilehdr.off_bits=54;
  winbmpinfohdr.width=surp->status.size.w;
  winbmpinfohdr.height=surp->status.size.h;
  winbmpinfohdr.planes=1;
  winbmpinfohdr.bits=32;
  winbmpinfohdr.compression=BI_RGB;
  winbmpinfohdr.imgsize=surp->status.size.w*surp->status.size.h*4;
  aaDynbufAppend(du.handle,sizeof(bmpfilehdr),&bmpfilehdr);
  c=40;
  aaDynbufAppend(du.handle,sizeof(H),&c);
  aaDynbufAppend(du.handle,sizeof(winbmpinfohdr),&winbmpinfohdr);
  if(flip==YES) {  c=0; }
  else          {  c=surp->status.size.h-1; }
  for(y=0;y<surp->status.size.h;y++)
   {
   aaMemoryCopy(block,surp->status.size.w*4,&surp->status.mem[c*surp->status.size.w]);
   aaDynbufAppend(du.handle,surp->status.size.w*4,block);
   if(flip==YES) { c++; }
   else          { c--; }
   }
  }
 else
  {
  if(r1->w==0||r1->h==0) { aaDynbufDestroy(du.handle); return RET_FAILED; }
  // add more sanitychecks
  bmpfilehdr.type=19778;
  bmpfilehdr.size=54+(r1->w*r1->h*4);
  bmpfilehdr.off_bits=54;
  winbmpinfohdr.width=r1->w;
  winbmpinfohdr.height=r1->h;
  winbmpinfohdr.planes=1;
  winbmpinfohdr.bits=32;
  winbmpinfohdr.compression=BI_RGB;
  winbmpinfohdr.imgsize=r1->w*r1->h*4;
  aaDynbufAppend(du.handle,sizeof(bmpfilehdr),&bmpfilehdr);
  c=40;
  aaDynbufAppend(du.handle,sizeof(H),&c);
  aaDynbufAppend(du.handle,sizeof(winbmpinfohdr),&winbmpinfohdr);
  if(flip==YES) {  c=r1->y; }
  else          {  c=(r1->y+r1->h)-1; }
  for(y=0;y<r1->h;y++)
   {
   aaMemoryCopy(block,r1->w*4,&surp->status.mem[(c*surp->status.size.w)+(r1->x)]);
   aaDynbufAppend(du.handle,r1->w*4,block);
   if(flip==YES) { c++; }
   else          {  c--; }
   }
  }

 aaDynbufStatus(du.handle,&du.status);
 if(bytes) { *bytes=du.status.bytes_used; }
 if(du.status.bytes_used>maxbytes) { aaDynbufDestroy(du.handle);  return RET_BOUNDS; }
 if(mem!=NULL) { aaMemoryCopy(mem,du.status.bytes_used,du.status.mem); }
 aaDynbufDestroy(du.handle);
 return RET_YES;
 }




 B aaSurfaceDestroy                    (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;
 B isprot,loopfull;
 _aa_surfaceobject*csurp;
 H it,han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }

 if(surp->status.is_visual==YES)
  {
  if(surp->status.is_systray==YES) { aaSurfaceTraySet(handle,0,NULL); surp->status.is_systray=NO; }
  if(surp->status.is_rounded!=0)
   {
   if(SetWindowRgn(surp->status.hwnd,NULL,YES)==0)  { oof; }
   DeleteObject(surp->status.region);
   surp->status.region=NULL;
   surp->status.is_rounded=NO;
   }
  }

 if(surp->status.is_child==YES)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surp->status.parent_handle,(VP)&psurp,0))!=RET_YES) { oops; }
  //  aaNote(0,"myhandle=%x parent_handle=%x cc=%i pcc=%i",handle,surp->status.parent_handle,surp->status.child_count,psurp->status.child_count);
  if(psurp->status.is_parent!=YES) { oof; }
  if(psurp->status.child_count==0) { oof; }
  SetParent(surp->status.hwnd,NULL);
  psurp->status.child_count--;
  if(psurp->status.child_count==0) { psurp->status.is_parent=NO; }
  }

 if(surp->status.is_parent==YES)
  {
  it=0;
  loopfull=0;
  while(1)
   {
   ret=aa_ObjectNext(aa.surface_system.object_id,&han,(VP)&csurp,&it);
   if(ret==RET_NOTFOUND) { aaNote(0,"cc=%i",surp->status.child_count); break; }
   if(ret!=YES) { oops; }
   if(handle==han)
    {
    loopfull++;
    if(loopfull==2) { break; }
    continue;
    }
   if(csurp->status.parent_handle!=handle) { oof; }
   if(csurp->status.parent_hwnd!=surp->status.hwnd)
    {
    aaNote(0,"cphw=%x chw=%x chan=%x",csurp->status.parent_hwnd,surp->status.hwnd,han);
    }
   if(csurp->status.is_visual==YES)
    {
    if(csurp->status.is_systray==YES) { aaSurfaceTraySet(han,0,NULL); csurp->status.is_systray=NO; }
    if(csurp->status.is_rounded!=0)
     {
     if(SetWindowRgn(csurp->status.hwnd,NULL,YES)==0)  { oof; }
     DeleteObject(csurp->status.region);
     csurp->status.region=NULL;
     csurp->status.is_rounded=NO;
     }
    }
   SetParent(csurp->status.hwnd,NULL);
   if(surp->status.child_count==0) { oof; }
   surp->status.child_count--;
   csurp->status.parent_handle=0;
   csurp->status.parent_hwnd=0;
   csurp->status.is_child=NO;
   surp->status.is_parent=NO;
   if(csurp->status.is_visual==YES) {  DestroyWindow(csurp->status.hwnd);  csurp->status.hwnd=NULL;  }
   if(csurp->status.icon_mem!=NULL) {  aaMemoryRelease(csurp->status.icon_mem);  csurp->status.icon_mem=0;  }
   if(csurp->status.mem!=NULL)
    {
    if(csurp->status.is_made==NO)  {   aa_MemoryRelease(csurp->status.mem);   csurp->status.mem=NULL;   }
    }
   if(csurp->status.spot_slots!=0)
    {
    aaMemoryRelease(csurp->status.spot);
    aaMemoryRelease(csurp->status.spot_id_order);
    //citsys01: aaMemoryRelease(csurp->status.spot_index_order);
    csurp->status.spot=0;
    }
   aaSurfaceExtraDataSet(han,0);
   aa_ObjectDestroy(aa.surface_system.object_id,han);
   it=0;
   loopfull=0;
   }
  }
 if(surp->status.is_visual==YES) {  DestroyWindow(surp->status.hwnd);  surp->status.hwnd=NULL;  }
 if(surp->status.icon_mem!=NULL) {  aaMemoryRelease(surp->status.icon_mem);  surp->status.icon_mem=0;  }
 if(surp->status.mem!=NULL)
  {
  if(surp->status.is_made==NO)  {   aa_MemoryRelease(surp->status.mem);   surp->status.mem=NULL;   }
  }
 if(surp->status.spot_slots!=0)
  {
  aaMemoryRelease(surp->status.spot);
  //citsys01: aaMemoryRelease(surp->status.spot_index_order);
  aaMemoryRelease(surp->status.spot_id_order);
  surp->status.spot=NULL_POINTR;
  //citsys01: surp->status.spot_index_order=NULL_POINTR;
  surp->status.spot_id_order=NULL_POINTR;
  surp->status.spot=0;
  }
 if(surp->status.spot_depth_map!=NULL)
  {
  aaMemoryRelease(surp->status.spot_depth_map);
  surp->status.spot_depth_map=NULL_POINTR;
  }
 if(surp->status.spot_id_map!=NULL)
  {
  aaMemoryRelease(surp->status.spot_id_map);
  surp->status.spot_id_map=NULL_POINTR;
  }
 if(surp->status.drop_list.magic)
  {
  aaListDelete(&surp->status.drop_list);
  }
 aaSurfaceExtraDataSet(handle,0);
 aa_ObjectDestroy(aa.surface_system.object_id,handle);
 return RET_YES;
 }





 B aaSurfaceIgnoreWMPaint              (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==YES) {  surp->status.is_ignore_wmpaint=YES; }
 else           { surp->status.is_ignore_wmpaint=NO; }
 return RET_YES;
 }





 B aaSurfaceMinMaxSizeSet              (H handle,_size*minsize,_size*maxsize)
 {
 B ret;
 _aa_surfaceobject*surp;
 //H index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(minsize) { aaSizeCopy(&surp->status.min_size,minsize); }
 if(maxsize) { aaSizeCopy(&surp->status.max_size,maxsize); }
 if(aaSizeEqualsSize(&surp->status.min_size,&surp->status.max_size)==YES) { surp->status.is_sizeable=NO; }
 else {  surp->status.is_sizeable=YES; }
  #if 1
 //index=1;
 if(surp->status.is_sizeable==YES)
  {


//  (surp->status.size.w-16),(surp->status.size.h-16),14,14);
//  aaSurfaceFill(handle,&surp->status.spot_rect[index],&col_red[31]);
  //aaLog(-1,"%i %i %i %i",(surp->status.size.w-16),(surp->status.size.h-16),14,14);
  }
 else
  {
//  aaNote(0,"%i %i",maxsize->w,maxsize->h);

  }
  #endif

 return RET_YES;
 }





 B aaSurfaceMaximize                   (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;
 //_displayinfo di;
 //_cord cd1;
 //B mi;
 _size sz1;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==TOGGLE)
  {
  if(surp->status.is_maximized) { state=NO; }
  else                          { state=YES; }
  }
 if(state==YES)
  {
  if(surp->status.is_maximized==YES) { return RET_FAILED; }
  aaRectCopy(&surp->status.last_rect,&surp->status.rect);
  aaRectCopy(&rc1,&surp->status.last_rect_max);
  if(rc1.w==0||rc1.h==0)
   {
   aaSizeCopy(&sz1,&surp->status.max_size);
   aaRectSet(&rc1,0,0,sz1.w,sz1.h);
   aaRectCopy(&surp->status.last_rect_max,&rc1);
   aaSurfaceRectSet(handle,&rc1);
   aaSurfaceCenter(handle,0);
   }
  else
   {
   aaSurfaceRectSet(handle,&rc1);
   }
  //cd1.x=moni
  surp->status.is_maximized=YES;
  }
 else
 if(state==NO)
  {
  if(surp->status.is_maximized!=YES) { return RET_FAILED; }
  aaRectCopy(&surp->status.last_rect_max,&surp->status.rect);
  aaSurfaceRectSet(handle,&surp->status.last_rect);
  surp->status.is_maximized=NO;
  }
 return RET_YES;
 }










 B aaSurfaceRequiresResize             (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _displayinfo di;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_shown!=YES) { return RET_NO; }
 if(surp->status.is_maximized!=YES) { return RET_NO; }
 aaDisplayInfoGet(&di);
 if(di.taskbar_orientation==aa_DIRECTION_S)
  {
  if((N)surp->status.size.h>(N)(di.taskbar_rect.y-1))
   {
   if(rect) { aaRectSet(rect,0,0,di.screen_size.w,di.taskbar_rect.y-1); }
   return RET_YES;
   }
  }
 else
 if(di.taskbar_orientation==aa_DIRECTION_W)
  {
  if((N)surp->status.size.w>(N)((di.screen_size.w-di.taskbar_rect.w)-1))
   {
   if(rect) {  aaRectSet(rect,di.taskbar_rect.w,0,(di.screen_size.w-di.taskbar_rect.w)-1,di.screen_size.h); }
   return RET_YES;
   }
  }
 return RET_NO;
 }








 B aaSurfaceElseProcSet                (H handle,N(*Proc)(HWND hWindow,H uiMessage,H uiParam,N ulParam,BP isseproc))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.ElseProc=Proc;
 return RET_YES;
 }





 B aaSurfaceStatus                     (H handle,_surfacestatus*surfacestatus)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.spot_order_ok!=YES)
  {
  aa_SurfaceSortSpots((VP)&surp);
  if(surp->status.spot_order_ok!=YES)   { oof; }
  }
 if(aaTimerPulse(&surp->caret_timer,surp->status.caret_speed)==RET_YES)
  {
  surp->status.caret_counter++;
  }
 if(surfacestatus) { aaMemoryCopy(surfacestatus,sizeof(_surfacestatus),&surp->status); }
 return RET_YES;
 }



 B aaSurfaceCursorCapture              (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(state)
  {
  SetCapture(surp->status.hwnd);
  surp->status.is_cursor_captured=YES;
  }
 else
  {
  ReleaseCapture();
  surp->status.is_cursor_captured=NO;
  }
 return RET_YES;
 }










 B aaSurfaceMoveableSet                (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;
// H index;
 //N ypos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state>2) { return RET_BOUNDS; }
 //ypos=0;
 if(state==0) { surp->status.is_moveable=NO; }
 else
 if(state==1)  { surp->status.is_moveable=YES; }///ypos=state; }
 else   { surp->status.is_moveable=2; }//ypos=state; }
 //if(state) { surp->status.is_moveable=YES; ypos=state; }
 //else      { surp->status.is_moveable=NO; ypos=0; }
 //index=0;
 if(surp->status.is_moveable==YES)
  {

  }
 else
  {

  }
 return RET_YES;
 }






 B aaSurfaceSizeableSet                (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;
// H index;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state) { surp->status.is_sizeable=YES; }
 else      { surp->status.is_sizeable=NO; }
 if(surp->status.is_sizeable==YES)
  {

  }
 else
  {

  }
 return RET_YES;
 }





 B aaSurfaceResizeCounterGet           (H handle,HP counter)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(counter==NULL) { return RET_BADPARM; }
 *counter=surp->status.resize_counter;
 return RET_YES;
 }



 B aaSurfaceResizeCounterReset         (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.resize_counter=0;
 return RET_YES;
 }







 B aaSurfaceDisableRect                (H handle,_rect*r1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r2;
 Z r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(r1==NULL)
  {
  r=SelectClipRgn(surp->status.dc,NULL);
  if(r==ERROR) { return RET_FAILED; }
  surp->status.is_disabled=NO;
  return RET_YES;
  }
 aaRectCopy(&r2,r1);
 if(r2.w==0) { r2.w=surp->status.size.w-r2.x; }
 if(r2.h==0) { r2.h=surp->status.size.h-r2.y; }
 r=ExcludeClipRect(surp->status.dc,r2.x,r2.y,r2.x+r2.w,r2.y+r2.h);
 if(r==ERROR) { return RET_FAILED; }
 surp->status.is_disabled=YES;
 return RET_YES;
 }






 B aaSurfaceClipperGet                 (H handle,_rect*r1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM;  }
 aaRectSet(r1,0,0,0,0);
 if(surp->status.is_clipper!=YES) { return RET_NO; }
 aaRectCopy(r1,&surp->status.clipper_rect);
 return RET_YES;
 }




 B aaSurfaceClipperSet                 (H handle,_rect*r1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { aaRectNull(&surp->status.clipper_rect);   surp->status.is_clipper=NO; return RET_YES; }
 if(r1->w==0||r1->h==0) { aaRectNull(&surp->status.clipper_rect);   surp->status.is_clipper=NO; return RET_YES; }

 if(aaRectIsValid(r1)!=YES) { return RET_BADPARM; }
 aaRectCopy(&surp->status.clipper_rect,r1);
 surp->status.is_clipper=YES;
 return RET_YES;
 }




 B aaSurfaceFlipSet                    (H handle,B hflipstate,B vflipstate)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(hflipstate)
  {
  surp->status.is_hflip=YES;
  }
 else
  {
  surp->status.is_hflip=NO;
  }
 if(vflipstate)
  {
  surp->status.is_vflip=YES;
  }
 else
  {
  surp->status.is_vflip=NO;
  }
 return RET_YES;
 }






 B aaSurfaceBlendSet                   (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==surp->status.is_blend) { return RET_YES; }
// aaDebugf("%s %i",__func__,__LINE__);
 if(state==YES)
  {
  surp->PixelGet=aaSurfacePixelGetProc;
  surp->PixelSet=aaSurfacePixelSetProc;
  surp->PixelPut=aaSurfacePixelPutProc;
  surp->status.is_blend=YES;
  }
 else
  {
  surp->PixelGet=aaSurfacePixelGetProc;
  surp->PixelSet=aaSurfacePixelSetProc;
  surp->PixelPut=aaSurfacePixelSetProc;
  surp->status.is_blend=NO;
  }
 return RET_YES;
 }





 B aaSurfaceAlphaSet                   (H handle,B alpha)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.alpha=alpha;
 return RET_YES;
 }





 B aaSurfaceVisualize                  (H handle,B tool,H parent)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;
 DWORD style,ex;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO)
  {                          //WS_EX_LAYERED|COLORREF re; SetLayeredWindowAttributes(surp->status.hwnd, RGB(100,100,100), (255*70) / 100,LWA_COLORKEY);
  if(parent==0)
   {
   style=WS_POPUP|WS_VISIBLE;//|WS_CLIPSIBLINGS|WS_CLIPCHILDREN;//|WS_CLIPSIBLINGS|WS_CLIPCHILDREN;
   if(tool) {  ex=WS_EX_TOOLWINDOW; }
   else     {  ex=0;}
   surp->status.hwnd=CreateWindowEx(ex,(LPCTSTR)aa.core_system.class_name,surp->status.title,style,surp->status.rect.x,surp->status.rect.y,surp->status.rect.w,surp->status.rect.h,NULL,NULL,aa.core_system.this_instance,NULL);
   }
  else
   {
   style=WS_POPUP;//|WS_CLIPCHILDREN|WS_CLIPSIBLINGS;
   //style=WS_POPUP|WS_CLIPCHILDREN;//WS_CLIPSIBLINGS|
   //ex=WS_EX_TRANSPARENT;
   ex=((tool)?WS_EX_TOOLWINDOW:WS_EX_TRANSPARENT);
   //ex|=WS_EX_TRANSPARENT;
   if((ret=aa_ObjectCheck(aa.surface_system.object_id,parent,(VP)&psurp,NULL))!=RET_YES) { return ret; }
   surp->status.hwnd=CreateWindowEx(ex,(LPCTSTR)aa.core_system.class_name,surp->status.title,style,surp->status.rect.x,surp->status.rect.y,surp->status.rect.w,surp->status.rect.h,psurp->status.hwnd,NULL,aa.core_system.this_instance,NULL);
   }
  if(surp->status.hwnd==NULL) { oow; }
  surp->status.dc=GetWindowDC(surp->status.hwnd);
  if(surp->status.hwnd==NULL||surp->status.dc==NULL) { oof; }
  surp->status.is_visual=YES;
  if(tool) surp->status.is_tool=YES;
  else     surp->status.is_tool=NO;
  if(parent)
   {
   surp->status.is_child=YES;
   surp->status.parent_hwnd=psurp->status.hwnd;
   surp->status.parent_handle=parent;
   psurp->status.is_parent=YES;
   psurp->status.child_count++;
   }
  //if(SetStretchBltMode(surp->status.dc,COLORONCOLOR)==0) oof;
  }
 return RET_YES;
 }









 B aaSurfaceRoundedSet                 (H handle,B state,Z rwid,Z rhit)
 {
 B ret;
 _aa_surfaceobject*surp;
 HRGN rgn;
 Z hit,wid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(state!=NO)
  {
  if(surp->status.is_rounded==0)
   {
   hit=rhit;
   wid=rwid;
   if(hit<=0) { hit=0; }
   if(wid<=0) { wid=0; }
   hit=aaNumRoof(hit,(Z)surp->status.size.h); // ningy added (Z)
   wid=aaNumRoof(wid,(Z)surp->status.size.w); // ningy added (Z)
   if((rgn=CreateRoundRectRgn(0,0,surp->status.size.w-1,surp->status.size.h-1,hit,wid))==NULL) oof;
   if(SetWindowRgn(surp->status.hwnd,rgn,TRUE)==0) { oof; }


   surp->status.region=rgn;
   surp->status.is_rounded=state;
   }
  }
 else
  {
  if(surp->status.is_rounded!=0)
   {
   if(SetWindowRgn(surp->status.hwnd,NULL,YES)==0)  { oof; }
   DeleteObject(surp->status.region);
   surp->status.region=NULL;
   surp->status.is_rounded=0;
   }
  }
 return RET_YES;
 }






 B aaSurfaceShow                       (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==YES||state==2)
  {
  if(surp->status.is_visual==NO)
   {
   logg("%s:%i",__func__,__LINE__);
   if((ret=aaSurfaceVisualize(handle,NO,surp->status.parent_handle))!=YES) { oops; }
   logg("%s:%i",__func__,__LINE__);
   }
  //logg("%s:%i",__func__,__LINE__);
  if(state==YES)
   {
   if(surp->status.is_shown==YES)  { return RET_YES; }
   ShowWindow(surp->status.hwnd,SW_SHOW);
   }
  else
   {
   if(surp->status.is_minimized==YES)  { return RET_YES; }
   ShowWindow(surp->status.hwnd,SW_SHOWMINIMIZED);
   surp->status.is_minimized=YES;
   }
  surp->status.is_shown=YES;
  }
 else
  {
  if(surp->status.is_shown!=YES)  { return RET_YES; }
  ShowWindow(surp->status.hwnd,SW_HIDE);
  surp->status.is_shown=NO;
  }
 return RET_YES;
 }




/*

 B aaSurfaceOriginSet                  (H handle,_cord*c1)
 {
 B ret;
 _aa_surfaceobject*surp;

 aa_DIAG("aaSurfaceOriginSet");
 aaNote(0,"Function @Line #%i not completed -- seeBlit for origin ",__LINE__);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL) { aaCordSet(&surp->status.origin_cord,0,0); }
 else
  {
  if(c1->x>=(N)surp->status.size.w) { return RET_BOUNDS; } // ningy added (N)
  if(c1->y>=(N)surp->status.size.h) { return RET_BOUNDS; } // ningy added (N)
  aaCordCopy(&surp->status.origin_cord,c1);
  }
 return RET_YES;
 }

*/




 B aaSurfaceTraySet                    (H handle,H iconresnum,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 B str[_4K];
 H sl;
 NOTIFYICONDATA nid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }

 if(surp->status.is_systray==YES)
  {
  if(fmt==NULL)
   {
   //oof;
   SetLastError(0);
   if(surp->status.is_tool)
    {
    SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)&~WS_EX_TOOLWINDOW);
    }
   else
    {
    SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)&~WS_EX_APPWINDOW);
    }
   if(GetLastError()) { oof; }
   nid.cbSize=sizeof(nid);
   nid.hWnd=surp->status.hwnd;
   nid.uID=1;
   nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
   nid.uCallbackMessage=WM_SURFACE_SYSTRAY_MSG;
   if(Shell_NotifyIcon(NIM_DELETE,&nid)==0) return RET_FAILED;
   surp->status.is_systray=NO;
   // go back to normal mode
   ShowWindow(surp->status.hwnd,SW_SHOW);
   surp->status.is_systray=NO;
   surp->status.is_shown=YES;
   }
  else
   {
   nid.cbSize=sizeof(nid);
   nid.hWnd=surp->status.hwnd;
   nid.uID=1;
   nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
   nid.uCallbackMessage=WM_SURFACE_SYSTRAY_MSG;
   if(iconresnum) {  nid.hIcon=(HICON)LoadIcon(aa.core_system.this_instance,MAKEINTRESOURCE(iconresnum));  }
   else           {   nid.hIcon=(HICON)LoadIcon(NULL,IDI_APPLICATION);   }
   aaStringLen(str,&sl);
   if(sl>1023) { str[1023]=0; }
   aaStringCopy(nid.szTip,str);
   if(Shell_NotifyIcon(NIM_MODIFY,&nid)==0) { return RET_FAILED; }
//   surp->status.is_systray=NO;
   // go back to normal mode
//   ShowWindow(surp->status.hwnd,SW_SHOW);
   surp->status.is_systray=YES;
   surp->status.is_shown=YES;
   aaSurfaceUpdateAreaAdd(handle,0,NO);
   //RedrawWindow(aa.input_system.tray_hwnd,0,0,RDW_INVALIDATE);
   return YES;
   }
  }
 else
  {
  //oof;
  if(fmt==NULL) { return RET_BADPARM; }
  // remove window from task bar, and move to systray
//  ShowWindow(surp->status.hwnd,SW_HIDE);
  SetLastError(0);
  if(surp->status.is_tool)
   {
   SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)|WS_EX_TOOLWINDOW);
   }
  else
   {
   SetWindowLong(surp->status.hwnd,GWL_EXSTYLE,GetWindowLong(surp->status.hwnd,GWL_EXSTYLE)|WS_EX_APPWINDOW);
   }
  if(GetLastError()) { oow; aaNote(0,"ss=%s",str); }

  aaMemoryFill(&nid,9,sizeof(nid));
  nid.cbSize=sizeof(nid);
  nid.hWnd=surp->status.hwnd;
  nid.uID=1;
  nid.uFlags=NIF_ICON|NIF_MESSAGE|NIF_TIP;
  nid.uCallbackMessage=WM_SURFACE_SYSTRAY_MSG;
  if(iconresnum) {  nid.hIcon=(HICON)LoadIcon(aa.core_system.this_instance,MAKEINTRESOURCE(iconresnum));  }
  else           {   nid.hIcon=(HICON)LoadIcon(NULL,IDI_APPLICATION);   }
  aaStringLen(str,&sl);
  if(sl>1023) { str[1023]=0; }
  aaStringCopy(nid.szTip,str);
  if(Shell_NotifyIcon(NIM_ADD,&nid)==0) {}//  { oow; return RET_FAILED; }
  surp->status.is_systray=YES;
  //surp->status.is_shown=NO;
  }
 aaSurfaceUpdateAreaAdd(handle,0,NO);
 return RET_YES;
 }






 B aaSurfaceTrayClickClear             (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.is_systray_clicked=NO;
 surp->status.is_systray_right_clicked=NO;
 return RET_YES;
 }



 B aaSurfaceIsTrayClicked              (H handle,_cord*cord,BP isright)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_systray_clicked==NO) { return RET_NO; }
 if(cord) { aaCordCopy(cord,&surp->status.systray_click_cord); }
 if(isright) { *isright=surp->status.is_systray_right_clicked; }
 return RET_YES;
 }





 B aaSurfaceTitleSet                   (H handle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 txt[63]=NULL_CHAR;
 aaStringCopy(surp->status.title,txt);
 if(surp->status.is_visual==YES)
  {
  if(SetWindowText(surp->status.hwnd,surp->status.title)==0) { return RET_FAILED; }
  }
 return RET_YES;
 }





 B aaSurfaceTitleAppendf               (H handle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 va_list argptr;
 B txt[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 txt[63]=NULL_CHAR;
 aaStringAppendf(surp->status.title,txt);
 if(surp->status.is_visual==YES)
  {
  if(SetWindowText(surp->status.hwnd,surp->status.title)==0) { return RET_FAILED; }
  }
 return RET_YES;
 }





 B aaSurfaceIconSetUsingResource       (H handle,H resnum,H index)
 {
 B ret;
 _aa_surfaceobject*surp;
 HRSRC rsca,rscb;
 HRSRC mema,memb;
 BP bufa,bufb;
 _size sz;
 H nid,i,zo,pzo,mode;
 BITMAPINFOHEADER bih;
 B px,ama;
 BP andp;
 W numi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) {  return RET_FAILED; }
 if((surp->status.icon=LoadIcon(aa.core_system.this_instance,MAKEINTRESOURCE(resnum)))==NULL)  { oow; aaNote(0,"line=%i %i",__LINE__,resnum); return RET_FAILED; }
 SetClassLong(surp->status.hwnd,GCL_HICON,(LONG)surp->status.icon);
 aaSizeSet(&surp->status.icon_size,0,0);
 if(index>1000) index=1000;
 surp->status.icon_mem=NULL;
 mode=0;
 while(1)
  {
  if((rsca=FindResource(0,MAKEINTRESOURCE(resnum),RT_GROUP_ICON))==NULL) { break; }
//  if((rsca=LoadImage(0,MAKEINTRESOURCE(resnum),RT_GROUP_ICON,48,48,0))==NULL) { break; }
  if((mema=LoadResource(0,rsca))==NULL) { break; }
  if((bufa=LockResource(mema))==NULL) { break; }
  numi=*(WP)&bufa[4];
  nid=*(WP)&bufa[18];
  if((index+1)>=(H)numi) { nid=numi; if(numi>1) nid=numi-(numi-2); } //index=numi-1;
  else {   nid=numi-index; }
  if((rscb=FindResource(0,MAKEINTRESOURCE(nid),RT_ICON))==NULL) { break; }
  if((memb=LoadResource(0,rscb))==NULL) { break; }
  if((bufb=LockResource(memb))==NULL) { break; }
  zo=0;
  aaMemoryCopy(&bih,sizeof(bih),&bufb[zo]);
  zo+=sizeof(bih);
  pzo=zo;
  bih.biHeight/=2;
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==0&&bih.biBitCount==8)   {   mode=1;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==256&&bih.biBitCount==8)   {   mode=2;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==0&&bih.biBitCount==32)   {   mode=3;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==0&&bih.biBitCount==4)   {   mode=4;   }
  else
  if(bih.biCompression==BI_RGB&&bih.biClrUsed==16&&bih.biBitCount==4)   {   mode=5;   }
  aaSizeSet(&sz,bih.biWidth,bih.biHeight);
  if(mode==0) { break; }
  if(mode==1)   {   zo+=(256*4);   }
  else
  if(mode==2)   {   zo+=(256*4);   }
  else
  if(mode==3)   {   }
  else
  if(mode==4)   {   zo+=(16*4);  }//   aaCast(andp,BP,&bufb[zo+bih.biSizeImage]);
  else
  if(mode==5)   {   zo+=(16*4); }////   aaCast(andp,BP,&bufb[zo+bih.biSizeImage]);
  //aaNote(0,"%i",mode);
//aaNote(0,"%i",mode);
  aaCast(andp,BP,&bufb[zo+bih.biSizeImage]);
  aaSizeCopy(&surp->status.icon_size,&sz);
  //aaLog(-1,"%i/%i mode=%i %i %i",nid,numi,mode,sz.w,sz.h);
  aaMemoryAllocate((VP)&surp->status.icon_mem,sz.w*sz.h*4);//surp->status.icon_bytes);
  aaMemoryNameSet(surp->status.icon_mem,"surficon"); //charlie
  if(mode==1)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
    px=bufb[zo];
    if(bufb[pzo+(px*4)+0]==0&&bufb[pzo+(px*4)+1]==0&&bufb[pzo+(px*4)+2]==0&&bufb[pzo+(px*4)+3]==0) { ama=0; }
    else { ama=255; }
    surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
    surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
    surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
    surp->status.icon_mem[(i<<2)+3]=ama;
    zo+=1;
    }
   }
  else
  if(mode==2)
   {
   //zo-=sz.w;   zo+=1; // added these 2
   for(i=0;i<((sz.w+0)*(sz.h+0));i++) // added+1
    {
    px=bufb[zo];
    //ama=bufb[pzo+(px*4)+3];
    //ama=(B)(aaBitGet(andp[i/8],(i%8)));
    //if(ama&bufb[pzo+(pzo*4)+3]) { ama=0; } else { ama=255; }
    ama=255;
    surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
    surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
    surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
    surp->status.icon_mem[(i<<2)+3]=ama;
    zo+=1;
    }
   }
  else
  if(mode==3)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
    surp->status.icon_mem[(i<<2)+0]=bufb[zo+0];
    surp->status.icon_mem[(i<<2)+1]=bufb[zo+1];
    surp->status.icon_mem[(i<<2)+2]=bufb[zo+2];
    surp->status.icon_mem[(i<<2)+3]=bufb[zo+3];
    zo+=4;
    }
   }
  else
  if(mode==4)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
    ama=(B)(aaBitGet(andp[i/8],(i%8)));
    if(ama) {}
    ama=255;
    if(aaNumIsMod(i,2))
     {
     px=(B)(bufb[zo]/16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     }
    else
     {
     px=(B)(bufb[zo]%16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     zo+=1;
     }
    }
   }
  else
  if(mode==5)
   {
   for(i=0;i<(sz.w*sz.h);i++)
    {
   // ama=(B)(aaBitGet(andp[i/8],(i%8)));
   // ama=bufb[pzo+(px*4)+3];
     ama=255;
    if(aaNumIsMod(i,2))
     {
     px=(B)(bufb[zo]/16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     }
    else
     {
     px=(B)(bufb[zo]%16);
     surp->status.icon_mem[(i<<2)+0]=bufb[pzo+(px*4)+0];
     surp->status.icon_mem[(i<<2)+1]=bufb[pzo+(px*4)+1];
     surp->status.icon_mem[(i<<2)+2]=bufb[pzo+(px*4)+2];
     surp->status.icon_mem[(i<<2)+3]=ama;
     zo+=1;
     }
    }
   }
  break;
  }
 if(mode==0||surp->status.icon_mem==NULL)
  {
  aaNote(0,"line=%i mode=%i  %i x %i  %i,%i,%i",__LINE__,mode,sz.w,sz.h,bih.biCompression,bih.biClrUsed,bih.biBitCount);
  return RET_FAILED;
  }
 surp->status.icon_resnum=resnum;
 surp->status.icon_index=index;
 return RET_YES;
 }









 B aaSurfaceFocus                      (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 H time_out;
 HWND fg_hwnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FORBIDDEN; }
 if(surp->status.is_shown==NO) { return RET_FAILED; }
 SystemParametersInfo(0x2000,0,&time_out,0);
 SystemParametersInfo(0x2001,0,(VP)0,0);
 fg_hwnd=GetForegroundWindow();
 AttachThreadInput(GetWindowThreadProcessId(fg_hwnd,NULL),GetCurrentThreadId(),TRUE);
 SetForegroundWindow(surp->status.hwnd);
 SetActiveWindow(surp->status.hwnd);
 BringWindowToTop(surp->status.hwnd);
 SetFocus(surp->status.hwnd);
 //BUG,"ss %i", SetFocus(surp->status.hwnd));
 AttachThreadInput(GetWindowThreadProcessId(fg_hwnd,NULL),GetCurrentThreadId(),FALSE);
 SystemParametersInfo(0x2001,0,(VP)time_out,0);
// BUG,"foc %i ",handle);
// BUG,"SurfaceFocus (%s)",surp->status.title);
 return RET_YES;
 }







 B aaSurfaceMinimize                   (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FORBIDDEN; }
 if(surp->status.is_shown==NO) { return RET_FAILED; }
 surp->status.is_minimized=YES;
 ShowWindow(surp->status.hwnd,SW_MINIMIZE);
 return RET_YES;
 }




 B aaSurfaceRestore                    (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) {  return RET_FORBIDDEN; }
 if(surp->status.is_shown==NO) {  return RET_FAILED; }
 if(surp->status.is_minimized==YES)
  {
  surp->status.is_minimized=NO;
  ShowWindow(surp->status.hwnd,SW_RESTORE);
  }
 else
  {
  return(aaSurfaceMinimize(handle));
  }
 return RET_YES;
 }







 B aaSurfaceCordSet                    (H handle,_cord*cord)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 aaRectCopy(&r1,&surp->status.rect);
 aaRectCordSet(&r1,cord->x,cord->y);
 return(aaSurfaceRectSet(handle,&r1));
 }





 B aaSurfaceSizeSet                    (H handle,_size*size)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) {  return ret; }
 if(size==NULL) {  return RET_BADPARM; }
 if(size->w==0) { return RET_BADPARM; }
 if(size->h==0) {  return RET_BADPARM; }

 if((size->w*size->h)>surp->status.real_pixel_count) { return RET_BOUNDS; }
 aaRectCopy(&r1,&surp->status.rect);
 aaRectSizeSet(&r1,size->w,size->h);
 ret=aaSurfaceRectSet(handle,&r1);
 if(ret!=RET_YES) {  return ret; }
 aaSizeSet(&surp->status.size,surp->status.rect.w,surp->status.rect.h);
// surp->status.pixel_count=surp->status.size.w*surp->status.size.h;//
 //surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 return RET_YES;
 }









 B aaSurfaceRectSet                    (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*psurp;
 B cord_changed;
 B size_changed;
 RECT rr;
// _rect rc;
 W flags;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaRectIsValid(rect)!=RET_YES) { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((rect->w*rect->h)>surp->status.real_pixel_count) { oof; return RET_BOUNDS; }
 if(surp->status.is_moveable==YES) { aaSurfaceMoveableSet(handle,YES); }
 if(surp->status.is_sizeable==YES) {aaSurfaceSizeableSet(handle,YES); }
 if(surp->status.is_visual==NO)
  {
  aaRectCopy(&surp->status.rect,rect);
  aaSizeSet(&surp->status.size,rect->w,rect->h);
  aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
  return RET_YES;
  }
 cord_changed=NO;
 size_changed=NO;
 if(rect->x!=surp->status.rect.x||rect->y!=surp->status.rect.y)  {  cord_changed=YES;  }
 if(rect->w!=surp->status.rect.w||rect->h!=surp->status.rect.h)  {  size_changed=YES;  }
 psurp=NULL;
 if(surp->status.parent_handle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surp->status.parent_handle,(VP)&psurp,NULL))!=RET_YES) { oops; }
  SendMessage(psurp->status.hwnd,WM_SETREDRAW,FALSE,0);
  //LockWindowUpdate(psurp->status.hwnd);
  }
 else
  {
  SendMessage(surp->status.hwnd,WM_SETREDRAW,FALSE,0);
  }
 //SendMessage(surp->status.hwnd, WM_SETREDRAW, FALSE, 0);
 WinRectSet(&rr,rect->x,rect->y,rect->w,rect->h);
 flags=SWP_NOACTIVATE;
 if(cord_changed==NO) { flags|=SWP_NOMOVE; }
 if(size_changed==NO) { flags|=SWP_NOSIZE; }

 flags|=SWP_NOOWNERZORDER;
 flags|=SWP_NOZORDER;
 flags|=SWP_NOSENDCHANGING;
 flags|=SWP_NOCOPYBITS;
 flags|=SWP_DEFERERASE;
 if(SetWindowPos(surp->status.hwnd,0,rr.left,rr.top,rr.right-rr.left,rr.bottom-rr.top,flags)==FALSE)  {  return RET_FAILED;  }
 aaRectCopy(&surp->status.rect,rect);
 aaSizeSet(&surp->status.size,rect->w,rect->h);
 aaRectToCornerCords(&surp->status.rect,&surp->status.corner[0],&surp->status.corner[1],&surp->status.corner[2],&surp->status.corner[3]);
 surp->status.pixel_count=surp->status.size.w*surp->status.size.h;//
 surp->status.real_pixel_count=surp->status.initial_size.w*surp->status.initial_size.h;
 if(size_changed) { surp->status.resize_counter++; }
 //if(psurp!=NULL)  { LockWindowUpdate(0);  }
 //else             { SendMessage(surp->status.hwnd, WM_SETREDRAW, TRUE, 0);  }

 // jul:2015 commented these 2 out charlie
// if(psurp!=NULL)  { SendMessage(psurp->status.hwnd,WM_SETREDRAW,TRUE,0);  }
 //else             { SendMessage(surp->status.hwnd,WM_SETREDRAW,TRUE,0);  }


 //SendMessage(surp->status.hwnd, WM_SETREDRAW, TRUE, 0) ;
 //RedrawWindow(surp->status.hwnd,0,0,RDW_UPDATENOW);
 return RET_YES;
 }




 B aaSurfaceCordGet                    (H handle,_cord*cord)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 return(aaCordSet(cord,surp->status.rect.x,surp->status.rect.y));
 }




 B aaSurfaceViewportSet                (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;
 H flags;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) {  return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectSet(&rr,rect->x,rect->y,rect->w,rect->h); }
 aaRectSet(&surp->status.viewport_rect,rr.x,rr.y,rr.w,rr.h);
 if(surp->status.hwnd==0) { oof; }
    flags=0;
    //flags|=SWP_SHOWWINDOW;
    flags|=SWP_FRAMECHANGED;
    flags|=SWP_NOACTIVATE;
    flags|=SWP_NOZORDER;
    flags|=SWP_NOMOVE;
    flags|=SWP_NOOWNERZORDER;
    flags|=SWP_NOSENDCHANGING;
    flags|=SWP_NOCOPYBITS;
    flags|=SWP_DEFERERASE;
   // flags|=SWP_NOREDRAW;
    if(SetWindowPos(surp->status.hwnd,0,0,0,surp->status.viewport_rect.w,surp->status.viewport_rect.h,flags)==FALSE)  { oow; }
    //RedrawWindow(surp->status.hwnd,0,0,RDW_INVALIDATE|RDW_UPDATENOW|RDW_ERASENOW);
    ///UpdateWindow(surp->status.hwnd);
 return RET_YES;
 }




 B aaSurfaceSizeGet                    (H handle,_size*size)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) {  return ret; }
 return(aaSizeCopy(size,&surp->status.size));
 }





 B aaSurfaceRectGet                    (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 return(aaRectCopy(rect,&surp->status.rect));
 }





 B aaSurfaceCordAdjust                 (H handle,N xamnt,N yamnt)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaCordCopy(&c1,&surp->status.corner[0]);
 aaCordAdjust(&c1,xamnt,yamnt);
 return(aaSurfaceCordSet(handle,&c1));
 }





 B aaSurfaceCenter                     (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size s2;
 _rect r1,r2;
 _displayinfo dsi;
 _cord c1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
// if(surp->status.is_visual==NO) { return RET_FAILED; }
 aaSizeSet(&s2,surp->status.rect.w,surp->status.rect.h);
 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=RET_YES) { return ret; }
  aaRectCopy(&r2,rect);

  aaRectSet(&r1,r2.x+((r2.w/2)-(s2.w/2)),r2.y+((r2.h/2)-(s2.h/2)),s2.w,s2.h);
  aaCordSet(&c1,r1.x,r1.y);
  if((ret=aaSurfaceCordSet(handle,&c1))!=RET_YES) { oops; return ret; }
  //aaRectAdjust(&r1,r2.x,r2.y,0,0);
//  aaNote(0,">%i %i %i %i",r1.x,r1.y,r1.w,r1.h);
//  aaRectSet(&r1,rect->x+((rect->w/2)-(s2.w/2)),rect->y+((rect->h/2)-(s2.h/2)),s2.w,s2.h);
  }
 else
  {
  if((ret=aaDisplayInfoGet(&dsi))!=YES) { oops; } // why do we get the display info again, if we already did it during startup ?
//  aaNote(0,"%i ",dsi.monitor_count);
  //aaDisplayInfoGet(&dsi,YES);
  //aaNote(0,"%i",dsi.monitor_primary_index_current);
  aaRectCopy(&r2,&dsi.monitor_rect[dsi.monitor_primary_index]);
  //aaNote(0,"%i %i %i %i %i",r2.x,r2.w,r2.h,s2.w,s2.h);
 //aaNote(0,"%i %i %i",r2.x,r2.w,dsi.monitor_primary_index);
  aaRectSet(&r1,(r2.w/2)-(s2.w/2),(r2.h/2)-(s2.h/2),s2.w,s2.h);
  aaRectAdjust(&r1,r2.x,r2.y,0,0);
  //aaNote(0,"%i %i %i",r1.x,r1.w,r1.h);
  if((ret=aaSurfaceRectSet(handle,&r1))!=RET_YES) { oops; return ret; }
  }
 //aaNote(0,"%i %i %i %i",r1.x,r1.y,r1.w,r1.h);
 return RET_YES;
 }




 B aaSurfaceRectAlign                  (H handle,_rect*rect,B ha,B va)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size s2;
 _rect r1,r2;
 _displayinfo dsi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaSizeSet(&s2,surp->status.rect.w,surp->status.rect.h);

 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=RET_YES) { return ret; }
  aaRectCopy(&r2,rect);
  r1.w=s2.w;
  r1.h=s2.h;
  r1.x=surp->status.rect.x;
  r1.y=surp->status.rect.y;
  switch(ha)
   {
   case aa_ALIGN_LEFT:     r1.x=r2.x;                      break;
   case aa_ALIGN_MIDDLE:   r1.x=r2.x+((r2.w/2)-(s2.w/2));   break;
   case aa_ALIGN_RIGHT:    r1.x=r2.x+(r2.w-r1.w);          break;
   }
  switch(va)
   {
   case aa_ALIGN_TOP:     r1.y=r2.y;                   break;
   case aa_ALIGN_MIDDLE:  r1.y=r2.y+((r2.h/2)-(s2.h/2));   break;
   case aa_ALIGN_BOTTOM:  r1.y=r2.y+(r2.h-r1.h);           break;
   }
  }
 else
  {
  if((ret=aaDisplayInfoGet(&dsi))!=YES) { oops; } // why do we get the display info again, if we already did it during startup ?
  aaRectCopy(&r2,&dsi.monitor_rect[dsi.monitor_primary_index]);
  r1.w=s2.w;
  r1.h=s2.h;
  r1.x=surp->status.rect.x;
  r1.y=surp->status.rect.y;
  switch(ha)
   {
   case aa_ALIGN_LEFT:     r1.x=r2.x;                      break;
   case aa_ALIGN_MIDDLE:   r1.x=r2.x+((r2.w/2)-(s2.w/2));   break;
   case aa_ALIGN_RIGHT:    r1.x=r2.x+(r2.w-r1.w);          break;
   }
  switch(va)
   {
   case aa_ALIGN_TOP:     r1.y=r2.y;                   break;
   case aa_ALIGN_MIDDLE:  r1.y=r2.y+((r2.h/2)-(s2.h/2));   break;
   case aa_ALIGN_BOTTOM:  r1.y=r2.y+(r2.h-r1.h);           break;
   }
  }
 if((ret=aaSurfaceRectSet(handle,&r1))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }






 B aaSurfaceMonitorAlign               (H handle,B mid,B ha,B va)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size s2;
 _rect r1,r2;
 _displayinfo dsi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaSizeSet(&s2,surp->status.rect.w,surp->status.rect.h);
 if((ret=aaDisplayInfoGet(&dsi))!=YES) { oops; } // why do we get the display info again, if we already did it during startup ?
 if(mid>=dsi.monitor_count) { return RET_BOUNDS; }
 aaRectCopy(&r2,&dsi.monitor_rect[mid]);
 r1.w=s2.w;
 r1.h=s2.h;
 r1.x=r2.x;
 r1.y=r2.y;
 switch(ha)
  {
  case aa_ALIGN_LEFT:     r1.x=r2.x;                      break;
  case aa_ALIGN_MIDDLE:   r1.x=r2.x+((r2.w/2)-(s2.w/2));  break;
  case aa_ALIGN_RIGHT:    r1.x=r2.x+(r2.w-r1.w);          break;
  }
 switch(va)
  {
  case aa_ALIGN_TOP:     r1.y=r2.y;                   break;
  case aa_ALIGN_MIDDLE:  r1.y=r2.y+((r2.h/2)-(s2.h/2));  break;
  case aa_ALIGN_BOTTOM:  r1.y=r2.y+(r2.h-r1.h);           break;
  }
 if((ret=aaSurfaceRectSet(handle,&r1))!=RET_YES) { oops; return ret; }
 return RET_YES;
 }











 B aaSurfaceOnTop                      (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }
 if(state==YES)
  {
  if(surp->status.is_top==YES) { return RET_YES; }
  if(SetWindowPos(surp->status.hwnd,HWND_TOPMOST,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE)==0) { return RET_FAILED;  }
  surp->status.is_top=YES;
  }
 else
  {
  if(surp->status.is_top==NO) { return RET_YES; }
  if(SetWindowPos(surp->status.hwnd,HWND_NOTOPMOST,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE)==0) { return RET_FAILED; }
  surp->status.is_top=NO;
  }
 return RET_YES;
 }







 B aaSurfaceCordToVisualCord           (H handle,_cord*cord,_cord*vcord)
 {
 B ret;
 _aa_surfaceobject*surp;
 POINT pt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 if(vcord==NULL) { return RET_BADPARM; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }
 WinPointSet(&pt,cord->x,cord->y);
 if(ClientToScreen(surp->status.hwnd,&pt)==0) { oow; }
 WinPointToCord(&pt,vcord);
 return RET_YES;
 }






 B aaSurfaceVisualCordToCord           (H handle,_cord*vcord,_cord*cord)
 {
 B ret;
 _aa_surfaceobject*surp;
 POINT pt;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 if(vcord==NULL) { return RET_BADPARM; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }
 WinPointSet(&pt,vcord->x,vcord->y);
 ScreenToClient(surp->status.hwnd,&pt);
 WinPointToCord(&pt,cord);
 return RET_YES;
 }




 B aaSurfaceCaretReset                 (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
// if(surp->status.is_visual==NO) { return RET_FAILED; }
 surp->status.caret_counter=0;
 aaTimerInit(&surp->caret_timer,1);
 return RET_YES;
 }




 B aaSurfaceCaretShow                  (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual==NO) { return RET_FAILED; }
 if(state==YES)
  {
  surp->status.is_caret_shown=YES;
  }
 else
  {
  surp->status.is_caret_shown=NO;
  }
 aaTimerInit(&surp->caret_timer,1);
 return RET_YES;
 }




 B aaSurfaceCaretRectSet               (H handle,_rect*rect)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) {  return RET_BADPARM; }
 if(aaRectIsValid(rect)==NO) {  return RET_BADPARM; }
 if(aaRectEqualsRect(&surp->status.caret_rect,rect)!=RET_YES)
  {
  aaTimerInit(&surp->caret_timer,1);
  surp->status.caret_counter=0;
  }
 aaRectCopy(&surp->status.caret_rect,rect);
 surp->status.is_caret_shown=YES;
 return RET_YES;
 }






 B aaSurfaceCaretGet                   (H handle,BP isshown,_rect*rect,HP counter)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(aaTimerPulse(&surp->caret_timer,surp->status.caret_speed)==RET_YES)
  {
  surp->status.caret_counter++;
  }
 if(isshown) { *isshown=surp->status.is_caret_shown; }
 if(rect)    { aaRectCopy(rect,&surp->status.caret_rect); }
 if(counter) { *counter=surp->status.caret_counter; }
 return RET_YES;
 }



 B aaSurfaceCaretSpeedSet              (H handle,H speed)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 surp->status.caret_speed=speed;
 //aaDebugf("cs=%i=%i",__LINE__,surp->status.caret_speed);
 return RET_YES;
 }





 B aaSurfaceBlit                       (H handle,_rect*rect,H dhandle,_rect*drect,B flip)
 {
 B ret;
 _aa_surfaceobject*srce_surp;
 _rect srce_rect;
 _rect dest_rect;
 BITMAPINFO bmi;
 H off;
 //N bottom_up_src_y;
 N sx,sy,sw,sh;
 N dx,dy,dw,dh;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&srce_surp,NULL))!=RET_YES) { return ret; }


 if(dhandle==0) // blit surface to screen
  {
  if(srce_surp->status.is_visual==NO) { return RET_FAILED; }

  if(rect==NULL) { aaRectSet(&srce_rect,0,0,srce_surp->status.viewport_rect.w,srce_surp->status.viewport_rect.h); }
  else              { aaRectCopy(&srce_rect,rect);  }

  if(drect==NULL) { aaRectCopy(&dest_rect,&srce_rect); }
  else              { aaRectCopy(&dest_rect,drect); }

  if(flip) {  WinBmpInfoSet(&bmi,srce_surp->status.size.w,srce_surp->status.size.h,32,NO); }
  else     {  WinBmpInfoSet(&bmi,srce_surp->status.size.w,srce_surp->status.size.h,32,YES); }


  //bottom_up_src_y=bmi.bmiHeader.biHeight-srce_rect.y-srce_rect.h;
  off=0;
  off+=srce_surp->status.viewport_rect.x;

  if(srce_surp->status.viewport_rect.y==0)//&&bottom_up_src_y==0)//&&(N)srce_rect.h!=bmi.bmiHeader.biHeight)
   {
   sx=(N)srce_rect.x;   sy=(N)srce_rect.y;
   sw=(N)srce_rect.w;   sh=(N)srce_rect.h;
   dx=(N)dest_rect.x;   dy=(N)dest_rect.y;
   dw=(N)dest_rect.w;   dh=(N)dest_rect.h;


   if(StretchDIBits(srce_surp->status.dc,
      dx,dh+dy-1,
      dw,-dh,
      sx,srce_surp->status.size.h-sy+1 ,
      sw,-sh,
      &srce_surp->status.mem[off],
      (BITMAPINFO*)&bmi,DIB_RGB_COLORS,SRCCOPY)==(Z)GDI_ERROR) { oow; }


   }
  else
   {
   oof;
   //aaDebugf("secc %-5i %s ",__LINE__,__FUNCTION__);
   if(StretchDIBits(srce_surp->status.dc,
    (N)dest_rect.x,(N)dest_rect.h+(N)dest_rect.y-1,(N)dest_rect.w,-(N)dest_rect.h,
    (N)srce_rect.x,(N)srce_surp->status.size.h-(N)srce_surp->status.viewport_rect.y,(N)srce_rect.w,-(N)srce_rect.h,
    &srce_surp->status.mem[off],(BITMAPINFO*)&bmi,DIB_RGB_COLORS,SRCCOPY)==(Z)GDI_ERROR) oow;
    }
   }
 else
  {
  oof;
  }
 return RET_YES;
 }






 B aaSurfaceImageDrawUsingSurface      (H handle,_rect*imagerect,H dhandle,_rect*drect,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_surfaceobject*dsurp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,dhandle,(VP)&dsurp,NULL))!=RET_YES) { return ret; }
 return(aaSurfaceImageDraw(handle,&dsurp->status.size,imagerect,dsurp->status.mem,drect,hflip,vflip,xalpha));
 }






 B aaSurfaceImageDraw                  (H handle,_size*imgsize,_rect*imgrect,VP img,_rect*drect,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1,r2;
 _aaDiv xdiv,ydiv;
 H y_off;//,soff,doff;
 register N x,y;
 register N z,dx,dy;
 N dx_tmp,dx_inc,dy_inc;
 _rgba*pn;
 _rgba*dpn;
 B ov;
 H WWW,HHH;
 H pre_stepx[4000];
 H pre_stepy[4000];
 H fulls,mods;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(img==NULL) { return RET_BADPARM; }
 if((ret=aaSizeIsValid(imgsize))!=RET_YES) { return ret; }
 if(imgrect==NULL) { aaRectSet(&r1,0,0,imgsize->w,imgsize->h); }
 else              { aaRectCopy(&r1,imgrect);                  }
 if((ret=aaRectIsValid(&r1))!=RET_YES) { return ret; }
 if(drect==NULL) { aaRectSet(&r2,0,0,imgsize->w,imgsize->h); }
 else            { aaRectCopy(&r2,drect);                    }
 if((ret=aaRectIsValid(&r2))!=RET_YES) { return ret; }

 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 UNUSE(pstylep);


 WWW=surp->status.size.w;
 HHH=surp->status.size.h;

 #if 1
 if(r2.w<r1.w&&r1.w%2!=0) {  r1.w+=1; } // i added this as scaling down
 if(r2.h<r1.h&&r1.h%2!=0) {  r1.h+=1; } // sometimes loses pixels on odd sizes
 #endif

 aaNumDivInit(xdiv,r1.w,r2.w);
 aaNumDivInit(ydiv,r1.h,r2.h);
 aaNumDivReset(ydiv,r1.y);
 if(vflip==YES) { dy=(r2.y+r2.h)-1; dy_inc=-1; }
 else             { dy=r2.y; dy_inc=+1; }
 if(hflip==YES) { dx=(r2.x+r2.w)-1; dx_inc=-1; }
 else             { dx=r2.x; dx_inc=+1; }
 dx_tmp=dx;
 if(r1.w==r2.w&&r1.h==r2.h&&xalpha==255)  {   goto noscale;  }
 if  (xalpha==0)
  {
  for(y=0;y<(N)r2.h;y++)  // ningy added (N)
   {
   aaNumDivReset(xdiv,r1.x);
   y_off=(ydiv.result*imgsize->w);
   aaCast(pn,_rgba*,img);
   pn+=y_off;
   dx=dx_tmp;
   for(x=0;x<(N)r2.w;x++) // ningy added (N)
    {
    surp->PixelPut(surp,dx,dy,&pn[xdiv.result]);
    aaNumDivStepInc(xdiv);
    dx+=dx_inc;
    }
   aaNumDivStepInc(ydiv);   dy+=dy_inc;
   }
  }
 else // force all alpha to solid
  if(xalpha==255) ////!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ULTRA
   {
   if(r2.w>=aaElementCount(pre_stepx)) { aaNote(0,"prestepx fail, w=%i",r2.w); }
   if(r2.h>=aaElementCount(pre_stepy)) { aaNote(0,"prestepy fail, h=%i",r2.h); }
   aaNumDivReset(xdiv,r1.x);
   for(x=0;x<(N)r2.w;x++) {  pre_stepx[x]=xdiv.result;             aaNumDivStepInc(xdiv);   } // ningy added (N)
   aaNumDivReset(ydiv,r1.y);
   for(y=0;y<(N)r2.h;y++) {  pre_stepy[y]=ydiv.result*imgsize->w;  aaNumDivStepInc(ydiv);   } // ningy added (N)
   fulls=r2.w/16;
   mods=r2.w%16;
   for(y=0;y<(N)r2.h;y++)  // ningy added (N)
    {
    aaCast(pn,_rgba*,img);
    pn+=pre_stepy[y];
    dx=dx_tmp;
    aaCast(dpn,_rgba*,&surp->status.mem[(dy*WWW)]);
    if(dy<(N)HHH) // ningy added (N)
     {
     z=0;
     for(x=0;x<(N)fulls;x++)   // ningy added (N) // unroll loop
      {
      dpn[dx]=pn[pre_stepx[z+ 0]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 1]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 2]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 3]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 4]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 5]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 6]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 7]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+ 8]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+ 9]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+10]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+11]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+12]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+13]];   dx+=dx_inc;
      dpn[dx]=pn[pre_stepx[z+14]];   dx+=dx_inc;      dpn[dx]=pn[pre_stepx[z+15]];   dx+=dx_inc;
      z+=16;
      }

     z=fulls*16;
     for(x=0;x<(N)mods;x++)  // ningy added (N)
      {
      dpn[dx]=pn[pre_stepx[z]];
      dx+=dx_inc;
      z++;
      }
     }

    dy+=dy_inc;
    }
   }
 else
  { // set all alphas to xalpha value
  for(y=0;y<(N)r2.h;y++)  // ningy added (N)
   {
   aaNumDivReset(xdiv,r1.x);
   y_off=(ydiv.result*imgsize->w);
   aaCast(pn,_rgba*,img);
   pn+=y_off;
   dx=dx_tmp;
   for(x=0;x<(N)r2.w;x++)  // ningy added (N)
    {
    if(pn[xdiv.result].a!=0)
     {
     ov=pn[xdiv.result].a;
     pn[xdiv.result].a=xalpha;
//     aa_DIAG("aaSurfaceImageDraw>>PixelPut xa=255");
     surp->PixelPut(surp,dx,dy,&pn[xdiv.result]);
     pn[xdiv.result].a=ov;
     }
    aaNumDivStepInc(xdiv);
    dx+=dx_inc;
    }
   aaNumDivStepInc(ydiv);   dy+=dy_inc;
   }
  }
 return RET_YES;

noscale:

  y_off=r1.y;
   fulls=r2.w/16;
   mods=r2.w%16;

//   aaNote(0,"dx=%i dy=%i sx_inc=%i dy_inc=%i\nWWW=%i HHH=%i\nr1.x=%i r1.y=%i r1.w=%i r1.h=%i\n r2.x=%u r2.y=%i r2.w=%i r2.h=%i\nimg=%p surp=%p\ny_off=%i fulls=%i mods=%i",dx,dy,dx_inc,dy_inc,WWW,HHH,r1.x,r1.y,r1.w,r1.h,r2.x,r2.y,r2.w,r2.h,img,surp->status.mem,y_off,fulls,mods);

   for(y=0;y<(N)r2.h;y++)  // ningy added (N)
    {
    aaCast(pn,_rgba*,img);
    pn+=(y_off*imgsize->w)+r1.x;
    //pn+=( (((r1.y+r1.h)-1)-y_off)*imgsize->w)+r1.x;
    aaCast(dpn,_rgba*,surp->status.mem);
    dpn+=(dy*WWW);
    //dpn+=( (((r2.y+r2.h)-1)-dy)*WWW);
    dx=dx_tmp;
    if(dy<(N)HHH) // ningy added (N)
     {
     z=0;
     for(x=0;x<(N)fulls;x++)   // ningy added (N)// unroll loop
      {
      dpn[dx]=pn[z+ 0];  dx+=dx_inc;      dpn[dx]=pn[z+ 1];  dx+=dx_inc;
      dpn[dx]=pn[z+ 2];  dx+=dx_inc;      dpn[dx]=pn[z+ 3];  dx+=dx_inc;
      dpn[dx]=pn[z+ 4];  dx+=dx_inc;      dpn[dx]=pn[z+ 5];  dx+=dx_inc;
      dpn[dx]=pn[z+ 6];  dx+=dx_inc;      dpn[dx]=pn[z+ 7];  dx+=dx_inc;
      dpn[dx]=pn[z+ 8];  dx+=dx_inc;      dpn[dx]=pn[z+ 9];  dx+=dx_inc;
      dpn[dx]=pn[z+10];  dx+=dx_inc;      dpn[dx]=pn[z+11];  dx+=dx_inc;
      dpn[dx]=pn[z+12];  dx+=dx_inc;      dpn[dx]=pn[z+13];  dx+=dx_inc;
      dpn[dx]=pn[z+14];  dx+=dx_inc;      dpn[dx]=pn[z+15];  dx+=dx_inc;
      z+=16;
      }
     z=fulls*16;
     for(x=0;x<(N)mods;x++)  {  dpn[dx]=pn[z];   dx+=dx_inc;      z++;      }
     }
    y_off++;
    dy+=dy_inc;
    }
 return RET_YES;
 }




 B aaSurfaceImageGrab                  (H handle,_rect*rect,_cord*imgcord,_size*imgsize,VP img)
 {
 B ret;
 _aa_surfaceobject*surp;
 //_surfacestatus ss;
 H x,y;
 _rgba*simg;
 _rgba*dimg;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 //if((ret=aaSurfaceStatus(handle,&ss))!=YES) { return ret; }
 //if(bigsprite_init==0) { aaMemoryFill(bigsprite,sizeof(bigsprite),0); bigsprite_init=1; }
 for(y=0;y<rect->h;y++)
  {
  simg=&surp->status.mem[((rect->y+y)*surp->status.size.w)+rect->x];
  dimg=(_rgba*)img;
  dimg+=((imgcord->y+y)*imgsize->w);
  dimg+=(imgcord->x);
  for(x=0;x<rect->w;x++) {   *dimg=*simg;   dimg++;   simg++;   }
  }
 return RET_YES;
 }




 B aaSurfaceImageTile                  (H handle,_size*imgsize,_rect*imgrect,VP img,_rect*drect,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1,r2;
 N xc,yc,xm,ym,y,x=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 xc=drect->w/imgrect->w;
 yc=drect->h/imgrect->h;
 xm=drect->w%imgrect->w;
 ym=drect->h%imgrect->h;
 for(y=0;y<yc;y++)
  {
  for(x=0;x<xc;x++)
   {
   aaRectSet(&r1,imgrect->x,imgrect->y,imgrect->w,imgrect->h);
   aaRectSet(&r2,0,0,imgrect->w,imgrect->h);
   aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
   aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
   }
  }
 if(xm)
  {
  for(y=0;y<yc;y++)
   {
   aaRectSet(&r1,imgrect->x,imgrect->y,xm,imgrect->h);
   aaRectSet(&r2,0,0,xm,imgrect->h);
   aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
   aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
   }
  }
 if(ym)
  {
  for(x=0;x<xc;x++)
   {
   aaRectSet(&r1,imgrect->x,imgrect->y,imgrect->w,ym);
   aaRectSet(&r2,0,0,imgrect->w,ym);
   aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
   aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
//   aaSurfaceUpdateAreaAdd(handle,&r2);
   oof;
   }
  }
 if(xm&&ym)
  {
  aaRectSet(&r1,imgrect->x,imgrect->y,xm,ym);
  aaRectSet(&r2,0,0,xm,ym);
  aaRectAdjust(&r2,drect->x+(x*imgrect->w),drect->y+(y*imgrect->h),0,0);
  aaSurfaceImageDraw(handle,imgsize,&r1,img,&r2,hflip,vflip,xalpha);
  }
 return RET_YES;
 }








 V aa_SurfaceWarpProc                  (_aa_surfaceobject*surp,_rgba*dst,_size*dsize,_size*ssize,POINT ul,POINT ur,POINT lr,POINT ll,_rgba*src,N x1,N y1,N x2,N y2,B xalpha)
 {
 POINT tm,lm,rm,bm,m;
 LONG mx,my;
 _rgba temp_rgba;
 H soff;//,doff;///,sca,dca;
 _cord cd;


 if((aaNumAbs(ul.x-ur.x)<aa_WARP_THRESH)&&(aaNumAbs(ul.x-lr.x)<aa_WARP_THRESH)&&(aaNumAbs(ul.x-ll.x)<aa_WARP_THRESH)&&(aaNumAbs(ul.y-ur.y)<aa_WARP_THRESH)&&(aaNumAbs(ul.y-lr.y)<aa_WARP_THRESH)&&(aaNumAbs(ul.y-ll.y)<aa_WARP_THRESH))
  {
  //doff=( (ul.y>>aa_WARP_SHIFTS)*dsize->w)+(ul.x>>aa_WARP_SHIFTS);
  soff=((y1>>aa_WARP_SHIFTS)*ssize->w)+(x1>>aa_WARP_SHIFTS);
  /*
  if(xalpha==0)
   {
   dst[doff]=src[soff];
   }
  else
  if(xalpha==255)
   {
   dst[doff]=src[soff];
   dst[doff].a=255;
   }
  else
  */
   {
   cd.x=(ul.x>>aa_WARP_SHIFTS);
   cd.y=(ul.y>>aa_WARP_SHIFTS);
   temp_rgba=src[soff];
   temp_rgba.a=xalpha;
   surp->PixelPut(surp,cd.x,cd.y,&temp_rgba);
   }
  }
 else
  {
  tm.x=(ul.x+ur.x)>>1; tm.y=(ul.y+ur.y)>>1;
  bm.x=(ll.x+lr.x)>>1; bm.y=(ll.y+lr.y)>>1;
  lm.x=(ul.x+ll.x)>>1; lm.y=(ul.y+ll.y)>>1;
  rm.x=(ur.x+lr.x)>>1; rm.y=(ur.y+lr.y)>>1;
   m.x=(tm.x+bm.x)>>1;  m.y=(tm.y+bm.y)>>1;
    mx=(x1+x2)>>1;       my=(y1+y2)>>1;
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,ul,tm,m,lm,src,x1,y1,mx,my,xalpha);
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,tm,ur,rm,m,src,mx,y1,x2,my,xalpha);
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,m,rm,lr,bm,src,mx,my,x2,y2,xalpha);
  aa_SurfaceWarpProc(surp,dst,dsize,ssize,lm,m,bm,ll,src,x1,my,mx,y2,xalpha);
  }
 }




 B aaSurfaceImageWarp                  (H handle,_size*imgsize,_rect*imgrect,VP img,_cord*c1,_cord*c2,_cord*c3,_cord*c4,B hflip,B vflip,B xalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 POINT ul,ur,lr,ll;
 N x1,y1,x2,y2;
 _size ds,ss;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 ul.x=c1->x; ul.y=c1->y;
 ur.x=c2->x; ur.y=c2->y;
 lr.x=c3->x; lr.y=c3->y;
 ll.x=c4->x; ll.y=c4->y;
 x1=imgrect->x; y1=imgrect->y;
 x2=imgrect->w; y2=imgrect->h; // not h-1 w-1 for some reason
 x1<<=aa_WARP_SHIFTS; y1<<=aa_WARP_SHIFTS;
 x2<<=aa_WARP_SHIFTS; y2<<=aa_WARP_SHIFTS;
 ul.x<<=aa_WARP_SHIFTS; ul.y<<=aa_WARP_SHIFTS;
 ur.x<<=aa_WARP_SHIFTS; ur.y<<=aa_WARP_SHIFTS;
 lr.x<<=aa_WARP_SHIFTS; lr.y<<=aa_WARP_SHIFTS;
 ll.x<<=aa_WARP_SHIFTS; ll.y<<=aa_WARP_SHIFTS;
 aaSizeSet(&ds,surp->status.size.w,surp->status.size.h);
 aaSizeSet(&ss,imgsize->w,imgsize->h);
 if(hflip!=YES&&vflip!=YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x1,y1,x2,y2,xalpha); }
 else
 if(hflip!=YES&&vflip==YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x1,y2,x2,y1,xalpha); }
 else
 if(hflip==YES&&vflip!=YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x2,y1,x1,y2,xalpha); }
 else
 if(hflip==YES&&vflip==YES) { aa_SurfaceWarpProc(surp,surp->status.mem,&ds,&ss,ul,ur,lr,ll,img,x2,y2,x1,y1,xalpha); }
 return RET_YES;
 }






 B aaSurfaceImageRgbaReplace           (H handle,_rect*rect,_rgba*p1,_rgba*p2,B logic,B checkalpha)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect mr;
 N x,y;
 _rgba vp1,vp2;
 _cord cd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&mr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&mr,rect); }
 if(aaRectIsValid(&mr)!=RET_YES) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p2==NULL) { aaRgbaSet(&vp2,0,0,0,0); }
 else         { aaRgbaCopy(&vp2,p2); }

 for(y=0;y<(N)mr.h;y++)   // ningy added (N)
  {
  for(x=0;x<(N)mr.w;x++)  // ningy added (N)
   {
   cd.x=mr.x+x;
   cd.y=mr.y+y;
   surp->PixelGet(surp,cd.x,cd.y,&vp1);
   if(logic==YES)
    {
    if(vp1.r==p1->r&&vp1.g==p1->g&&vp1.b==p1->b)///&&(vp1.a==p1->a)
     {
     if((checkalpha==YES&&vp1.a==p1->a)||(checkalpha!=YES))
      {
      surp->PixelSet(surp,cd.x,cd.y,&vp2);
      }
     }
    }
   else
    {
    if(vp1.r!=p1->r||vp1.g!=p1->g||vp1.b!=p1->b)//||vp1.a!=p1->a)
     {
     surp->PixelSet(surp,cd.x,cd.y,&vp2);
     }
    }
   }
  }
 return RET_YES;
 }




 B aaSurfacePixelStyleSet              (H handle,_pixelstyle*pixelstyle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(pixelstyle==NULL) { return RET_BADPARM; }
 aaMemoryCopy(&surp->status.pixl_style,sizeof(_pixelstyle),pixelstyle);//data);
 return RET_YES;
 }



 B aaSurfacePixelStyleGet              (H handle,_pixelstyle*pixelstyle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(pixelstyle==NULL) { return RET_BADPARM; }
 aaMemoryCopy(pixelstyle,sizeof(_pixelstyle),&surp->status.pixl_style);
 return RET_YES;
 }




 B aaSurfacePixelPutProcGet            (H handle,PP proc)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(proc) { *proc=surp->PixelPut; }
 return RET_YES;
 }




 B aaSurfacePixelSetProcGet            (H handle,PP proc)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(proc) { *proc=surp->PixelSet; }
 return RET_YES;
 }



 B aaSurfacePixelGetProcGet            (H handle,PP proc)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(proc) { *proc=surp->PixelGet; }
 return RET_YES;
 }



 B aaSurfacePixelPutProcSet            (H handle,B(*Proc)(VP sobj,N,N,_rgba*))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(Proc==NULL) { surp->PixelPut=aaSurfacePixelPutProc; }
 else           { surp->PixelPut=Proc; }
 return RET_YES;
 }



 B aaSurfacePixelSetProcSet            (H handle,B(*Proc)(VP,N,N,_rgba*))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(Proc==NULL) { surp->PixelSet=aaSurfacePixelSetProc; }
 else           { surp->PixelSet=Proc; }
 return RET_YES;
 }


 B aaSurfacePixelGetProcSet            (H handle,B(*Proc)(VP,N,N,_rgba*))
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(Proc==NULL) { surp->PixelGet=aaSurfacePixelGetProc; }
 else           { surp->PixelGet=Proc; }
 return RET_YES;
 }




 B aaSurfacePixelPut                   (H handle,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

// aa_DIAG("aaSurfacePixelPut");
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 surp->PixelPut(surp,c1->x,c1->y,p1);
 return RET_YES;
 }




 B aaSurfacePixelSet                   (H handle,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 //aa_DIAG("aaSurfacePixelSet");
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 surp->PixelSet(surp,c1->x,c1->y,p1);
 return RET_YES;
 }



 B aaSurfacePixelGet                   (H handle,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 //aa_DIAG("aaSurfacePixelGet");
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 surp->PixelGet(surp,c1->x,c1->y,p1);
 return RET_YES;
 }






 B aaSurfaceMaskSet                    (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { surp->status.is_mask=NO; }
 else         { surp->status.is_mask=YES; aaRgbaCopy(&surp->status.mask,p1); }
 return RET_YES;
 }


 B aaSurfaceMaskGet                    (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { return RET_BADPARM; }
 aaRgbaCopy(p1,&surp->status.mask);
 return RET_YES;
 }




 B aaSurfaceMaskNotSet                 (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { surp->status.is_masknot=NO; }
 else         { surp->status.is_masknot=YES; aaRgbaCopy(&surp->status.mask_not,p1); }
 return RET_YES;
 }


 B aaSurfaceMaskNotGet                 (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { return RET_BADPARM; }
 aaRgbaCopy(p1,&surp->status.mask_not);
 return RET_YES;
 }





 B aaSurfaceLine                       (H handle,_cord*c1,_cord*c2,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord df;
 N numpixels,i,x,y;
 N d,dinc1,dinc2;
 N xinc1,xinc2;
 N yinc1,yinc2;
 B(*PixelFunc)(VP surfobj,N x,N y,_rgba*p1);
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { return RET_BADPARM; }
 if(c1==NULL) { return RET_BADPARM; }
 if(c2==NULL) { return RET_BADPARM; }
 aaCordSubtract(c1,c2,&df);
 df.x=aaNumAbs(df.x);
 df.y=aaNumAbs(df.y);
 pstylep=(_pixelstyle*)&surp->status.pixl_style;
 UNUSE(pstylep);
 PixelFunc=surp->PixelPut;

 /**
 if(p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  PixelFunc=aaSurfacePixelSetProc;
  }



 if(p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  if(c1->x>=0&&c1->y>=0&&c2->x>=0&&c2->y>=0)
   {
   if(c1->x<(N)surp->status.size.w&&c1->y<(N)surp->status.size.h)
    {
    if(c2->x<(N)surp->status.size.w&&c2->y<(N)surp->status.size.h)
     {
     if(surp->status.is_clipper==YES&&surp->status.is_vflip==NO)
      {
     // return RET_YES;
      }
     }
    }
   PixelFunc=surp->PixelSet;
   }
  }
*/

 if(df.x==0&&df.y==0)
  {
  PixelFunc(surp,c1->x,c1->y,p1);
  return RET_YES;
  }

 if(df.x>=df.y)
  {
  numpixels=df.x;
  d=2*df.y-df.x;
  dinc1=df.y*2;
  dinc2=(df.y-df.x)*2;
  xinc1=xinc2=yinc2=1;
  yinc1=0;
  }
 else
  {
  numpixels=df.y;
  d=2*df.x-df.y;
  dinc1=df.x*2;
  dinc2=(df.x-df.y)*2;
  xinc1=0;
  xinc2=yinc1=yinc2=1;
  }
 numpixels++;
 if(c1->x>c2->x)  {  xinc1=-xinc1;  xinc2=-xinc2;  }
 if(c1->y>c2->y)  {  yinc1=-yinc1;  yinc2=-yinc2;  }
 x=c1->x;
 y=c1->y;
 for(i=0;i<numpixels; i++)
  {
//    aa_DIAG("aaSurfaceImageLine>>PixelPut>>stnd");
  //surp->PixelPut
  //PixelFunc(surp,x,y,p1);
  PixelFunc(surp,x,y,p1);
  if(d<0)   {   d+=dinc1;   x+=xinc1;   y+=yinc1;   }
  else        {   d+=dinc2;   x+=xinc2;   y+=yinc2;   }
  }

 return RET_YES;
 }







 B aaSurfaceClear                      (H handle,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 register H z;
// _rect mr;
// _cord cd;
 _rgba pn;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
// if(rect==NULL) { aaRectSet(&mr,0,0,surp->status.size.w,surp->status.size.h); }
// else           { aaRectCopy(&mr,rect); }
 if(p1==NULL) { aaRgbaSet(&pn,0,0,0,0); }
 else         { aaRgbaCopy(&pn,p1); }
// if(aaRectIsValid(&mr)!=RET_YES) { return RET_BADPARM; }
#if 0
 for(y=0;y<mr.h;y++)
  {
  for(x=0;x<mr.w;x++)
   {
   cd.x=mr.x+x;
   cd.y=mr.y+y;
   surp->status.mem[(cd.y*surp->status.rect.w)+cd.x]=pn;
   }
  }
 #endif
 for(z=0;z<surp->status.real_pixel_count;z+=1)
  {
  surp->status.mem[z+0]=pn;
  //surp->status.mem[z+1]=pn;
  }
 return RET_YES;
 }









 B aaSurfaceFill                       (H handle,_rect*rect,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 N x,y;
 N minx,miny;
 N maxx,maxy;
 _rect mr;
 _cord cd;
 H off;
 //BP pp;
 B(*PixelFunc)(VP surfobj,N x,N y,_rgba*p1);
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&mr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&mr,rect); }
 if(aaRectIsValid(&mr)!=RET_YES) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 pstylep=(_pixelstyle*)&surp->status.pixl_style;


 PixelFunc=surp->PixelPut;

 if(pstylep->mode==0&&p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  if(surp->status.is_mask==NO&&surp->status.is_masknot==NO)
   {
   if(mr.x>=0&&mr.y>=0&&mr.w>0&&mr.h>0)
    {
    if((mr.x+mr.w)<=surp->status.size.w&&(mr.y+mr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==NO&&surp->status.is_vflip==NO)
      {
      for(y=0;y<(N)mr.h;y++)
       {
       off=((mr.y+y)*surp->status.size.w)+mr.x;
       for(x=0;x<(N)mr.w;x++) {    *(_rgba*)&surp->status.mem[off++]=*p1;       }
       }
      return RET_YES;
      }
     }
    }
   }
  //PixelFunc=surp->PixelSet;
  }


 if(pstylep->mode==0&&p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {
  if(surp->status.is_mask==NO&&surp->status.is_masknot==NO)
   {
   if(mr.x>=0&&mr.y>=0&&mr.w>0&&mr.h>0)
    {
    if((mr.x+mr.w)<=surp->status.size.w&&(mr.y+mr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==YES&&surp->status.is_vflip==NO)
      {
      minx=surp->status.clipper_rect.x;
      miny=surp->status.clipper_rect.y;
      maxx=surp->status.clipper_rect.x+surp->status.clipper_rect.w;
      maxy=surp->status.clipper_rect.y+surp->status.clipper_rect.h;
      for(y=0;y<(N)mr.h;y++)
       {
       if((mr.y+y)>=miny&&(mr.y+y)<maxy)
        {
        for(x=0;x<(N)mr.w;x++)
         {
         if((mr.x+x)>=minx&&(mr.x+x)<maxx)
          {
          off=((mr.y+y)*surp->status.size.w)+mr.x+x;
          *(_rgba*)&surp->status.mem[off++]=*p1;
          }
         }
        }
       }
      return RET_YES;
      }
     }
    }
   }
  ///PixelFunc=surp->PixelSet;
  }


  cd.y=mr.y;
  for(y=0;y<(N)mr.h;y++)
   {
   cd.x=mr.x;
   for(x=0;x<(N)mr.w;x++)
    {
    PixelFunc(surp,cd.x,cd.y,p1);
    cd.x++;
    }
   cd.y++;
   }
 return RET_YES;
 }







 B aaSurfaceFrame                      (H handle,_rect*rect,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1,c2;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1);
 aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1);
 aaCordSet(&c1,(rr.x+rr.w)-1,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1);
 aaCordSet(&c1,rr.x,(rr.y+rr.h)-1);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1);
 return RET_YES;
 }



 B aaSurfaceFramePart                  (H handle,_rect*rect,_rgba*p1,B dol,B dot,B dor,B dob,B dotlbr,B dotrbl)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1,c2;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 if(dot) { aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dol) { aaCordSet(&c1,rr.x,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dor) { aaCordSet(&c1,(rr.x+rr.w)-1,rr.y);  aaCordSet(&c2,c1.x,(rr.y+rr.h)-1);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dob) { aaCordSet(&c1,rr.x,(rr.y+rr.h)-1);  aaCordSet(&c2,(rr.x+rr.w)-1,c1.y);  aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dotlbr) { aaCordSet(&c1,rr.x,rr.y); aaCordSet(&c2,(rr.x+rr.w)-1,(rr.y+rr.h)-1); aaSurfaceLine(handle,&c1,&c2,p1); }
 if(dotrbl) { aaCordSet(&c1,(rr.x+rr.w)-1,rr.y); aaCordSet(&c2,rr.x,(rr.y+rr.h)-1); aaSurfaceLine(handle,&c1,&c2,p1); }
 return RET_YES;
 }


 B aaSurfaceFillFrame                  (H handle,_rect*rect,B thickness,_rgba*p1,_rgba*p2)
 {
 B ret;
 N z;
 _rect rr;
 _aa_surfaceobject*surp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 if(p2) {  aaSurfaceFill(handle,&rr,p2);    }
 if(thickness==0) { return RET_YES; }
 if(p1)
  {
  for(z=0;z<(N)thickness;z++)
   {
   aaSurfaceFrame(handle,&rr,p1);
   aaRectExpand(&rr,-1,-1);
   }
  }
 return RET_YES;
 }









 B aaSurfacePoly                       (H handle,_cord**cords,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 H i,j,flag;
 _cord c1,c2;
 N hx,hy,lx,ly;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(cords==NULL) { return RET_BADPARM; }
 if(p1==NULL&&p2==NULL) { return RET_BADPARM; }
 i=flag=0;
 while(1)
  {
  j=i+1;
  if(cords[i]==NULL) { break; }
  if(cords[j]==NULL) { j=0; flag=1; }
  c1.x=cords[i]->x;
  c1.y=cords[i]->y;
  c2.x=cords[j]->x;
  c2.y=cords[j]->y;
  if(p1!=NULL) { aaSurfaceLine(handle,&c1,&c2,p1);   }
  else         { aaSurfaceLine(handle,&c1,&c2,p2);   }
  if(flag)     { break; }
  i++;
  }
 if(p2)
  {
  lx=ly=+100000;
  hx=hy=-100000;
  for(j=0;j<i;j++)
   {
   if(cords[j]->x<lx) { lx=cords[j]->x; }
   if(cords[j]->y<ly) { ly=cords[j]->y; }
   if(cords[j]->x>hx) { hx=cords[j]->x; }
   if(cords[j]->y>hy) { hy=cords[j]->y; }
   }
  aaRectSet(&rc1,lx,ly,hx-lx,hy-ly);
  c1.x=rc1.x+(rc1.w/2);
  c1.y=rc1.y+(rc1.h/2);
  aaSurfaceFloodFill(handle,&rc1,&c1,p2);
  }
 return RET_YES;
 }






 B aaSurfaceBar                        (H handle,_rect*rect,_rgba*p1,_rgba*p2,H hsk,H vsk)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rgba pn[3];
 _cord c1,c2,c3,c4;
 _rect rc1,rc3;
 N xsl,ysl;
 _cord*cordl[10];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 aaMemoryFill(cordl,sizeof(cordl),0);
 cordl[0]=&c1; cordl[1]=&c2;
 cordl[2]=&c3; cordl[3]=&c4;

 aaRectSet(&rc3,rect->x,rect->y,rect->w,rect->h);
 aaRectCopy(&rc1,&rc3);
 xsl=hsk;
 ysl=vsk;
 aaRectAdjust(&rc1,0,0,-xsl,-ysl);

 aaRgbaCopy(&pn[0],p2);
 aaRgbaCopy(&pn[1],p2);
 aaRgbaCopy(&pn[2],p2);
 aaRgbaAdjustUsingHlsa(&pn[1],0,-40,0,0,0);
 aaRgbaAdjustUsingHlsa(&pn[2],0,-70,0,0,0);

 aaCordSet(&c1,rc1.x,rc1.y);
 aaCordSet(&c2,rc1.x+rc1.w,rc1.y);
 aaCordSet(&c3,rc1.x+rc1.w+xsl,rc1.y+ysl);
 aaCordSet(&c4,rc1.x+xsl,rc1.y+ysl);
 aaSurfacePoly(handle,cordl,p1,&pn[0]);

 aaCordSet(&c1,rc1.x,rc1.y);
 aaCordSet(&c2,rc1.x+xsl,rc1.y+ysl);
 aaCordSet(&c3,rc1.x+xsl,rc1.y+rc1.h+ysl);
 aaCordSet(&c4,rc1.x,rc1.y+rc1.h);
 aaSurfacePoly(handle,cordl,p1,&pn[2]);

 aaCordSet(&c1,rc1.x+xsl,rc1.y+ysl);
 aaCordSet(&c2,rc1.x+rc1.w+xsl,rc1.y+ysl);
 aaCordSet(&c3,rc1.x+rc1.w+xsl,rc1.y+rc1.h+ysl);
 aaCordSet(&c4,rc1.x+xsl,rc1.y+rc1.h+ysl);
 aaSurfacePoly(handle,cordl,p1,&pn[1]);

 return RET_YES;
 }






 B aaSurfaceTriangle                   (H handle,_cord*c1,_cord*c2,_cord*c3,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord cd1,cd2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL||c2==NULL||c3==NULL) { return RET_BADPARM; }
 aaCordsSet(&cd1,&cd2,c1->x,c1->y,c2->x,c2->y);
 if((ret=aaSurfaceLine(handle,&cd1,&cd2,p1))!=YES) { return ret; }
 aaCordsSet(&cd1,&cd2,c2->x,c2->y,c3->x,c3->y);
 if((ret=aaSurfaceLine(handle,&cd1,&cd2,p1))!=YES) { return ret; }
 aaCordsSet(&cd1,&cd2,c3->x,c3->y,c1->x,c1->y);
 if((ret=aaSurfaceLine(handle,&cd1,&cd2,p1))!=YES) { return ret; }
 return RET_YES;
 }




 B aaSurfaceTriangleFill               (H handle,_cord*c1,_cord*c2,_cord*c3,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord cd1,cd2;
 N tmp;
 N startx[_2K],endx[_2K];
 N xa,ya,xb,yb;
 N miny,maxy;
 N x,m,i,y;
 N x1,y1,x2,y2,x3,y3;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(c1==NULL||c2==NULL||c3==NULL) { return RET_BADPARM; }
 x1=c1->x; y1=c1->y;
 x2=c2->x; y2=c2->y;
 x3=c3->x; y3=c3->y;

 miny=16000;
 maxy=-16000;
 if(y1<miny) miny=y1;
 if(y1>maxy) maxy=y1;
 if(y2<miny) miny=y2;
 if(y2>maxy) maxy=y2;
 if(y3<miny) miny=y3;
 if(y3>maxy) maxy=y3;
 if(miny<0||maxy>2000) return RET_FAILED;
 for(i=miny;i<=maxy;i++)
  {
  startx[i]=endx[i]=-16000;
  }
 // VERTEX 1
 xa=x1; ya=y1; xb=x2; yb=y2;

 if(yb!=ya)
  {
  if(yb<ya)   {    tmp=ya;    ya=yb;    yb=tmp;    tmp=xa;    xa=xb;    xb=tmp;   }
  x=(N)xa<<8;
  m=((N)(xb-xa)<<8)/((N)(yb-ya));
  x+=m;
  ya++;
  for(y=ya;y<=yb;y++)
   {
   if((y>=0)&(y<2000))
    {
    if(startx[y]==-16000)  startx[y]=(I)(x>>8);
    else                     endx[y]=(I)(x>>8);
    }
   x+=m;
   }
  }


 // VERTEX 2
 xa=x2; ya=y2; xb=x3; yb=y3;

 if(yb!=ya)
  {
  if(yb<ya)   {    tmp=ya;    ya=yb;    yb=tmp;    tmp=xa;    xa=xb;    xb=tmp;   }
  x=(N)xa<<8;
  m=((N)(xb-xa)<<8)/((N)(yb-ya));
  x+=m;
  ya++;
  for(y=ya;y<=yb;y++)
   {
   if((y>=0)&(y<2000))
    {
    if(startx[y]==-16000)  startx[y]=(I)(x>>8);
    else                     endx[y]=(I)(x>>8);
    }
   x+=m;
   }
  }

 xa=x3; ya=y3; xb=x1; yb=y1;

 if(yb!=ya)
  {
  if(yb<ya)   {    tmp=ya;    ya=yb;    yb=tmp;    tmp=xa;    xa=xb;    xb=tmp;   }
  x=(N)xa<<8;
  m=((N)(xb-xa)<<8)/((N)(yb-ya));
  x+=m;
  ya++;
  for(y=ya;y<=yb;y++)
   {
   if((y>=0)&(y<2000))
    {
    if(startx[y]==-16000)  startx[y]=(I)(x>>8);
    else                     endx[y]=(I)(x>>8);
    }
   x+=m;
   }
  }
 for(i=miny;i<=maxy;i++)
  {
  if(startx[i]!=-16000)
   {
   if(endx[i]== -16000) endx[i]=startx[i];
   aaCordsSet(&cd1,&cd2,startx[i],i,endx[i],i);
   aaSurfaceLine(handle,&cd1,&cd2,p1);
//   HiCallVideoLine(img,imgwidth,startx[i], i, endx[i], i,face);
   }
  }
 return RET_YES;
 }




 B aaSurfaceEllipse                    (H handle,_rect*rect,_rgba*p1)
 {
 N xoff,yoff;
 Z w2,h2,s,t;
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;
 N x,y,w,h;
 B(*PixelFunc)(VP surfobj,N x,N y,_rgba*p1);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }

 PixelFunc=surp->PixelPut;
 if(p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc&&surp->status.pixl_style.mode==0)//[0]==0)
  {
  PixelFunc=aaSurfacePixelSetProc;
  }
 w=rr.w; h=rr.h; x=rr.x; y=rr.y;
 /*
 #ifdef WAGO
 //w=w-1;  w=w>>1;  h=h-1;  h=h>>1;
 #else
  w=--w>>1;  h=--h>>1;
  #endif
  */
 //w=--w>>1;  h=--h>>1;
 w=w-1;  w=w>>1;  h=h-1;  h=h>>1;

  w2=w*w;  h2=h*h;
  w2--; h2--;
  s=w2*(1-(h<<1))+(h2<<1);
  t=h2-(w2*((h<<1)-1)<<1);
  xoff=x+w;  yoff=y+h;
  x=0;
  y=h;
  do
   {
   if(s<0)    {    s+=h2*((x<<1)+3)<<1;    t+=h2*(x+1)<<2;    x++;    }
   else
   if(t<0)
    {
    s+=(h2*((x<<1)+3)<<1)-(w2*(y-1)<<2);
    t+=(h2*(x+1)<<2)-(w2*((y<<1)-3)<<1);
    x++;
    y--;
    }
   else    {    s-=w2*(y-1)<<2;    t-=w2*((y<<1)-3)<<1;    y--;    }
   PixelFunc(surp,xoff+x,yoff+y,p1);
   PixelFunc(surp,xoff-x,yoff+y,p1);
   PixelFunc(surp,xoff+x,yoff-y,p1);
   PixelFunc(surp,xoff-x,yoff-y,p1);
   }
  while(y>0);

  // fill in remaining gaps and adjsting edge lines by taking into consideration odd/even sizes
  // and adding/subtracting respectively to compensate for pixel errors

 // to
 y=rr.y;
 PixelFunc(surp,xoff-1,y,p1);  PixelFunc(surp,xoff+0,y,p1);  PixelFunc(surp,xoff+1,y,p1);

 // bottom
 if(aaNumIsMod(rr.h,2))
 y=(rr.y+rr.h)-2;    else
 y=(rr.y+rr.h)-1;
 PixelFunc(surp,xoff-1,y,p1);  PixelFunc(surp,xoff+0,y,p1);  PixelFunc(surp,xoff+1,y,p1);

 // left
 x=rr.x;
 PixelFunc(surp,x,yoff-1,p1);  PixelFunc(surp,x,yoff+0,p1);  PixelFunc(surp,x,yoff+1,p1);

 // right
 if(aaNumIsMod(rr.w,2))
 x=(rr.x+rr.w)-2;     else
 x=(rr.x+rr.w)-1;
 PixelFunc(surp,x,yoff-1,p1);  PixelFunc(surp,x,yoff+0,p1);  PixelFunc(surp,x,yoff+1,p1);
 return RET_YES;
 }







 B aaSurfaceEllipseFill                (H handle,_rect*rect,_rgba*p1)
 {
 _aa_surfaceobject*surp;
 B ret;
 _rect rr;
 N rx,ry;
 N x,y,dc,dd,ix,iy;
 N na,nb,nc,nd;
 N a,b,c,d,da,db;
 _cord cc,ee;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 rx=((rr.x+rr.w-1)-rr.x)/2;
 ry=((rr.y+rr.h-1)-rr.y)/2;
 x=rr.x+(rx);
 y=rr.y+(ry);
 if(rx<1)  rx=1;
 if(ry<1)  ry=1;
 if(rx>ry)
  {
  dc=-1;
  dd=0xFFFF;
  ix=0;
  iy=rx*64;
  na=0;
  nb=(iy+32)>>6;
  nc=0;
  nd=(nb*ry)/rx;
  do
   {
   a=na;
   b=nb;
   c=nc;
   d=nd;
   ix=ix+(iy/rx);
   iy=iy-(ix/rx);
   na=(ix+32)>>6;
   nb=(iy+32)>>6;
   nc=(na*ry)/rx;
   nd=(nb*ry)/rx;
   if((c>dc)&&(c<dd))
    {
    cc.x=x-b; cc.y=y+c; ee.x=x+b; ee.y=cc.y;
    aaSurfaceLine(handle,&cc,&ee,p1);
    if(c)
     {
     cc.x=x-b; cc.y=y-c; ee.x=x+b; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     }
    dc=c;
    }
   if((d<dd)&&(d>dc))
    {
    cc.x=x-a; cc.y=y+d; ee.x=x+a; ee.y=cc.y;
    aaSurfaceLine(handle,&cc,&ee,p1);
    cc.x=x-a; cc.y=y-d; ee.x=x+a; ee.y=cc.y;
    aaSurfaceLine(handle,&cc,&ee,p1);
    dd=d;
    }
   }
   while(b>a);
   }
  else
   {
   da=-1;
   db=0xFFFF;
   ix=0;
   iy=ry*64;
   na=0;
   nb=(iy+32)>>6;
   nc=0;
   nd=(nb*rx)/ry;
   do
    {
    a=na;
    b=nb;
    c=nc;
    d=nd;
    ix=ix+(iy/ry);
    iy=iy-(ix/ry);
    na=(ix+32)>>6;
    nb=(iy+32)>>6;
    nc=(na*rx)/ry;
    nd=(nb*rx)/ry;
    if((a>da)&&(a<db))
     {
     cc.x=x-d; cc.y=y+a; ee.x=x+d; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     if(a)
      {
      cc.x=x-d; cc.y=y-a; ee.x=x+d; ee.y=cc.y;
      aaSurfaceLine(handle,&cc,&ee,p1);
      }
     da=a;
     }
    if((b<db)&&(b>da))
     {
     cc.x=x-c; cc.y=y+b; ee.x=x+c; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     cc.x=x-c; cc.y=y-b; ee.x=x+c; ee.y=cc.y;
     aaSurfaceLine(handle,&cc,&ee,p1);
     db=b;
     }
    }
    while(b>a);
    }
 return RET_YES;
 }


 B aaSurfaceEllipseFillFrame           (H handle,_rect*rect,N thick,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _rect rc1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&rc1,rect);
 if(p2)
  {
  aaRectCopy(&rc1,rect);
  aaRectExpand(&rc1,-((thick/4)+1),-((thick/4)+1));
  aaSurfaceEllipseFill(handle,&rc1,p2);
  }
 if(p1)
  {
  aaRectCopy(&rc1,rect);
  aaRectExpand(&rc1,-(thick/2),-(thick/2));
  if((rect->w%2)==1) aaRectExpand(&rc1,-1,0);
  if((rect->h%2)==1) aaRectExpand(&rc1,0,-1);
  aaSurfacePixelStyleGet(handle,&pstyle_save);
  aaPixelStyleInit(&pstyle_data);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/2),(thick/2),0,0,0,0,handle);
  aaSurfaceEllipse(handle,&rc1,p1);
  aaSurfacePixelStyleSet(handle,&pstyle_save);
  }
 return RET_YES;
 }



 B aaSurfaceFloodFill                  (H handle,_rect*r1,_cord*c1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _ministack ms;
 _cord cc,cd;
 H val,ww;
 N y1,spanLeft,spanRight;
 N x,y;
 _rect rc;
 _rgba nc,oc;
 _rgba*mem;
 B r,g,b;
 H old_mode;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaMiniStackInit(&ms);
 if(p1==NULL) { return RET_BADPARM; }
 if(r1==NULL) { aaRectSet(&rc,0,0,surp->status.size.w,surp->status.size.h); }
 else         { aaRectCopy(&rc,r1);  }
 if(c1==NULL) { aaCordSet(&cc,rc.w/2,rc.h/2); }
 else         { aaCordCopy(&cc,c1); }
 if(cc.x<rc.x) { return RET_BOUNDS; }
 if(cc.x>=(N)(rc.x+rc.w)) { return RET_BOUNDS; }
 if(cc.y<rc.y) { return RET_BOUNDS; }
 if(cc.y>=(N)(rc.y+rc.h)) { return RET_BOUNDS; }
 old_mode=*(HP)&surp->status.pixl_style;
 //*(HP)&surp->status.pixel_style[0]=0;
 surp->status.pixl_style.mode=0;

 aaCordSet(&cd,cc.x,cc.y);
 ww=surp->status.size.w;
 aaMiniStackPushDword(&ms,(cd.y*ww)+cd.x);
 mem=(_rgba*)&surp->status.mem[0];
 aaRgbaCopy(&nc,p1);
 x=cd.x; y=cd.y;
 #if 1
 aaSurfacePixelGet(handle,&cd,&oc);
 r=oc.r; g=oc.g; b=oc.b;
 while(1)
  {
  if(ms.height==0) { break; }
  if(aaMiniStackPopDword(&ms,&val)!=YES) break;
  y=val/ww;
  x=val%ww;
  y1=y;
  while(y1>=rc.x&&(mem[(y1*ww)+x].r==r&&mem[(y1*ww)+x].g==g&&mem[(y1*ww)+x].b==b))   {   y1--;   }
  y1++;
  spanLeft=spanRight=0;
  while(y1<(N)(rc.y+rc.h)&&(mem[(y1*ww)+x].r==r&&mem[(y1*ww)+x].g==g&&mem[(y1*ww)+x].b==b))
   {
   surp->PixelPut(surp,x,y1,&nc);
   //aaSurfacePixelPutProc(surp,x,y1,&nc);
   if(!spanLeft&&x>rc.x&&(mem[(y1*ww)+(x-1)].r==r&&mem[(y1*ww)+(x-1)].g==g&&mem[(y1*ww)+(x-1)].b==b))
    {
    aaMiniStackPushDword(&ms,(y1*ww)+(x-1));
    spanLeft=1;
    }
   else
   if(spanLeft&&x>rc.x&&(mem[(y1*ww)+(x-1)].r!=r||mem[(y1*ww)+(x-1)].g!=g||mem[(y1*ww)+(x-1)].b!=b))
    {
    spanLeft=0;
    }
   if(!spanRight&&x<(N)(rc.x+rc.w-1)&&(mem[(y1*ww)+(x+1)].r==r&&mem[(y1*ww)+(x+1)].g==g&&mem[(y1*ww)+(x+1)].b==b))
    {
    aaMiniStackPushDword(&ms,(y1*ww)+x+1);
    spanRight=1;
    }
   else
   if(spanRight&&x<(N)(rc.x+rc.w-1)&&(mem[(y1*ww)+x+1].r!=r||mem[(y1*ww)+x+1].g!=g||mem[(y1*ww)+x+1].b!=b))
    {
    spanRight=0;
    }
   y1++;
   }
  }
 #else
 aaSurfacePixelGet(handle,&cd,&oc);
 aaRgbaCopy(&oc,&col_gray[20]);
 r=oc.r; g=oc.g; b=oc.b;
 while(1)
  {
  if(ms.height==0) { break; }
  if(aaMiniStackPopDword(&ms,&val)!=YES) break;
  y=val/ww;
  x=val%ww;
  y1=y;
  while(y1>=rc.x&&(mem[(y1*ww)+x].r!=r||mem[(y1*ww)+x].g!=g||mem[(y1*ww)+x].b!=b))   {   y1--;   }
  y1++;
  spanLeft=spanRight=0;
  while(y1<(N)(rc.y+rc.h)&&(mem[(y1*ww)+x].r!=r||mem[(y1*ww)+x].g!=g||mem[(y1*ww)+x].b!=b))
   {
   surp->PixelPut(surp,x,y1,&nc);
   if(!spanLeft&&x>rc.x&&(mem[(y1*ww)+(x-1)].r!=r||mem[(y1*ww)+(x-1)].g!=g||mem[(y1*ww)+(x-1)].b!=b))
    {
    aaMiniStackPushDword(&ms,(y1*ww)+(x-1));
    spanLeft=1;
    }
   else
   if(spanLeft&&x>rc.x&&(mem[(y1*ww)+(x-1)].r==r&&mem[(y1*ww)+(x-1)].g==g&&mem[(y1*ww)+(x-1)].b==b))
    {
    spanLeft=0;
    }
   if(!spanRight&&x<(N)(rc.x+rc.w-1)&&(mem[(y1*ww)+(x+1)].r!=r||mem[(y1*ww)+(x+1)].g!=g||mem[(y1*ww)+(x+1)].b!=b))
    {
    aaMiniStackPushDword(&ms,(y1*ww)+x+1);
    spanRight=1;
    }
   else
   if(spanRight&&x<(N)(rc.x+rc.w-1)&&(mem[(y1*ww)+x+1].r==r&&mem[(y1*ww)+x+1].g==g&&mem[(y1*ww)+x+1].b==b))
    {
    spanRight=0;
    }
   y1++;
   }
  }
#endif
 surp->status.pixl_style.mode=old_mode;
 return RET_YES;
 }







 B aaSurfaceArc                        (H handle,_rect*rect,N astart,N astop,N arot,_rgba*p1)
 {
 D rad_start,rad_stop,rad_rot;
 D rot_cos,rot_sin;
 D aStep=0.05;            // Angle step
 D a;                // Current angle
 N xc,yc,radius1,radius2,x_last,x_tmp,x_next,y_last,y_tmp,y_next;
 _cord c1,c2;
 _rect rr;
 B ret;
 _aa_surfaceobject*surp;
 N x,y,w,h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }
 x=rr.x;
 y=rr.y;
 w=rr.w;
 h=rr.h;
    // This algorythm wants center and two radiuses...
    xc=x+w/2;
    yc=y+h/2;
    radius1=w/2;
    radius2=h/2;
    // ... and euclidian radians
    rad_start=astart*aaPi/180;
    rad_stop=astop*aaPi/180;
    rad_rot=-arot*aaPi/180;
    // rotation multipliers
    rot_cos=cos(rad_rot);
    rot_sin=sin(rad_rot);
    if(radius1<2.0) { radius1=2.0; aStep=0.05; }
    if(radius2<2.0) { radius2=2.0; aStep=0.05; }
    // Angle step in rad
    if(radius1>2.0&&radius2>2.0)
     {
     if(radius1<radius2)
      {
      if(radius1<1.0e-4) { aStep=1.0; }
      else               { aStep=asin(2.0/radius1);     }
      }
     else
      {
      if(radius2<1.0e-4) { aStep=1.0; }
      else               { aStep=asin(2.0/radius2);   }
      }
     }
    if(aStep<0.05)       { aStep=0.05;  }
    x_tmp=cos(rad_start)*radius1;
    y_tmp=sin(rad_start)*radius2;
    x_next=xc+(rot_cos*x_tmp)-(rot_sin*y_tmp);
    y_next=yc+(rot_cos*y_tmp)+(rot_sin*x_tmp);
    x_last=x_next;
    y_last=y_next;
    for(a=rad_start+aStep;a<=rad_stop;a+=aStep)
     {
     x_tmp=cos(a)*radius1;
     y_tmp=sin(a)*radius2;
     x_next=xc+(rot_cos*x_tmp)-(rot_sin*y_tmp);
     y_next=yc+(rot_cos*y_tmp)+(rot_sin*x_tmp);
     aaCordsSet(&c1,&c2,x_last,y_last,x_next,y_next);
     c1.x=aaNumRoof(c1.x,((x+w)-1));
     c2.x=aaNumRoof(c2.x,((x+w)-1));
     c1.y=aaNumRoof(c1.y,((y+h)-1));
     c2.y=aaNumRoof(c2.y,((y+h)-1));
     aaSurfaceLine(handle,&c1,&c2,p1);
     x_last=x_next;
     y_last=y_next;
    }
 return RET_YES;
 }





 B aaSurfaceRoundedFrame               (H handle,_rect*rect,N r,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;
 _cord cd1,cd2,cd3,cd4;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r<0) { return RET_BOUNDS; }
 aaRectToCornerCords(rect,&cd1,&cd2,&cd3,&cd4);
 cd1.x+=r;  cd2.x-=r;                         aaSurfaceLine(handle,&cd1,&cd2,p1);
 cd1.x-=r;  cd2.x+=r;   cd2.y+=r;  cd3.y-=r;  aaSurfaceLine(handle,&cd2,&cd3,p1);
 cd2.y-=r;  cd3.y+=r;   cd3.x-=r;  cd4.x+=r;  aaSurfaceLine(handle,&cd3,&cd4,p1);
 cd3.x+=r;  cd4.x-=r;   cd4.y-=r;  cd1.y+=r;  aaSurfaceLine(handle,&cd4,&cd1,p1);
 //cd4.y+=r;  cd1.y-=r;
 aaRectSet(&rc1,rect->x,rect->y,r*2,r*2);                 aaSurfaceArc(handle,&rc1,270,360,90,p1);
 aaRectSet(&rc1,((rect->x+rect->w)-(r*2))-1,rect->y,(r*2)+1,r*2); aaSurfaceArc(handle,&rc1,0,90,90,p1);
 aaRectSet(&rc1,rect->x,(rect->y+rect->h)-(r*2),r*2,r*2); aaSurfaceArc(handle,&rc1,180,270,90,p1);
 aaRectSet(&rc1,((rect->x+rect->w)-(r*2))-1,(rect->y+rect->h)-(r*2),(r*2)+1,r*2);
 aaSurfaceArc(handle,&rc1,90,180,90,p1);
 return RET_YES;
 }








 B aaSurfaceRoundedFill                (H handle,_rect*rect,N r,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rc1;
 _rect clip;
 //_cord cd1,cd2,cd3,cd4;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r<0) { return RET_BOUNDS; }

 aaSurfaceClipperGet(handle,&clip);
 aaRectCopy(&rc1,rect);

 aaRectAdjust(&rc1,0,r,0,-(r*2));
 aaSurfaceFill(handle,&rc1,p1);

 aaRectAdjust(&rc1,r,-r,-(r*2),0);
 rc1.h=r;
 aaSurfaceFill(handle,&rc1,p1);

 aaRectAdjust(&rc1,0,rect->h-(r),0,0);
 aaSurfaceFill(handle,&rc1,p1);

 aaRectSet(&rc1,rect->x,rect->y,r*1,r*1);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,0,0,r,r);
 aaSurfaceEllipseFill(handle,&rc1,p1);

 aaSurfaceClipperSet(handle,rect);
 aaRectSet(&rc1,(rect->x+rect->w)-(r*2),rect->y,r*2,r*2);
 aaRectAdjust(&rc1,r,0,-r,-r);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,-r,0,+r,+r);
 aaSurfaceEllipseFill(handle,&rc1,p1);

 aaRectSet(&rc1,rect->x,(rect->y+rect->h)-(r*1),r*1,r*1);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,0,-r,r,r);
 aaSurfaceEllipseFill(handle,&rc1,p1);

 aaSurfaceClipperSet(handle,rect);
 aaRectSet(&rc1,(rect->x+rect->w)-(r*2),(rect->y+rect->h)-(r*2),r*2,r*2);
 aaRectAdjust(&rc1,r,r,-r,-r);
 aaSurfaceClipperSet(handle,&rc1);
 aaRectAdjust(&rc1,-r,-r,+r,+r);
 aaSurfaceEllipseFill(handle,&rc1,p1);


 aaSurfaceClipperSet(handle,&clip);
 return RET_YES;
 }




 B aaSurfaceChamfer                    (H handle,_rect*rect,B state,_rgba*p1,N rad)
 {
 B ret;
 _aa_surfaceobject*surp;
 N v,e,u,x,y,i;
 _rgba lpen,rpen,bcol;
 _rect rr;
 _rect r1;
 _cord c1,c2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(p1==NULL) { return RET_BADPARM; }
 if(aaRectIsValid(&rr)!=YES) { return RET_BADPARM; }


 aaRgbaCopy(&bcol,p1);
 if(state==NO) {  aaRgbaAdjust(&bcol,-60,-60,-60,0);  }
 else          {  aaRgbaAdjust(&bcol,+60,+60,+60,0);  }
 aaRgbaCopy(&lpen,&bcol);

 aaRgbaCopy(&bcol,p1);
 if(state==NO) {  aaRgbaAdjust(&bcol,+60,+60,+60,0);  }
 else          {  aaRgbaAdjust(&bcol,-60,-60,-60,0);  }
 aaRgbaCopy(&rpen,&bcol);

 aaRectSet(&r1,rr.x+rad,rr.y+rad,rr.w-rad*2,rr.h-rad);
 aaSurfaceFill(handle,&r1,&bcol);
 aaRectSet(&r1,rr.x+rad,rr.y,rr.w-rad*2,rr.h);
 aaSurfaceFill(handle,&r1,&bcol);
 aaRectSet(&r1,rr.x,rr.y+rad,rad,rr.h-rad);
 aaSurfaceFill(handle,&r1,&bcol);
 aaRectSet(&r1,rr.x+rr.w-rad,rr.y+rad,rad,rr.h-rad);
 aaSurfaceFill(handle,&r1,&bcol);
 aaCordsSet(&c1,&c2,rr.x+rad,rr.y,rr.x+rr.w-rad,rr.y);
 aaSurfaceLine(handle,&c1,&c2,&bcol);
 aaCordsSet(&c1,&c2,rr.x,rr.y+rad,rr.x,rr.y+rr.h);
 aaSurfaceLine(handle,&c1,&c2,&lpen);
 aaCordsSet(&c1,&c2,rr.x+rr.w-1,rr.y+rad,rr.x+rr.w-1,rr.y+rr.h);
 aaSurfaceLine(handle,&c1,&c2,&rpen);
 v=2*rad-1;
 e=0;
 u=0;
 x=0;
 y=rad;
 while(x<=y)
     {
     aaCordSet(&c1,rr.x+rad-x,rr.y+rad-y);
     aaSurfacePixelPut(handle,&c1,&lpen);
     aaCordSet(&c1,rr.x+rad-y,rr.y+rad-x);
     aaSurfacePixelPut(handle,&c1,&lpen);
     aaCordSet(&c1,rr.x-rad+(rr.w-1)+x,rr.y+rad-y);
     aaSurfacePixelPut(handle,&c1,&rpen);
     aaCordSet(&c1,rr.x-rad+(rr.w-1)+y,rr.y+rad-x);
     aaSurfacePixelPut(handle,&c1,&rpen);
  for(i=0;i<x;i++)
      {
      aaCordSet(&c1,rr.x+rad-i,rr.y+rad-y);
      aaSurfacePixelPut(handle,&c1,&bcol);
      aaCordSet(&c1,rr.x-rad+(rr.w-1)+i,rr.y+rad-y);
      aaSurfacePixelPut(handle,&c1,&bcol);
      }
  for(i=0;i<y;i++)
      {
      aaCordSet(&c1,rr.x+rad-i,rr.y+rad-x);
      aaSurfacePixelPut(handle,&c1,&bcol);
      aaCordSet(&c1,rr.x-rad+(rr.w-1)+i,rr.y+rad-x);
      aaSurfacePixelPut(handle,&c1,&bcol);
     }
     e+=u;
  u+=2;
  if(v<2*e) { y--; e-=v; v-=2;}
  x++;
  }

 return RET_YES;
 }





 B aaSurfaceGimpTile                   (H handle,_rect*rect,N sz,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 N alt1,alt2,x,y;
 _rect r1,rr;
 _rect cc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(sz<1) { return RET_BOUNDS; }
 alt1=alt2=0;
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 aaSurfaceClipperGet(handle,&cc);
 aaSurfaceClipperSet(handle,&rr);
 for(y=0;y<(N)rr.h;y+=sz)  // ningy added (N)
  {
  for(x=0;x<(N)rr.w;x+=sz) // ningy added (N)
   {
   aaRectSet(&r1,rr.x+x,rr.y+y,sz,sz);
   if(alt1++==1) {  aaSurfaceFill(handle,&r1,p1); alt1=0; }
   else          {  aaSurfaceFill(handle,&r1,p2); }
   }
  if(alt2++==1) { alt2=0; } alt1=alt2;
  }
 aaSurfaceClipperSet(handle,&cc);
 return RET_YES;
 }








 B aaSurfaceDragBar                    (H handle,_rect*rect,_rgba*p1,_rgba*p2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c1,c2;
 N xx,zz;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 zz=rect->w;
 for(xx=0;xx<zz;xx++)
  {
  aaCordsSet(&c1,&c2,((rect->x+rect->w)-zz)+xx,(rect->y+rect->h)-1,(rect->x+rect->w)-1,((rect->y+rect->h)-zz)+xx);
  aaSurfaceLine(handle,&c1,&c2,(xx%3)?p1:p2);
  }
 return RET_YES;
 }





 B aaSurfaceLabel                      (H handle,_rect*rect,_rgba*p1,H fhandle,_rgba*p2,N xadj,N yadj,N ha,N va,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_fontobject*fntp;
 _rect mr;
 _cord c1;
 va_list argptr;
 B txt[_64K];//16K+_4K];
 _rgba*pn;
 _parser pa,pb;
 H pos,sl,li;
// H cnt;
 _size sz;
 _size se;
 B line_type;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);

 if(fhandle==0) {  fhandle=aa.font_system.font_8x8; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }

 if(rect==NULL) { aaRectSet(&mr,0,0,surp->status.size.w,fntp->status.size.h+4); } //mr.h+=fntp->status.v_bias; }
 else           { aaRectCopy(&mr,rect); }

 aaStringLen(txt,&sl);
 if(maxchars==0) { maxchars=sl; }
 if(maxchars<sl&&maxchars!=0) { txt[maxchars]=0; }

 if(p1)
  {
  if(p1->a!=0) {  aaSurfaceFill(handle,&mr,p1);  }
  }
 if(p2==NULL) { aaCast(pn,_rgba*,&col_white); }
 else         { aaCast(pn,_rgba*,p2); }

 aaCordSet(&c1,mr.x,mr.y);
 aaFontStringSizeGet(fhandle,&se,0,"%s",txt);

 if(va==YES)
  {
  aaCordAdjust(&c1,0,(mr.h/2));
  aaCordAdjust(&c1,0,-(N)(se.h/2));
  }
 else
 if(va==-YES)
  {
  aaCordAdjust(&c1,0,(mr.h-1));
  aaCordAdjust(&c1,0,-(N)(se.h));
  }
 if(c1.y<mr.y) { c1.y=mr.y; }
 aaParserInit(&pa,txt,0);

 li=0;
 while(1)
  {
  aaStringFindCharList(pa.bp,0,&pos,"\r\n",YES,0,YES);
  if(pos!=F32)
   {
   line_type=pa.bp[pos];
   if(line_type==CR_CHAR) { line_type=aa_STRINGMODE_CR; }
   else
   if(line_type==LF_CHAR) { line_type=aa_STRINGMODE_LF; }
   if(line_type==aa_STRINGMODE_CR)  {    if(pa.bp[pos+1]==LF_CHAR) { line_type=aa_STRINGMODE_CRLF; }    }
   aaParserCopy(&pb,&pa,NO);
   pb.bp[pos]=NULL_CHAR;
   if(ha==YES)
    {
    aaFontStringSizeGet(fhandle,&sz,pos,"%s",pb.bp);
    if(sz.w<mr.w)  {   c1.x=mr.x+((mr.w/2)-(sz.w/2));  }
    }
   if(li==0) {    aaCordAdjust(&c1,xadj,yadj); }
   else      {    aaCordAdjust(&c1,xadj,0); }
   aaSurfacePrintf(handle,&c1,fhandle,pn,pos,"%s",pb.bp);
   li++;
   aaParserSeek(&pa,pos+1);
   if(line_type==aa_STRINGMODE_CRLF) {  aaParserSeek(&pa,1); }
   c1.y+=fntp->status.size.h+4; // feb2016: added +2
   c1.x=mr.x;
   continue;
   }
  if(ha==YES)
   {
   aaFontStringSizeGet(fhandle,&sz,0,"%s",pa.bp);
   if(sz.w<mr.w)  {   c1.x=mr.x+((mr.w/2)-(sz.w/2));  }
   }
  else
  if(ha==-YES)
   {
   aaFontStringSizeGet(fhandle,&sz,0,"%s",pa.bp);
   if(sz.w<mr.w)   {   c1.x=mr.x+mr.w-(sz.w); } //+16);  }
   }

  if(li==0) {    aaCordAdjust(&c1,xadj,yadj); }
  else      {    aaCordAdjust(&c1,xadj,0); }

//  aaCordAdjust(&c1,xadj,yadj);
  aaSurfacePrintf(handle,&c1,fhandle,pn,0,"%s",pa.bp);

  break;
  }


 return RET_YES;
 }




 B aaSurfaceFuzz                       (H handle,_rect*rect,_rgba*p1,B level,H xmod,H ymod)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;
 _rect*mr;
 _rgba*pn;
 Y x,y;
 H noise,carry;
 static H seed=0x123456;
 B r,g,b,a;
 _rgba p2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaCast(mr,_rect*,&rr); aaRectSet(mr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaCast(mr,_rect*,rect); }
 if(aaRectIsValid(mr)!=RET_YES) { return RET_BADPARM; }
 if(p1==NULL)   { aaCast(pn,_rgba*,&col_white); }
 else           { aaCast(pn,_rgba*,p1); }
 if(level==0) { level=1; }

 p2.r=r=pn->r;
 p2.b=g=pn->g;
 p2.g=b=pn->b;
 p2.a=a=pn->a;

 for(y=0;y<mr->h;y++)
  {
  for(x=0;x<mr->w;x++)
   {
   if(((x%(xmod+1))==0)&&((y%(ymod+1))==0))
    {
    noise=seed;
    noise>>=3;
    noise^=seed;
    carry=noise&3;
    noise>>=1;
    seed>>=1;
    seed|=(carry<<30);
    //noise&=0xfF;
    noise%=level;
    p2.r=(B)((r-(noise&r)));
    p2.g=(B)((g-(noise&g)));
    p2.b=(B)((b-(noise&b)));
    p2.a=a;
    }
   surp->PixelPut(surp,mr->x+x,mr->y+y,&p2);
   }
  }
 return RET_YES;
 }





 B aaSurfacePrintf                     (H handle,_cord*cord,H fhandle,_rgba*p1,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _aa_fontobject*fntp;
 register N off,xx,yy;
 register N rxx,ryy;
 _cord ccc,cz;
 N s;
 H sl;
 B ch,alpha;
 H to,o;
 _rgba pp;
 F adiv;
 H fpa,v;
 N newhit,newwid,back;
 va_list argptr;
 B txt[_64K];
 N minx,miny;
 N maxx,maxy;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(fhandle==0) {  fhandle=aa.font_system.font_8x8; }

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(cord==NULL) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 newhit=fntp->status.size.h;

// newhit+=fntp->status.v_bias;
 aaCordCopy(&cz,cord);
 ccc.x=cz.x;

 aaStringLen(txt,&sl);
 if(sl==0)   {   return RET_YES;   }
 if(maxchars==0) maxchars=sl;
 if(sl>maxchars) sl=maxchars;

 aaRgbaCopy(&pp,p1);
 adiv=(F)(pp.a)/255.0;
 fpa=(adiv*65536);

 //  aaLog(-777,"p1->a=%i ppeq=%i pseq=%i vf=%i",p1->a,(surp->PixelPut==aaSurfacePixelPutProc),(surp->PixelSet==aaSurfacePixelSetProc),surp->status.is_vflip);
 if(p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
  {

  if(surp->status.is_vflip==NO)
   {
   minx=0;
   miny=0;
   maxx=surp->status.size.w;
   maxy=surp->status.size.h;
   if(surp->status.is_clipper)
    {
    minx=surp->status.clipper_rect.x;
    miny=surp->status.clipper_rect.y;
    maxx=surp->status.clipper_rect.x+surp->status.clipper_rect.w;
    maxy=surp->status.clipper_rect.y+surp->status.clipper_rect.h;
    }
   for(s=0;s<(N)sl;s++)
    {
    ch=(B)txt[s];
    off=((ch>>4)*((fntp->status.size.w<<4)*fntp->status.size.h))+((ch&15)*(fntp->status.size.w)); /// &15 was %16
    newwid=0;
    back=0;
    newwid+=((fntp->char_width[ch]));
    newwid+=((fntp->char_gap[ch]));
    newwid+=((fntp->char_lead[ch]));
    back=+0;
    if(fntp->status.is_italic) { newwid+=3; back=+3; }
    ccc.y=cz.y;
    for(yy=0;yy<newhit;yy++)
     {
     to=off+((fntp->status.size.w<<4)*yy);
     to+=back;
     if(ccc.y<miny||ccc.y>=maxy) { ccc.y++;   continue; }

     for(xx=0;xx<newwid;xx++)
      {
      if(ccc.x<minx||ccc.x>=maxx) { ccc.x++; continue; }
      alpha=fntp->img[to+xx];
      if(alpha==0)                { ccc.x++; continue; }
      pp.a=(B)((alpha*fpa)>>16);
      //pp.a=(B)(v);
     // if(pp.a==0)   { ccc.x++; continue; }
      rxx=ccc.x;
      ryy=ccc.y;
      if(pp.a!=255)
       {
       surp->PixelPut(surp,rxx,ryy,&pp);
       }
      else
       {
       if(surp->status.is_vflip==YES) { o=(((surp->status.size.h-ryy)-1)*surp->status.size.w)+rxx; }
       else                           { o=(ryy*surp->status.size.w)+rxx; }
       *(_rgba*)&surp->status.mem[o]=pp;
       }
      ccc.x++;
      }
     ccc.x-=(newwid);
     ccc.y++;
     xx=0;
     }
    ccc.x+=newwid;
    if(fntp->status.is_mono_forced==YES)
     {
     ccc.x-=newwid;
     if(newwid<(N)fntp->status.init_mono_size.w) {   ccc.x+=(fntp->status.curr_mono_size.w*.7);      }
     else                                        {   ccc.x+=(fntp->status.curr_mono_size.w);      }
     }
    }
   return RET_YES;
   }
  }

 if(surp->PixelPut!=aaSurfacePixelPutProc)
  {
 for(s=0;s<(N)sl;s++) // ningy added (N)
  {
  ch=(B)txt[s];
  off=((ch/16)*(fntp->status.size.w*16*fntp->status.size.h))+((ch%16)*(fntp->status.size.w));
  // get the width of character,, event in force mono mode
  newwid=(fntp->char_width[ch]+fntp->char_gap[ch]+fntp->char_lead[ch]);
  if(fntp->status.is_italic) { newwid+=1; }
  ccc.y=cz.y;
  for(yy=0;yy<newhit;yy++)
   {
   to=off+(fntp->status.size.w*16*yy);
   for(xx=0;xx<newwid;xx++)
    {
    alpha=fntp->img[to+xx];
    v=(alpha*fpa)>>16;
    if(v!=0)
     {
     pp.a=(B)(v);
     surp->PixelPut(surp,ccc.x,ccc.y,&pp);
     }
    ccc.x++;
    }
   ccc.x-=(newwid);
   ccc.y++;
   }
  ccc.x+=newwid;
  if(fntp->status.is_mono_forced==YES)  {   ccc.x+=(fntp->status.curr_mono_size.w)-newwid;   }
  }

  }
 else
  {
 for(s=0;s<(N)sl;s++)  // ningy added (N)
  {
  ch=(B)txt[s];
  off=((ch>>4)*((fntp->status.size.w<<4)*fntp->status.size.h))+((ch&15)*(fntp->status.size.w)); /// &15 was %16
  // get the width of character,, event in force mono mode
  newwid=(fntp->char_width[ch]+fntp->char_gap[ch]+fntp->char_lead[ch]);
  if(fntp->status.is_italic) { newwid+=1; }
  ccc.y=cz.y;
  for(yy=0;yy<newhit;yy++)
   {
   to=off+((fntp->status.size.w<<4)*yy);
   for(xx=0;xx<newwid;xx++)
    {
    alpha=fntp->img[to+xx];
    v=(alpha*fpa)>>16;
    pp.a=(B)(v);
    if(surp->status.is_clipper)
     {//#if 0
     if(pp.a!=0) {    surp->PixelPut(surp,ccc.x,ccc.y,&pp); }
     //#else
     }
    else
     {
     if(v==255) // added dec 06  /// shonky
      {
      H o;
      //pp.a=(B)v;
      if(surp->status.is_vflip==YES) { o=(((surp->status.size.h-ccc.y)-1)*surp->status.size.w)+ccc.x; }
      else                           { o=(ccc.y*surp->status.size.w)+ccc.x; }
      if(o<surp->status.real_pixel_count) {     surp->status.mem[o]=pp; } // added sep 07
      }
     else
     if(v!=0)
      {
      //pp.a=(B)(v);
      surp->PixelPut(surp,ccc.x,ccc.y,&pp);
      }
     }
    //#endif
    ccc.x++;
    }
   ccc.x-=(newwid);
   ccc.y++;
   }
  ccc.x+=newwid;
  if(fntp->status.is_mono_forced==YES)
   {
   ccc.x+=(fntp->status.curr_mono_size.w)-newwid;
   //( (fntp->char_width[aa_FONT_MONO_CHAR]+fntp->char_gap[aa_FONT_MONO_CHAR]+fntp->char_lead[aa_FONT_MONO_CHAR])-newwid);
   }
  }
 }
 return RET_YES;
 }








 B aaSurfaceScroll                     (H handle,_rect*rect,N xpixels,N ypixels,_rgba*pn)
 {
 B ret;
 _aa_surfaceobject*surp;
 BP tmp=NULL_POINTR;
 N xx,yy;
 N tx,ty;
 N x,y,left;//,eights;
 _rect r1,r2,r3;
 _rect mr;
 _size s1;
 H tmp_handle;
 H soff,doff;
 B alpha=255;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(xpixels==0&&ypixels==0) { return RET_YES; }

 if(rect==NULL) { aaSizeToRect(&surp->status.size,&mr); }
 else
  {
  if((ret=aaRectIsValid(rect))!=RET_YES) { return ret; }
  aaRectCopy(&mr,rect);
  }
 aaSizeSet(&s1,mr.w,mr.h);

 xx=aaNumAbs(xpixels);
 yy=aaNumAbs(ypixels);

 if(xpixels==0&&ypixels<0)
  {
  if(surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
   {
   if(mr.x>=0&&mr.y>=0&&mr.w>0&&mr.h>0)
    {
    if((mr.x+mr.w)<=surp->status.size.w&&(mr.y+mr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==NO&&surp->status.is_vflip==NO)
      {
      ty=(N)mr.h-yy;
      tx=(N)mr.w;
      for(y=0;y<ty;y++)
       {
       soff=((mr.y+y+yy)*surp->status.size.w)+mr.x;
       doff=((mr.y+y)*surp->status.size.w)+mr.x;
       x=0;
       left=tx-x;
       //eights=left/8;
       do
        {
        if(left<8) { break; }
        *(_rgba*)&surp->status.mem[doff+0]=*(_rgba*)&surp->status.mem[soff+0];
        *(_rgba*)&surp->status.mem[doff+1]=*(_rgba*)&surp->status.mem[soff+1];
        *(_rgba*)&surp->status.mem[doff+2]=*(_rgba*)&surp->status.mem[soff+2];
        *(_rgba*)&surp->status.mem[doff+3]=*(_rgba*)&surp->status.mem[soff+3];
        *(_rgba*)&surp->status.mem[doff+4]=*(_rgba*)&surp->status.mem[soff+4];
        *(_rgba*)&surp->status.mem[doff+5]=*(_rgba*)&surp->status.mem[soff+5];
        *(_rgba*)&surp->status.mem[doff+6]=*(_rgba*)&surp->status.mem[soff+6];
        *(_rgba*)&surp->status.mem[doff+7]=*(_rgba*)&surp->status.mem[soff+7];
        doff+=8;
        soff+=8;
        left-=8;
        }
        while(1);
       do
        {
        if(left==0) { break; }
        *(_rgba*)&surp->status.mem[doff++]=  *(_rgba*)&surp->status.mem[soff++];
        left--;
        }
       while(1);
       }
      if(pn==NULL) { return RET_YES; }
      if(pn->a==0) { return RET_YES; }
      aaRectSet(&r1,mr.x,(mr.y+mr.h)-yy,mr.w,yy);
      aaSurfaceFill(handle,&r1,pn);
      return RET_YES;
      }
     }
    }
   }
  }

 if((ret=aa_MemoryTemp((VP)&tmp,((rect->w+xx)*4)*(rect->h+yy),aa_MEMORYTEMP_SurfaceScroll))!=RET_YES) { return ret; }

 if((ret=aaSurfaceMake(&tmp_handle,&s1,tmp))!=RET_YES) { oops; }
 if(xpixels>=0&&ypixels<0) // scroll up, possible scroll right
  {
  //aaDebugf("line=%i",__LINE__);
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x+xpixels,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha); // was ,0,0,0);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha); // was ,0,0,0);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,(mr.y+mr.h)-ypixels,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,mr.x,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 else
 if(xpixels>=0&&ypixels>=0) // possible scroll down, possible scroll right
  {
  //aaDebugf("line=%i",__LINE__);
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x+xpixels,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha); // was ,0,0,0);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha); // was ,0,0,0);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,mr.y,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,mr.x,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 else
 if(xpixels<0&&ypixels<0)  // scrolll left, scroll up
  {
 // aaDebugf("line=%i",__LINE__);
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x+xpixels,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha); // was ,0,0,0);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha); // was ,0,0,0);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,(mr.y+mr.w)-ypixels,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,(mr.x+mr.w)-xpixels,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 else
 if(xpixels<0&&ypixels>=0) // scroll left, possible scroll down
  {
  ///aaDebugf("line=%i",__LINE__);
  ypixels=aaNumAbs(ypixels);
  xpixels=aaNumAbs(xpixels);
  aaRectSet(&r1,mr.x+xpixels,mr.y,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r2,0,0,mr.w-xpixels,mr.h-ypixels);
  aaRectSet(&r3,mr.x,mr.y+ypixels,mr.w-xpixels,mr.h-ypixels);
  aaSurfaceImageDraw(tmp_handle,&surp->status.size,&r1,surp->status.mem,&r2,0,0,alpha); // was ,0,0,0);
  aaSurfaceImageDraw(handle,&s1,&r2,tmp,&r3,0,0,alpha); // was ,0,0,0);
  if(pn)
   {
   if(ypixels!=0) { aaRectSet(&r1,mr.x,mr.y,mr.w,ypixels); aaSurfaceFill(handle,&r1,pn); }
   if(xpixels!=0) { aaRectSet(&r1,(mr.x+mr.w)-xpixels,mr.y,xpixels,mr.h); aaSurfaceFill(handle,&r1,pn); }
   }
  }
 aaSurfaceDestroy(tmp_handle);
 return RET_YES;
 }





 B aaSurfaceBevel                      (H handle,_rect*rect,_rgba*p1,B state)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rgba mr;//,pn;
 _rgba pna,pnb,pnc,pnd;
 _rect r1;
 _cord c1,c2;
// _hlsa hs,mhs;
// N ll1;//,amb,mul;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(p1==NULL) { aaRgbaCopy(&mr,&col_gray[20]); }
 else         { aaRgbaCopy(&mr,p1); }
 if(rect==NULL) { aaRectSet(&r1,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&r1,rect); }

 if(mr.a!=0)
  {
  aaSurfaceFill(handle,&r1,&mr);
  }
 else
  {
  aaRgbaCopy(&mr,&col_gray[20]);
  }
 if(state)
  {
  aaRgbaSet(&pnb,0,0,0,120);
  aaRgbaSet(&pna,80,80,80,140);
  aaRgbaSet(&pnd,160,160,160,160);
  aaRgbaSet(&pnc,215,215,215,170);
  }
 else
  {
  aaRgbaSet(&pnc,0,0,0,120);
  aaRgbaSet(&pnd,80,80,80,140);
  aaRgbaSet(&pna,180,180,180,160);
  aaRgbaSet(&pnb,215,215,215,170);
  }
  // top line
  aaCordsSet(&c1,&c2,r1.x,r1.y,(r1.x+r1.w)-1,r1.y); aaSurfaceLine(handle,&c1,&c2,&pna);
  // left line
  aaCordsSet(&c1,&c2,r1.x,r1.y,r1.x,(r1.y+r1.h)-1); aaSurfaceLine(handle,&c1,&c2,&pna);
  // top line 1 down
  aaCordsSet(&c1,&c2,r1.x+1,r1.y+1,(r1.x+r1.w)-2,r1.y+1); aaSurfaceLine(handle,&c1,&c2,&pnb);
  // left line 1 right
  aaCordsSet(&c1,&c2,r1.x+1,r1.y+1,r1.x+1,(r1.y+r1.h)-2); aaSurfaceLine(handle,&c1,&c2,&pnb);
  // right line
  aaCordsSet(&c1,&c2,(r1.x+r1.w)-1,r1.y,(r1.x+r1.w)-1,(r1.y+r1.h)-1); aaSurfaceLine(handle,&c1,&c2,&pnc);
  // bottom line
  aaCordsSet(&c1,&c2,r1.x,(r1.y+r1.h)-1,(r1.x+r1.w)-1,(r1.y+r1.h)-1); aaSurfaceLine(handle,&c1,&c2,&pnc);
  // right line 1 left
  aaCordsSet(&c1,&c2,(r1.x+r1.w)-2,r1.y+1,(r1.x+r1.w)-2,(r1.y+r1.h)-2); aaSurfaceLine(handle,&c1,&c2,&pnd);
  // botom line 1 up
  aaCordsSet(&c1,&c2,r1.x+1,(r1.y+r1.h)-2,(r1.x+r1.w)-2,(r1.y+r1.h)-2); aaSurfaceLine(handle,&c1,&c2,&pnd);
 return RET_YES;
 }






 B aaSurfaceBlur                       (H handle,_rect*rect,B hstrength,B vstrength)
 {
 B ret;
 N i,j;
 N r1,r2,r3;
 N g1,g2,g3;
 N b1,b2,b3;
// N a1,a2,a3;
// _rgba p1;
 H imgw,imgh;
 N x,y;
 H w,h;
 H off;
// _cord c1;
 _aa_surfaceobject*surp;
 _rect rr,rx;
// _rect clip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 if(vstrength==0&&hstrength==0) { return RET_YES; }
 imgw=surp->status.size.w;
 imgh=surp->status.size.h;
 x=rr.x;
 y=rr.y;
 w=rr.w;//imgw;
 h=rr.h;//imgh;
 if(x<=0) x=1;
 if(h<=0) y=1;
 if(x+w>=imgw) w=imgw-x-1;
 if(y+h>=imgh) h=imgh-y-1;

 aaRectSet(&rx,x,y,w,h);
 if(rx.x<0) { rx.x=0; }
 if(rx.y<0) { rx.y=0; }
 if((rx.x+rx.w)>=surp->status.size.w) { rx.w=surp->status.size.w-rx.x; }
 if((rx.y+rx.h)>=surp->status.size.h) { rx.h=surp->status.size.h-rx.y; }
 //aaSurfaceClipperGet(handle,&clip);
 //aaSurfaceClipperSet(handle,&rx);

 while(hstrength--)
  {
  for(j=0;j<(N)h;j++) // ningy added (N)
   {
   if((x+0)<(rx.x)) { continue; }
   if((y+j)<(rx.y)) { continue; }
   if((H)(x+0)>=(rx.x+rx.w)) { continue; }
   if((H)(y+j)>=(rx.y+rx.h)) { continue; }

   off=((y+j)*imgw)+x;
   r2=surp->status.mem[off].r;
   g2=surp->status.mem[off].g;
   b2=surp->status.mem[off].b;
   r3=r2; g3=g2; b3=b2;
   if((H)(x+1)<(rx.x+rx.w))
    {
    r3=surp->status.mem[off+1].r;
    g3=surp->status.mem[off+1].g;
    b3=surp->status.mem[off+1].b;
    }
   for(i=0;i<(N)w;i++) // ningy added (N)
    {
    if((H)(x+i)<(rx.x+rx.w))
     {
     r1=r2;    r2=r3;    r3=surp->status.mem[off+1+i].r;
     g1=g2;    g2=g3;    g3=surp->status.mem[off+1+i].g;
     b1=b2;    b2=b3;    b3=surp->status.mem[off+1+i].b;
     surp->status.mem[(off+1+i)].r=(B)((r1+r2+r3)/3);
     surp->status.mem[(off+1+i)].g=(B)((g1+g2+g3)/3);
     surp->status.mem[(off+1+i)].b=(B)((b1+b2+b3)/3);
     }
    }
   }
  }

 while(vstrength--)
  {
  for(i=0;i<(N)w;i++)  // ningy added (N)
   {
   if((x+i)<(rx.x)) { continue; }
   if((y+0)<(rx.y)) { continue; }
   if((H)(x+i)>=(rx.x+rx.w)) { continue; }
   if((H)(y+0)>=(rx.y+rx.h)) { continue; }
   off=(y*imgw)+(x+i);
   r2=surp->status.mem[off].r;
   g2=surp->status.mem[off].g;
   b2=surp->status.mem[off].b;
   r3=r2; g3=g2; b3=b2;
   if((H)(y+1)<=(rx.y+rx.h))
    {
    r3=surp->status.mem[off+imgw].r;
    g3=surp->status.mem[off+imgw].g;
    b3=surp->status.mem[off+imgw].b;
    }
   for(j=0;j<(N)h;j++) // ningy added (N)
    {
    if((H)(y+j)<(rx.y+rx.h))
     {
     r1=r2;    r2=r3;    r3=surp->status.mem[off+(imgw*j)].r;
     g1=g2;    g2=g3;    g3=surp->status.mem[off+(imgw*j)].g;
     b1=b2;    b2=b3;    b3=surp->status.mem[off+(imgw*j)].b;
     surp->status.mem[off+(imgw*j)].r=(B)((r1+r2+r3)/3);
     surp->status.mem[off+(imgw*j)].g=(B)((g1+g2+g3)/3);
     surp->status.mem[off+(imgw*j)].b=(B)((b1+b2+b3)/3);
     }
    }
   }
  }
 //aaSurfaceClipperSet(handle,&clip);
 return RET_YES;
 }





 // output_handle ,, needs to be integrated back to input handle

//F mat[9]= {-1, -2, -1,-2, 20, -2,	-1, -2, -1    }; // sharpen
//F mat[9]={-1, -2, 0,	-2, 0, 2,	0, 2, 1 }; // edge
//F mat[9]={-1, -2, 0,	-2, 0, 2,	0, 2, 1 }; // base ( neeed to use p1 arg )
//F mat[9]={ 0, -1, 0,	-1, 5,-1,	0,-1, 0 }; // sharpen
//F mat[9]={ 1,  2, 1,	 2, 4, 2,	1, 2, 1 }; // gausian blur


 B aaSurfaceConvolve                   (H handle,_rect*rect,FP matrix,N n,_rgba*p1,B absflag)
 {
 B ret;
 Z x,y,xx,yy,xv,yv,ir,ig,ib,ia;
 N xy,ye,xe,hh,ww;
 F r,g,b,sum;
 BP p,op;
 _aa_surfaceobject*surp;
 _size s1;
 BP tmp;

 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 xy=-n/2;
 ye=rect->h+xy;
 xe=rect->w+xy;
 hh=rect->h+rect->h;
 ww=rect->w+rect->w;
 aaSizeSet(&s1,rect->w,rect->h);
 if((ret=aa_MemoryTemp((VP)&tmp,s1.w*s1.h*4,aa_MEMORYTEMP_SurfaceConvolve))!=RET_YES) { oops; }

 sum=0;
 for(yy=0;yy<n;yy++)
  {
  for(xx=0;xx<n;xx++)  {   sum+=matrix[xx+n*yy];   }
  }
 if(sum<=0) { sum=1; }

 for(y=xy;y<ye;y++)
  {
  for(x=xy;x<xe;x++)
   {
   r=g=b=0;
   for(yy=0;yy<n;yy++)
    {
    for(xx=0;xx<n;xx++)
     {
     xv=x+xx+rect->x;
     yv=y+yy+rect->y;
     if(xv<0) {  xv=-xv; }
     if(yv<0) {  yv=-yv; }
     if(xv>=(Z)surp->status.rect.w)
      {
      xv=xv%ww;
      if(xv>=(Z)surp->status.rect.w)  {  xv=ww-xv-1; }
      }
     if(yv>(Z)surp->status.rect.h)
      {
      yv=yv%hh;
      if(yv>=(Z)surp->status.rect.h)  {  yv=hh-yv-1; }
      }
     aaCast(p,BP,&surp->status.mem[0]);
     p+=(yv*surp->status.rect.w*4)+(xv*4);
     b+=(F)*p++*matrix[xx+n*yy];
     g+=(F)*p++*matrix[xx+n*yy];
     r+=(F)*p  *matrix[xx+n*yy];
     }
    }
   if(absflag)
    {
    if(r<0)   {   r=-r; }
    if(g<0)   {   g=-g; }
    if(b<0)   {   b=-b; }
    }
   ir=r/sum;
   ig=g/sum;
   ib=b/sum;
   ia=255;
   if(p1) {  ir+=p1->r; ig+=p1->g;  ib+=p1->b;  ia=p1->a;  }
   ir=aaNumClamp(ir,0,255);
   ig=aaNumClamp(ig,0,255);
   ib=aaNumClamp(ib,0,255);
   ia=aaNumClamp(ia,0,255);
   if(x>=0&&y>=0&&x<(Z)s1.w&&y<(Z)s1.h)
    {
    aaCast(op,BP,&tmp[0]);
    op+=(y*s1.w*4)+(x*4);
    *op++=(B)ib;
    *op++=(B)ig;
    *op++=(B)ir;
    *op++=(B)ia;
    }
   }
  }
 // if p1==NULL or p1->a==255 then imagedraw should use,255 for last parm, maybe it will be faster ?
 aaSurfaceImageDraw(handle,&s1,0,tmp,rect,0,0,0);
 return RET_YES;
 }



 B aaSurfaceButtonFrame                (H handle,_rect*r1,B state,B depth)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rgba pn[4];
 _rect ra,r2;
 _cord c1,c2,c3,c4;
 B d,pa,pb;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&ra,r1);
 if(state==0)
  {
  aaRgbaCopy(&pn[0],&col_gray[0]);  aaRgbaCopy(&pn[1],&col_gray[16]);
  aaRgbaCopy(&pn[2],&col_gray[24]); aaRgbaCopy(&pn[3],&col_gray[31]);
  }
 else
 if(state==1)
  {
  aaRgbaCopy(&pn[0],&col_gray[31]); aaRgbaCopy(&pn[1],&col_gray[24]);
  aaRgbaCopy(&pn[2],&col_gray[0]);  aaRgbaCopy(&pn[3],&col_gray[16]);
  }
 aaRectCopy(&r2,&ra);
 pa=2;
 pb=0;
 for(d=0;d<depth;d++)
  {
  aaRectToCornerCords(&ra,&c1,&c2,&c3,&c4);
  aaSurfaceLine(handle,&c1,&c2,&pn[pa]);
  aaSurfaceLine(handle,&c1,&c4,&pn[pa]);
  aaSurfaceLine(handle,&c2,&c3,&pn[pb]);
  aaSurfaceLine(handle,&c3,&c4,&pn[pb]);
  aaRectExpand(&ra,-1,-1);
  pa=3;
  pb=1;
  }
 return RET_YES;
 }


 /*
 gradient rules:
 type 0=linear   scale=(-5.0 to +0.5=spread )                            tilt=tilt (0-90 )
 type 1=radial   scale=(-5.0 to +0.5=spread )                            tilt=tilt
 type 2=square   scale=(-5.0 to +0.5=spread, >+0.5 is reversed )         tilt=tilt
 type 3=conict   scale=(-5.0 to +0.5=spread, >+0.5 is reversed )         tilt=( not used )
 */




 B aaSurfaceGradientFill               (H handle,_rect*rect,_cord*c1,_rgba*p1,_rgba*p2,B type,F tilt)
 {
 B ret;
 H wid,hit,ok,off;
 N x,y,dx,dy,ox,oy,xx,yy;
 F f1,f2,dv,s,ang,sn,cs;
 _rgba p3;
// _cord cd;
 N maxdist;
 F scale,om;
 _aa_surfaceobject*surp;
 _rect rr;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 scale=0.5;

 wid=rr.w;
 hit=rr.h;
 ox=oy=0;
 if(c1!=NULL)
  {
  ox=c1->x;
  oy=c1->y;
  }
                                      // ningy added (N)
 maxdist=aaNumMax(ox,(N)wid-ox); // Max distance to any point in pixmap
 maxdist=aaNumMax(maxdist,oy);
 maxdist=aaNumMax(maxdist,(N)hit-oy);
 dv=(1.0-2*scale);
 if(type==aa_GRADIENT_Linear)  // linear
  {
  if(tilt==90) { s=wid; }
  else
   {
   ang=tan(tilt*(aaPi/180.0));
   s=aaNumAbs(ang*wid+(ang<0?(-(N)hit):(N)hit))/sqrt(ang*ang+1); // ningy added : (N)hit
   }
  cs=cos(tilt*(aaPi/180.0)); /* For rotation of coords */
  sn=sin(tilt*(aaPi/180.0));

  ok=0;
  pstylep=(_pixelstyle*)&surp->status.pixl_style;
  if(pstylep->mode==0&&p1->a==255&&surp->PixelPut==aaSurfacePixelPutProc&&surp->PixelSet==aaSurfacePixelSetProc)
   {
   if(rr.x>=0&&rr.y>=0&&rr.w>0&&rr.h>0)
    {
    if((rr.x+rr.w)<=surp->status.size.w&&(rr.y+rr.h)<=surp->status.size.h)
     {
     if(surp->status.is_clipper==NO&&surp->status.is_vflip==NO)
      {
      if(surp->status.is_mask==NO&&surp->status.is_masknot==NO)
       {
       ok=1;
       for(y=0;y<(N)hit;y++) // ningy added (N)
        {
        off=((rr.y+y)*surp->status.size.w)+rr.x;
        for(x=0;x<(N)wid;x++) // ningy added (N)
         {
         yy=x*sn+y*cs;
         f1=(((F)yy)/s-dv);
         if(dv!=0) { f1=f1/dv; }
         f1=aaNumClamp(f1,0.0,1.0);
         om=1-f1;
         p3.r=(om)*p1->r+f1*p2->r;
         p3.g=(om)*p1->g+f1*p2->g;
         p3.b=(om)*p1->b+f1*p2->b;
         p3.a=(om)*p1->a+f1*p2->a;
         *(_rgba*)&surp->status.mem[off++]=p3;
         }
        }
       }
      }
     }
    }
   }

  if(ok==0)
   {
   for(y=0;y<(N)hit;y++) // ningy added (N)
    {
    for(x=0;x<(N)wid;x++) // ningy added (N)
     {
     yy=x*sn+y*cs;
     f1=(((F)yy)/s-dv);
     if(dv!=0) { f1=f1/dv; }
     f1=aaNumClamp(f1,0.0,1.0);
     om=1-f1;
     p3.r=(om)*p1->r+f1*p2->r;
     p3.g=(om)*p1->g+f1*p2->g;
     p3.b=(om)*p1->b+f1*p2->b;
     p3.a=(om)*p1->a+f1*p2->a;
     //aaCordSet(&cd,rr.x+x,rr.y+y);
     surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
     //surp->(handle,&cd,&p3);
     }
    }
   }
  }
 else
 if(type==aa_GRADIENT_Radial) // radial
  {
  for(y=0;y<(N)hit;y++) // ningy added (N)
   {
   for(x=0;x<(N)wid;x++) // ningy added (N)
    {
    dx=x-ox;
    dy=y-oy;
    f2=dx*dx+dy*dy;
    f1=sqrt(f2);
    f2=maxdist-scale;
    f1=f1/f2;
    if(dv!=0)  {        f1=f1/dv;          }
    f1=aaNumClamp(f1,0.0,1.0);
    p3.r=(1-f1)*p1->r+f1*p2->r;
    p3.g=(1-f1)*p1->g+f1*p2->g;
    p3.b=(1-f1)*p1->b+f1*p2->b;
    p3.a=(1-f1)*p1->a+f1*p2->a;
//    aaCordSet(&cd,rr.x+x,rr.y+y);
//    aaSurfacePixelSet(handle,&cd,&p3);
    surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
    }
   }
  }
 else
 if(type==aa_GRADIENT_Square) // square
  {
  cs=cos(tilt*(aaPi/180.0));
  sn=sin(tilt*(aaPi/180.0));
  for(y=0;y<(N)hit;y++)// ningy added (N)
   {
   for(x=0;x<(N)wid;x++)// ningy added (N)
    {
    // transform coords and take absolute value
    dx=x-ox;
    dy=y-oy;
     // work-around for sco v5 cc internal compiler error
    xx=dx*cs-dy*sn;
    if(xx<0) xx=-xx;
    yy=dx*sn+dy*cs;
    if(yy<0) yy=-yy;
    if(xx<yy) s=yy;
    else     s=xx;
    f1=(((F)s)/maxdist-scale);
    if(dv!=0) { f1=f1/dv; }
    f1=aaNumClamp(f1,0.0,1.0);
    p3.r=(1-f1)*p1->r+f1*p2->r;
    p3.g=(1-f1)*p1->g+f1*p2->g;
    p3.b=(1-f1)*p1->b+f1*p2->b;
    p3.a=(1-f1)*p1->a+f1*p2->a;
//    aaCordSet(&cd,rr.x+x,rr.y+y);
//    aaSurfacePixelSet(handle,&cd,&p3);
    surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
    }
   }
  }
 else
 if(type==aa_GRADIENT_Cone) // cone
  {
  for(y=0;y<(N)hit;y++)// ningy added (N)
   {
   for(x=0;x<(N)wid;x++)// ningy added (N)
    {
    dx=x-ox;
    dy=y-oy;
    if(dx==0) ang=dy>0?270:90;
    else
     {
     ang=atan(((F)dy)/((F)dx));
     ang*=1.0/(aaPi/180.0);
     if(dx>0) ang=ang+180.0;
     while(ang<0) ang+=360.0;
     }
    ang+=tilt;
    while(ang>360.0)  ang-=360.0;
   if(ang>180.0) ang=360.0-ang;
   f1=(ang/180.0-scale);
   if(dv!=0) { f1=f1/dv; }
   f1=aaNumClamp(f1,0.0,1.0);
   p3.r=(1-f1)*p1->r+f1*p2->r;
   p3.g=(1-f1)*p1->g+f1*p2->g;
   p3.b=(1-f1)*p1->b+f1*p2->b;
   p3.a=(1-f1)*p1->a+f1*p2->a;
   // aaCordSet(&cd,rr.x+x,rr.y+y);
    //aaSurfacePixelSet(handle,&cd,&p3);
    surp->PixelPut(surp,rr.x+x,rr.y+y,&p3);
    }
   }
  }

 return RET_YES;
 }




 /*
 usecaret: if you have mroe than one field, and you want to draw one which is not the field in focus,,
 you dont want it to change the caret position of the main one. so you can disable it with usecaret=NO
 */

 B aaSurfaceField                      (H handle,_rect*rect,_rgba*p1,H fhandle,_rgba*p2,B masked,N xadj,N yadj,B usecaret,H pos,H maxchars,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1,r2;
 _cord c1;
 _aa_fontobject*fntp;
 va_list argptr;
 B txt[_6K];
 N pixels;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(fhandle==0) {  fhandle=aa.font_system.font_8x8; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&r1,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&r1,rect); }
 if(maxchars==0) { aaStringLen(txt,&maxchars); }
 pixels=fntp->status.size.h;
 if(masked==NO)
  {
  aaStringCopy(&txt[_2K],&txt[0]);
  }
 else
  {
  aaStringLen(&txt[0],&sl);
  aaMemoryFill(&txt[_2K],sl,'*');
  txt[_2K+sl]=NULL_CHAR;
  }

 aaSurfaceLabel(handle,&r1,p1,fhandle,p2,xadj,yadj,0,1,maxchars,"%s",&txt[_2K]);
 // if was shown at this point,, then set a flag in surfaceobject,, to reshow caret after next blit
 if(usecaret==YES)
  {
  aaFontStringCharRectGet(fhandle,&r2,pos,0,"%s",&txt[_2K]);
  aaCordSet(&c1,r1.x,r1.y+(r1.h/2));
  aaCordAdjust(&c1,r2.x,-(pixels/2));
  aaCordAdjust(&c1,xadj,yadj);
  aaRectSet(&r2,c1.x,c1.y,2,pixels);
  if((c1.y>r1.y)&&((r2.h+1)<r1.h)) { r2.y-=2; r2.h+=3; }
  if(r2.y<r1.y) { r2.y=r1.y; }
  if(r2.h>r1.h) { r2.h=r1.h; }
  aaSurfaceCaretRectSet(handle,&r2);
  }
 return RET_YES;
 }






 B aaSurfaceLog                        (H handle,_rect*rect,_rgba*p1,H fhandle,_rgba*p2,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect r1,r2;
 _size s1;
 _aa_fontobject*fntp;
 va_list argptr;
 B txt[_64K];
 N pixels;
 _parser pa,pb;
 H pos;
 B line_type;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(fhandle==0) { fhandle=aa.font_system.font_8x8; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.font_system.object_id,fhandle,(VP)&fntp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&r1,0,0,surp->status.rect.w,surp->status.rect.h); }
 else           { aaRectCopy(&r1,rect); }
 pixels=fntp->status.size.h+4;
// pixels+=fntp->status.v_bias;
 aaRectToSize(&r1,&s1);
 aaParserInit(&pa,txt,0);
 while(1)
  {
  //oof; //
  aaSurfaceScroll(handle,&r1,0,aaNumNeg(pixels),p1);
  aaRectSet(&r2,r1.x,((r1.y+r1.h)-pixels),r1.w,pixels);
  aaStringFindCharList(pa.bp,0,&pos,"\r\n",YES,0,YES);
  if(pos!=F32)
   {
   line_type=pa.bp[pos];
   if(line_type==CR_CHAR) { line_type=aa_STRINGMODE_CR; }
   else
   if(line_type==LF_CHAR) { line_type=aa_STRINGMODE_LF; }
   if(line_type==aa_STRINGMODE_CR)  {    if(pa.bp[pos+1]==LF_CHAR) { line_type=aa_STRINGMODE_CRLF; }    }

   aaParserCopy(&pb,&pa,NO);
   pb.bp[pos]=NULL_CHAR;
   aaSurfaceLabel(handle,&r2,(p1==NULL)?&col_gray[4]:p1,fhandle,(p2==NULL)?&col_gray[23]:p2,1,0,0,1,0,"%s",pb.bp);
   aaParserSeek(&pa,pos+1);
   if(line_type==aa_STRINGMODE_CRLF) { aaParserSeek(&pa,1); }
   continue;
   }
  aaSurfaceLabel(handle,&r2,(p1==NULL)?&col_gray[4]:p1,fhandle,(p2==NULL)?&col_gray[23]:p2,1,0,0,1,0,"%s",pa.bp);
  break;
  }
 if(surp->status.is_log_write) { aaLog(-777,"%s",txt); }
 return RET_YES;
 }







 B aaSurfaceLogWriteSet                (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state==YES) { surp->status.is_log_write=YES; }
 else { surp->status.is_log_write=NO; }
 return RET_YES;
 }



// do we need to set spot_order_ok=NO after every update or blit or wm_paint


 B aaSurfaceUpdateAreaAdd              (H handle,_rect*rect,B update)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 rr.x=aaNumClamp(rr.x,0,(N)surp->status.size.w); // ningy added (N)
 rr.y=aaNumClamp(rr.y,0,(N)surp->status.size.h); // ningy added (N)
 rr.w =aaNumRoof(rr.w,(surp->status.size.w-rr.x));
 rr.h =aaNumRoof(rr.h,(surp->status.size.h-rr.y));
 if(rr.w==0||rr.h==0) {  return RET_BADPARM;  /*aaNote(0,"line=%i rr.w=%i rr.h=%i",__LINE__,rr.w,rr.h); */}
 if((aaUpdateAreaAdd(&surp->status.update_area,&rr))!=YES) oops;
 if(update) {  aaSurfaceUpdate(handle); }
 return RET_YES;
 }


 B aaSurfaceUpdateAreaRemove           (H handle,_rect*rect,B update)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect rr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(rect==NULL) { aaRectSet(&rr,0,0,surp->status.size.w,surp->status.size.h); }
 else           { aaRectCopy(&rr,rect); }
 rr.x=aaNumClamp(rr.x,0,(N)surp->status.size.w); // ningy added (N)
 rr.y=aaNumClamp(rr.y,0,(N)surp->status.size.h); // ningy added (N)
 rr.w =aaNumRoof(rr.w,(surp->status.size.w-rr.x));
 rr.h =aaNumRoof(rr.h,(surp->status.size.h-rr.y));
 if(rr.w==0||rr.h==0) {  return RET_BADPARM; }
 if((aaUpdateAreaRemove(&surp->status.update_area,&rr))!=YES) oops;
 if(update) {  aaSurfaceUpdate(handle); }
 return RET_YES;
 }


 B aaSurfaceUpdateAreaReset            (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aaUpdateAreaReset(&surp->status.update_area))!=RET_YES) { oops; }
 return RET_YES;
 }




 B aaSurfaceUpdate                     (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 RECT r1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_visual!=YES) { return RET_FAILED; }
 if(surp->status.update_area.state==YES)
  {
  r1.left=surp->status.update_area.rect.x;
  r1.top=surp->status.update_area.rect.y;
  r1.right=(r1.left+surp->status.update_area.rect.w)-0;
  r1.bottom=(r1.top+surp->status.update_area.rect.h)-0;
  aaSurfaceBlit(handle,&surp->status.update_area.rect,0,&surp->status.update_area.rect,NO);
//  aaDebugf("ud: %i,%i,%i,%i",aaRectParts(surp->status.update_area.rect));
  ///if(ValidateRect(surp->status.hwnd,&r1)==0) { oof; oow; }
  }
 if((ret=aaSurfaceUpdateAreaReset(handle))!=RET_YES) { oops; }
 return RET_YES;
 }



 B aaSurfaceUpdateAndStatus            (H handle,_surfacestatus*status)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaSurfaceUpdate(handle))!=YES) { return ret; }
 if(status)
  {
  aaSurfaceStatus(handle,status);
  }
 return RET_YES;
 }





 B aaSurfaceCaptureScreen              (H handle,_rect*r1,HWND hwnd,_rect*r2,B vflip)
 {
 B ret;
 _aa_surfaceobject*surp;
 BITMAPINFO bmi;
 BP dib_data;
 _size s1;
 _rect rr1,rr2;
 HWND source_hwnd;
 HDC source_dc,capture_dc;
 HBITMAP bmp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(hwnd==0) { hwnd=GetDesktopWindow(); }
 source_hwnd=hwnd;
 if(r1==NULL) { aaRectSet(&rr1,0,0,surp->status.size.w,surp->status.size.h); } //800,600); }
 else         { aaRectCopy(&rr1,r1); }
 if(r2==NULL) { aaRectCopy(&rr2,&rr1); } //aaRectSet(&rr2,0,0,surp->status.size.w,surp->status.size.h); }
 else         { aaRectCopy(&rr2,r2); }


       source_dc=GetDC(source_hwnd);
       capture_dc=CreateCompatibleDC(source_dc);
         WinBmpInfoSet(&bmi,rr1.w,(vflip)?-rr1.h:rr1.h,32,NO);
   bmp=CreateDIBSection(capture_dc,(LPBITMAPINFO)&bmi,DIB_RGB_COLORS,(V**)&dib_data,NULL,0);
         SelectObject(capture_dc,bmp);

          //if(SetStretchBltMode(capture_dc,COLORONCOLOR)==0) oof;
          if(SetStretchBltMode(capture_dc,HALFTONE)==0) oof;


  StretchBlt(capture_dc,rr2.x,rr2.y,rr2.w,rr2.h,source_dc,rr1.x,rr1.y,rr1.w,rr1.h,SRCCOPY);
   aaSizeSet(&s1,rr1.w,rr1.h);
  if(aaRectEqualsRect(&rr1,&rr2)==YES&&aaSizeEqualsSize(&s1,&surp->status.size)==YES)
   {
   aaMemoryCopy(surp->status.mem,s1.w*s1.h*4,dib_data);
   }
  else
   {
   aaRectSet(&rr1,0,0,s1.w,s1.h);
   aaSurfaceImageDraw(handle,&s1,&rr1,dib_data,&rr2,0,0,255);
   }

   ReleaseDC(source_hwnd,source_dc);
   DeleteObject(bmp);
   DeleteDC(capture_dc);

   #if 1
   {
   H xx,yy,off,rem,div,mod;
   off=((rr2.y+0)*surp->status.size.w)+rr2.x;
   rem=surp->status.size.w-rr2.w;
   div=rr2.w/16;
   mod=rr2.w%16;
   for(yy=0;yy<rr2.h;yy++)
    {
    for(xx=0;xx<div;xx++)
     {
     surp->status.mem[off+0].a=255;      surp->status.mem[off+1].a=255;     surp->status.mem[off+2].a=255;     surp->status.mem[off+3].a=255;
     surp->status.mem[off+4].a=255;      surp->status.mem[off+5].a=255;     surp->status.mem[off+6].a=255;     surp->status.mem[off+7].a=255;
     surp->status.mem[off+8].a=255;      surp->status.mem[off+9].a=255;     surp->status.mem[off+10].a=255;    surp->status.mem[off+11].a=255;
     surp->status.mem[off+12].a=255;     surp->status.mem[off+13].a=255;    surp->status.mem[off+14].a=255;    surp->status.mem[off+15].a=255;
     off+=16;
     }
    for(xx=0;xx<mod;xx++)
     {
     surp->status.mem[off++].a=255;
     }
    off+=rem;
    }
   }
  #endif
 return RET_YES;
 }






 B aaSurfaceExtraDataSet               (H handle,H bytes)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)
  {
  if(surp->status.extra_bytes!=0)
   {
   if((ret=aaMemoryRelease(surp->status.extra_data))!=RET_YES) { oops; }
   }
  surp->status.extra_data=NULL;
  surp->status.extra_bytes=bytes;
  }
 else
  {
  if(surp->status.extra_bytes==0)
   {
   surp->status.extra_data=NULL;
   }
  if(surp->status.extra_bytes!=bytes)
   {
   if((ret=aaMemoryMake((VP)&surp->status.extra_data,bytes))!=RET_YES) { oops; }
   }
  surp->status.extra_bytes=bytes;
  }
 return RET_YES;
 }








 B aaSurfaceExtraDataGet               (H handle,HP bytes,PP ptr)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif if(bytes) { *bytes=0; }
 if(ptr)  { *ptr=NULL; }
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(bytes) { *bytes=surp->status.extra_bytes; }
 if(ptr)   { *ptr=surp->status.extra_data; }
 return RET_YES;
 }




 B aaSurfaceDropClear                  (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surp->status.is_drop_accept!=YES)
  {
  return RET_FAILED;
  }
 if(surp->status.drop_count!=0)
  {
  aaListReset(&surp->status.drop_list);
  surp->status.drop_count=0;
  }
 return RET_YES;
 }




 B aaSurfaceDropAccept                 (H handle,B state)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(state)
  {
  if(surp->status.is_drop_accept!=YES)
   {
   DragAcceptFiles(surp->status.hwnd,YES);
   surp->status.is_drop_accept=YES;
   }
  }
 else
  {
  if(surp->status.is_drop_accept==YES)
   {
   DragAcceptFiles(surp->status.hwnd,NO);
   surp->status.is_drop_accept=NO;
   }
  }
 return RET_YES;
 }







///=====================================================



 B aaSurfaceSpotIdRangeReserve         (H handle,HP firstid,H count)
 {
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(firstid==NULL) { return RET_BADPARM; }
 *firstid=0;
 if(count==0) { return RET_BADPARM; }
 surp->spot_id_counter++;
 *firstid=surp->spot_id_counter;
 surp->spot_id_counter+=count;
 return RET_YES;
 }









 B aaSurfaceSpotFindByNumber           (H handle,H sn,_surfacespot**surfacespot)
 {
 B ret;
 _aa_surfaceobject*surp;
 H i,mx,sc,checked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 sc=surp->status.spot_count;
 if(sn>=sc) { return RET_BOUNDS; }
 mx=surp->status.spot_slots;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=sc) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  if(sn==checked)
   {
   //if(id) { *id=surp->status.spot[i].id; }
   if(surfacespot) { *surfacespot=(_surfacespot*)&surp->status.spot[i]; }
   return RET_YES;
   }
  checked++;
  }
 oof;
 return RET_FAILED;
 }



 B aaSurfaceSpotFindById               (H handle,H id,_surfacespot**surfacespot)
 {
 H i,mx,checked;
 B ret;
 _aa_surfaceobject*surp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 if(id==0) { return RET_BADPARM; }
 mx=surp->status.spot_slots;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=surp->status.spot_count) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  checked++;
  if(surp->status.spot[i].id!=id) { continue; }
  if(surfacespot) { *surfacespot=(_surfacespot*)&surp->status.spot[i]; }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }







 B aaSurfaceSpotAdd                    (H handle,H id,_surfacespot**surfacespot)
 {
 H i,ix,mx,f,left,add,by;
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*ss;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 if(id==0) { return RET_BADPARM; }
 if((ret=aaSurfaceSpotFindById(handle,id,&ss))==RET_YES)
   {
   ix=ss->index;
   surp->status.spot[ix].id=id;
   if(surfacespot) { *surfacespot=(_surfacespot*)ss; }//&surp->status.spot[ix]; }
   return RET_YES;
   }
 if(ret!=RET_NOTFOUND) { oops; }
 by=sizeof(_surfacespot);
 left=surp->status.spot_slots-surp->status.spot_count;
 if(left<5)
  {
  add=surp->status.spot_slots+10;
  if(surp->status.spot_slots==0)
   {
   if((ret=aaMemoryAllocate((VP)&surp->status.spot,add*by))!=RET_YES) { oops; }
   aaMemoryNameSet(surp->status.spot,"spott");
   if((ret=aaMemoryAllocate((VP)&surp->status.spot_id_order,add*sizeof(H)))!=RET_YES) { oops; }
   aaMemoryNameSet(surp->status.spot_id_order,"spotidord");
   //citsys01: if((ret=aaMemoryAllocate((VP)&surp->status.spot_index_order,add*sizeof(H)))!=RET_YES) { oops; }
   }
  else
   {
   if((ret=aaMemoryReAllocate((VP)&surp->status.spot,add*by))!=RET_YES) { oops; }
   if((ret=aaMemoryReAllocate((VP)&surp->status.spot_id_order,add*sizeof(H)))!=RET_YES) { oops; }
   //citsys01: if((ret=aaMemoryReAllocate((VP)&surp->status.spot_index_order,add*sizeof(H)))!=RET_YES) { oops; }
   }
  if(ret!=RET_YES) { oops; return ret; }
  surp->status.spot_slots=add;
  left=surp->status.spot_slots-surp->status.spot_count;
  }
 f=F32;
 mx=surp->status.spot_slots;
 for(i=0;i<mx;i++)
  {
  if(surp->status.spot[i].id==0&&f==F32) { f=i; break; }
  }
 if(f==F32) { oof; }
 i=f;
 aaMemoryFill(&surp->status.spot[i],by,0);
 surp->status.spot[i].id=id;
 surp->status.spot[i].index=i;
 surp->status.spot_count++;
 if(surp->status.spot[i].rect.w==0) { surp->status.spot[i].rect.w=1; }
 if(surp->status.spot[i].rect.h==0) { surp->status.spot[i].rect.h=1; }
 if(surfacespot) { *surfacespot=(_surfacespot*)&surp->status.spot[i]; }
 surp->status.spot_order_ok=NO;
 return RET_YES;
 }





 B aaSurfaceSpotRemove                 (H handle,H id)
 {
 B ret;
 _aa_surfaceobject*surp;
 H mx,i,checked;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(id==0) { return RET_BADPARM; }
 mx=surp->status.spot_slots;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=surp->status.spot_count) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  checked++;
  if(surp->status.spot[i].id!=id) { continue; }
  aaMemoryFill(&surp->status.spot[i],sizeof(_surfacespot),0);
  surp->status.spot[i].id=0;
  surp->status.spot[i].index=0;
  surp->status.spot_count--;
  surp->status.spot_order_ok=NO;
  return RET_YES;
  }
 return RET_NOTFOUND;
 }








 B aaSurfaceSpotPurge                  (H handle)
 {
 B ret;
 _aa_surfaceobject*surp;
 H mx,i,checked,count;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 mx=surp->status.spot_slots;
 count=surp->status.spot_count;
 checked=0;
 for(i=0;i<mx;i++)
  {
  if(checked>=count) { break; }
  if(surp->status.spot[i].id==0) { continue; }
  aaMemoryFill(&surp->status.spot[i],sizeof(_surfacespot),0);
  surp->status.spot[i].id=0;
  surp->status.spot[i].index=0;
  surp->status.spot_count--;
  checked++;
  }
 if(surp->status.spot_count!=0) { oof; }
 surp->status.spot_order_ok=NO;
 return RET_YES;
 }





 B aaSurfaceSpotSet                    (H handle,H id,H type,Z depth,N x,N y,H w,H h,_surfacespot**surfacespot)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 H old_type;
 Z old_depth;
 N old_x,old_y;
 H old_w,old_h;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(surfacespot) { *surfacespot=NULL; }
 if((ret=aaSurfaceSpotAdd(handle,id,&sspot))!=YES) { oops; return ret; }
 old_type=sspot->type;
 old_depth=sspot->depth;
 old_x=sspot->rect.x;
 old_y=sspot->rect.y;
 old_w=sspot->rect.w;
 old_h=sspot->rect.h;
//aaDebugf("%s id=%i type=%i dep=%i %i,%i,%i,%i",__func__,id,type,depth,x,y,w,h);
 if((old_type!=type)||(old_depth!=depth)||(old_x!=x)||(old_y!=y)||(old_w!=w)||(old_h!=h))
  {
  sspot->type=type;
  sspot->depth=depth;
  aaRectSet(&sspot->rect,x,y,w,h);
  surp->status.spot_order_ok=NO;
  }
 if(surfacespot) { *surfacespot=(_surfacespot*)sspot; }
 return RET_YES;
 }





 B aaSurfaceSpotStateSet               (H handle,H id,B isover,B ispress,B isfocus,B ispaint,_surfacespot**surfacespot)
 {
 B ret;
 _aa_surfaceobject*surp;
 _surfacespot*sspot;
 B prev_is_over;
 B prev_is_press;
 B prev_is_focus;
 B prev_is_paint;
 H prev_foc_id;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if((ret=aaSurfaceSpotFindById(handle,id,&sspot))!=YES) { return ret; }
 if(isover>TOGGLE) { return RET_BADPARM; }
 if(ispress>TOGGLE) { return RET_BADPARM; }
 if(isfocus>TOGGLE) { return RET_BADPARM; }
 if(ispaint>TOGGLE) { return RET_BADPARM; }
 prev_is_over=sspot->is_over;
 prev_is_press=sspot->is_press;
 prev_is_focus=sspot->is_focus;
 prev_is_paint=sspot->is_paint;

 prev_foc_id=surp->status.spot_focus_id;

 if(isover!=NEITHER)
  {
  if(isover==TOGGLE) { sspot->is_over^=1; } else
  if(isover<=YES)    { sspot->is_over=isover; }
  }
 if(ispress!=NEITHER)
  {
  if(ispress==TOGGLE) { sspot->is_press^=1; } else
  if(ispress<=YES)    { sspot->is_press=ispress; }
  }
 if(isfocus!=NEITHER)
  {
  if(isfocus==TOGGLE) { sspot->is_focus^=1; } else
  if(isfocus<=YES)    { sspot->is_focus=isfocus; }
  }
 if(ispaint!=NEITHER)
  {
  if(ispaint==TOGGLE) { sspot->is_paint^=1; } else
  if(ispaint<=YES)    { sspot->is_paint=ispaint; }
  }
 if(prev_is_over!=sspot->is_over)
  {
  if(sspot->is_over==YES) { surp->status.spot_over_count++; }
  else                    { surp->status.spot_over_count--; }
  }
 if(prev_is_press!=sspot->is_press)
  {
  if(sspot->is_press==YES) { surp->status.spot_press_count++; }
  else                     { surp->status.spot_press_count--; }
  }
 if(prev_is_focus!=sspot->is_focus)
  {
  if(sspot->is_focus==YES) { surp->status.spot_focus_count++; }
  else                     { surp->status.spot_focus_count--; }
  }
 if(prev_is_paint!=sspot->is_paint)
  {
  if(sspot->is_paint==YES) { surp->status.spot_paint_count++; }
  else                     { surp->status.spot_paint_count--; }
  }

 if(sspot->is_focus==YES)
  {
  if(prev_foc_id!=sspot->id)
   {
   surp->status.spot_focus_id=sspot->id;
   if(prev_foc_id!=0)
    {
    if((ret=aaSurfaceSpotFindById(handle,id,&sspot))!=YES) { return ret; }
    sspot->is_focus=NO;
    }
   }
  }

 if(surfacespot) { *surfacespot=(_surfacespot*)sspot; }
 return RET_YES;
 }











//=====================================================



 B aaSurfaceArrow                      (H handle,_cord*cd1,_cord*cd2,N which,N thick,N hang,D ang,_rgba*pn1,_rgba*pn2)
 {
 B ret;
 _aa_surfaceobject*surp;
 _cord c0,c1,c2,c3;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 N arrowlength,dx,dy;
 H flag;
 D theta,rad,phi2,x2,y2,x1,y1,ang1,ang2;
 _cord*cd1p;
 _cord*cd2p;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 if(which==0)  {  cd1p=cd2;  cd2p=cd1;  }
 else          {  cd1p=cd1;  cd2p=cd2;  }

 ang1=+ang;
 ang2=-ang;
 arrowlength=hang;
 dx=cd2p->x-cd1p->x;
 dy=cd2p->y-cd1p->y;
 theta=atan2(dy,dx);
 rad=(ang1*aaPi/180.0);
 x1=cd2p->x-arrowlength*cos(theta+rad);
 y1=cd2p->y-arrowlength*sin(theta+rad);
 phi2=(ang2*aaPi/180.0);
 x2=cd2p->x-arrowlength*cos(theta+phi2);
 y2=cd2p->y-arrowlength*sin(theta+phi2);

 aaCordSet(&c0,cd1p->x,cd1p->y);
 aaCordSet(&c1,cd2p->x,cd2p->y);
 aaCordSet(&c2,(N)x1,(N)y1);
 aaCordSet(&c3,(N)x2,(N)y2);

 if(thick>1)
  {
  aaSurfacePixelStyleGet(handle,&pstyle_save);
  aaPixelStyleInit(&pstyle_data);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/1),(thick/1),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c2,pn1);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/1),(thick/1),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c3,pn1);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/1),(thick/1),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c0,pn1);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/2),(thick/2),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c2,pn2);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/2),(thick/2),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c3,pn2);
  aaPixelStyleSet(&pstyle_data,7,1,(thick/2),(thick/2),0,0,0,0,handle); aaSurfaceLine(handle,&c1,&c0,pn2);
  aaSurfacePixelStyleSet(handle,&pstyle_save);
  }
 else
  {
  flag=0;
  if(surp->status.pixl_style.mode!=0)
   {
   aaSurfacePixelStyleGet(handle,&pstyle_save);
   aaPixelStyleInit(&pstyle_data);
   aaPixelStyleSet(&pstyle_data,7,0,0,0,0,0,0,0,handle);
   flag=1;
   }
  aaSurfaceLine(handle,&c1,&c2,pn1);
  aaSurfaceLine(handle,&c1,&c3,pn1);
  aaSurfaceLine(handle,&c1,&c0,pn1);
  if(flag)
   {
   aaSurfacePixelStyleSet(handle,&pstyle_save);
   }
  }
 return RET_YES;
 }








 B aaSurfaceCheckMark                  (H handle,_rect*r1,_rgba*p1,_rgba*p2,_rgba*p3)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect ra,r2;
 _cord c1,c2,c3,c4;
 _cord c5,c6,c7;
 _rgba pn1,pn2,pn3;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }

 aaRectCopy(&ra,r1);
 aaRectSet(&r2,ra.x,ra.y,ra.w,ra.h);
 aaRectExpand(&r2,-4,-4);
 aaRectToCornerCords(&r2,&c1,&c2,&c3,&c4);
 aaCordSet(&c5,c1.x+((c2.x-c1.x)*0.00),c1.y+((c4.y-c1.y)*0.50));
 aaCordSet(&c6,c1.x+((c2.x-c1.x)*0.30),c1.y+((c4.y-c1.y)*1.00));
 aaCordSet(&c7,c1.x+((c2.x-c1.x)*1.00),c1.y+((c4.y-c1.y)*0.00));
 if(p1) { aaRgbaCopy(&pn1,p1); } else { aaRgbaSet(&pn1,0,100,0,255); }
 if(p2) { aaRgbaCopy(&pn2,p2); } else { aaRgbaSet(&pn2,0,255,0,192);  }
 if(p3) { aaRgbaCopy(&pn3,p3); } else { aaRgbaSet(&pn3,255,255,0,128); }

 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;

 pstylep->mode=1; pstylep->nparm0=2; pstylep->nparm1=2;
 if(aaSurfacePixelStyleSet(handle,&pstyle_data)!=YES) oof;
 aaSurfaceLine(handle,&c5,&c6,&pn1);
 aaSurfaceLine(handle,&c6,&c7,&pn1);


 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn2);
 aaSurfaceLine(handle,&c6,&c7,&pn2);

 pstylep->mode=0;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn3);
 aaSurfaceLine(handle,&c6,&c7,&pn3);

 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }





 B aaSurfaceCrossMark                  (H handle,_rect*r1,_rgba*p1,_rgba*p2,_rgba*p3)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect ra,r2;
 _cord c1,c2,c3,c4;
 _cord c5,c6,c7,c8;
 _rgba pn1,pn2,pn3;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;

// B pixel_style_save[64];
 //B pixel_style_data[64];
 _pixelstyle*pstylep;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&ra,r1);
 aaRectSet(&r2,ra.x,ra.y,ra.w,ra.h);
 aaRectExpand(&r2,-4,-4);
 aaRectToCornerCords(&r2,&c1,&c2,&c3,&c4);
 aaCordSet(&c5,c1.x,c1.y);
 aaCordSet(&c6,c3.x,c3.y);
 aaCordSet(&c7,c2.x,c2.y);
 aaCordSet(&c8,c4.x,c4.y);
 if(p1) { aaRgbaCopy(&pn1,p1); } else {  aaRgbaSet(&pn1,100,0,0,255); }
 if(p2) { aaRgbaCopy(&pn2,p2); } else { aaRgbaSet(&pn2,255,0,0,192);  }
 if(p3) { aaRgbaCopy(&pn3,p3); } else { aaRgbaSet(&pn3,255,255,0,128); }

 aaSurfacePixelStyleGet(handle,&pstyle_save);//pixel_style_save);
 aaPixelStyleInit(&pstyle_data);
 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
 pstylep=(_pixelstyle*)&pstyle_data;//pixel_style_data;

 pstylep->mode=1; pstylep->nparm0=2;  pstylep->nparm1=2;
 aaSurfacePixelStyleSet(handle,&pstyle_data);//pixel_style_data);
 aaSurfaceLine(handle,&c5,&c6,&pn1);
 aaSurfaceLine(handle,&c7,&c8,&pn1);

 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 //aaSurfacePixelStyleSet(handle,pixel_style_data);
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn2);
 aaSurfaceLine(handle,&c7,&c8,&pn2);

 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
 pstylep->mode=0;
 //aaSurfacePixelStyleSet(handle,pixel_style_data);
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceLine(handle,&c5,&c6,&pn3);
 aaSurfaceLine(handle,&c7,&c8,&pn3);

 aaSurfacePixelStyleSet(handle,&pstyle_save);//pixel_style_save);
 return RET_YES;
 }





 B aaSurfaceRadioButton                (H handle,_rect*r1,B state,_rgba*p1,_rgba*p2,_rgba*p3)
 {
 B ret;
 _aa_surfaceobject*surp;
 _rect ra,r2;
 _rgba pn1,pn2,pn3,pn4;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaRectCopy(&ra,r1);
 aaRectSet(&r2,ra.x,ra.y,ra.w,ra.h);
 aaRectExpand(&r2,-1,-1);
 if(p1) { aaRgbaCopy(&pn1,p1); } else {  aaRgbaSet(&pn1,192,192,192,255); }
 if(p2) { aaRgbaCopy(&pn2,p2); } else { aaRgbaSet(&pn2,100,100,100,255);  }
 if(p3) { aaRgbaCopy(&pn3,p3); } else { aaRgbaSet(&pn3,80,80,80,255); }
 //aaSurfacePixelStyleGet(handle,pixel_style_save);
 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);

 aaSurfacePixelStyleGet(handle,&pstyle_save);//pixel_style_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;//l..pixel_style_data;

 aaSurfaceEllipseFill(handle,&r2,&pn1);//   ;

 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);//pixel_style_data);
 aaRgbaCopy(&pn4,&pn2); pn4.a=pn4.a*0.2;
 aaSurfaceEllipse(handle,&r2,&pn2);

 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
 //aaSurfacePixelStyleSet(handle,pixel_style_data);
 aaPixelStyleInit(&pstyle_data);
 aaSurfacePixelStyleSet(handle,&pstyle_data);

  aaRectCopy(&r2,r1);
  aaRectExpand(&r2,-(ra.w*.3),-(ra.h*.3));
  if(state) { aaSurfaceEllipseFill(handle,&r2,&pn3); }

  if(state)
   {
   pstylep->mode=1;   pstylep->nparm0=1; pstylep->nparm1=1;
   //aaSurfacePixelStyleSet(handle,pixel_style_data);
   aaSurfacePixelStyleSet(handle,&pstyle_data);
   aaSurfaceEllipse(handle,&r2,&pn4);
   }
  else
   {
   //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
   aaPixelStyleInit(&pstyle_data);
   //aaSurfacePixelStyleSet(handle,pixel_style_data);
   aaSurfacePixelStyleSet(handle,&pstyle_data);
   aaSurfaceEllipse(handle,&r2,&pn4);
   }

 aaSurfacePixelStyleSet(handle,&pstyle_save);//pixel_style_save);
 return RET_YES;
 }






 B aaSurfaceCloseIcon                  (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 //B pixel_style_save[64];
// B pixel_style_data[64];
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;

 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }

 aaSurfacePixelStyleGet(handle,&pstyle_save);//pixel_style_save);
 aaPixelStyleInit(&pstyle_data);
 pstylep=(_pixelstyle*)&pstyle_data;//l..pixel_style_data;

// aaSurfacePixelStyleGet(handle,pixel_style_save);
 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
 //pstylep=(_pixelstyle*)pixel_style_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);//pixel_style_data);
 aaSurfaceFramePart(handle,r1,p1,0,0,0,0,1,1);
 aaSurfacePixelStyleSet(handle,&pstyle_save);//pixel_style_save);
 return RET_YES;
 }





 B aaSurfaceMaximizeIcon               (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 //B pixel_style_save[64];
 //B pixel_style_data[64];
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }
 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceFramePart(handle,r1,p1,1,1,1,1,0,0);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }



 B aaSurfaceRestoreIcon                (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _rect rc1;
 _aa_surfaceobject*surp;
 //B pixel_style_save[64];
// B pixel_style_data[64];
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;

 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }
 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaRectCopy(&rc1,r1);
 aaRectExpand(&rc1,-1,-2);
 aaRectAdjust(&rc1,-1,2,0,0); aaSurfaceFramePart(handle,&rc1,p1,1,1,1,1,0,0);
 aaRectAdjust(&rc1,3,-3,0,0); aaSurfaceFramePart(handle,&rc1,p1,1,1,1,1,0,0);
 aaRectExpand(&rc1,+1,+2);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }




 B aaSurfaceMinimizeIcon               (H handle,_rect*r1,_rgba*p1)
 {
 B ret;
 _aa_surfaceobject*surp;
 _pixelstyle pstyle_save;
 _pixelstyle pstyle_data;
 _pixelstyle*pstylep;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 if(r1==NULL) { return RET_BADPARM; }
 if(r1->w==0||r1->h==0) { return RET_BADPARM; }
 if(p1==NULL) { return RET_BADPARM; }
 if(p1->a==0) { return RET_YES; }
 aaSurfacePixelStyleGet(handle,&pstyle_save);
 aaPixelStyleInit(&pstyle_data);
 //aaMemoryFill(pixel_style_data,sizeof(pixel_style_data),0);
 pstylep=(_pixelstyle*)&pstyle_data;
 pstylep->mode=1; pstylep->nparm0=1; pstylep->nparm1=1;
 aaSurfacePixelStyleSet(handle,&pstyle_data);
 aaSurfaceFramePart(handle,r1,p1,0,0,0,1,0,0);
 aaSurfacePixelStyleSet(handle,&pstyle_save);
 return RET_YES;
 }





 B aaSurfaceCaption                    (H handle,H spotidbase,H fonthandle,VP fmt,...)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size sz1;
 _cord cd1,cd2;
 _rect rc1,rc2;
 va_list argptr;
 B str[_4K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 //aaSurfaceStatus(handle,&ss);
 aaSizeSet(&sz1,surp->status.size.w,surp->status.size.h);
 // caption

 aaRectSet(&rc1,0,0,sz1.w,45);
 aaCordSet(&cd1,10,10);
 aaSurfaceGradientFill(handle,&rc1,&cd1,&col_gray[26],&col_pastelblue[30],0,90);

 aaRectToCornerCords(&rc1,0,0,&cd1,&cd2);
 aaSurfaceLine(handle,&cd1,&cd2,&col_red[31]);
 aaCordsAdjust(&cd1,&cd2,0,+1,0,+1);

 aaSurfaceLine(handle,&cd1,&cd2,&col_blue[0]);

 // caption title
 aaRectAdjust(&rc1,0,0,-100,0);
 if(spotidbase!=0)
  {
  //aaDebugf("spid=%i",spotidbase);
  if(aaSurfaceSpotSet(handle,spotidbase+0,10,10,rc1.x,rc1.y,rc1.w,rc1.h,0)!=YES) { oof; }
  }
 //if((ret=aaSurfaceSpotAdd(surf->handle,100,&sspot))!=YES) { oops; }
 //aaRectCopy(&sspot->rect,&rc1);
 if(sl!=0)
  {
  aaSurfaceLabel(handle,&rc1,&col_null,fonthandle,&col_gray[7],45,0,0,1,0,"%s",str);
  }
 aaSizeCopy(&sz1,&surp->status.icon_size);
 aaRectSet(&rc1,0,0,sz1.w,sz1.h);
 aaRectSet(&rc2,6,6,34,34);
 if((ret=aaSurfaceImageDraw(handle,&sz1,&rc1,surp->status.icon_mem,&rc2,0,1,0))!=YES) { oops; }

 return RET_YES;
 }




 B aaSurfaceCaptionButtons             (H handle,H spotidbase,H usebits,H overbits,H pressbits)
 {
 B ret;
 _aa_surfaceobject*surp;
 _size sz1;
 _rect rc1;
 B press,over;
 H sid;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.surface_system.object_id,handle,(VP)&surp,NULL))!=RET_YES) { return ret; }
 aaSizeSet(&sz1,surp->status.size.w,surp->status.size.h);

 aaRectSet(&rc1,sz1.w-5,5,25,25);
 sid=spotidbase;

 if(aaBitGet(usebits,0))
  {
  aaRectAdjust(&rc1,-30,0,0,0);
  if(aaBitGet(pressbits,0)) { press=YES; }
  else                      { press=NO;  }
  if(aaBitGet(overbits,0))  { over=YES;  }
  else                      { over=NO;   }
  aaSurfaceFill(handle,&rc1,&col_pastelpurple[20+(over*5)]);
  aaSurfaceButtonFrame(handle,&rc1,press,1);
  aaRectExpand(&rc1,-5,-5);
  if(press) { aaRectAdjust(&rc1,1,1,0,0); }
  aaSurfaceCloseIcon(handle,&rc1,&col_yellow[31]);
  if(press) { aaRectAdjust(&rc1,-1,-1,0,0); }
  aaRectExpand(&rc1,+5,+5);
  if(spotidbase!=0)
   {
   if(aaSurfaceSpotSet(handle,sid,11,10,rc1.x,rc1.y,rc1.w,rc1.h,0)!=YES) { oof; }
   sid++;
   }
  }

 if(aaBitGet(usebits,1))
  {
  aaRectAdjust(&rc1,-30,0,0,0);
  if(aaBitGet(pressbits,1)) { press=YES; }
  else                      { press=NO;  }
  if(aaBitGet(overbits,1))  { over=YES;  }
  else                      { over=NO;   }
  aaSurfaceFill(handle,&rc1,&col_pastelpurple[20+(over*5)]);
  aaSurfaceButtonFrame(handle,&rc1,press,1);
  aaRectExpand(&rc1,-5,-5);
  if(press) { aaRectAdjust(&rc1,1,1,0,0); }
  aaSurfaceMaximizeIcon(handle,&rc1,&col_yellow[31]);
  if(press) { aaRectAdjust(&rc1,-1,-1,0,0); }
  aaRectExpand(&rc1,+5,+5);
  if(spotidbase!=0)
   {
   if(aaSurfaceSpotSet(handle,sid,12,10,rc1.x,rc1.y,rc1.w,rc1.h,0)!=YES) { oof; }
   sid++;
   }
  }

 if(aaBitGet(usebits,2))
  {
  aaRectAdjust(&rc1,-30,0,0,0);
  if(aaBitGet(pressbits,2)) { press=YES; }
  else                      { press=NO;  }
  if(aaBitGet(overbits,2))  { over=YES;  }
  else                      { over=NO;   }
  aaSurfaceFill(handle,&rc1,&col_pastelpurple[20+(over*5)]);
  aaSurfaceButtonFrame(handle,&rc1,press,1);
  aaRectExpand(&rc1,-5,-5);
  if(press) { aaRectAdjust(&rc1,1,1,0,0); }
  aaSurfaceMinimizeIcon(handle,&rc1,&col_yellow[31]);
  if(press) { aaRectAdjust(&rc1,-1,-1,0,0); }
  aaRectExpand(&rc1,+5,+5);
  if(spotidbase!=0)
   {
   if(aaSurfaceSpotSet(handle,sid,13,10,rc1.x,rc1.y,rc1.w,rc1.h,0)!=YES) { oof; }
   sid++;
   }
  }


 return RET_YES;
 }

/*-----------------------------------------------------------------------*/

 B aaImageYuv420ToBgra                 (_size*size,Z ystride,Z uvstride,VP yplane,VP uplane,VP vplane,VP dest)
 {
 N u,v;
 N b_u,g_uv,r_v,rgb_y;
 N r,g,b;
 Z wid,hit,dst_stride;
 Z y_stride,uv_stride;
 register N x,y;
 H dst_dif;
 register BP dst;
 register BP ysrc,usrc,vsrc;
 register N y_dif;
 register BP dst2;
 register BP ysrc2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.surface_system.yuva_tables_init!=YES)
  {
  aa_SurfaceSystemYuvTablesInit();
  }
 wid=size->w;
 hit=size->h;
 dst_stride=wid;
 y_stride=ystride;
 uv_stride=uvstride;
 dst=(BP)dest;
 ysrc=(BP)yplane;
 usrc=(BP)uplane;
 vsrc=(BP)vplane;

 dst_dif=8*dst_stride-4*wid;
   y_dif=2*y_stride-wid;
    dst2=dst+4*dst_stride;
  ysrc2=ysrc+y_stride;

 if(hit<0)
  {
  hit=-hit;
  ysrc+=(hit-1)*y_stride;
  ysrc2=ysrc-y_stride;
  usrc+=(hit/2-1)*uv_stride;
  vsrc+=(hit/2-1)*uv_stride;
  y_dif=-wid-2*y_stride;
  uv_stride=-uv_stride;
  }

 for(y=hit/2;y;y--)
  {
  for(x=0;x<wid/2;x++)
   {
   u=usrc[x];
   v=vsrc[x];
   b_u=aa.surface_system.B_U_tab[u];
   g_uv=aa.surface_system.G_U_tab[u]+aa.surface_system.G_V_tab[v];
   r_v=aa.surface_system.R_V_tab[v];

   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst[0]=aaNumMax(0,aaNumMin(255,b));
   dst[1]=aaNumMax(0,aaNumMin(255,g));
   dst[2]=aaNumMax(0,aaNumMin(255,r));
   dst[3]=255;
   ysrc++;
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst[4]=aaNumMax(0,aaNumMin(255,b));
   dst[5]=aaNumMax(0,aaNumMin(255,g));
   dst[6]=aaNumMax(0,aaNumMin(255,r));
   dst[7]=255;
   ysrc++;
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc2];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst2[0]=aaNumMax(0,aaNumMin(255,b));
   dst2[1]=aaNumMax(0,aaNumMin(255,g));
   dst2[2]=aaNumMax(0,aaNumMin(255,r));
   dst2[3]=255;
   ysrc2++;
   rgb_y=aa.surface_system.RGB_Y_tab[*ysrc2];
   b=(rgb_y+b_u)>>SCALEBITS_OUT;
   g=(rgb_y-g_uv)>>SCALEBITS_OUT;
   r=(rgb_y+r_v)>>SCALEBITS_OUT;
   dst2[4]=aaNumMax(0,aaNumMin(255,b));
   dst2[5]=aaNumMax(0,aaNumMin(255,g));
   dst2[6]=aaNumMax(0,aaNumMin(255,r));
   dst2[7]=255;
   ysrc2++;
   dst+=8;
   dst2+=8;
   }
  dst+=dst_dif;
  dst2+=dst_dif;
  ysrc+=y_dif;
  ysrc2+=y_dif;
  usrc+=uv_stride;
  vsrc+=uv_stride;
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/

 B aaFancyTextInit                     (_fancytext*fancytext,H surfacehandle,H fonthandle)
 {
 B ret;
 _surfacestatus ss;

 if(fancytext==NULL) { return RET_BADPARM; }
 aaMemoryFill(fancytext,sizeof(_fancytext),0);
 if((ret=aaSurfaceStatus(surfacehandle,&ss))!=YES) { return ret; }
 if((ret=aaFontStatus(fonthandle,&fancytext->font_status))!=YES) { return ret; }
 fancytext->magic=aaHPP(aaFancyTextInit);
 fancytext->surface_handle=surfacehandle;
 fancytext->font_handle=fonthandle;
 aaRgbaDwordSet(&fancytext->txt_bg_pen,0x002040ff);//&col_blue[10]);
 aaRgbaDwordSet(&fancytext->txt_fg_pen,0x37FF69ff);///002040ff);//&col_blue[10]);
 aaRgbaDwordSet(&fancytext->sel_bg_pen,0x6D23DCff);
 ///&col_purple[16]);
 aaRgbaDwordSet(&fancytext->sel_fg_pen,0x00FFFFff);//&col_cyan[28]);
 aaRgbaDwordSet(&fancytext->caret_pen,0xB5F40Bff);//100,200,2,170);
 return RET_YES;
 }



 B aaFancyTextRectSet                  (_fancytext*fancytext,_rect*rect)
 {
 if(fancytext==NULL) { return RET_BADPARM; }
 if(fancytext->magic!=aaHPP(aaFancyTextInit)) { return RET_NOTINITIALIZED; }
 if(rect==NULL)  { return RET_BADPARM; }
 aaRectCopy(&fancytext->rect,rect);
 return RET_YES;
 }


 B aaFancyTextSelSet                   (_fancytext*fancytext,H selstart,H selcount)
 {
 if(fancytext==NULL) { return RET_BADPARM; }
 if(fancytext->magic!=aaHPP(aaFancyTextInit)) { return RET_NOTINITIALIZED; }
 fancytext->sel_start=selstart;
 fancytext->sel_count=selcount;
 return RET_YES;
 }



 B aaFancyTextCaretSet                 (_fancytext*fancytext,H position,B type,B state)
 {
 if(fancytext==NULL) { return RET_BADPARM; }
 if(fancytext->magic!=aaHPP(aaFancyTextInit)) { return RET_NOTINITIALIZED; }
 state&=1;
 fancytext->caret_pos=position;
 fancytext->caret_state=state;
 fancytext->caret_type=type;
 return RET_YES;
 }


 B aaFancyTextPositionSet              (_fancytext*fancytext,H position)
 {
 if(fancytext==NULL) { return RET_BADPARM; }
 if(fancytext->magic!=aaHPP(aaFancyTextInit)) { return RET_NOTINITIALIZED; }
 fancytext->position=position;
 return RET_YES;
 }




 B aaFancyTextWrite                    (_fancytext*fancytext,H chars,VP txt)
 {
 if(fancytext==NULL) { return RET_BADPARM; }
 if(fancytext->magic!=aaHPP(aaFancyTextInit)) { return RET_NOTINITIALIZED; }
 if(txt==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(txt,&chars); }
 fancytext->txt_len=chars;
 if(fancytext->txt_len!=0) { aaStringNCopy(fancytext->txt_buf,txt,fancytext->txt_len,YES);  }
 fancytext->txt_buf[fancytext->txt_len]=NULL_CHAR;
 aaFontStringCharRectsGet(fancytext->font_handle,aaElementCount(fancytext->char_rect),fancytext->char_rect,0,"%s",fancytext->txt_buf);
 return RET_YES;
 }




 B aaFancyTextWritef                   (_fancytext*fancytext,VP fmt,...)
 {
 if(fancytext==NULL) { return RET_BADPARM; }
 if(fancytext->magic!=aaHPP(aaFancyTextInit)) { return RET_NOTINITIALIZED; }
 aaVargsf(fmt);
 return(aaFancyTextWrite(fancytext,str64k.len,str64k.buf));
 }




 B aaFancyTextPaint                    (_fancytext*fancytext)
 {
 _rect rc1;
 _cord cd1;
 B txt[_8K];
 H pos;

 if(fancytext==NULL) { return RET_BADPARM; }
 if(fancytext->magic!=aaHPP(aaFancyTextInit)) { return RET_NOTINITIALIZED; }
 aaRectCopy(&rc1,&fancytext->rect);
 aaSurfaceFill(fancytext->surface_handle,&rc1,&fancytext->txt_bg_pen);
 aaCordSet(&cd1,rc1.x,rc1.y);
 pos=fancytext->position;
 if(fancytext->txt_len>pos)
  {
  aaSurfacePrintf(fancytext->surface_handle,&cd1,fancytext->font_handle,&fancytext->txt_fg_pen,0,"%s",&fancytext->txt_buf[pos]);
  }
 if(fancytext->sel_count!=0)
  {
  rc1.x=fancytext->char_rect[(fancytext->sel_start-pos)].x;
  rc1.w=fancytext->char_rect[(fancytext->sel_start-pos)+(fancytext->sel_count-1)].x;
  rc1.w+=fancytext->char_rect[(fancytext->sel_start-pos)+(fancytext->sel_count-1)].w;
  //rc1.w-=rc1.x;
  rc1.x+=fancytext->rect.x;
  aaSurfaceFill(fancytext->surface_handle,&rc1,&fancytext->sel_bg_pen);
  aaCordSet(&cd1,rc1.x,rc1.y);
  txt[0]=0;
  aaStringCopy(txt,fancytext->txt_buf);
  txt[fancytext->sel_start+fancytext->sel_count]=0;
  if(fancytext->txt_len>pos)
   {
   aaSurfacePrintf(fancytext->surface_handle,&cd1,fancytext->font_handle,&fancytext->sel_fg_pen,0,"%s",&txt[fancytext->sel_start]);
   }
  }
 if(fancytext->caret_state)
  {
  rc1.x=fancytext->char_rect[fancytext->caret_pos].x;
  if(fancytext->caret_type==0)
   {
   rc1.w=fancytext->char_rect[fancytext->caret_pos+1].x-rc1.x;
   }
  else
  if(fancytext->caret_type==1)
   {
   rc1.w=3;
   }
  else
  if(fancytext->caret_type==2)
   {
   rc1.w=fancytext->char_rect[fancytext->caret_pos+1].x-rc1.x;
   rc1.h=2;
   rc1.y=(fancytext->rect.y+fancytext->rect.h)-(rc1.h);

   }


  rc1.x+=fancytext->rect.x;
  aaSurfaceFill(fancytext->surface_handle,&rc1,&fancytext->caret_pen);
  }
 //aaSurfaceUpdateAreaAdd(fancytext->surface_handle,&fancytext->rect,NO);
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/




 B aaCursorSet                         (B id)
 {
 HCURSOR cursor_handle;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==aa.cursor_system.cursor_id)  {  return RET_YES;  }
 switch(id)
  {
  case aa_CURSOR_None:       cursor_handle=NULL;                             break;
  case aa_CURSOR_Arrow:      cursor_handle=LoadCursor(NULL,IDC_ARROW);       break;
  case aa_CURSOR_HourGlass:  cursor_handle=LoadCursor(NULL,IDC_WAIT);        break;
  case aa_CURSOR_Resize:     cursor_handle=LoadCursor(NULL,IDC_SIZEALL);     break;
  case aa_CURSOR_ResizeV:    cursor_handle=LoadCursor(NULL,IDC_SIZENS);      break;
  case aa_CURSOR_ResizeH:    cursor_handle=LoadCursor(NULL,IDC_SIZEWE);      break;
  case aa_CURSOR_ResizeB:    cursor_handle=LoadCursor(NULL,IDC_SIZENWSE);    break;
  case aa_CURSOR_ResizeF:    cursor_handle=LoadCursor(NULL,IDC_SIZENESW);    break;
  case aa_CURSOR_Move:       cursor_handle=LoadCursor(NULL,IDC_CROSS);       break;
  case aa_CURSOR_Beam:       cursor_handle=LoadCursor(NULL,IDC_IBEAM);       break;
  case aa_CURSOR_Hand:       cursor_handle=aa.cursor_system.hand_cursor_handle; break;
  case aa_CURSOR_Help:       cursor_handle=LoadCursor(NULL,IDC_HELP);         break;
  case aa_CURSOR_TimeGlass:  cursor_handle=LoadCursor(NULL,IDC_APPSTARTING);  break;
  case aa_CURSOR_SlashRound: cursor_handle=LoadCursor(NULL,IDC_NO);           break;
  case aa_CURSOR_ArrowUp:    cursor_handle=LoadCursor(NULL,IDC_UPARROW);      break;

  default:
  return RET_BADPARM;
  }
 aa.cursor_system.current_cursor_handle=cursor_handle;
 aa.cursor_system.cursor_id=id;
 //Debugf("setcursor");
 SetCursor(cursor_handle);
 return RET_YES;
 }



 B aaCursorGet                         (BP id)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==NULL) { return RET_BADPARM; }
 *id=aa.cursor_system.cursor_id;
 return RET_YES;
 }





 B aaCursorSimulate                    (B flag,N x,N y,H wid,H hit,N etc,H del)
 {
 H flags;
 S H last_wid=0;
 S H last_hit=0;
 N xx,yy;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wid!=0) { last_wid=wid; }
 if(hit!=0) { last_hit=hit; }
 if(last_wid==0) { oof; return RET_FAILED; }
 if(last_hit==0) { oof; return RET_FAILED; }
 wid=last_wid;
 hit=last_hit;
 flags=0;
 if(aaBitGet(flag,0)) {  flags|=MOUSEEVENTF_ABSOLUTE; }
 if(aaBitGet(flag,1)) {  flags|=MOUSEEVENTF_MOVE; }
 if(aaBitGet(flag,2)) {  flags|=MOUSEEVENTF_LEFTDOWN; }
 if(aaBitGet(flag,3)) {  flags|=MOUSEEVENTF_LEFTUP; }
 if(aaBitGet(flag,4)) {  flags|=MOUSEEVENTF_RIGHTDOWN; }
 if(aaBitGet(flag,5)) {  flags|=MOUSEEVENTF_RIGHTUP; }
 if(aaBitGet(flag,6)) {  flags|=MOUSEEVENTF_WHEEL; }

 xx=(N)(65536.0/wid*x-1);
 yy=(N)(65536.0/hit*y-1);
 mouse_event(flags,xx,yy,etc,0);
 if(del) { aaSleep(del); }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aaAppBarSet                         (B state,B orientation,H depth)
 {
 B ret;
 APPBARDATA data;
 H sh;
 _surfacestatus ss;
 _size s1;
 H edge=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(orientation==aa_DIRECTION_W) { edge=ABE_LEFT; } else
 if(orientation==aa_DIRECTION_E) { edge=ABE_RIGHT; } else
 if(orientation==aa_DIRECTION_N) { edge=ABE_TOP; } else
 if(orientation==aa_DIRECTION_S) { edge=ABE_BOTTOM; }

 if(aa.appbar_system.state==YES)
  {
  if(aaSurfaceStatus(aa.appbar_system.surface_handle,&ss)!=YES) { oof; }

  if(state==NO)
   {
   aaMemoryFill(&data,sizeof(data),0);
   data.cbSize=sizeof(data);
   data.hWnd=ss.hwnd;
   if(SHAppBarMessage(ABM_REMOVE,&data)==FALSE) { oof; }
   if(aaSurfaceDestroy(aa.appbar_system.surface_handle)!=YES) { oof; }
   aa.appbar_system.state=NO;
   return RET_YES;
   }
  if(aa.appbar_system.orientation!=orientation)
   {
   aaMemoryFill(&data,sizeof(data),0);
   data.cbSize=sizeof(data);
   data.hWnd=ss.hwnd;
   if(SHAppBarMessage(ABM_REMOVE,&data)==FALSE) { oof; }
   aaMemoryFill(&data,sizeof(data),0);
   data.cbSize=sizeof(data);
   data.hWnd=ss.hwnd;
   data.uCallbackMessage=WM_APP_BAR_MSG;
   if(SHAppBarMessage(ABM_NEW,&data)==FALSE) { oof; }
   aa.appbar_system.surface_handle=aa.appbar_system.surface_handle;
   aa.appbar_system.state=YES;
   aa.appbar_system.edge=edge;
   }
  }

 if(aa.appbar_system.state==NO)
  {
  if(state==NO) { return RET_YES; }
  aaSizeSet(&s1,1,1);
  if((ret=aaSurfaceCreate(&sh,&s1))!=RET_YES) { return ret; }
  aaSurfaceVisualize(sh,YES,0);
  aaSurfaceStatus(sh,&ss);
  aaMemoryFill(&data,sizeof(data),0);
  data.cbSize=sizeof(data);
  data.hWnd=ss.hwnd;
  data.uCallbackMessage=WM_APP_BAR_MSG;
  if(SHAppBarMessage(ABM_NEW,&data)==FALSE) { oof; }
  aa.appbar_system.surface_handle=sh;
  aa.appbar_system.state=YES;
  aa.appbar_system.edge=edge;
  }

 aa.appbar_system.orientation=orientation;
 aa.appbar_system.depth=depth;
 aaMemoryFill(&data,sizeof(data),0);
 data.cbSize=sizeof(data);
 data.hWnd=ss.hwnd;
 data.uCallbackMessage=WM_APP_BAR_MSG;
 data.uEdge=aa.appbar_system.edge;
 SetRect(&data.rc,0,0,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
 if(SHAppBarMessage(ABM_QUERYPOS,&data)==FALSE) { oof; }
 switch (data.uEdge)
  {
  case ABE_LEFT:   data.rc.right=data.rc.left+aa.appbar_system.depth;   break;
  case ABE_TOP:    data.rc.bottom=data.rc.top+aa.appbar_system.depth;   break;
  case ABE_RIGHT:  data.rc.left=data.rc.right-aa.appbar_system.depth;    break;
  case ABE_BOTTOM: data.rc.top=data.rc.bottom-aa.appbar_system.depth;     break;
  default: oof; break;
  }
 if(SHAppBarMessage(ABM_SETPOS,&data)==FALSE) { oof; }
 aaRectSet(&aa.appbar_system.rect,data.rc.left,data.rc.top,data.rc.right-data.rc.left,data.rc.bottom-data.rc.top);
// BUG,"AppBar Set to %i,%i,%i,%i",aa.appbar_system.rect.x,aa.appbar_system.rect.y,aa.appbar_system.rect.w,aa.appbar_system.rect.h);
 return RET_YES;
 }




 B aaAppBarGet                         (BP state,BP orientation,_rect*rect)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state) { *state=aa.appbar_system.state; }
 if(orientation) { *orientation=aa.appbar_system.orientation; }
 if(rect) { aaRectCopy(rect,&aa.appbar_system.rect); }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aaGifCreate                         (HP handle,VP filename)
 {
 B ret;
 _aa_gifobject*gifp;
 H file_handle,rem,td,of;
 B buf[_8K];
 N  BitsPerPixel,i;
 _filestreamstatus fs;
 H done,del;
 B record_type;
 BP extension;
 N extension_code,yy;
 N dif;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.gif_system.object_id,handle,(VP)&gifp))!=RET_YES) { oops; return ret; }
 gifp->self_handle=*handle;
 if(filename==NULL) {  return RET_BADPARM; }
 if((ret=aaFileStreamCreate(&file_handle,filename,NO,3,3,0,NO))!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  return ret;
  }
 aaFileStreamStatus(file_handle,&fs);
 gifp->file_bytes=(Q)fs.bytes;//aaDoubleToLong(fs.bytes);//.lo;
 //aaDebugf("gifbytes=%I64u",gifp->file_bytes);

 if((ret=aa_MemoryAllocate((VP)&gifp->file_mem,gifp->file_bytes,"gifint",NO))!=RET_YES)
  {
  aaFileStreamDestroy(file_handle);
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  return ret;
  }
 rem=gifp->file_bytes;
 of=0;

 while(1)
  {
  td=rem;
  if(td>_4K) td=_4K;
  if((ret=aaFileStreamRead(file_handle,td,&gifp->file_mem[of]))!=RET_YES)
   {
   aa_ObjectDestroy(aa.gif_system.object_id,*handle);
   aaFileStreamDestroy(file_handle);
   aa_MemoryRelease(gifp->file_mem);
   return ret;
   }
  of+=td;
  rem-=td;
  if(rem==0) break;
  }


 aaFileStreamDestroy(file_handle);
 if(aa_GifSystemReadBytes((PP)&gifp,6,buf)!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  aa_MemoryRelease(gifp->file_mem);
  return RET_FAILED;
  }
 ret=aaStringNCompare("GIF",buf,3,&dif);
 if(ret!=RET_YES||dif!=0)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  aa_MemoryRelease(gifp->file_mem);
  return RET_FAILED;
  }
 ret=aaStringNCompare("87a",&buf[3],3,&dif);
 if(ret==RET_YES&&dif==0) { gifp->version=0x87a; }
 else
  {
  ret=aaStringNCompare("89a",&buf[3],3,&dif);
  if(ret==RET_YES&&dif==0) { gifp->version=0x89a; }
  }
 if(gifp->version==0)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  aa_MemoryRelease(gifp->file_mem);
  return RET_FAILED;
  }

 if(aa_GifSystemReadBytes((PP)&gifp,2,&gifp->status.size.w)==RET_FAILED||aa_GifSystemReadBytes((PP)&gifp,2,&gifp->status.size.h)==RET_FAILED)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  aa_MemoryRelease(gifp->file_mem);
  return RET_FAILED;
  }
 if(aa_GifSystemReadBytes((PP)&gifp,3,buf)!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  aa_MemoryRelease(gifp->file_mem);
  return RET_FAILED;
  }
 gifp->total_colors=(W)((((buf[0]&0x70)+1)>>4)+1);
 BitsPerPixel=(buf[0]&0x07)+1;

 if(buf[0]&0x80)
  {
  gifp->bg_color_used=YES;
  gifp->bg_color_index=(W)buf[1];
  if((1<<BitsPerPixel)!=(1<<aa_GifSystemBitSize(1<<BitsPerPixel)))
   {
   aa_ObjectDestroy(aa.gif_system.object_id,*handle);
   aa_MemoryRelease(gifp->file_mem);
   return RET_FAILED;
   }
  gifp->global_color_count=(W)(1<<BitsPerPixel);
  gifp->global_color_bits=(W)aa_GifSystemBitSize((1<<BitsPerPixel));
  for(i=0;i<gifp->global_color_count; i++)
   {
   if(aa_GifSystemReadBytes((PP)&gifp,3,buf)!=RET_YES)
    {
    aa_ObjectDestroy(aa.gif_system.object_id,*handle);
    aa_MemoryRelease(gifp->file_mem);
    return RET_FAILED;
    }
   aaRgbaSet(&gifp->global_color_pen[i],buf[0],buf[1],buf[2],255);
   }
  }
 gifp->file_offset_root=gifp->file_offset;
 ret=aa_MemoryAllocate((VP)&gifp->img,gifp->status.size.w*gifp->status.size.h*4,"gifimg",NO);
 if(ret!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  aa_MemoryRelease(gifp->file_mem);
  return ret;
  }

 done=NO;


///<gifp->status.frame_delay


 go=0;
 //aaDebugf("start=%I64u",aaMicrosecsRunning());
 while(1)
 {
 if((go%150)==149)  {  aaYield(-1.0);  }
 ///if(aaNumIsMod(go,150))  {  aaYield(aa_askhz);  }

 if((ret=aa_GifSystemReadBytes((PP)&gifp,1,&record_type))!=RET_YES) {  break; }
    switch (record_type)
     {
     case '!': // extension 0x21 GRAPHIC CONTROL
     if((ret=aa_GifSystemReadExtension((PP)&gifp,&extension_code,&extension))!=RET_YES) {  break; }
     if(extension_code!=0xf9)
      {
      while(extension!=NULL)    {    if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  break; }    }
      break;
      }
     while(extension!=NULL)
      {
      if(extension[0]!=4) { ret=RET_FAILED; break; }

      del=(W)((extension[3]<<8)+extension[2])*10;
      //if(del>gifp->status.total_ms) { gifp->status.total_ms=ms; }
      //else
      //if
      gifp->status.total_ms+=del;

      if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  break; }
      }
     break;

     case ',': // extension 0x2c IMAGE DESCRIPTOR
     if((ret=aa_GifSystemReadFrameInfo((PP)&gifp))!=RET_YES) {  break; }
     ///// interlace
      for(yy=0; yy<(N)gifp->frame_size.h; yy++) // ningy added (N)
       {
       if((ret=aa_GifSystemReadLine((PP)&gifp,buf,gifp->frame_size.w))!=RET_YES) {  break; }
       }
      if(ret!=RET_YES) { break; }
     gifp->status.total_frames++;
     break;

     case ';':   // trailer  0x3b
     done=YES;
     break;

     default:  ret=RET_FAILED;  break;
     }
  if(ret!=RET_YES||done) break;
  go++;
  }

 if(ret!=RET_YES)
  {
  aa_ObjectDestroy(aa.gif_system.object_id,*handle);
  aa_MemoryRelease(gifp->file_mem);
  return ret;
  }
 aaTimerTikGet(&gifp->tik);
 gifp->status.ms=0;
 aaGifRewind(*handle);

 return RET_YES;
 }





 B aaGifCreateUsingResource            (HP handle,H resnum)
 {
 B ret;
 B path[MAX_PATH];
 B file[33];
 B filename[MAX_PATH];
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 if(GetTempPath(MAX_PATH,(CP)path)==0) { oof; }
 while(1)
  {
  aaStringRandomSet(file,8,YES,NO,YES,YES);
  aaStringCopyf(filename,"%s%s.tmp",path,file);
  if(aaFileExists(filename)!=YES) { break; }
  break;
  }
 if((ret=aaResourceToFile(resnum,&bytes,filename))!=RET_YES) { oops; return ret; }
 if((ret=aaGifCreate(handle,filename))!=RET_YES) { return ret; }
 return RET_YES;
 }




 B aaGifDestroy                        (H handle)
 {
 B ret;
 _aa_gifobject*gifp;
 B isprot;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,&isprot))!=RET_YES) { return ret; }
 if(gifp->img!=NULL)  {  aa_MemoryRelease(gifp->img);  }
 if(gifp->file_mem!=NULL) {  aa_MemoryRelease(gifp->file_mem);  }
 aa_ObjectDestroy(aa.gif_system.object_id,handle);
 return RET_YES;
 }






 B aaGifStatus                         (H handle,_gifstatus*gifstatus)
 {
 B ret;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,0))!=RET_YES) { return ret; }
 aaTimerTikElapsed(gifp->tik,&gifp->status.ms);
 if(gifstatus) { aaMemoryCopy(gifstatus,sizeof(_gifstatus),&gifp->status); }
 return RET_YES;
 }





 B aaGifRewind                         (H handle)
 {
 B ret;
 _aa_gifobject*gifp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,NULL))!=RET_YES) { return ret; }
 gifp->file_offset=gifp->file_offset_root;
 gifp->status.frame_number=0;
 gifp->frame_transparent_index_set=NO;
 gifp->status.frame_delay=0;
 gifp->disposal_method=0;
 gifp->allow_next=NO;
 return RET_YES;
 }





 B aaGifFrameNext                      (H handle,PP img)
 {
 B ret;
 _aa_gifobject*gifp;
 B record_type,done;
 N extension_code,i,xx,yy;
 B cc;
 B screenbuf[_8K];
 BP extension;
 _rgba*dp;
 _rgba*sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.gif_system.object_id,handle,(VP)&gifp,NULL))!=RET_YES) { return ret; }

 aaTimerTikElapsed(gifp->tik,&gifp->status.ms);
 if((gifp->status.ms+10)<gifp->status.frame_delay) { return RET_NOTREADY; }

 done=NO;
 gifp->frame_transparent_index_set=NO;
 gifp->status.frame_delay=0;
 gifp->disposal_method=0;


 while(!done)
 {
 if((ret=aa_GifSystemReadBytes((PP)&gifp,1,&record_type))!=RET_YES) {  return ret; }
 switch (record_type)
  {
  case '!': // extension 0x21 GRAPHIC CONTROL
  if((ret=aa_GifSystemReadExtension((PP)&gifp,&extension_code,&extension))!=RET_YES) {  return ret; }
  if(extension_code!=0xf9)
   {
   while(extension!=NULL)
    {
    if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) {  return ret; }
    }
   break;
   }
  while(extension!=NULL)
   {
   if(extension[0]!=4) {  return RET_FAILED; }
   else
    {
    gifp->disposal_method=extension[1];
    gifp->disposal_method<<=3;
    gifp->disposal_method>>=5;
    gifp->status.frame_delay=(W)((extension[3]<<8)+extension[2])*10;
    if(aaBitGet(extension[1],0))
     {
     gifp->frame_transparent_index_set=YES;
     gifp->frame_transparent_index=extension[4];
     }
    }
   if((ret=aa_GifSystemReadExtensionNext((PP)&gifp,&extension))!=RET_YES) { return ret; }
   }
  break;

  case ',': // extension 0x2c IMAGE DESCRIPTOR
  if((ret=aa_GifSystemReadFrameInfo((PP)&gifp))!=RET_YES) {  return ret; }
  cc=gifp->bg_color_index;


  if(gifp->status.frame_number==0&&gifp->bg_color_used)
   {
    for(yy=0; yy<(N)gifp->status.size.h; yy++) // ningy added (N)
     {
     aaCast(dp,_rgba*,&gifp->img[yy*gifp->status.size.w*4]);
     // ashodapakian,, was cc!=
     if(cc==gifp->frame_transparent_index)     aaCast(sp,_rgba*,&col_null);
     else     aaCast(sp,_rgba*,&gifp->global_color_pen[cc]);
     for(xx=0;xx<(N)gifp->status.size.w;xx++) // ningy added (N)
      {
      *dp=*sp;
      dp++;
      }
     }
   }


  ///// interlace
  if(gifp->frame_interlaced)
   {
    yy=0;
    i=0;
    while(1)
     {
     if((ret=aa_GifSystemReadLine((PP)&gifp,screenbuf,gifp->frame_size.w))!=RET_YES) {  return ret; }
//     dp=Cast(_pen*,&gifp->img[yy*gifp->frame_size.w*4]); // other bitresolutions, possible here by changing from dwords to 16bits etc
     aaCast(dp,_rgba*,&gifp->img[((yy+gifp->frame_cord.y)*(gifp->status.size.w*4))+((gifp->frame_cord.x)*4)]);
     for(xx=0;xx<(N)gifp->frame_size.w;xx++)// ningy added (N)
      {
      cc=screenbuf[xx];
      if(gifp->frame_transparent_index_set&&cc==gifp->frame_transparent_index)
       {
       }
      else
       {
       if(gifp->frame_use_local_color)
        {
        aaCast(sp,_rgba*,&gifp->local_color_pen[cc]);
        }
       else
        {
        aaCast(sp,_rgba*,&gifp->global_color_pen[cc]);
        }
       *dp=*sp;
       }
      dp++;
      }
     yy+=aa_GifInterlacedJumps[i];
     if(yy>= (N)gifp->frame_size.h) // ningy added (N)
      {
      i++;
      if(i==4) break;
      yy=aa_GifInterlacedOffset[i];
      }
     }
 }
  else // non interla
   {
   for(yy=0; yy<(N)gifp->frame_size.h; yy++) // ningy added (N)
    {
    if((ret=aa_GifSystemReadLine((PP)&gifp,screenbuf,gifp->frame_size.w))!=RET_YES) {  return ret; }
    aaCast(dp,_rgba*,&gifp->img[((yy+gifp->frame_cord.y)*(gifp->status.size.w*4))+((gifp->frame_cord.x)*4)]);
    for(xx=0;xx<(N)gifp->frame_size.w;xx++) // ningy added (N)
     {
     cc=screenbuf[xx];
     if(gifp->frame_transparent_index_set&&cc==gifp->frame_transparent_index)
      {
      }
     else
      {
      if(gifp->frame_use_local_color)
       {
       aaCast(sp,_rgba*,&gifp->local_color_pen[cc]);
       }
      else
       {
       aaCast(sp,_rgba*,&gifp->global_color_pen[cc]);
       }
      *dp=*sp;
      }
     dp++;
     }
    }
   }
  done=YES;
  break;

  default: oof;
  return RET_FAILED;
  }
 }
 if(done!=YES) oof;
 *img=gifp->img;

 gifp->status.frame_number++;
 aaTimerTikGet(&gifp->tik);
 gifp->status.ms=0;
 if(gifp->status.frame_number==gifp->status.total_frames)  {  aaGifRewind(handle);  }
 return RET_YES;
 }




/**-----------*******************/




 B aaInputKeySimulate                  (B virtkey,B isscan,B isdown)
 {
 INPUT ip;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&ip,sizeof(ip),0);
 ip.type=INPUT_KEYBOARD;
 ip.ki.wVk=virtkey;
 ip.ki.wScan=virtkey;
 if(isdown)  {  ip.ki.dwFlags=0;  }
 else        {  ip.ki.dwFlags=KEYEVENTF_KEYUP;  }
 if(isscan) { ip.ki.dwFlags|=KEYEVENTF_SCANCODE;  }
 if(SendInput(1,&ip,sizeof(INPUT))!=1) { oof; }
 return RET_YES;
 }






 B aaInputKeyPairSimulate              (B virtkey1,B virtkey2,H sleep)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(virtkey1==0&&virtkey2==0) { return RET_BADPARM; }
 if(virtkey1!=0) { aaInputKeySimulate(virtkey1,NO,YES); }
 if(virtkey2!=0) { aaInputKeySimulate(virtkey2,NO,YES); }
 aaSleep(sleep);
 if(virtkey2!=0) { aaInputKeySimulate(virtkey2,NO,NO); }
 if(virtkey1!=0) { aaInputKeySimulate(virtkey1,NO,NO); }
 return RET_YES;
 }




 B aaInputKeyPattern                   (H state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 switch(state)
  {
  case 0:  return(aaInputKeySimulate(VK_LMENU,NO,YES));
  case 1:  return(aaInputKeySimulate(VK_TAB,NO,YES));
  case 2:  return(aaInputKeySimulate(VK_TAB,NO,NO));
  case 3:  return(aaInputKeySimulate(VK_LMENU,NO,NO));
  case 4:  return(aaInputKeySimulate(VK_F5,NO,YES));
  case 5:  return(aaInputKeySimulate(VK_F5,NO,NO));
  default: break;
  }
 return RET_BADPARM;
 }





 B aaInputKeyStringSimulate            (VP fmt,...)
 {
 va_list argptr;
 B str[_4K];
 H s,sl;
 B v1,v2;
 B ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 for(s=0;s<sl;s++)
  {
  v1=v2=0;
  while(1)
   {
   ch=str[s];
   if(ch>='A'&&ch<='Z')  {  v1=VK_SHIFT;   v2=ch;    break;    }
   if(ch>='a'&&ch<='z')  {  v1=(B)(ch-32); v2=0; break; }
   if(ch>='0'&&ch<='9')  {  v1=ch; v2=0; break; }
   if(ch=='!') { v1=VK_SHIFT; v2='1'; break; }
   if(ch=='@') { v1=VK_SHIFT; v2='2'; break; }
   if(ch=='#') { v1=VK_SHIFT; v2='3'; break; }
   if(ch=='$') { v1=VK_SHIFT; v2='4'; break; }
   if(ch=='\%') { v1=VK_SHIFT; v2='5'; break; }
   if(ch=='^') { v1=VK_SHIFT; v2='6'; break; }
   if(ch=='&') { v1=VK_SHIFT; v2='7'; break; }
   if(ch=='*') { v1=VK_SHIFT; v2='8'; break; }
   if(ch=='(') { v1=VK_SHIFT; v2='9'; break; }
   if(ch==')') { v1=VK_SHIFT; v2='0'; break; }
   if(ch==SPACE_CHAR) { v1=VK_SPACE; break; }
   if(ch=='-') { v1=VK_SUBTRACT; break; }
   if(ch=='+') { v1=VK_ADD; break; }
   if(ch=='.') { v1=VK_DECIMAL; break; }
   if(ch==',') { v1=0xbc; break; }
   if(ch=='=') { v1=187; break; }
   if(ch=='_') { v1=VK_SHIFT; v2=189; break; }
   if(ch=='<') { v1=VK_SHIFT; v2=188; break; }
   if(ch=='>') { v1=VK_SHIFT; v2=190; break; }
   if(ch=='/') { v1=191; break; }
   if(ch=='?') { v1=VK_SHIFT; v2=191; break; }

   if(ch=='[') { v1=219; break; }
   if(ch==']') { v1=221; break; }
   if(ch=='{') { v1=VK_SHIFT; v2=219; break; }
   if(ch=='}') { v1=VK_SHIFT; v2=221; break; }

   if(ch=='\\') { v1=220; break; }
   if(ch=='|')  { v1=VK_SHIFT; v2=220; break; }

   if(ch==';')  { v1=186; break; }
   if(ch=='\'') { v1=220; break; }
   if(ch==':')  { v1=VK_SHIFT; v2=186; break; }
   if(ch=='\"') { v1=VK_SHIFT; v2=220; break; }

   if(ch=='`') { v1=192; break; }
   if(ch=='~') { v1=VK_SHIFT; v2=192; break; }

   if(ch==LF_CHAR) { v1=VK_RETURN; break; }

   break;
   }
  if((v1==0&&v2==0)&&ch!=CR_CHAR) {  continue; }
  aaInputKeyPairSimulate(v1,v2,8);
  }
 return RET_YES;
 }






 B aaInputKeyCharSimulate              (B ch,B count)
 {
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringFill(txt,(H)count,ch,YES);
 aaNote(0,"%s",txt);
 return(aaInputKeyStringSimulate("%s",txt));
 }






 B aaInputStateGet                     (_inputstate*inputstate)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aa_InputStateGet(inputstate,1,1));
 }






 B aaInputEngine                       (_inputengine*inputengine)
 {
 B ret;
 H kr,i,c;
 _inputstate*curr;
 _inputstate*prev;
 _inputstate*ldwn;
 _inputstate*rdwn;
 _inputstate*pcur;
 _inputengine*ieng;
 _inputengine iengine;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 //if(ieng==NULL) { return RET_BADPARM; }
 if(inputengine==NULL) { ieng=(_inputengine*)&iengine;    }
 else                  { ieng=(_inputengine*)inputengine; }

 if(ieng->magic!=(H)(PP)aaInputEngine)
  {
  aaMemoryFill(ieng,sizeof(_inputengine),0);
  ieng->magic=(H)(PP)aaInputEngine;
  }
 ieng->curr=(_inputstate*)&ieng->ises[0];
 ieng->prev=(_inputstate*)&ieng->ises[1];
 ieng->ldwn=(_inputstate*)&ieng->ises[2];
 ieng->rdwn=(_inputstate*)&ieng->ises[3];
 ieng->pcur=(_inputstate*)&ieng->ises[4];
 ieng->event_bit=0;
 ieng->bits_on=0;
 //ieng->events_waiting=0;
 ieng->is_ok=NO;
 // cit00: aaMemoryFill(ieng->event_byt,sizeof(ieng->event_byt),0);

 if(aaBitGet(ieng->internal_flag,0))
  {
  aaMemoryFill(ieng->ldwn,sizeof(_inputstate),0);
  ieng->internal_flag=aaBitClr(ieng->internal_flag,0);
  }
 if(aaBitGet(ieng->internal_flag,1))
  {
  aaMemoryFill(ieng->rdwn,sizeof(_inputstate),0);
  ieng->internal_flag=aaBitClr(ieng->internal_flag,1);
  }
 if(aaBitGet(ieng->internal_flag,2))
  {
  aaMemoryCopy(ieng->prev,sizeof(_inputstate),ieng->pcur);
  aaMemoryFill(ieng->pcur,sizeof(_inputstate),0);
  ieng->internal_flag=aaBitClr(ieng->internal_flag,2);
  }


 while(1)
  {
  ///aaMemoryFill(ieng->event_byt,sizeof(ieng->event_byt),0); // cit00: moved to here

  if((ret=aaInputStateGet(ieng->curr))!=YES)
   {
   oops;
   //if(ret!=RET_NOTREADY) { oops; }
   return ret;
   }

  aaMemoryFill(ieng->event_byt,sizeof(ieng->event_byt),0); // cit00: moved to here
  ieng->is_ok=YES;
  ieng->seq=aa.input_system.engine_sequence;
  curr=(_inputstate*)ieng->curr;
  prev=(_inputstate*)ieng->prev;
  ldwn=(_inputstate*)ieng->ldwn;
  rdwn=(_inputstate*)ieng->rdwn;
  pcur=(_inputstate*)ieng->pcur;


  if(curr->is_left!=prev->is_left)
   {
   if(curr->is_left==YES)    {    aaMemoryCopy(ieng->ldwn,sizeof(_inputstate),ieng->curr);    }
   else                      {    ieng->internal_flag=aaBitSet(ieng->internal_flag,0);        }
   if(curr->is_left==YES&&prev->is_left==NO&&ldwn->is_left==YES&&ldwn->over_handle!=0)
    {
    aaSurfaceCursorCapture(ldwn->over_handle,YES);
    }
   else
   if(curr->is_left==NO&&prev->is_left==YES)
    {
    aaSurfaceCursorCapture(ldwn->over_handle,NO);
    }
   }

  //--------------------------
  if(curr->is_right!=prev->is_right)
   {
   if(curr->is_right==YES)    {    aaMemoryCopy(ieng->rdwn,sizeof(_inputstate),ieng->curr);    }
   else                       {    ieng->internal_flag=aaBitSet(ieng->internal_flag,1);        }

   if(curr->is_right==YES&&prev->is_right==NO&&rdwn->is_right==YES&&rdwn->over_handle!=0)
    {
    aaSurfaceCursorCapture(rdwn->over_handle,YES);
    }
   else
   if(curr->is_right==NO&&prev->is_right==YES)
    {
    aaSurfaceCursorCapture(rdwn->over_handle,NO);
    }
   }
  break;
  }
 /*================================================================================*/

 if(aa.input_system.ihke_events_waiting!=0)
  {
  logg("%s:%i ievw=%I64u",__func__,__LINE__,aa.input_system.ihke_events_waiting);
  }

 /*================================================================================*/
 while(1)
  {
  //---------------------------------------------- left clicks
  if(curr->is_left==YES&&prev->is_left==NO&&ldwn->is_left==YES)     {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_LeftDown);   }
  if(curr->is_left==NO&&prev->is_left==YES&&ldwn->is_left==YES)     {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_LeftUp);     }
  if(curr->is_left==YES&&prev->is_left==YES&&ldwn->is_left==YES)    {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_LeftHeld);   }
  //---------------------------------------------- right clicks
  if(curr->is_right==YES&&prev->is_right==NO&&rdwn->is_right==YES)  {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightDown);  }
  if(curr->is_right==NO&&prev->is_right==YES&&rdwn->is_right==YES)  {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightUp);    }
  if(curr->is_right==YES&&prev->is_right==YES&&rdwn->is_right==YES) {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_RightHeld);  }
  //---------------------------------------------- spots
  if(curr->spot_index!=-1&&prev->spot_index==-1)                    {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotEnter);  }
  else
  if(curr->spot_index!=-1&&prev->is_ok!=YES)                        {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotEnter);  } //citsys04:

  if(curr->spot_index!=-1&&prev->spot_index!=-1&&prev->is_ok==YES)   //citsys04:
   {
   if(curr->spot_index!=prev->spot_index)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotEnter);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotChange);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotLeave);
    }
   }

  if(curr->spot_index==-1&&prev->spot_index!=-1&&prev->is_ok==YES)   //citsys04:
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotLeave);
   }



  //---------------------------------------------- surfaces
  #if 1
  if(curr->over_handle!=0&&prev->over_handle==0)   {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);  }
  else
  if(curr->over_handle!=0&&prev->is_ok!=YES)       {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);  } //citsys04:
  if(curr->over_handle!=0&&prev->over_hwnd!=curr->over_hwnd)         //citsys04:
   {
   if(prev->over_handle!=0)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceChange);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceLeave);
    }
   else
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);
    }
   }
  if(curr->over_handle==0&&prev->over_handle!=0&&prev->is_ok==YES)   //citsys04:
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceLeave);
   }
  #else // maybe the following works better, try both
  if(curr->over_handle!=0&&prev->over_handle==0)   {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);  }
  else
  if(curr->over_handle!=0&&prev->is_ok!=YES)       {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);  } //citsys04:

  if(curr->over_handle!=0&&prev->over_handle!=0&&prev->is_ok==YES)   //citsys04:
   {
   if(curr->over_handle!=prev->over_handle)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceEnter);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceChange);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceLeave);
    }
   }

  if(curr->over_handle==0&&prev->over_handle!=0&&prev->is_ok==YES)   //citsys04:
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SurfaceLeave);
   }
  #endif



  //---------------------------------------------- wheel
  if(curr->wheel!=prev->wheel)                                      {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_WheelChange);   }
  //---------------------------------------------- keys
  if(curr->key_msg!=0)                                              {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyMsg);   }
  if(aaMemoryCompare(&curr->vkey_state,sizeof(curr->vkey_state),&prev->vkey_state,0)!=YES)
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_VkeyStateChange);
   }
  //---------------------------------------------- keys
  if(curr->key_msg=='d')
   {
   kr=(H)(curr->skey<<8)+curr->vkey;

   if(aa.input_system.vs_key_rep[kr]==0)   {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyDown);  }
   else                                    {  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyHeld);  }
   if(aa.input_system.vs_key_rep[kr]<126)
    {
    aa.input_system.vs_key_rep[kr]++;
    }
   ieng->key_rep[curr->vkey]=aa.input_system.vs_key_rep[kr];
   }
  if(curr->key_msg=='u')
   {
   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_KeyUp);
   kr=(H)(curr->skey<<8)+curr->vkey;
   if(aa.input_system.vs_key_rep[kr]==0)
    {
    aaDebugHwnds();
    aaWinEventLog(2,0,123,8999,"%s %s %i\nup but rep was zero kr=%02x %02x %02x %02x %02x %c %ci",__FILE__,__func__,__LINE__,kr,curr->skey,curr->vkey,curr->akey,curr->xkey,aaCharIsVisible(curr->akey)?curr->akey:32,aaCharIsVisible(curr->xkey)?curr->xkey:32);
    aa_stats[9]++;
    }
   aa.input_system.vs_key_rep[kr]=0;
   ieng->key_rep[curr->vkey]=aa.input_system.vs_key_rep[kr];
   }

  //---------------------------------------------- mouse
  if(aaCordEqualsCord(&curr->cord,&prev->cord)!=YES)                {   ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_Move);   }

  if(aaBitGet(ieng->event_bit,aa_IE_Move))
   {
   if(curr->is_left&&ldwn->is_left)
    {
    if(aa.input_system.is_dragging!=YES)
     {
     ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_DragStart);
     aa.input_system.is_dragging=YES;
     }
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_Drag);
    }
   }
  ieng->is_dragging=aa.input_system.is_dragging;
  if(aaBitGet(ieng->event_bit,aa_IE_LeftUp))
   {
   if(aa.input_system.is_dragging==YES)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_DragEnd);
    aa.input_system.is_dragging=NO;
    }
   }
  //-----------------------------------------------spot clicking
  if(aaBitGet(ieng->event_bit,aa_IE_LeftUp))
   {
   if(ldwn->over_hwnd==curr->over_hwnd)
    {
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_SpotClick);
    ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_Click);
    if(ldwn->spot_id==0||curr->spot_id!=ldwn->spot_id)
     {
     ieng->event_bit=aaBitClr(ieng->event_bit,aa_IE_SpotClick);
     }
    }
   }
  break;
  }
 /*================================================================================*/

 if(aa.input_system.ihke_events_waiting!=0)
  {
  logg("%s:%i ievw=%I64u",__func__,__LINE__,aa.input_system.ihke_events_waiting);
  }

 if(curr->focus_hwnd!=prev->focus_hwnd)
  {
  ieng->event_bit=aaBitSet(ieng->event_bit,aa_IE_FocusChange);
  }


 if(ieng->event_bit!=0)
  {
  for(i=0;i<64;i++)
   {
   if(aaBitGet(ieng->event_bit,i))  {   ieng->event_byt[i]=1;  ieng->bits_on++; }
   }
  }
 if(ieng->bits_on!=0)
  {
  aa.input_system.engine_sequence++;
  }

 // sanity
 if(curr->spot_id!=0) { ieng->c_spot=curr->spot_ptr; }
 if(prev->spot_id!=0) { ieng->p_spot=prev->spot_ptr; }
 if(ldwn->spot_id!=0) { ieng->l_spot=ldwn->spot_ptr; }
 if(rdwn->spot_id!=0) { ieng->r_spot=rdwn->spot_ptr; }
 aaMemoryCopy(pcur,sizeof(_inputstate),curr);
 ieng->internal_flag=aaBitSet(ieng->internal_flag,2);


 if(ieng->bits_on)
  {
  c=0;
  for(i=0;i<64;i++)
   {
   if(ieng->event_byt[i]) { ieng->event[c]=i; c++; if(c>=aaElementCount(ieng->event)) { break; } }
   }

  }

  /*
 if(aa.input_system.input_stream_que.handle!=0)
  {
  aaQueStatus(aa.input_system.input_stream_que.handle,&aa.input_system.input_stream_que.status);
  ieng->stream_events_waiting=(Q)aa.input_system.input_stream_que.status.bytes;
  ieng->stream_events_waiting/=sizeof(_inputstream);
  }
  */


 return RET_YES;
 }




 B aaInputEventToString                (Q eventbit,H from,H count,VP str)
 {
 H i,b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str) { aaStringNull(str); }
 if(from>=64) { return RET_BOUNDS; }
 if(count>64) { return RET_BOUNDS; }
 if((from+count)>64) { return RET_BOUNDS; }
 for(i=0;i<(H)count;i++)
  {
  b=from+i;
  switch(b)
   {
   case aa_IE_LeftDown: //                0
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","LcD");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_LeftUp: //                  1
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","LcU");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_LeftHeld: //                2
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","LcH");   } else { aaStringAppendf(str,"%4s"," "); }
   break;


   case aa_IE_RightDown: //               3
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","RcH");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_RightUp: //                 4
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","RcU");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_RightHeld: //               5
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","RcH");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_SpotEnter: //               6
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","SpE");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_SpotChange: //              7
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","SpC");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_SpotLeave: //               8
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","SpL");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_WheelChange: //             9
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","WhC");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_KeyDown: //                 12
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","KyD");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_KeyUp: //                   13
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","KyU");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_KeyHeld: //                 14
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","KyH");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_Move: //                    15
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","Mve");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_DragStart: //               18
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","DrS");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_Drag: //                    19
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","Drg");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_DragEnd:  //                20
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","Dre");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_Click: //                   21
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","clk");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_SpotClick: //               22
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","sck");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_FocusChange: //             24
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","FoC");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_SurfaceEnter: //            27
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","SfE");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_SurfaceChange: //           28
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","SfC");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_SurfaceLeave: //            29
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","SfL");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_KeyMsg: //                  30
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","Kym");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   case aa_IE_VkeyStateChange: //         31
   if(aaBitGet(eventbit,b)) {  aaStringAppendf(str,"%4s","VkC");   } else { aaStringAppendf(str,"%4s"," "); }
   break;

   default:
   aaStringAppendf(str,"%4s"," ");
   break;
   }
  }
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/






 B aaDisplaySet                        (_size*size,B bits,B revert)
 {
 DEVMODE dm;
 N res;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
// if(size==NULL&&bits==0) { return RET_BADPARM; }
 if(bits!=0&&bits!=15&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 if(size!=NULL)
  {
  if(aaSizeIsValid(size)!=YES) { return RET_BADPARM; }
  }
 if(size!=NULL||bits!=0)
  {
  aaMemoryFill(&dm,sizeof(dm),0);
  dm.dmSize=sizeof(dm);
  if(size!=NULL) { dm.dmFields=(DM_PELSWIDTH|DM_PELSHEIGHT); }
  if(bits!=0)    { dm.dmFields|=DM_BITSPERPEL; }
  dm.dmBitsPerPel=bits;
  if(size!=NULL) { dm.dmPelsWidth=size->w;  dm.dmPelsHeight=size->h; }
  res=ChangeDisplaySettings(&dm,0);
  switch(res)
   {
   case DISP_CHANGE_SUCCESSFUL:  break;
   case DISP_CHANGE_RESTART:  oof;  break;
   case DISP_CHANGE_BADFLAGS:   return RET_BADPARM;
   case DISP_CHANGE_FAILED: return RET_FAILED;
   case DISP_CHANGE_BADMODE: return RET_FAILED;
   case DISP_CHANGE_NOTUPDATED: return RET_FAILED;
   default: oof; return RET_FAILED;
   }
  }
 if(revert==YES) { aa.display_system.is_revert=YES; }
 return RET_YES;
 }




#if 0


void displaydemo (void)
 {
 W WidthMm, HeightMm;
 DISPLAY_DEVICE ddMon;
 DISPLAY_DEVICE dd;
 DWORD dev;
 DWORD devMon;
 C DeviceID[_1K];

 dd.cb=sizeof(dd);
 dev=0;
 while(EnumDisplayDevices(0,dev,&dd,0))
  {
  aaMemoryFill(&ddMon,sizeof(ddMon),0);
  ddMon.cb=sizeof(ddMon);
  devMon=0;
  while(EnumDisplayDevices(dd.DeviceName,devMon,&ddMon,0))
   {
   if(ddMon.StateFlags&DISPLAY_DEVICE_ACTIVE&&!(ddMon.StateFlags&DISPLAY_DEVICE_MIRRORING_DRIVER))
    {
    if(aa_DisplayGetSizeForDevID(DeviceID,&WidthMm,&HeightMm))
     {
     aaDebugf("%s| %s | %s | wh=%i %i",ddMon.DeviceName,ddMon.DeviceString,ddMon.DeviceID,WidthMm,HeightMm);
     }
    }
   devMon++;
   aaMemoryFill(&ddMon,sizeof(ddMon),0);
   ddMon.cb=sizeof(ddMon);
   }
  aaMemoryFill(&dd,sizeof(dd),0);
  dd.cb=sizeof(dd);
  dev++;
  }
 }


 #endif



 B aaDisplayInfoGet                    (_displayinfo*displayinfo)
 {
 HDC dc;
 HWND wnd,twnd;
 RECT rr;
 H i,todo,pos;
 aa_MONITOR_INFO mi;
 N vars[1+(64*6)]; // 64 monitots, each on is monitorhandle,hdc,rect ,, plus 1 for monitor count
 ///
 W WidthMm,HeightMm;
 DISPLAY_DEVICE ddMon;
 DWORD devMon;
 C DeviceID[_1K];
 D area;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(displayinfo==NULL) { return RET_BADPARM; }
 /*
 if(atlaunch==YES)
  {
  if(aaSizeIsValid(&aa.display_system.launch_display_info.screen_size)!=YES||aa.display_system.launch_display_info.monitor_count==0)
   {
   return RET_FAILED;
   }
  aaMemoryCopy(displayinfo,sizeof(_displayinfo),&aa.display_system.launch_display_info);
  return RET_YES;
  }
*/
 aaMemoryFill(displayinfo,sizeof(_displayinfo),0);
 displayinfo->magic=aaHPP(aaDisplayInfoGet);
 aaRectSet(&displayinfo->virtual_rect,GetSystemMetrics(76),GetSystemMetrics(77),GetSystemMetrics(78),GetSystemMetrics(79));
 aaSizeSet(&displayinfo->screen_size,GetSystemMetrics(SM_CXSCREEN),GetSystemMetrics(SM_CYSCREEN));
 if(aaSizeIsValid(&displayinfo->screen_size)!=YES)   { oof;  return RET_FAILED;   }
 displayinfo->aspect_ratio=(F)displayinfo->screen_size.w/(F)displayinfo->screen_size.h;
 if(displayinfo->aspect_ratio<1.0) { displayinfo->is_tall_screen=YES; }
 if(displayinfo->aspect_ratio>1.6) { displayinfo->is_wide_screen=YES; }
 //monitor_tall_wide
 if((dc=GetDC(GetDesktopWindow()))==NULL)   {  oof; return RET_FAILED;   }
 displayinfo->screen_bits=(B)GetDeviceCaps(dc,BITSPIXEL);
 displayinfo->screen_dpi.w=GetDeviceCaps(dc,LOGPIXELSX);
 displayinfo->screen_dpi.h=GetDeviceCaps(dc,LOGPIXELSY);
 //displayinfo->screen_mm.w=GetDeviceCaps(dc,HORZSIZE);
 //displayinfo->screen_mm.h=GetDeviceCaps(dc,VERTSIZE);
 displayinfo->screen_vrefresh=GetDeviceCaps(dc,VREFRESH);
 ReleaseDC(GetDesktopWindow(),dc);
 if(displayinfo->screen_bits==0)  { oof;  return RET_FAILED;   }
 wnd=aa.input_system.tray_hwnd;
 if(wnd==NULL)
  {
  if((wnd=FindWindow("Shell_TrayWnd",NULL))==NULL) { oof; return RET_FAILED; }
  aa.input_system.tray_hwnd=wnd;
  }
 displayinfo->taskbar_hwnd=wnd;

 if(GetWindowRect(wnd,&rr)==0) { oof; return RET_FAILED; }
 WinRectToRect(&rr,&displayinfo->taskbar_rect);
  if((rr.bottom-rr.top)>=(rr.right-rr.left))
   {
   if(rr.left>10) { displayinfo->taskbar_orientation=aa_DIRECTION_E; } // vert.left
   else           { displayinfo->taskbar_orientation=aa_DIRECTION_W; } // vert.right
   }
  else
   {
   if(rr.top>10) { displayinfo->taskbar_orientation=aa_DIRECTION_S; } // horz.bottom
   else          { displayinfo->taskbar_orientation=aa_DIRECTION_N; } // horz.top
   }
 if((twnd=FindWindowEx(wnd,NULL,"TrayNotifyWnd",NULL))!=NULL)
  {
  GetWindowRect(twnd,&rr);
  WinRectToRect(&rr,&displayinfo->tray_rect);
  displayinfo->tray_hwnd=wnd;
  }
 else
  {
  if((rr.bottom-rr.top)>=(rr.right-rr.left))
   {
   if(rr.left>10) { aaRectSet(&displayinfo->tray_rect,rr.left,rr.bottom-100,(rr.right-rr.left),100);  }
   else             { aaRectSet(&displayinfo->tray_rect,rr.left,rr.bottom-100,(rr.right-rr.left),100); }
   }
  else
   {
   if(rr.top>10) { aaRectSet(&displayinfo->tray_rect,rr.left-100,rr.top,100,(rr.bottom-rr.top)); }
   else            { aaRectSet(&displayinfo->tray_rect,rr.left-100,rr.top,100,(rr.bottom-rr.top)); }
   }
  }
 displayinfo->monitor_count=(B)GetSystemMetrics(80);
 aaMemoryFill(vars,sizeof(vars),0);
 displayinfo->monitor_primary_index=F8;
 if(displayinfo->monitor_count>=1)
  {
  if(aa.core_system.EnumDisplayMonitors(0,NULL,MonitorEproc,(LPARAM)vars)!=TRUE) { oof; }
  todo=vars[0];
  if(todo>displayinfo->monitor_count) { todo=displayinfo->monitor_count; }
  todo=displayinfo->monitor_count;
  todo=aaNumRoof(todo,aaElementCount(displayinfo->monitor_rect));
  for(i=0;i<todo;i++)
   {
   aaRectSet(&displayinfo->monitor_rect[i],vars[1+(i*6)+2],vars[1+(i*6)+3],vars[1+(i*6)+4]-vars[1+(i*6)+2],vars[1+(i*6)+5]-vars[1+(i*6)+3]);
   displayinfo->monitor_handle[i]=vars[1+(i*6)+0];
   if(displayinfo->monitor_handle[i]!=0&&displayinfo->monitor_primary_index==F8)
    {
    aaMemoryFill(&mi,sizeof(mi),0);
    mi.cb_size=sizeof(mi);
    if(aa.core_system.GetMonitorInfoEx((HANDLE)displayinfo->monitor_handle[i],&mi)!=0)
     {
     if((mi.flags&0x00000001))  {  displayinfo->monitor_primary_index=(B)i;     }
     aaMemoryFill(&ddMon,sizeof(ddMon),0);
     ddMon.cb=sizeof(ddMon);
     devMon=0;
     //aaNote(0,".. %s",mi.szDevice);
     while(EnumDisplayDevices(mi.szDevice,devMon,&ddMon,0))
      {
      if(ddMon.StateFlags&DISPLAY_DEVICE_ACTIVE&&!(ddMon.StateFlags&DISPLAY_DEVICE_MIRRORING_DRIVER))
       {
       if(aaStringFindChar(ddMon.DeviceName,0,&pos,BSLASH_CHAR,YES,3,YES)==YES)
        {
        if(aaStringNICompare(ddMon.DeviceName,mi.szDevice,pos,0)==YES)
         {
   //      aaNote(0,"++ %s",ddMon.DeviceName);
         if(aa_DisplayGetSizeForDevID(DeviceID,&WidthMm,&HeightMm))
          {
     //     aaNote(0,"%s %s (%u,%u)",ddMon.DeviceName,mi.szDevice,WidthMm,HeightMm);
          aaStringNCopy(displayinfo->monitor_name[i],ddMon.DeviceString,sizeof(displayinfo->monitor_name[0])-1,YES);
          aaSizeSet(&displayinfo->monitor_mm[i],WidthMm,HeightMm);
          displayinfo->monitor_ppmm[i][0]=(D)displayinfo->monitor_rect[i].w/(D)displayinfo->monitor_mm[i].w;
          displayinfo->monitor_ppmm[i][1]=(D)displayinfo->monitor_rect[i].h/(D)displayinfo->monitor_mm[i].h;

          area=((D)displayinfo->monitor_mm[i].w*(D)displayinfo->monitor_mm[i].w);
          area+=((D)displayinfo->monitor_mm[i].h*(D)displayinfo->monitor_mm[i].h);
          displayinfo->monitor_diagonal_mm[i]=sqrt(area);
          break;
          }
         }
        }


       }
      devMon++;
      aaMemoryFill(&ddMon,sizeof(ddMon),0);
      ddMon.cb=sizeof(ddMon);
      }
     }
    }
   }
  }
 for(i=0;i<16;i++)
  {
  if(displayinfo->monitor_handle[i]!=0)
   {
   if(displayinfo->monitor_rect[i].h!=0&&displayinfo->monitor_rect[i].w!=0)
    {
    displayinfo->monitor_aspect[i]=(F)displayinfo->monitor_rect[i].w/(F)displayinfo->monitor_rect[i].h;
    }
   }
  }

 if(SystemParametersInfo(SPI_GETWORKAREA,0,&rr,0)==0) { oow; }
 aaRectFromWinRect(&displayinfo->desktop_rect,&rr);
 return RET_YES;
 }








 B aaDisplayMonitorFromCord            (_displayinfo*displayinfo,_cord*cord,BP monitorindex)
 {
 HMONITOR mon;
 POINT pt;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(monitorindex) { *monitorindex=0; }
 if(displayinfo==NULL) { return RET_BADPARM; }
 if(cord==NULL)
  {
  WinPointSet(&pt,0,0);
  mon=MonitorFromPoint(pt,MONITOR_DEFAULTTOPRIMARY);
  }
 else
  {
  WinPointSet(&pt,cord->x,cord->y);
  mon=MonitorFromPoint(pt,MONITOR_DEFAULTTONEAREST);
  }
 if(monitorindex&&mon==0) { *monitorindex=0; return RET_YES; }
 for(i=0;i<16;i++)  { if((HMONITOR)displayinfo->monitor_handle[i]==mon&&mon!=0) {  break; }  }
 if(monitorindex) { *monitorindex=(B)i; }
 return RET_YES;
 }



 //if(cord==NULL) { return RET_BAD



 B aaDisplayGammaGet                   (WP gbuf)
 {
 B ret;
 HDC dc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(gbuf==NULL) { return RET_BADPARM; }
 if((ret=aa_DisplaySystemLoadModules())!=YES) { return ret; }
 if((dc=GetDC(0))==NULL) {  return RET_FAILED; }
 if(aa.display_system.GetDeviceGammaRamp (dc,gbuf)==FALSE) {  ret=RET_NOTSUPPORTED; }
 else                                  {  ret=RET_YES; }
 ReleaseDC(0,dc);
 return ret;
 }





 B aaDisplayGammaSet                   (WP gbuf)
 {
 B ret;
 HDC dc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(gbuf==NULL) { return RET_BADPARM; }
 if((ret=aa_DisplaySystemLoadModules())!=YES) { return ret; }
 if((dc=GetDC(0))==NULL) {  return RET_FAILED; }
 if(aa.display_system.SetDeviceGammaRamp (dc,gbuf)==FALSE) { ret=RET_NOTSUPPORTED;  }
 else                                  {  ret=RET_YES; }
 ReleaseDC(0,dc);
 return ret;
 }





 B aaDisplayGammaBrightnessSet         (WP gbuf,B brightness)
 {
 H i;
 N v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(gbuf==NULL) { return RET_BADPARM; }
 for(i=0;i<256;i++)
  {
  v=i*(brightness+128);
  v=aaNumRoof(v,65535);
  gbuf[0+i]=gbuf[256+i]=gbuf[512+i]=(WORD)v;
  }
 return RET_YES;
 }


 B aaDisplayBrightnessSet              (B brightness)
 {
 W gb[_2K];
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaDisplayGammaGet(gb))!=YES) { return ret; }
 if((ret=aaDisplayGammaBrightnessSet(gb,brightness))!=YES) { return ret; }
 if((ret=aaDisplayGammaSet(gb))!=YES) { return ret; }
 return RET_YES;
 }




 B aaDisplayBrightnessFlash            (B count,H sleep)
 {
 W gam[_2K];
 H i;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaDisplayGammaGet(gam);
 sleep=aaNumClamp(sleep,1,100);
 for(i=0;i<(H)count;i++)
  {
  aaDisplayGammaBrightnessSet(gam,0);
  aaDisplayGammaSet(gam);
  aaSleep(sleep);
  aaDisplayGammaBrightnessSet(gam,128);
  aaDisplayGammaSet(gam);
  aaSleep(sleep);
  }
 return RET_YES;
 }




 B aaDisplayPixelGet                   (_cord*cord,_rgba*pn)
 {
 HDC dc;
 COLORREF rpix;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(pn==NULL) { return RET_BADPARM; }
 if((dc=GetDC(0))==NULL) { return RET_FAILED; }
 rpix=GetPixel(dc,cord->x,cord->y);
 ReleaseDC(0,dc);
 if((Y)rpix==CLR_INVALID) { return RET_BOUNDS;  }
 pn->r=GetRValue(rpix);
 pn->g=GetGValue(rpix);
 pn->b=GetBValue(rpix);
 pn->a=255;
 return RET_YES;
 }




 B aaDisplayPixelSet                   (_cord*cord,_rgba*pn)
 {
 HDC dc;
 COLORREF pix,rpix;
 _rgba pb;
 N a1,a2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(cord==NULL) { return RET_BADPARM; }
 if(pn==NULL) { return RET_BADPARM; }
 if((dc=GetDC(0))==NULL) { return RET_FAILED; }
 if(pn->a==255)
  {
  pix=RGB(pn->r,pn->g,pn->b);
  rpix=SetPixel(dc,cord->x,cord->y,pix);
  ReleaseDC(0,dc);
  if((N)rpix==-1) {  return RET_FAILED; }
  return RET_YES;
  }
 rpix=GetPixel(dc,cord->x,cord->y);
 pb.r=GetRValue(rpix);
 pb.g=GetGValue(rpix);
 pb.b=GetBValue(rpix);
 a1=(N)(255-pn->a);     // a1=pixels transparency
 a2=(N)(pn->a);    // a2=how far is a1 from full solidness
 pb.b=(B)(((a1*pb.b)+(a2*pn->b))>>8);
 pb.g=(B)(((a1*pb.g)+(a2*pn->g))>>8);
 pb.r=(B)(((a1*pb.r)+(a2*pn->r))>>8);
 pb.a=255;
 pix=RGB(pb.r,pb.g,pb.b);
 rpix=SetPixel(dc,cord->x,cord->y,pix);
 ReleaseDC(0,dc);
 if((N)rpix==-1) {  return RET_FAILED; }
 return RET_YES;
 }




 B aaDisplayInfoToString               (_displayinfo*displayinfo,VP str)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(displayinfo==NULL) { return RET_BADPARM; }
 aaStringAppendf(str,"screen_size=%ix%i\n",displayinfo->screen_size.w,displayinfo->screen_size.h);
 aaStringAppendf(str,"screen_bits=%i\n",displayinfo->screen_bits);
 aaStringAppendf(str,"screen_dpi=%i,%i\n",displayinfo->screen_dpi.w,displayinfo->screen_dpi.h);
 //aaStringAppendf(str,"screen_mm=%i,%i\n",displayinfo->screen_mm.w,displayinfo->screen_mm.h);
 aaStringAppendf(str,"screen_vreshresh=%i\n",displayinfo->screen_vrefresh);
 aaStringAppendf(str,"taskbar_rect=%i,%i,%i,%i\n",displayinfo->taskbar_rect.x,displayinfo->taskbar_rect.y,displayinfo->taskbar_rect.w,displayinfo->taskbar_rect.h);
 aaStringAppendf(str,"taskbar_orientation=%i ");
 switch(displayinfo->taskbar_orientation)
  {
  case aa_DIRECTION_E: aaStringAppendf(str,"E\n"); break;
  case aa_DIRECTION_W: aaStringAppendf(str,"W\n"); break;
  case aa_DIRECTION_N: aaStringAppendf(str,"N\n"); break;
  case aa_DIRECTION_S: aaStringAppendf(str,"S\n"); break;
  default: aaStringAppendf(str,"?\n"); break;
  }
 aaStringAppendf(str,"taskbar_hwnd=0x%08x\n",displayinfo->taskbar_hwnd);
 aaStringAppendf(str,"tray_rect=%i,%i,%i,%i\n",displayinfo->tray_rect.x,displayinfo->tray_rect.y,displayinfo->tray_rect.w,displayinfo->tray_rect.h);
 aaStringAppendf(str,"tray_hwnd=0x%08x\n",displayinfo->tray_hwnd);
 aaStringAppendf(str,"is_wide_screen=%s\n",aaBoolString(displayinfo->is_wide_screen));
 aaStringAppendf(str,"is_tall_screen=%s\n",aaBoolString(displayinfo->is_tall_screen));
 aaStringAppendf(str,"aspect_ratio=%.2f\n",displayinfo->aspect_ratio);
 aaStringAppendf(str,"monitor_count=%i\n",displayinfo->monitor_count);
 aaStringAppendf(str,"monitor_primary_index=%i\n",displayinfo->monitor_primary_index);
 for(i=0;i<displayinfo->monitor_count;i++)
  {
  aaStringAppendf(str,"monitor:[%i]\n",i);
  aaStringAppendf(str,"monitor_rect=%i,%i,%i,%i\n",displayinfo->monitor_rect[i].x,displayinfo->monitor_rect[i].y,displayinfo->monitor_rect[i].w,displayinfo->monitor_rect[i].h);
  aaStringAppendf(str,"monitor_handle=0x%08x\n",displayinfo->monitor_handle[i]);
  aaStringAppendf(str,"monitor_aspect=%.2f\n",displayinfo->monitor_aspect[i]);
  aaStringAppendf(str,"monitor_name=%s\n",displayinfo->monitor_name[i]);
  aaStringAppendf(str,"monitor_mm=%i,%i\n",displayinfo->monitor_mm[i].w,displayinfo->monitor_mm[i].h);
  aaStringAppendf(str,"monitor_ppmm=%.2f,%.2f\n",displayinfo->monitor_ppmm[i][0],displayinfo->monitor_ppmm[i][1]);
  }
 aaStringAppendf(str,"virtual_rect=%i,%i,%i,%i\n",displayinfo->virtual_rect.x,displayinfo->virtual_rect.y,displayinfo->virtual_rect.w,displayinfo->virtual_rect.h);
 aaStringAppendf(str,"desktop_rect=%i,%i,%i,%i\n",displayinfo->desktop_rect.x,displayinfo->desktop_rect.y,displayinfo->desktop_rect.w,displayinfo->desktop_rect.h);
 return RET_YES;
 }



 B aaDisplayMonitorPowerSet            (B state)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state) { SendMessage(HWND_BROADCAST,WM_SYSCOMMAND,SC_MONITORPOWER,(LPARAM) -1); }
 else      { SendMessage(HWND_BROADCAST,WM_SYSCOMMAND,SC_MONITORPOWER,(LPARAM) 2); }
 return RET_YES;
 }



 B aaDisplayPowerBrightnessGet         (BP acordc,BP aclev,BP dclev)
 {
 BOOL br;
 HANDLE hdev;
 H bytes;
 B buf[256];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(acordc) { *acordc=F8; }
 if(aclev)  { *aclev=F8;  }
 if(dclev)  { *dclev=F8;  }
 hdev=CreateFile(TEXT("\\\\.\\LCD"),0,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
 if(hdev==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 br=DeviceIoControl(hdev,IOVIDQRY_DISPLAY_BRIGHT,NULL,0,buf,sizeof(buf),&bytes,NULL);
 CloseHandle(hdev);
 if(br==0)  { oow; return RET_FAILED; }
 if(bytes>=1)  { if(acordc) *acordc=buf[0]; }
 if(bytes>=2)  { if(aclev)  *aclev=buf[1];  }
 if(bytes>=3)  { if(dclev)  *dclev=buf[2];  }
 return RET_YES;
 }


 B aaDisplayPowerBrightnessSet         (B acordc,B aclev,B dclev)
 {
 BOOL br;
 HANDLE hdev;
 H bytes;
 B buf[3];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(acordc==0||acordc>3) { return RET_BADPARM; }
 if(aclev>=100) { aclev=100; }
 if(dclev>=100) { dclev=100; }
 buf[0]=(B)acordc;
 buf[1]=(B)aclev;
 buf[2]=(B)dclev;
 hdev=CreateFile(TEXT("\\\\.\\LCD"),0,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0,NULL);
 if(hdev==INVALID_HANDLE_VALUE) { return RET_FAILED; }
 br=DeviceIoControl(hdev,IOVIDSET_DISPLAY_BRIGHT,buf,3,NULL,0,&bytes,NULL);
 CloseHandle(hdev);
 if(br==0) { oow; return RET_FAILED; }
 return RET_YES;
 }



 B aaDisplayToMm                       (_displayinfo*displayinfo,B monitorindex,_cord*pixel,DP xmm,DP ymm)
 {
 B mi;
 D xr,yr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(displayinfo==NULL) { return RET_BADPARM; }
 if(displayinfo->magic!=aaHPP(aaDisplayInfoGet)) { return RET_NOTINITIALIZED; }
 if(xmm) { *xmm=0; }
 if(ymm) { *ymm=0; }
 if(monitorindex>=aaElementCount(displayinfo->monitor_rect)) { return RET_BOUNDS; }
 mi=monitorindex;
 if(displayinfo->monitor_mm[mi].w==0)    { return RET_FAILED; }
 if(displayinfo->monitor_mm[mi].h==0)    { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][0]==0) { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][1]==0) { return RET_FAILED; }
 if(pixel==NULL) { return RET_BADPARM; }
 xr=displayinfo->monitor_ppmm[mi][0];
 yr=displayinfo->monitor_ppmm[mi][1];
 xr=(D)pixel->x/xr;
 yr=(D)pixel->y/yr;
 if(xmm!=NULL) { *xmm=xr; }
 if(ymm!=NULL) { *ymm=yr; }
 return RET_YES;
 }






 B aaDisplayFromMm                     (_displayinfo*displayinfo,B monitorindex,D xmm,D ymm,_cord*pixel)
 {
 B mi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(displayinfo==NULL) { return RET_BADPARM; }
 if(displayinfo->magic!=aaHPP(aaDisplayInfoGet)) { return RET_NOTINITIALIZED; }
 if(pixel) { pixel->x=pixel->y=0; }
 if(monitorindex>=aaElementCount(displayinfo->monitor_rect)) { return RET_BOUNDS; }
 mi=monitorindex;
 if(displayinfo->monitor_mm[mi].w==0)    { return RET_FAILED; }
 if(displayinfo->monitor_mm[mi].h==0)    { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][0]==0) { return RET_FAILED; }
 if(displayinfo->monitor_ppmm[mi][1]==0) { return RET_FAILED; }
 if(pixel==NULL) { return RET_BADPARM; }
 xmm=xmm*displayinfo->monitor_ppmm[mi][0];
 ymm=ymm*displayinfo->monitor_ppmm[mi][1];
 pixel->x=(N)xmm;
 pixel->y=(N)ymm;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaUpdateAreaReset                   (_updatearea*updatearea)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(updatearea==NULL) { return RET_BADPARM; }
 aaMemoryFill(updatearea,sizeof(_updatearea),0);
 updatearea->magic=aa_UPDATEAREA_MAGIC;
 return RET_YES;
 }





 B aaUpdateAreaAdd                     (_updatearea*updatearea,_rect*rect)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(updatearea==NULL) { return RET_BADPARM; }
 if(updatearea->magic!=aa_UPDATEAREA_MAGIC) { return RET_FAILED; }
 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=YES) { oof; return ret; }
  if(updatearea->state==NO)  {  aaRectCopy(&updatearea->rect,rect);   }
  else                       {   aaRectAdd(&updatearea->rect,rect,&updatearea->rect);   }
  updatearea->state=YES;
  }
 return RET_YES;
 }




 B aaUpdateAreaRemove                  (_updatearea*updatearea,_rect*rect)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(updatearea==NULL) { return RET_BADPARM; }
 if(updatearea->magic!=aa_UPDATEAREA_MAGIC) { return RET_FAILED; }
 if(rect!=NULL)
  {
  if((ret=aaRectIsValid(rect))!=YES) { return ret; }
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaAudioCountGet                     (BP playcount,BP reccount)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(playcount!=NULL)  {  *playcount=(B)waveOutGetNumDevs();  }
 if(reccount!=NULL)   {  *reccount=(B)waveInGetNumDevs();  }
 return RET_YES;
 }





 B aaAudioNameGet                      (B id,B rec,VP name)
 {
 B count;
 WAVEINCAPS capi;
 WAVEOUTCAPS capo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name!=NULL) { aaStringNull(name); }
 if(id>=10) { return RET_NOTFOUND; }
 if(rec)
  {
  aaAudioCountGet(NULL,&count);
  if(id>=count) { return RET_NOTFOUND; }
  if(waveInGetDevCaps(id,&capi,sizeof(capi))!=MMSYSERR_NOERROR)   {   return RET_FAILED;   }
  if(name) {  aaStringNCopy(name,capi.szPname,32,YES); }
  }
 else
  {
  aaAudioCountGet(&count,NULL);
  if(id>=count) { return RET_NOTFOUND; }
  if(waveOutGetDevCaps(id,&capo,sizeof(capo))!=MMSYSERR_NOERROR)   {   return RET_FAILED;   }
  if(name) { aaStringNCopy(name,capo.szPname,32,YES); }
  }
 return RET_YES;
 }









 B aaAudioModeSet                      (_audiomode*audiomode,H frequency,B bits,B channels)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL) { return RET_BADPARM; }
 audiomode->frequency=frequency;
 audiomode->bits=bits;
 audiomode->channels=channels;
 if((ret=aa_AudioSystemModeVerify(audiomode))!=RET_YES)
  {
  return ret;
  }
 return RET_YES;
 }





 B aaAudioModeCopy                     (_audiomode*audiomode,_audiomode*saudiomode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL) { return RET_BADPARM; }
 if(saudiomode==NULL) { return RET_BADPARM; }
 audiomode->frequency=saudiomode->frequency;
 audiomode->bits=saudiomode->bits;
 audiomode->channels=saudiomode->channels;
 audiomode->rate=saudiomode->rate;
 audiomode->bps=saudiomode->bps;
 audiomode->mode=saudiomode->mode;
 return RET_YES;
 }





 B aaAudioModeIsValid                  (_audiomode*audiomode)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audiomode==NULL) { return RET_BADPARM; }
 ret=aa_AudioSystemModeVerify(audiomode);
 if(ret!=RET_YES) { return RET_FAILED; }
 return RET_YES;
 }







 B aaAudioBpmToSamples                 (_audiomode*audiomode,D bpm,HP samples)
 {
 B ret;
 D c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(bpm<=0.0) { return RET_BADPARM; }
 if(samples) { *samples=0; }
 c=(D)audiomode->frequency;
 c=c*60.0;
 c=c/bpm;
 c=c/4.0;
 if(samples) { *samples=(H)c; }
 return RET_YES;
 }






 B aaAudioBpmFromSamples               (_audiomode*audiomode,H samples,DP bpm)
 {
 B ret;
 D c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(bpm) { *bpm=0; }
 if(samples==0) { return RET_BADPARM; }
 c=(D)audiomode->frequency;
 c=c*60.0;
 c=c/(D)samples;
 c=c/4.0;
 if(bpm) { *bpm=(D)c; }
 return RET_YES;
 }



 B aaAudioSamplesToTime                (_audiomode*audiomode,H samples,DP ms)
 {
 B ret;
 D c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(ms) { *ms=0; }
 if(samples==0) { return RET_BADPARM; }
 c=(D)samples;
 c=c/(D)audiomode->frequency;
 if(ms) { *ms=(D)c; }

 return RET_YES;
 }


 B aaAudioSamplesFromTime              (_audiomode*audiomode,D ms,HP samples)
 {
 B ret;
 D c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(samples) { *samples=0; }
 if(ms<=0.0) { return RET_BADPARM; }
 c=(D)audiomode->frequency;
 c=c*ms;
 if(samples) { *samples=c; }
 return RET_YES;
 }


//=====================================================



 B aaAudioToFloats                     (_audiomode*audiomode,H isamples,VP idata,FP odata)
 {
 B ret;
 H i;
 D dub;
 IP pcm16;
 CP pcm8;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(isamples==0) { return RET_YES; }
 if(idata==NULL) { return RET_BADPARM; }
 if(odata==NULL) { return RET_BADPARM; }
 pcm16=(IP)idata;
 pcm8=(CP)idata;
 if(audiomode->bits==8)
  {
   if(audiomode->channels==1)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm8[(i)];
     dub=dub/128.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i)]=(F)dub;
     }
    }
   else
   if(audiomode->channels==2)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm8[(i*2)+0];
     dub=dub/128.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i*2)+0]=(F)dub;
     dub=(D)pcm8[(i*2)+1];
     dub=dub/128.0;
      if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i*2)+1]=(F)dub;
     }
    }
  }
 else
  if(audiomode->bits==16)
   {
   if(audiomode->channels==1)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm16[(i)];
     dub=dub/32768.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i)]=(F)dub;
     }
    }
   else
   if(audiomode->channels==2)
    {
    for(i=0;i<isamples;i++)
     {
     dub=(D)pcm16[(i*2)+0];
     dub=dub/32768.0;
     if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i*2)+0]=(F)dub;
     dub=(D)pcm16[(i*2)+1];
     dub=dub/32768.0;
      if(dub>+1.0) dub=+1.0;
     if(dub<-1.0) dub=-1.0;
     odata[(i*2)+1]=(F)dub;
     }
    }
   }
 return RET_YES;
 }






 B aaAudioFromFloats                   (_audiomode*audiomode,H isamples,FP idata,VP odata)
 {
 B ret;
 H i;
 D dub;
 IP pcm16;
 CP pcm8;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioModeIsValid(audiomode))!=YES) { return ret; }
 if(isamples==0) { return RET_YES; }
 if(idata==NULL) { return RET_BADPARM; }
 if(odata==NULL) { return RET_BADPARM; }
 pcm16=(IP)odata;
 pcm8=(CP)odata;

 if(audiomode->bits==8)
  {
 if(audiomode->channels==1)
  {
  for(i=0;i<isamples;i++)
   {
   dub=idata[(i)];
     dub=dub*128.0;
     if(dub>+127.0) dub=+127.0;
     if(dub<-128.0) dub=-128.0;
   pcm8[(i)]=(I)dub;
   }
  }
 else
 if(audiomode->channels==2)
  {
  for(i=0;i<isamples;i++)
   {
   dub=idata[(i*2)+0];
   dub=dub*128.0;
   if(dub>+127.0) dub=+127.0;
   if(dub<-128.0) dub=-128.0;
   pcm8[(i*2)+0]=(I)dub;
   dub=idata[(i*2)+1];
   dub=dub*128.0;
   if(dub>+127.0) dub=+127.0;
   if(dub<-128.0) dub=-128.0;
   pcm8[(i*2)+1]=(I)dub;
   }
  }

  }
 else
 if(audiomode->bits==16)
  {
 if(audiomode->channels==1)
  {
  for(i=0;i<isamples;i++)
   {
   dub=idata[(i)];
     dub=dub*32768.0;
     if(dub>+32767.0) dub=+32767.0;
     if(dub<-32768.0) dub=-32768.0;
   pcm16[(i)]=(I)dub;
   }
  }
 else
 if(audiomode->channels==2)
  {
  for(i=0;i<isamples;i++)
   {
   dub=idata[(i*2)+0];
   dub=dub*32768.0;
   if(dub>+32767.0) dub=+32767.0;
   if(dub<-32768.0) dub=-32768.0;
   pcm16[(i*2)+0]=(I)dub;
   dub=idata[(i*2)+1];
   dub=dub*32768.0;
   if(dub>+32767.0) dub=+32767.0;
   if(dub<-32768.0) dub=-32768.0;
   pcm16[(i*2)+1]=(I)dub;
   }
  }

  }

 return RET_YES;
 }


///=====================================================




 B aaAudioConverterInit                (_audioconverter*audioconverter,_audiomode*imode,_audiomode*omode)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audioconverter==NULL) { return RET_BADPARM; }
 if(imode==NULL) { return RET_BADPARM; }
 if(omode==NULL) { return RET_BADPARM; }
 if((ret=aaAudioModeIsValid(imode))!=YES) { return ret; }
 if((ret=aaAudioModeIsValid(omode))!=YES) { return ret; }
 aaMemoryFill(audioconverter,sizeof(_audioconverter),0);
 aaMemoryCopy(&audioconverter->i_mode,sizeof(_audiomode),imode);
 aaMemoryCopy(&audioconverter->o_mode,sizeof(_audiomode),omode);
// audioconverter->i_ratio=(D)imode->frequency/omode->frequency;
// audioconverter->o_ratio=(D)omode->frequency/imode->frequency;
 audioconverter->magic=aaHPP(aaAudioConverterInit);
 return RET_YES;
 }








 B aaAudioConverterProcess             (_audioconverter*audioconverter,H isamples,VP idata,D tempo,HP osamples,VP odata)
 {
 D oratio;
 D iratio;
 D oaccum;
 D iaccum;
 H i_pos;
 H o_pos;
 H prev_o_pos;
 H prev_i_pos;
 N dif_o_pos;
 N dif_i_pos;
 N r;
 H todo,sodo;
 IP s_16m;
 BP s_8m;
 D lv,rv;
 I temp_i;
 H k;
 IP pcmi;
 CP pcmc;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(audioconverter==NULL) { return RET_BADPARM; }
 if(audioconverter->magic!=aaHPP(aaAudioConverterInit)) { return RET_NOTINITIALIZED; }
 if(idata==NULL) {  return RET_BADPARM; }
 todo=isamples;

 if(tempo==0.0)  {  oof;  }
 else
 if(tempo==1.0)
  {
  iratio=(D)audioconverter->i_mode.frequency/(audioconverter->o_mode.frequency/tempo);
  oratio=1.0;
  }
 else
 if(tempo>1.0)
  {
  oratio=(D)(audioconverter->o_mode.frequency/tempo)/(audioconverter->i_mode.frequency);
  iratio=1.0;
  }
 else
 if(tempo<1.0)
  {
  iratio=(D)audioconverter->i_mode.frequency/(audioconverter->o_mode.frequency/tempo);
  oratio=1.0;
  //aaLog(-555,"ir=%.2f or=%.2f",iratio,oratio);
  }


 iaccum=0;
 oaccum=0;
  i_pos=0;
  o_pos=0;

  s_16m=(IP)idata;
  s_8m=(BP)idata;

  prev_o_pos=o_pos;
  prev_i_pos=i_pos;



  while(1)
   {
   if(i_pos>=todo)    {    break;    }
   lv=rv=0;
   if(audioconverter->i_mode.channels==1&&audioconverter->i_mode.bits==8)
    {
    temp_i=((s_8m[(i_pos*1)+0])-128)<<8;
    rv=lv=(D)temp_i;
    }
   else
   if(audioconverter->i_mode.channels==2&&audioconverter->i_mode.bits==8)
    {
    temp_i=((s_8m[(i_pos*2)+0])-128)<<8;
    lv=(D)temp_i;
    temp_i=((s_8m[(i_pos*2)+1])-128)<<8;
    rv=(D)temp_i;
    }
   else
   if(audioconverter->i_mode.channels==1&&audioconverter->i_mode.bits==16)
    {
    rv=lv=(D)(s_16m[(i_pos*1)+0]);
    }
   else
   if(audioconverter->i_mode.channels==2&&audioconverter->i_mode.bits==16)
    {
    lv=(D)(s_16m[(i_pos*2)+0]);
    rv=(D)(s_16m[(i_pos*2)+1]);
    }




   aa.audio_system.ch_block[(o_pos*2)+0]=rv;
   aa.audio_system.ch_block[(o_pos*2)+1]=lv;

   oaccum+=oratio;
   o_pos=(H)oaccum;
   iaccum+=iratio;
   i_pos=(H)iaccum;

   dif_o_pos=(o_pos-prev_o_pos);
   dif_i_pos=(i_pos-prev_i_pos);

   if(dif_o_pos>=2)
    {
    //aaDebugf("jumped %i to %i",prev_o_pos,o_pos);
    for(r=0;r<(dif_o_pos-1);r++)
     {
     prev_o_pos++;
     aa.audio_system.ch_block[(prev_o_pos*2)+0]=rv;
     aa.audio_system.ch_block[(prev_o_pos*2)+1]=lv;
     }
    }

   if(dif_i_pos>=2)
    {
    //aaDebugf("juiiid %i to %i",prev_i_pos,i_pos);
    oof;
    }

   prev_o_pos=o_pos;
   prev_i_pos=i_pos;
   //aaDebugf("oaccum=%.2f opos=%i iaccum=%.2f  i_pos=%i    ",oaccum,o_pos,iaccum,i_pos);
   }


 //audioconverter->i_accum=iaccum;
 ///audioconverter->o_accum=oaccum;
//aaLog(-555,"%s %i is=%i ipos=%i opos=%i",__FILE__,__LINE__,isamples,i_pos,o_pos);

 if(odata==NULL)  {  *osamples=o_pos;  return RET_YES;  }

 pcmi=(IP)odata;
 pcmc=(CP)odata;
 sodo=o_pos;
 if(audioconverter->o_mode.bits==8)
  {
  if(audioconverter->o_mode.channels==1)
   {
   for(k=0;k<sodo;k++)
    {
    temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    temp_i=(temp_i>>8)-128;
    pcmc[(k*1)+0]=(C)temp_i;
    }
   }
  else
  if(audioconverter->o_mode.channels==2)
   {
   for(k=0;k<sodo;k++)
    {
    temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    temp_i=(temp_i>>8)-128;
    pcmc[(k*2)+0]=(C)temp_i;
    temp_i=(I)aa.audio_system.ch_block[(k*2)+1];
    temp_i=(temp_i>>8)-128;
    pcmc[(k*2)+1]=(C)temp_i;
    }
   }
  }
 else
 if(audioconverter->o_mode.bits==16)
  {
  if(audioconverter->o_mode.channels==1)
   {
   for(k=0;k<sodo;k++)
    {
    temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    pcmi[(k*1)+0]=(I)temp_i;
    }
   }
  else
  if(audioconverter->o_mode.channels==2)
   {
   for(k=0;k<sodo;k++)
    {
    temp_i=(I)aa.audio_system.ch_block[(k*2)+0];
    pcmi[(k*2)+0]=(I)temp_i;
    temp_i=(I)aa.audio_system.ch_block[(k*2)+1];
    pcmi[(k*2)+1]=(I)temp_i;
    }
   }
  }

 *osamples=(sodo);
 return RET_YES;
 }




//=====================================================




 B aaAudioPitchTempoGet                (_aapitchtempo*aapitchtempo,N octave,N note,D fine,N mode)
 {
 D sem;
 D oct;
 F pv;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aapitchtempo==NULL) { return RET_BADPARM; }
 if(octave>7) { return RET_BOUNDS; }
 aapitchtempo->octave=octave;
 if(note>11)  { return RET_BOUNDS; }
 aapitchtempo->fine=fine;
 aapitchtempo->note=note;
 aapitchtempo->pitch=1.0;
 aapitchtempo->tempo=1.0;
 oct=(D)octave-2;
 aapitchtempo->piano=(N)(oct*12)+note;
 sem=(oct*12)+note;
 sem=sem+fine;
 pv=pow(2.,sem/12.);

 if(aaBitGet(mode,0))  {  aapitchtempo->pitch=pv;  }
 if(aaBitGet(mode,1))  {  aapitchtempo->tempo=1.0/pv;  }
 return RET_YES;
 }







 B aaAudioPitchShiftInit               (_aapitchshift*aapitchshift,N framesize,N osamp)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aapitchshift==NULL) { return RET_BADPARM; }
 if(framesize>4096) { return RET_BOUNDS; }
 aaMemoryFill(aapitchshift,sizeof(_aapitchshift),0);
 aapitchshift->magic=aaHPP(aaAudioPitchShiftInit);
 aapitchshift->frame_size=framesize;
 aapitchshift->osamp=osamp;
 return RET_YES;
 }





 B aaAudioPitchShift                   (_aapitchshift*aapitchshift,F amount,N isamps,F rate,FP indata,FP outdata)
 {
 D magn,phase,tmp,window,real,imag;
 D freqPerBin,expct;
 N i,k,qpd,index,inFifoLatency,stepSize,fftframesize2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aapitchshift==NULL) { return RET_BADPARM; }
 if(aapitchshift->magic!=aaHPP(aaAudioPitchShiftInit)) { return RET_NOTINITIALIZED; }
 if(amount==1.0&&rate==1.0)
  {
  aaMemoryCopy(outdata,sizeof(F)*isamps,indata);
  return RET_YES;
  }

 fftframesize2=aapitchshift->frame_size/2;
 stepSize=aapitchshift->frame_size/aapitchshift->osamp;
 freqPerBin=rate/(double)aapitchshift->frame_size;
 expct=2.*aaPi*(double)stepSize/(double)aapitchshift->frame_size;
 inFifoLatency=aapitchshift->frame_size-stepSize;
 if(aapitchshift->gRover==0) aapitchshift->gRover=inFifoLatency;

 for(i=0;i<isamps; i++)
  {
  aapitchshift->gInFIFO[aapitchshift->gRover]=indata[i];
  outdata[i]=aapitchshift->gOutFIFO[aapitchshift->gRover-inFifoLatency];
  aapitchshift->gRover++;
  if(aapitchshift->gRover>=aapitchshift->frame_size)
   {
   aapitchshift->gRover=inFifoLatency;
   for(k=0; k<aapitchshift->frame_size;k++)
    {
    window=-.5*cos(2.*aaPi*(double)k/(double)aapitchshift->frame_size)+.5;
    aapitchshift->gFFTworksp[2*k]=aapitchshift->gInFIFO[k]*window;
    aapitchshift->gFFTworksp[2*k+1]=0.;
    }
   aa_AudioSystemFFT(aapitchshift->gFFTworksp,aapitchshift->frame_size,-1);
   for(k=0; k<=fftframesize2; k++)
    {
    real=aapitchshift->gFFTworksp[2*k];
    imag=aapitchshift->gFFTworksp[2*k+1];
    magn=2.*sqrt(real*real+imag*imag);
    phase=aa_AudioSystemAtan2(imag,real);
    tmp=phase - aapitchshift->gLastPhase[k];
    aapitchshift->gLastPhase[k]=phase;
    tmp-=(double)k*expct;
    qpd=tmp/aaPi;
    if(qpd>=0) qpd+=qpd&1;
    else          qpd-=qpd&1;
    tmp-=aaPi*(double)qpd;
    tmp=aapitchshift->osamp*tmp/(2.*aaPi);
    tmp=(double)k*freqPerBin+tmp*freqPerBin;
    aapitchshift->gAnaMagn[k]=magn;
    aapitchshift->gAnaFreq[k]=tmp;
    }
   aaMemoryFill(aapitchshift->gSynMagn,aapitchshift->frame_size*sizeof(F),0);
   //memset(aapitchshift->gSynMagn, 0, aapitchshift->frame_size*sizeof(F));
   //memset(aapitchshift->gSynFreq, 0, aapitchshift->frame_size*sizeof(F));
   aaMemoryFill(aapitchshift->gSynFreq,aapitchshift->frame_size*sizeof(F),0);
   for(k=0;k<=fftframesize2; k++)
    {
    index=k*amount;
    if(index<=fftframesize2)
     {
     aapitchshift->gSynMagn[index]+=aapitchshift->gAnaMagn[k];
     aapitchshift->gSynFreq[index]=aapitchshift->gAnaFreq[k]*amount;
     }
    }
   for(k=0;k<=fftframesize2;k++)
    {
    magn=aapitchshift->gSynMagn[k];
    tmp=aapitchshift->gSynFreq[k];
    tmp-=(double)k*freqPerBin;
    tmp/=freqPerBin;
    tmp=2.*aaPi*tmp/aapitchshift->osamp;
    tmp+=(double)k*expct;
    aapitchshift->gSumPhase[k]+=tmp;
    phase=aapitchshift->gSumPhase[k];
    aapitchshift->gFFTworksp[2*k]=magn*cos(phase);
    aapitchshift->gFFTworksp[2*k+1]=magn*sin(phase);
    }
   for(k=aapitchshift->frame_size+2; k<2*aapitchshift->frame_size; k++) aapitchshift->gFFTworksp[k]=0.;
   aa_AudioSystemFFT(aapitchshift->gFFTworksp,aapitchshift->frame_size,1);
   for(k=0; k<aapitchshift->frame_size; k++)
    {
    window=-.5*cos(2.*aaPi*(double)k/(double)aapitchshift->frame_size)+.5;
    aapitchshift->gOutputAccum[k]+=2.*window*aapitchshift->gFFTworksp[2*k]/(fftframesize2*aapitchshift->osamp);
    }
   for(k=0; k<stepSize; k++) aapitchshift->gOutFIFO[k]=aapitchshift->gOutputAccum[k];
   aaMemoryMove(aapitchshift->gOutputAccum,aapitchshift->frame_size*sizeof(F),aapitchshift->gOutputAccum+stepSize);
   //memmove(aapitchshift->gOutputAccum, aapitchshift->gOutputAccum+stepSize, aapitchshift->frame_size*sizeof(F));
   for(k=0; k<inFifoLatency; k++) aapitchshift->gInFIFO[k]=aapitchshift->gInFIFO[k+stepSize];
   }
  }

 return RET_YES;
 }



//=====================================================





 B aaAudioCreate                       (HP handle,B id,B rec,_audiomode*audiomode,H blocksize,H maxblocks,B(*proc)(H,H,H,H,H,VP,VP))
 {
 B ret;
 _aa_audioobject*audp;
 MMRESULT mr;
 H i,ms,elapsed;
 C txt[65];
 BP mem;
 H len;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_AudioSystemModeVerify(audiomode))!=RET_YES) { return ret; }
 if(blocksize<120) { return RET_BOUNDS; }
 if(maxblocks==0) { return RET_BOUNDS; }

 if((ret=aaAudioNameGet(id,rec,txt))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCreate(aa.audio_system.object_id,handle,(VP)&audp))!=RET_YES) { oops;  return ret; }
 audp->self_handle=*handle;

 if(rec!=YES)
  {
  audp->status.is_record=NO;
  audp->status.id=id;
  audp->status.blocksize=blocksize;
  audp->status.maxblocks=maxblocks;
  aaStringCopy(audp->status.name,txt);
  ret=aaMemoryCopy(&audp->status.mode,sizeof(_audiomode),audiomode);
  WinWaveFormatExFromAudioMode(&audp->wfx,audiomode);
  if((ret=aaQueCreate(&audp->que_handle))!=RET_YES) { oops; Boop; }
  if((ret=aaQueStatus(audp->que_handle,&audp->que_status))!=RET_YES) { oops; Boop; }
  len=blocksize*audiomode->bps;
  if((ret=aa_MemoryAllocate((VP)&mem,len*maxblocks,"WaveAlloc",NO))!=RET_YES) { oops; }
  aaCast(audp->wave_buf,BP,mem);
  for(i=0;i<maxblocks;i++)  {   WinWaveHdrSet(&audp->wave_hdr[i],(LPSTR)&audp->wave_buf[(i*len)],len,0,i,0);   }
  if((mr=waveOutOpen((LPHWAVEOUT)&audp->handle,(UINT)id,&audp->wfx,(DWORD)aa_AudioSystemOutProc,(DWORD)*handle,CALLBACK_FUNCTION))!=MMSYSERR_NOERROR)
   {
   aa_MemoryRelease(audp->wave_buf);
   aaQueDestroy(audp->que_handle);
   audp->que_handle=0;
   audp->wave_buf=NULL;
   aa_ObjectDestroy(aa.audio_system.object_id,*handle);
   *handle=0;
   if(mr==MMSYSERR_NODRIVER) { return RET_NOTFOUND; }
   return RET_FAILED;
   }
  for(i=0;i<audp->status.maxblocks;i++)
   {
   if(waveOutPrepareHeader((HWAVEOUT)audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR))!=MMSYSERR_NOERROR) { oof; break; }
   }
  if((mr=mixerOpen(&audp->status.mixer_device,(UINT)audp->handle,0,0,MIXER_OBJECTF_HWAVEOUT))!=MMSYSERR_NOERROR) { oof; }
  if(aa_AudioSystemGetLineControls((VP)&audp,&audp->ctrl_master_line,(H)-1,0,&audp->ctrl_master_volume,&audp->ctrl_master_mute)!=YES) oof;
  }
 else //////////////////////////////////////////////++++++++++++++++++++++++++++++++++++++++++++++++
  {
  audp->status.is_record=YES;
  audp->status.id=id;
  audp->status.blocksize=blocksize;
  audp->status.maxblocks=maxblocks;
  aaStringCopy(audp->status.name,txt);
  aaMemoryCopy(&audp->status.mode,sizeof(_audiomode),audiomode);
  WinWaveFormatExFromAudioMode(&audp->wfx,audiomode);
  if((ret=aaQueCreate(&audp->que_handle))!=RET_YES) { oops;  Boop; }
  if((ret=aaQueStatus(audp->que_handle,&audp->que_status))!=RET_YES) { oops; Boop; }
  len=blocksize*audiomode->bps;
  if((ret=aa_MemoryAllocate((VP)&mem,len*maxblocks,"WaveAlloc",NO))!=RET_YES) { oops; }
  aaCast(audp->wave_buf,BP,mem);
  for(i=0;i<maxblocks;i++) {  WinWaveHdrSet(&audp->wave_hdr[i],(LPSTR)&audp->wave_buf[i*len],len,0,i,0);   }
  if((mr=waveInOpen(&audp->handle,id,&audp->wfx,(H)aa_AudioSystemInProc,*handle,CALLBACK_FUNCTION))!=MMSYSERR_NOERROR)
   {
   aa_MemoryRelease(audp->wave_buf);
   aaQueDestroy(audp->que_handle);
   audp->que_handle=0;
   audp->wave_buf=NULL;
   aa_ObjectDestroy(aa.audio_system.object_id,*handle);
   *handle=0;
   if(mr==MMSYSERR_NODRIVER) { return RET_NOTFOUND; }
   return RET_FAILED;
   }
  for(i=0;i<audp->status.maxblocks; i++)
   {
   if(waveInPrepareHeader(audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR))!=MMSYSERR_NOERROR) { oof; break; }
   if(waveInAddBuffer(audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR))!=MMSYSERR_NOERROR) { oof; break; }
   }
  if((mr=mixerOpen(&audp->status.mixer_device,(UINT)audp->handle,0,0,MIXER_OBJECTF_HWAVEIN))!=MMSYSERR_NOERROR) { oof; }
  if(aa_AudioSystemGetLineControls((VP)&audp,&audp->ctrl_master_line,(H)-1,0,&audp->ctrl_master_volume,&audp->ctrl_master_mute)!=YES) oof;
  }

 aaTimerTikGet(&ms);
 logg("wainting for open_receive message");
 while(1)
  {
  if(audp->is_openreceived==YES) break;
  aaTimerTikElapsed(ms,&elapsed);
  if(elapsed>5000) { aaNote(0,"audio opn tout waitn 4 WIM_OPEN msg");  break;   }
  aaSleep(2); // was just sleep
  }
 audp->status.div=(D)(audiomode->frequency)/1000000.0;
 aaAudioReset(*handle);
 aaTimerInit(&audp->inactive_timer,1);
 audp->status.wave_device=audp->handle;

 // if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
 //audp->status.sample_position=0;
 audp->last_sample_position=audp->status.sample_position;
 audp->self_handle=*handle;
 audp->status.proc=proc;
 return RET_YES;
 }







 B aaAudioDestroy                      (H handle)
 {
 B ret;
 _aa_audioobject*audp;
 B isprot;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }



 if(audp->status.is_record!=YES)
  {
  waveOutReset((HWAVEOUT)audp->handle);
  for(i=0;i<audp->status.maxblocks;i++)
   {
   waveOutUnprepareHeader((HWAVEOUT)audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR));
   }
  waveOutReset((HWAVEOUT)audp->handle);
  waveOutClose((HWAVEOUT)audp->handle);
  if(audp->wave_buf!=NULL) {  aa_MemoryRelease(audp->wave_buf);  audp->wave_buf=NULL; }
  if(audp->que_handle!=0)
   {
   if(aaQueDestroy(audp->que_handle)!=RET_YES)
    {
    logg("que destroy failed");
    }
   audp->que_handle=0;
   }
  }
 else // record
  {
  waveInReset((HWAVEIN)audp->handle);
  for(i=0;i<audp->status.maxblocks;i++)
   {
   waveInUnprepareHeader((HWAVEIN)audp->handle,&audp->wave_hdr[i],sizeof(WAVEHDR));
   }
  waveInReset((HWAVEIN)audp->handle);
  waveInClose((HWAVEIN)audp->handle);
  if(audp->wave_buf!=NULL) {  aa_MemoryRelease(audp->wave_buf);  audp->wave_buf=NULL; }
  if(audp->que_handle!=0)
   {
   if(aaQueDestroy(audp->que_handle)!=RET_YES)
    {
    logg("que destroy failed");
    }
   audp->que_handle=0;
   }
  }
 if(audp->status.mixer_device!=0)
  {
  mixerClose(audp->status.mixer_device);
  }
 aa_ObjectDestroy(aa.audio_system.object_id,handle);
 return RET_YES;
 }







 B aa_AudioStatus                      (PP ptr)
 {
 B ret;
 _aa_audioobject*audp;

 aaCast(audp,_aa_audioobject*,*ptr);
 aa_AudioSystemProcessQues((VP)&audp);
 if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
 if(audp->status.sample_position!=audp->last_sample_position)
  {
  audp->inactive_timer.magic=0;
  audp->status.inactive=0;
  }
 else
  {
  if(audp->inactive_timer.magic==0) { aaTimerInit(&audp->inactive_timer,1); }
  aaTimerUpdate(&audp->inactive_timer,1);
  audp->status.inactive=audp->inactive_timer.elapsed;
  }
 audp->last_sample_position=audp->status.sample_position;
 aaQueStatus(audp->que_handle,&audp->que_status);
 audp->status.samples_qued=audp->que_status.bytes/audp->status.mode.bps;
 return RET_YES;
 }









 B aaAudioStatus                       (H handle,_audiostatus*audiostatus)
 {
 B ret;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 aa_AudioStatus((VP)&audp);
 if(audiostatus) {   aaMemoryCopy(audiostatus,sizeof(_audiostatus),&audp->status);   }
 return RET_YES;
 }





 B aaAudioReset                        (H handle)
 {
 B ret;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(audp->status.is_record==YES)
  {
  if(waveInReset(audp->handle)!=MMSYSERR_NOERROR) { oof; Boop; return RET_FAILED; }
  audp->status.is_paused=YES;
  }
 else
  {
  if(waveOutReset((HWAVEOUT)audp->handle)!=MMSYSERR_NOERROR) { oof; Boop; return RET_FAILED; }
  if(waveOutPause((HWAVEOUT)audp->handle)!=MMSYSERR_NOERROR) { oof;  return RET_FAILED; }
  audp->status.is_paused=YES;
  }
 aaQueDiscard(audp->que_handle,F32);
 aaQueStatus(audp->que_handle,&audp->que_status);
 audp->status.mcs=0;
 audp->status.samples_qued=0;
 audp->status.sample_position=0;
 audp->status.samples_written=0;
 audp->status.samples_surplus=0;
 if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
 return RET_YES;
 }









 B aaAudioPause                        (H handle,B state)
 {
 B ret;
 _aa_audioobject*audp;
 MMRESULT mr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(audp->status.is_record==YES)
  {
  if(state==YES)
   {
   if(audp->status.is_paused==NO)
    {
    if(waveInStop(audp->handle)!=MMSYSERR_NOERROR) oof;
    audp->status.is_paused=YES;
    }
   }
  else
   {
   if(audp->status.is_paused==YES)
    {
    if(waveInStart(audp->handle)!=MMSYSERR_NOERROR) oof;
    audp->status.is_paused=NO;
    }
   }
  return RET_YES;
  }

 if(state==YES)
  {
  if(audp->status.is_paused==YES) { return RET_YES; }
  if((mr=waveOutPause((HWAVEOUT)audp->handle))!=MMSYSERR_NOERROR)
   {
   logg("mr=%i",mr);
   return RET_FAILED;
   }
  audp->status.is_paused=YES;
  }
 else
  {
  if(audp->status.is_paused==NO) { return RET_YES; }
  if((mr=waveOutRestart((HWAVEOUT)audp->handle))!=MMSYSERR_NOERROR)
   {
   oof;
   prevent_warning(mr);
   aaLog(-1,"mr=%i",mr);
   return RET_FAILED;
   }
  audp->status.is_paused=NO;
  }
 return RET_YES;
 }





 B aaAudioWrite                        (H handle,H samples,VP data)
 {
 B ret;
 _aa_audioobject*audp;
 H bytes;
 H todo;
 B block[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(samples==0)  {  return RET_YES;  }
 bytes=samples*audp->status.mode.bps;
 if  ((N) bytes<0||bytes>_128MEG) aaNote(0,"Tried 2 wrt smples=%i byts=%i",samples,bytes);
// aa_AudioSystemProcessQues((VP)&audp);
// if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;

 if(data==NULL)
  {
  aaMemoryFill(block,_2K,0);
  while(1)
   {
   todo=bytes;
   todo=aaNumRoof(todo,_2K);
   if(todo==0) break;
   if((ret=aaQueWrite(audp->que_handle,todo,block))!=RET_YES) { oops; return ret; }
   audp->status.samples_written+=(todo/audp->status.mode.bps);
   bytes-=todo;
//   aa_AudioSystemProcessQues((VP)&audp);
   }
  }
 else
  {
//  BUG,"Writing %i bytes writ=%i",bytes,audp->status.samples_written);
  if((ret=aaQueWrite(audp->que_handle,bytes,data))!=RET_YES) { oops; return ret; }
  audp->status.samples_written+=(bytes/audp->status.mode.bps);
//  BUG,"post Writing %i bytes writ=%i",bytes,audp->status.samples_written);
//  aa_AudioSystemProcessQues((VP)&audp);
  }

//  BUG,"A wrote %i writ=%i",samples,audp->status.samples_written);

 aa_AudioSystemProcessQues((VP)&audp);
 if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
// BUG,"ggm writ=%i",audp->status.samples_written);
//  BUG,"B wrote %i writ=%i",samples,audp->status.samples_written);
 return RET_YES;
 }














 B aaAudioRead                         (H handle,H samples,VP data)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaAudioPeek(handle,0,samples,data))!=RET_YES) {  return ret; }
 if((ret=aaAudioDiscard(handle,samples))!=RET_YES) {  return ret; }
 return RET_YES;
 }







 B aaAudioPeek                         (H handle,H sample,H samples,VP data)
 {
 B ret;
 _aa_audioobject*audp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
//  aa_AudioSystemProcessQues((VP)&audp);
// if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
 if(samples==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 if((ret=aaQuePeek(audp->que_handle,sample*audp->status.mode.bps,samples*audp->status.mode.bps,data))!=RET_YES) { return ret; }
 return RET_YES;
 }




 B aaAudioDiscard                      (H handle,H samples)
 {
 B ret;
 _aa_audioobject*audp;
 H bytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
// aa_AudioSystemProcessQues((VP)&audp);
// if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
 if(samples==F32) { bytes=audp->que_status.bytes/audp->status.mode.bps; bytes=bytes*audp->status.mode.bps; }
 else             { bytes=samples*audp->status.mode.bps; }
 if(bytes==0) { return RET_YES; }
 if((ret=aaQueDiscard(audp->que_handle,bytes))!=RET_YES) { return ret; }
 aaQueStatus(audp->que_handle,&audp->que_status);
 audp->status.samples_written+=(bytes/audp->status.mode.bps);
 aa_AudioSystemProcessQues((VP)&audp);
 if((ret=aa_AudioSystemUpdateSamplePosition((VP)&audp))!=RET_YES) oops;
 return RET_YES;
 }




 B aaAudioMuteSet                      (H handle,B state)
 {
 B ret;
 _aa_audioobject*audp;
 N val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 if(state)  {  val=1;  }
 else       {  val=0;  }
 if(aa_AudioSystemSetMute((VP)&audp,audp->ctrl_master_mute,&val)!=YES) { return RET_FAILED; }
 audp->status.is_mute=(B)val;
 return RET_YES;
 }





 B aaAudioVolumeSet                    (H handle,W volume)
 {
 B ret;
 _aa_audioobject*audp;
 N val;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.audio_system.object_id,handle,(VP)&audp,NULL))!=RET_YES) { return ret; }
 val=(N)volume;
 if(aa_AudioSystemSetVolume((VP)&audp,audp->ctrl_master_volume,&val)!=YES) { return RET_FAILED; }
 audp->status.volume=volume;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/




 B aaBiquadInit                        (_biquad*bq,B type,H srate,D freq,D gain,D width)
 {
 D za,omega,sn,cs,alpha,beta,sr;
 D a0,a1,a2,b0,b1,b2;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bq==NULL) { return RET_BADPARM; }
 aaMemoryFill(bq,sizeof(_biquad),0);
 if(srate==0||srate>96000) { return RET_BADPARM; }
 if(freq==0||freq>20000) { return RET_BADPARM; }
 sr=(D)srate;
 za=pow(10,gain/40);
 omega=2*aaPi*freq/sr;
 sn=sin(omega);
 cs=cos(omega);
 alpha=sn*sinh(0.69314718055994530942/2*width*omega/sn);
 beta=sqrt(za+za);
 switch (type)
  {
  case aa_BIQUAD_LPass:
  b0=(1-cs)/2;
  b1=1-cs;
  b2=(1-cs)/2;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_HPass:
  b0=(1+cs)/2;
  b1=-(1+cs);
  b2=(1+cs)/2;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_BPass:
  b0=alpha;
  b1=0;
  b2=-alpha;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_Notch:
  b0=1;
  b1=-2*cs;
  b2=1;
  a0=1+alpha;
  a1=-2*cs;
  a2=1-alpha;
  break;

  case aa_BIQUAD_PeakR:
  b0=1+(alpha*za);
  b1=-2*cs;
  b2=1-(alpha*za);
  a0=1+(alpha/za);
  a1=-2*cs;
  a2=1-(alpha/za);
  break;

  case aa_BIQUAD_LShlf:
  b0=za*((za+1)-(za-1)*cs+beta*sn);
  b1=2*za*((za-1)-(za+1)*cs);
  b2=za*((za+1)-(za-1)*cs-beta*sn);
  a0=(za+1)+(za-1)*cs+beta*sn;
  a1=-2*((za-1)+(za+1)*cs);
  a2=(za+1)+(za-1)*cs-beta*sn;
  break;

  case aa_BIQUAD_HShlf:
  b0=za*((za+1)+(za-1)*cs+beta*sn);
  b1=-2*za*((za-1)+(za+1)*cs);
  b2=za*((za+1)+(za-1)*cs-beta*sn);
  a0=(za+1)-(za-1)*cs+beta*sn;
  a1=2*((za-1)-(za+1)*cs);
  a2=(za+1)-(za-1)*cs-beta*sn;
  break;

  default:
  return RET_BADPARM;
  }
 bq->magic=aa_BIQUAD_MAGIC;
 bq->type=type;
 bq->rate=srate;
 bq->freq=freq;
 bq->gain=gain;
 bq->width=width;
 bq->a0=b0/a0;
 bq->a1=b1/a0;
 bq->a2=b2/a0;
 bq->a3=a1/a0;
 bq->a4=a2/a0;
 bq->x1=bq->x2=0;
 bq->y1=bq->y2=0;
 return RET_YES;
 }






 B aaBiquadProcess                     (_biquad*bq,D sin,DP sout)
 {
 D r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bq==NULL) { return RET_BADPARM; }
 if(sout==NULL) { return RET_BADPARM; }
 if(bq->magic!=aa_BIQUAD_MAGIC) { return RET_NOTSTARTED; }
 if(bq->type==0) {  *sout=sin;  return RET_YES;  }
 r=bq->a0*sin+bq->a1*bq->x1+bq->a2*bq->x2-bq->a3*bq->y1-bq->a4*bq->y2;
 bq->x2=bq->x1;
 bq->x1=sin;
 bq->y2=bq->y1;
 bq->y1=r;
 *sout=r;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/





 B aaVidCapCountGet                    (BP count)
 {
 H c,cnt;
 BOOL bl;

 if(count==NULL) { return RET_BADPARM; }
 cnt=0;
 for(c=0;c<10;c++)
  {
  bl=capGetDriverDescription(c,0,0,0,0);
  if(bl==TRUE) { cnt++; }
  }
 *count=(B)cnt;
 return RET_YES;
 }




 B aaVidCapNameGet                     (B id,VP name)
 {
 if(name==NULL) { return RET_BADPARM; }
 aaStringNull(name);
 if(id>=10) { return RET_NOTFOUND; }
 if(capGetDriverDescription(id,name,50,0,0)==FALSE) { return RET_NOTFOUND; }
 return RET_YES;
 }





 B aaVidCapCreate                      (HP handle,B id)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _aa_threadobject*thrp;
 H win_handle,bytes;
 HWND currently_active_window;
 BP mem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle==NULL)  {  return RET_BADPARM;  }
 if(id>=10) { return RET_NOTFOUND; }

 if((ret=aa_ObjectCreate(aa.vidcap_system.object_id,handle,(VP)&vdcp))!=RET_YES)  { oops; return ret;  }
 vdcp->self_handle=*handle;
 currently_active_window=GetActiveWindow();
 if(currently_active_window!=NULL)
  {
  if(aa_SurfaceSystemFindSurfaceByHwnd(&win_handle,NULL,currently_active_window)==YES)
   {
   vdcp->window_to_active_after_connect=win_handle;
   }
  }
  // start in high mode
 vdcp->status.is_previewmode=NO;
 if(aa_EventDefine(&vdcp->connect_event,YES,NO,"VidCap.Event.%i.%lx",id,GetTickCount())!=YES)
  {
  logg("dmdm");
  }
 vdcp->device_id=id;
 vdcp->status.id=id;
 capGetDriverDescription((WORD)vdcp->device_id,(CP)vdcp->status.name,32,(CP)vdcp->status.ver,32);
 if((ret=aaThreadCreate(&vdcp->thread_handle,aa_VidCapThread,*handle,YES))!=RET_YES)
  {
  logg("vidcapthreadcreate failed=%s",ret_string[ret]);
  aa_EventUndefine(&vdcp->connect_event);
  aa_ObjectDestroy(aa.vidcap_system.object_id,*handle);
  return RET_FAILED;
  }
 logg("radioing vidcap thread");
 aa_ObjectCheck(aa.thread_system.object_id,vdcp->thread_handle,(VP)&thrp,NULL);
 vdcp->thread_id=thrp->id;
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
 logg("allocating memory for vidcap frame");
 bytes=320*242*4;
 if((ret=aa_MemoryAllocate((VP)&mem,bytes,"vidcapframe",YES))!=RET_YES)
  {
  oops;
  if(aaThreadDestroy(vdcp->thread_handle)!=RET_YES) { oof; Boop; }
  aa_EventUndefine(&vdcp->connect_event);
  aa_ObjectDestroy(aa.vidcap_system.object_id,*handle);
  oops;
  return RET_FAILED;
  }
 vdcp->frame_buf=mem;
 vdcp->frame_buf_bytes=bytes;
 logg("memory for vidcap frame OK, unpausing vidcap thread ");
 aaThreadPause(vdcp->thread_handle,NO);
 logg("vidcap created");
 return RET_YES;
 }




 B aaVidCapCreateAutoDetect            (HP handle,B id,_size*size)
 {
 B ret;
 _aa_vidcapobject*vdcp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaSizeIsValid(size)!=YES) { return RET_BADPARM; }
 if((ret=aaVidCapCreate(handle,id))!=RET_YES) { return ret; }
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,*handle,(VP)&vdcp,NULL))!=RET_YES) { oops; }
 if(vdcp->status.is_detecting==YES) { return RET_YES; }
 if(vdcp->status.is_detected==YES) { return RET_YES; }
 vdcp->status.is_detecting=YES;
 aaSizeCopy(&vdcp->auto_detect_size,size);
 return RET_YES;
 }







 B aaVidCapDestroy                     (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _threadstatus ts;
 B isprot;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 logg("VidCapDestroy()");
 if(vdcp->status.is_ready)
  {
  if(vdcp->hwnd!=NULL)
   {
   if(vdcp->status.is_previewmode==YES)
    {
    if(capPreview(vdcp->hwnd,FALSE)==FALSE) { aaLog(__LINE__,"fail2 stop preview"); }
    }
   else
    {
    logg("Calling aa_VidCapAbort in vidcapdestroy");
    aa_VidCapAbort((VP)&vdcp);
    logg("aa_VidCapAbort returns in  vidcapdestroy");
    }
   vdcp->status.is_ready=NO;
   }
  else
   {
   oof;
   Boop;
   logg("indestroy, status was ready, but couldnt stop cap, as hwnd was null");
   }
  }
  logg("calling threadExit in VidCapDestroy()");
  aaThreadExit(vdcp->thread_handle);

 if(PostThreadMessage(vdcp->thread_id,WM_QUIT,0,0)==0)
  {
//  oow;
  logg("postthreadmessage failed");
  }

 go=0;
 while(1)
  {
  ret=aaThreadStatus(vdcp->thread_handle,&ts);
  if(ret!=YES) { oof; Boop; }
  if(ts.is_exited) break;
  aaSleep(1); // was just sleep
  go++;
  if(go>300) { break; }
  }

 if(vdcp->status.is_connected==YES)
  {
  capDriverDisconnect(vdcp->hwnd);
  vdcp->status.is_connected=NO;
  }

 if(vdcp->hwnd)
  {
  DestroyWindow(vdcp->hwnd);
  vdcp->hwnd=NULL;
  }
 if(vdcp->status.surface_handle!=0)
  {
  logg("Destroy vidcap frame surface");
  if(aaSurfaceDestroy(vdcp->status.surface_handle)!=RET_YES) oof;
  vdcp->status.surface_handle=0;
  aaMemoryFill(&vdcp->status.surface_status,sizeof(_surfacestatus),0);
  }
 if(vdcp->frame_buf!=NULL)
  {
  logg("Release vidcap frame buf");
  aa_MemoryRelease(vdcp->frame_buf);
  vdcp->frame_buf=NULL;
  vdcp->frame_buf_bytes=0;
  }
 if(vdcp->thread_handle!=0)
  {
  if(aaThreadDestroy(vdcp->thread_handle)!=RET_YES) { oof; Boop; }
  vdcp->thread_handle=0;
  }

 if(vdcp->connect_event.handle!=NULL)
  {
  if(aa_EventUndefine(&vdcp->connect_event)!=YES)
   {
   logg("dewD");
   }
  }
 aa_ObjectDestroy(aa.vidcap_system.object_id,handle);
 return RET_YES;
 }










 B aaVidCapStatus                      (H handle,_vidcapstatus*vidcapstatus)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _size s1;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }

// logg("aavidcapStatus is_connected=%s is_failed=%s",aaBoolString(vdcp->status.is_connected),aaBoolString(vdcp->status.is_failed));
 if(vdcp->status.is_connected==NO&&vdcp->status.is_failed==NO)
  {
  ret=aa_EventIsSignaled(&vdcp->connect_event);
  if(ret==RET_FAILED) { oof; Boop; }
  if(ret==RET_YES)
   {
//   aa_DIAG("...  aaVicCapStatus>>aa_EventIsSignaled>>YES");
   }
  else
   {
  // aa_DIAG("...  aaVidCapStatus>>aa_EventIsSignaled>>NO");
   }
  if(ret==RET_YES)
   {
   if(vdcp->is_connect_failed==NO)
    {
    // because vidcap steals window, we re-active after it connects
    if(vdcp->window_to_active_after_connect!=0)
     {
     ///  aaLog(__LINE__,"******** if there is focus problems, its cause i took this line out **********");
     aaSurfaceFocus(vdcp->window_to_active_after_connect);
     logg("VidCap About to activate after connect");
     vdcp->window_to_active_after_connect=0;
     }
    vdcp->status.is_connected=YES;
    logg("----- Vidcap %i conneced ---",vdcp->device_id);
    }
   else
    {
    vdcp->status.is_failed=YES;
    logg("Vidcap Failed");
    }
   }
  }
 // if sourcebox was opened, then closed and prior to it being opened we had an active hicallwindow
 // then reactivate it, to give it the original keyboard focus, before the sourcebox dialog was shown...
 if(vdcp->is_sourcebox_message_received==YES&&vdcp->status.is_sourcebox_open==YES&&vdcp->is_sourcebox_closed==YES)
  {
  if(vdcp->window_to_active_after_sourcebox_close!=0)
   {
   aaSurfaceFocus(vdcp->window_to_active_after_sourcebox_close);
   logg("Reactivated window %i after sourcebox close",vdcp->window_to_active_after_sourcebox_close);
   vdcp->window_to_active_after_sourcebox_close=0;
   }
  vdcp->status.is_sourcebox_open=NO;
  vdcp->is_sourcebox_closed=NO;
  }
 if(vidcapstatus)
  {
  aaMemoryCopy(vidcapstatus,sizeof(_vidcapstatus),&vdcp->status);
  }

 if(vdcp->status.is_detecting==NO)
  {
  if(vdcp->status.is_ready==YES&&vdcp->is_frame_waiting==YES) { vdcp->status.is_detected=YES; }
  return RET_YES;
  }

 switch(vdcp->auto_detect_stage)
  {
  case 0:
  vdcp->auto_detect_stage=10;
  break;

  case 10:
  if(vdcp->status.is_failed==YES)
   {
   vdcp->auto_detect_stage=200;
   vdcp->status.is_detecting=NO;
   break;
   }
  if(vdcp->status.is_connected==NO) { break; }
  vdcp->auto_detect_stage=20;
  break;

  case 20:
  aaSizeCopy(&s1,&vdcp->auto_detect_size);

//  BUG,"bitmode=%i",vdcp->auto_detect_bit_mode);
  switch(vdcp->auto_detect_bit_mode)
   {
   case 0:    ret=aaVidCapFormatSet(handle,&s1,24);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 1:    ret=aaVidCapFormatSet(handle,&s1,12);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 2:    ret=aaVidCapFormatSet(handle,&s1,11);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 3:    ret=aaVidCapFormatSet(handle,&s1,16);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 4:    ret=aaVidCapFormatSet(handle,&s1,32);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   case 5:    ret=aaVidCapFormatSet(handle,&s1,15);
              if(ret==YES) { vdcp->auto_detect_stage=40;  break; }
              break;
   default:
   vdcp->auto_detect_stage=200;
   vdcp->status.is_detecting=NO;
   vdcp->status.is_failed=YES;
   break;
   }
  if(vdcp->auto_detect_stage==20)
   {
   vdcp->auto_detect_bit_mode++;
   break;
   }
 // if(vdcp->auto_detect_stage==40) { BUG,"%i",vdcp->auto_detect_bit_mode); }
  break;

  case 40:
  if(vdcp->status.is_frameready!=YES) { break; }
  vdcp->auto_detect_stage=50;
  vdcp->status.is_detecting=NO;
  break;

  default:
  break;
  }


 if(vidcapstatus)
  {
  aaMemoryCopy(vidcapstatus,sizeof(_vidcapstatus),&vdcp->status);
  }
 // if(vdcp->is_auto_detecting==YES) { return RET_FORBIDDEN; }
 return RET_YES;
 }








 B aaVidCapFormatSet                   (H handle,_size*size,B bits)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 BITMAPINFO cool;
 aa_CAPTUREPARMS caparm;
 _size sz;
 HWND aw;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 #if aa_VIDCAP_ALLOW_YUY2==YES
 if(bits!=11&&bits!=12&&bits!=13&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #else
 if(bits!=11&&bits!=12&&bits!=16&&bits!=24&&bits!=32) { return RET_BADPARM; }
 #endif

 if((ret=aaSizeIsValid(size))!=RET_YES) { return ret; }
 if(vdcp->status.is_connected==NO)  {  return RET_NOTREADY;  }

 logg("Seeing if vidcap format is different");
 while(1)
  {
  aaSizeCopy(&sz,size);
  if(aaSizeEqualsSize(&sz,&vdcp->requested_capture_size)==NO) break;
  if(bits!=vdcp->requested_capture_bits) break;
  logg("nothing changed");
  return RET_YES;
  }

 if(vdcp->status.is_ready==YES)
  {
  if(vdcp->status.is_previewmode==NO)
   {
   //aaDebugf("Changing display in streammode, must abort");
   aa_VidCapAbort((VP)&vdcp);
   }
  else
   {
   oof;
   logg("line=%i",__LINE__);
   Boop; //
   }
  }
 vdcp->status.is_ready=NO;

 aaSizeCopy(&sz,size);
 WinBmpInfoSet(&cool,sz.w,sz.h,bits,NO);
 logg("Setting vidcap format");
 if(capSetVideoFormat(vdcp->hwnd,&cool,sizeof(cool))==FALSE)
  {
  return RET_FAILED;
  }
 aaSizeCopy(&vdcp->requested_capture_size,&sz);
 vdcp->requested_capture_bits=bits;
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
// vdcp->tikmicro.lo=0; vdcp->tikmicro.hi=0;
 vdcp->status.frames_dropped=0;
 vdcp->status.frame_number=0;
 vdcp->status.bits=(B)cool.bmiHeader.biBitCount;
 aaSizeSet(&vdcp->status.size,cool.bmiHeader.biWidth,cool.bmiHeader.biHeight);
 vdcp->using_bmp_compression=cool.bmiHeader.biCompression;
// logg("aaVidCapFormatSet VIDEOMODE: %i,%i (%i)",vdcp->status.size.w,vdcp->status.size.h,vdcp->status.bits);
 logg(" in %s mode",aaBoolStrings(vdcp->status.is_previewmode,"preview","non-preview"));
 if(vdcp->status.is_previewmode)
  {
//  aaDebugf("Setting capture device to preview mode");
  if(capPreview(vdcp->hwnd,TRUE)==FALSE) { oof; }
  logg("and no scaling");
  if(capPreviewScale(vdcp->hwnd,FALSE)==FALSE) { oof; }
  aw=GetActiveWindow();
  SetWindowLong(vdcp->hwnd,GWL_EXSTYLE,WS_EX_TOOLWINDOW);
               ///garlic SetWindowPos( vdcp->hwnd,HWND_TOPMOST,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);
               ///garlic ShowWindow(vdcp->hwnd,SW_SHOW);
  //log(Setting the capture preview rate to %i",(N)(1000.0/aa_VIDCAP_PreviewRate));
  //if(capPreviewRate(vdcp->hwnd, (N)(1000.0/aa_VIDCAP_PreviewRate))==FALSE) oof;
  if(capPreviewRate(vdcp->hwnd,30000)==FALSE) oof;
  oof;
  if(aw!=NULL) SetActiveWindow(aw);
  }
 else
  {
//  aaDebugf("calling cpaturesetsetup");
  WinCapParmsInit(&caparm);
  if(capCaptureSetSetup(vdcp->hwnd,&caparm,sizeof(caparm))==FALSE) { oof; Boop; }
//  aaDebugf("calling cpatureNOFILE");
  if(capCaptureSequenceNoFile(vdcp->hwnd)==FALSE) { oof; Boop; }
//  aaDebugf("done");
  }

 vdcp->status.is_ready=YES;
 logg("aa_vidcapformatSet success status.is_ready=YES");
 return RET_YES;
 }









 B aaVidCapPreviewSet                  (H handle,B state)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 _size old_size;
 B old_bits;
 BITMAPINFO cool;
 HWND active_window_hwnd;
 aa_CAPTUREPARMS caparm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }

 if(state==YES)
  {
  if(vdcp->status.is_previewmode==YES) {  return RET_YES;   }
  if(vdcp->status.is_ready==NO) // display not set, but we can let it know to goto preview when it does
   {
   vdcp->status.is_previewmode=YES;
   return RET_YES;
   }
  // cant change during sourcebox show
  if(vdcp->status.is_sourcebox_open==YES)  {   return RET_FAILED;   }
  // remember our settings
  aaSizeCopy(&old_size,&vdcp->status.size);
  old_bits=vdcp->status.bits;
  aa_VidCapAbort((VP)&vdcp);
  vdcp->status.is_ready=NO;
  WinBmpInfoSet(&cool,old_size.w,old_size.h,old_bits,NO);
  vdcp->is_frame_waiting=NO;
  vdcp->status.is_frameready=NO;
  vdcp->status.bits=(B)cool.bmiHeader.biBitCount;
  aaSizeSet(&vdcp->status.size,cool.bmiHeader.biWidth,cool.bmiHeader.biHeight);
  vdcp->using_bmp_compression=cool.bmiHeader.biCompression;
  vdcp->status.is_previewmode=YES;
  logg("aaVidcapPreviewSet(YES) ... calling capPreview=TRUE");

  if(capPreview(vdcp->hwnd,TRUE)==FALSE)
   {
   //aaDebugf("err func %s line %i",__func__,__LINE__);
   }
  if(capPreviewScale(vdcp->hwnd,FALSE)==FALSE)
   {
   //aaDebugf("err func %s line %i",__func__,__LINE__);
   }
  active_window_hwnd=GetActiveWindow();
  SetWindowLong(vdcp->hwnd,GWL_EXSTYLE,WS_EX_TOOLWINDOW);
  SetWindowPos(vdcp->hwnd,HWND_TOPMOST,0,0,0,0,SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE);
  ShowWindow(vdcp->hwnd,SW_SHOW);
///   if(capPreviewRate(vdcp->hwnd,(N)(1000.0/aa_VIDCAP_PreviewRate))==FALSE) { oof; }
  if(capPreviewRate(vdcp->hwnd,30000)==FALSE)
   {
   //aaDebugf("err func %s line %i",__func__,__LINE__);
   }
  if(active_window_hwnd!=NULL) SetActiveWindow(active_window_hwnd);
  vdcp->status.is_ready=YES;
  }
 else
  {
  if(vdcp->status.is_previewmode==NO)   {   return RET_YES;   }
  // display not set, but we can let it know to goto highmode when it does
  if(vdcp->status.is_ready==NO)  {  vdcp->status.is_previewmode=NO;   return RET_YES;   }
   /*
  // cant change during sourcebox show
  if(vdcp->status.is_sourcebox_open==YES)
   {
   return RET_FAILED;
   }
   */
  // remember our settings
  aaSizeCopy(&old_size,&vdcp->status.size);
  old_bits=vdcp->status.bits;

  if(capPreview(vdcp->hwnd,FALSE)==FALSE)
   {
   //aaDebugf("err func %s line %i",__func__,__LINE__);
   }
 //aa_VidCapAbort((VP)&vdcp);
 vdcp->status.is_ready=NO;
 WinBmpInfoSet(&cool,old_size.w,old_size.h,old_bits,NO);//,1,old_bits,BI_RGB,bytes,0,0);
 vdcp->status.is_frameready=NO;
 vdcp->is_frame_waiting=NO;
 vdcp->status.bits=(B)cool.bmiHeader.biBitCount;
 aaSizeSet(&vdcp->status.size,cool.bmiHeader.biWidth,cool.bmiHeader.biHeight);
 vdcp->using_bmp_compression=cool.bmiHeader.biCompression;
 vdcp->status.is_previewmode=NO;
 WinCapParmsInit(&caparm);
  logg("aaVidcapPreviewSet(NO) ... calling cpaturesetsetup");
 if(capCaptureSetSetup(vdcp->hwnd,&caparm,sizeof(caparm))==FALSE)
  {
  //aaDebugf("err func %s line %i",__func__,__LINE__);
  }
 if(capCaptureSequenceNoFile(vdcp->hwnd)==FALSE)
  {
  //aaDebugf("err func %s line %i",__func__,__LINE__);
  }
 vdcp->status.is_ready=YES;
  }
 return RET_YES;
 }





 B aaVidCapFrameIsReady                (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 if(vdcp->status.is_ready==NO)  {  return RET_NOTREADY;  }
 if(vdcp->is_frame_waiting==NO)   {  return RET_NOTREADY;  }
 return RET_YES;
 }





 B aaVidCapFrameNext                   (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 if(vdcp->status.is_ready==NO)  {  return RET_NOTREADY;  }
 if(vdcp->is_frame_waiting==NO)   {  return RET_NOTREADY;  }
 vdcp->is_frame_waiting=NO;
 vdcp->status.is_frameready=NO;
 return RET_YES;
 }







 B aaVidCapSourceBoxShow               (H handle)
 {
 B ret;
 _aa_vidcapobject*vdcp;
 H win_handle;
 HWND currently_active_window;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.vidcap_system.object_id,handle,(VP)&vdcp,NULL))!=RET_YES) { return ret; }
 if(vdcp->status.has_sourcebox==NO)  { return RET_NOTFOUND;  }


 if((ret=aaVidCapPreviewSet(handle,YES))!=YES) { oops; }
 if(vdcp->status.is_previewmode==NO)  {  return RET_FAILED;  }

 if(vdcp->status.is_ready==NO)
  {
  logg("notread");
  return RET_NOTREADY;
  }
 if(vdcp->status.is_sourcebox_open==YES)  {  return RET_YES;  }

 currently_active_window=GetActiveWindow();
 if(currently_active_window!=NULL)
  {
  if(aa_SurfaceSystemFindSurfaceByHwnd(&win_handle,NULL,currently_active_window)==YES)
   {
   vdcp->window_to_active_after_sourcebox_close=win_handle;
   }
  }
 vdcp->is_sourcebox_message_received=NO;
 vdcp->is_sourcebox_closed=NO;
 vdcp->status.is_sourcebox_open=YES;
 //aaDebugf("#%i %I64u ",__LINE__,aaMsRunning());
 if(PostThreadMessage(vdcp->thread_id,WM_USER_VIDCAP_SOURCE,0,0)==FALSE)
  {
  oow;
  }
 //if((ret=aaVidCapPreviewSet(handle,NO))!=YES) { oops; }
 //aaDebugf("#%i %I64u ",__LINE__,aaMsRunning());
 return RET_YES;
 }


 #if 0
    if(hw.capture.status.is_sourcebox_open==NO )
     {
     if(hw.capture.is_sourcebox_requested==YES)
      {
      aaVidCapPreviewSet(hw.capture.handle,YES);
      aaVidCapSourceBoxShow(hw.capture.handle);
      hwCaptureStatus();
//      aaVidCapStatus(hw.capture.handle,&hw.capture.status);
      hw.capture.is_frame=NO;
      hw.capture.is_sourcebox_requested=NO;
      }
     else
     if(hw.capture.status.is_previewmode==YES )
      {
      aaVidCapPreviewSet(hw.capture.handle,NO);
      hwCaptureStatus();
//      aaVidCapStatus(hw.capture.handle,&hw.capture.status);
      if(hw.capture.is_sourcebox_requested==YES) oof;
      hw.capture.is_frame=NO;
      }
     }
#endif







/*-----------------------------------------------/----------------------------------------------*/



 B aaWavLoad                           (_wav*wav,VP filename)
 {
 B ret;
 H fh;
 _filestreamstatus fs;
 BP mem;
 C ch[5];
 N itmp,bps,skip;
 I stmp,align;
 _audiomode am;
 D fo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wav==NULL)  { return RET_BADPARM; }
 aaMemoryFill(wav,sizeof(_wav),0);
 wav->magic=aaHPP(aaWavLoad);

 if(filename==NULL) { return RET_BADPARM; }
 //if(audiomode!=NULL) { aaMemoryFill(audiomode,sizeof(_audiomode),0); }
 //aaMemoryFill(&am,sizeof(_audiomode),0);
 if((ret=aaFileStreamCreate(&fh,filename,NO,3,3,0,NO))!=RET_YES) { return ret; }
 fo=12.0;
// aaQuadSet(&fo,12,0);
 if((ret=aaFileStreamOffsetSet(fh,fo))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 ch[4]=0;
 while(1)
  {
  if(aaStringCompare(ch,"fmt ",NULL)==RET_YES) { break; }
  if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  if((ret=aaFileStreamOffsetAdjust(fh,(Q)itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  }
 if((ret=aaFileStreamRead(fh,4,&skip))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 skip-=16;
 if((ret=aaFileStreamRead(fh,2,&stmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(stmp!=1)  {  aaFileStreamDestroy(fh); return RET_FAILED; }
 if((ret=aaFileStreamRead(fh,2,&stmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(stmp>2)  {  aaFileStreamDestroy(fh); return RET_FAILED; }
 am.channels=stmp;
 if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(itmp!=8000&&itmp!=16000&&itmp!=11025&&itmp!=22050&&itmp!=32000&&itmp!=44100&&itmp!=48000)
  {
  aaFileStreamDestroy(fh);
  return RET_FAILED;
  }
 am.frequency=itmp;
 if((ret=aaFileStreamRead(fh,4,&bps))!=RET_YES)   { aaFileStreamDestroy(fh); return ret;  }
 am.bps=(B)bps;
 if((ret=aaFileStreamRead(fh,2,&align))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if(align!=1&&align!=2&&align!=4)  { aaFileStreamDestroy(fh); return RET_FAILED; }
 if((ret=aaFileStreamRead(fh,2,&stmp))!=RET_YES)  { aaFileStreamDestroy(fh); return ret;  }
 if(stmp!=16&&stmp!=8) { aaFileStreamDestroy(fh); return RET_FAILED; }
 am.bits=stmp;
 if(skip>0)
  {
  if((ret=aaFileStreamOffsetAdjust(fh,(G)skip))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  }
 if((ret=aa_AudioSystemModeVerify(&am))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 while(1)
  {
  if(aaStringCompare(ch,"data",NULL)==RET_YES) { break; }
  if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  if((ret=aaFileStreamOffsetAdjust(fh,(G)itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  if((ret=aaFileStreamRead(fh,4,ch))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
  }
 if((ret=aaFileStreamRead(fh,4,&itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 aaFileStreamStatus(fh,&fs);
 if((ret=aaMemoryAllocate((VP)&mem,itmp))!=RET_YES) { aaFileStreamDestroy(fh); return ret;  }
 aaMemoryNameSet(mem,"wavitm");
 if((ret=aaFileStreamRead(fh,itmp,mem))!=RET_YES) { aaFileStreamDestroy(fh); aaMemoryRelease(mem); return ret;  }
 wav->samples=itmp/align;
 aaFileStreamDestroy(fh);
 wav->ptr=mem;
 aaMemoryCopy(&wav->mode,sizeof(_audiomode),&am);
 //wav->position=0;
 //wav->left=wav->samples-wav->position;
 //wav->start=0;
 //wav->end=wav->samples-1;
 //wav->written=0;
 wav->duration=(D)wav->samples/(D)wav->mode.frequency;

 return RET_YES;
 }





 B aaWavLoadUsingResource              (_wav*wav,H resnum)
 {
 B ret;
 H bytes,off;
 BP mem,sam;
 C ch[5];
 N itmp,bps,skip;
 I stmp,align;
 _audiomode am;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wav==NULL)  { return RET_BADPARM; }
 aaMemoryFill(wav,sizeof(_wav),0);
 wav->magic=aaHPP(aaWavLoad);
 //if(samples==NULL)  { return RET_BADPARM; }
 //if(ptr==NULL)  { return RET_BADPARM; }
 ///if(audiomode!=NULL) { aaMemoryFill(audiomode,sizeof(_audiomode),0); }
 aaMemoryFill(&am,sizeof(_audiomode),0);
 if((ret=aaResourceToMemory(resnum,&bytes,(VP)&mem))!=RET_YES) { oops; return ret; }
 off=12;
 aaMemoryCopy(ch,4,&mem[off]); off+=4;
// aaMemoryPeekDword(&mem[off],0,ch); off+=4;
 ch[4]=0;
 while(1)
  {
  if(aaStringCompare(ch,"fmt ",NULL)==RET_YES) { break; }
  aaMemoryPeekDword(&mem[off],0,(HP)&itmp); off+=4; off+=itmp;
  aaMemoryPeekDword(&mem[off],0,(HP)ch); off+=4;
  }

 aaMemoryPeekDword(&mem[off],0,(HP)&skip); off+=4;
 skip-=16;
 aaMemoryPeekWord(&mem[off],0,(WP)&stmp); off+=2;
 if(stmp!=1)  { aaMemoryRelease(mem); return RET_FAILED; }
 aaMemoryPeekWord(&mem[off],0,(WP)&stmp); off+=2;
 if(stmp>2)  {  aaMemoryRelease(mem); return RET_FAILED; }
 am.channels=stmp;
 aaMemoryPeekDword(&mem[off],0,(HP)&itmp); off+=4;
 if(itmp!=8000&&itmp!=16000&&itmp!=11025&&itmp!=22050&&itmp!=32000&&itmp!=44100&&itmp!=48000)
  {
  aaMemoryRelease(mem);
  return RET_FAILED;
  }
 am.frequency=itmp;
 aaMemoryPeekDword(&mem[off],0,(HP)&bps); off+=4;
 am.bps=(B)bps;
 aaMemoryPeekWord(&mem[off],0,(WP)&align); off+=2;
 if(align!=1&&align!=2&&align!=4)  {  aaMemoryRelease(mem); return RET_FAILED; }
 aaMemoryPeekWord(&mem[off],0,(WP)&stmp); off+=2;
 if(stmp!=16&&stmp!=8) { aaMemoryRelease(mem); return RET_FAILED; }
 am.bits=stmp;
 if(skip>0)  {  off+=skip;  }
 if((ret=aa_AudioSystemModeVerify(&am))!=RET_YES) {aaMemoryRelease(mem); return ret;  }
 aaMemoryPeekDword(&mem[off],0,(HP)ch); off+=4;
 while(1)
  {
  if(aaStringCompare(ch,"data",NULL)==RET_YES) { break; }
  aaMemoryPeekDword(&mem[off],0,(HP)&itmp); off+=4;
  off+=itmp;
  aaMemoryPeekDword(&mem[off],0,(HP)ch); off+=4;
  }
 aaMemoryPeekDword(&mem[off],0,(HP)&itmp); off+=4;
 if((ret=aaMemoryAllocate((VP)&sam,itmp))!=RET_YES) { aaMemoryRelease(mem); return ret;  }
 aaMemoryCopy(sam,itmp,&mem[off]);
 wav->samples=itmp/align;
 wav->ptr=sam;
 aaMemoryCopy(&wav->mode,sizeof(_audiomode),&am);
// wav->position=0;
 //wav->left=wav->samples-wav->position;
 //wav->start=0;
 //wav->end=wav->samples-1;
 //wav->written=0;
 wav->duration=(D)wav->samples/(D)wav->mode.frequency;
 aaMemoryRelease(mem);
 return RET_YES;
 }



 B aaWavRelease                        (_wav*wav)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wav==NULL)  { return RET_BADPARM; }
 if(wav->magic!=aaHPP(aaWavLoad)) { return RET_NOTINITIALIZED; }
 if(wav->ptr) { aaMemoryRelease(wav->ptr); }
 aaMemoryFill(wav,sizeof(_wav),0);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/




 B aaIniOpen                           (_ini*ini,VP filename)
 {
 B ret;
 _filestreamunit fu;
 H chars,pos,count,i;
 H fl,dl,tl,ndx;
 B mode,type;
 B txt[_2K];
 _parser pa;
 B field[_1K];
 B flot[2][129];
 B data[_1K];
 D dval,dubl=0;
 H uval;
 N sval;
 H plus_count,minus_count,dot_count,num_count;
 H plus_pos,minus_pos,dot_pos,num_pos;
 BP mem;
 H slots;
 B ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ini==NULL) { return RET_BADPARM; }
 if(filename==NULL) { return RET_BADPARM; }
 aaMemoryFill(ini,sizeof(_ini),0);
 if((ret=aaFileStreamCreate(&fu.handle,filename,NO,3,3,0,NO))!=YES) { return ret; }
 aaFileStreamStatus(fu.handle,&fu.status);
 ini->magic=aa_INI_MAGIC;
 slots=0;
 while(1)
  {
  if((ret=aaFileStreamStringRead(fu.handle,&chars,&mode,_2K,txt))==RET_NOTREADY) { break; }
  if(ret!=YES) {  oops; }
  if(chars==0) { continue; }
  if(txt[0]==';'||txt[0]=='#') { continue; }
  aaStringReplaceChar(txt,chars,HTAB_CHAR,SPACE_CHAR);
  aaStringNull(field);
  aaStringNull(data);
  aaParserInit(&pa,txt,chars);
  do { if(aaCharIsVisible(pa.ch)==YES) { break; } aaParserSeek(&pa,1);  }  while(!pa.is_end);
  type=0;
  if(pa.ch==';'||pa.ch=='#') { continue; }
  //if(pa.ch==';') {  type=111;   } else
  if(pa.ch=='[')
   {
   if(pa.to_end>0) { if(pa.bp[pa.to_end-1]==']')  { aaStringCopy(field,txt);  type=aa_INITYPE_Section;  }   }
   }
  else
  if(pa.ch=='<')
   {
   aaStringLastCharGet(pa.bp,0,&ch);
   if(ch=='>')
    {
    aaStringCopy(field,pa.bp);
    aaParserInit(&pa,field,0);
    aaParserSeek(&pa,1);
    aaParserSeekToVisibleChar(&pa,YES);
    type=aa_INITYPE_TagOpen;
    if(pa.ch=='/') { type=aa_INITYPE_TagClose; }
    aaParserReset(&pa);
    }
   }

  if(type==0)
   {
   aaStringFindCharList(pa.bp,pa.to_end,&pos,"= ",YES,0,YES);
   if(pos==F32) { continue; }
   aaStringNCopy(field,pa.bp,pos,YES);
   aaParserSeek(&pa,pos);
   do
    {
    if(pa.ch==SPACE_CHAR) { aaParserSeek(&pa,1); continue; }
    if(pa.ch==EQUAL_CHAR) { break; }
    }
   while(0);
   aaStringFindCharList(pa.bp,pa.to_end,&pos,"= ",NO,0,YES);
   if(pos==F32) { continue; }
   aaParserSeek(&pa,pos);
   if(pa.to_end<1) { break; }
   aaStringFindChar(pa.bp,pa.to_end,&pos,';',YES,0,YES);
   if(pos!=F32) {  aaStringNCopy(data,pa.bp,pos,YES);   }
   else         {  aaStringNCopy(data,pa.bp,pos,YES);   }
   aaStringRemoveSpaces(field,0,YES,YES);
   aaStringRemoveSpaces(data,0,YES,YES);
   aaStringLen(field,&fl);
   aaStringLen(data,&dl);
   ////////////////////////////
   do
    {
    if(aaCharIsNum(data[0]))
     {
     aaStringCountNumbers(data,0,&count,YES);
     if(count==dl) { aaStringToNumber(data,count,&uval,0,0,0);   type=aa_INITYPE_Unsigned;    break;     }
     }
    if(data[0]=='-'||data[0]=='+')
     {
     aaStringCountNumbers(&data[1],0,&count,YES);
     if((count+1)==dl) {  aaStringToNumber(&data[1],count,(HP)&sval,0,0,0);  if(data[0]=='-') { sval=aaNumNeg(sval); }   type=aa_INITYPE_Signed;    break;     }
     }
    plus_count=minus_count=dot_count=num_count=0;
    plus_pos=minus_pos=dot_pos=num_pos=F32;
    for(i=0;i<dl;i++)
     {
     if(aaCharIsNum(data[i])==YES)   { if(num_pos==F32) { num_pos=i; }    num_count++; continue;      }
     if(data[i]=='.')                { if(dot_pos==F32) { dot_pos=i; }  dot_count++; continue; }
     if(data[i]=='+')                { if(plus_pos==F32) { plus_pos=i; } plus_count++; continue; }
     if(data[i]=='-')                { if(minus_pos==F32) { minus_pos=i; } minus_count++; continue; }
     break;
     }
    if(i==dl)
     {
     if(plus_count<=1&&minus_count<=1&&dot_count==1&&num_count>=1)
      {
      if(!(plus_count==1&&minus_count==1))
       {
       if(plus_count==0||(plus_count==1&&plus_pos==0))
        {
        if(minus_count==0||(minus_count==1&&minus_pos==0))
         {
         if(dot_pos<num_pos)   { tl=num_pos-dot_pos;    aaStringCopy(flot[0],"0");    aaStringCopy(flot[1],&data[num_pos]);         }
         else                  { tl=dot_pos-num_pos;    aaStringNCopy(flot[0],&data[num_pos],tl,YES);   aaStringCopy(flot[1],&data[dot_pos+1]);     }
         aaStringToNumber(flot[1],0,&uval,0,0,0);
         dubl=(D)uval;
         aaStringLen(flot[1],&tl);
         while(tl--) { dubl=dubl/10.0; }
         aaStringToNumber(flot[0],0,&uval,0,0,0);
         dval=(D)uval;
         dubl=dubl+dval;
         type=aa_INITYPE_Float;
         if(minus_count==1) { type=aa_INITYPE_SignedFloat; dubl=-dubl; }
         else
         if(plus_count==1)  { type=aa_INITYPE_SignedFloat; }
         break;
         }
        }
       }
      }
     }
    if(type==0)
     {
     if(aaStringICompare(data,"On",0)==YES)   {  type=aa_INITYPE_On;   break;    }
     if(aaStringICompare(data,"Off",0)==YES)  {  type=aa_INITYPE_Off;   break;    }
     if(aaStringICompare(data,"true",0)==YES)  {  type=aa_INITYPE_True;   break;    }
     if(aaStringICompare(data,"false",0)==YES)  {  type=aa_INITYPE_False;   break;    }
     if(aaStringICompare(data,"yes",0)==YES)  {  type=aa_INITYPE_Yes;   break;    }
     if(aaStringICompare(data,"no",0)==YES)  {  type=aa_INITYPE_No;   break;    }
     }
    }
   while(0);
   ////////////////////////////
   if(type==0) { type=aa_INITYPE_Text; }
   }
  if(type==0) { continue; }
  if(ini->entries==0)
   {
   if((ret=aaDataAllocate(&ini->field))!=YES) { oops; }
   if((ret=aaDataAllocate(&ini->data))!=YES) { oops; }
   }
  if((ini->entries-slots)<50) { if((ret=aaMemoryMake((VP)&ini->type,(100+slots)*sizeof(B)))!=YES) { oops; }  slots+=100;   }
  ini->type[ini->entries]=type;
  aaStringLen(field,&fl);
  if((ret=aaDataFieldAdd(&ini->field,&ndx,fl+1,0,(VP)&mem))!=YES) { oops; }
  aaStringNCopy(mem,field,fl,YES);
   switch(type)
    {
    case aa_INITYPE_Section: dl=aa_INITYPE_Section;  break;
    case aa_INITYPE_Text: aaStringLen(data,&dl); dl++; break;
    case aa_INITYPE_Unsigned: dl=aa_INITYPE_Signed;  break;
    case aa_INITYPE_Signed: dl=aa_INITYPE_Signed;  break;
    case aa_INITYPE_Float: dl=aa_INITYPE_SignedFloat;  break;  /// shold be
    case aa_INITYPE_SignedFloat: dl=aa_INITYPE_SignedFloat;  break;
    case aa_INITYPE_On: dl++; break;
    case aa_INITYPE_Off: dl++; break;
    case aa_INITYPE_True: dl++; break;
    case aa_INITYPE_False: dl++; break;
    case aa_INITYPE_Yes: dl++; break;
    case aa_INITYPE_No: dl++; break;
    case aa_INITYPE_TagOpen: aaStringLen(data,&dl); dl++; break;
    case aa_INITYPE_TagClose: aaStringLen(data,&dl); dl++; break;
    default: aaNote(0,"a %i",type);   break;
    }
  if((ret=aaDataFieldAdd(&ini->data,&ndx,dl,0,(VP)&mem))!=YES) { oops; }
   switch(type)
    {
    case aa_INITYPE_Section: mem[0]=0; break;
    case aa_INITYPE_Text: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_Unsigned: *(HP)mem=uval; break;
    case aa_INITYPE_Signed: *(NP)mem=sval; break;
    case aa_INITYPE_Float: *(DP)mem=dubl; break;
    case aa_INITYPE_SignedFloat: *(DP)mem=dubl; break;
    case aa_INITYPE_On: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_Off: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_True: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_False: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_Yes: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_No: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_TagOpen: aaStringNCopy(mem,data,dl-1,YES); break;
    case aa_INITYPE_TagClose: aaStringNCopy(mem,data,dl-1,YES);  break;
    default: aaNote(0,"b %i",type);   break;
    }
  ini->entries++;
  }
 aaFileStreamDestroy(fu.handle);
 return RET_YES;
 }




 B aaIniClose                          (_ini*ini)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ini==NULL) { return RET_BADPARM; }
 if(ini->magic!=aa_INI_MAGIC) { return RET_NOTSTARTED; }
 if(ini->entries!=0)
  {
  aaMemoryRelease(ini->type);
  if((ret=aaDataRelease(&ini->field))!=YES) { oops; }
  if((ret=aaDataRelease(&ini->data))!=YES) { oops; }
  }
 aaMemoryFill(ini,sizeof(_ini),0);
 return RET_YES;
 }



 B aaIniEntryGet                       (_ini*ini,H index,PP fmem,PP dmem,VP txt)
 {
 B ret;
 BP fm,dm;
 NP sv;
 HP uv;
 DP fl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ini==NULL) { return RET_BADPARM; }
 if(fmem) { *fmem=NULL; }
 if(dmem) { *dmem=NULL; }
 if(txt) { aaStringNull(txt); }
 if(ini->magic!=aa_INI_MAGIC) { return RET_NOTSTARTED; }
 if(index>=ini->entries) { return RET_BOUNDS; }
 oof;
 if((ret=aaDataFieldInfoGetByIndex(&ini->field,index,0,0,(VP)&fm))!=YES) { oops; }
 if((ret=aaDataFieldInfoGetByIndex(&ini->data,index,0,0,(VP)&dm))!=YES) { oops; }
 if(fmem) { *fmem=fm;  }
 if(dmem) { *dmem=dm;  }
 if(txt==NULL) { return RET_YES; }
 switch(ini->type[index])
     {
     case aa_INITYPE_Section:                     aaStringCopyf(txt,"Section: %s",fm);         break;
     case aa_INITYPE_Text:                        aaStringCopyf(txt,"   Text: [%s][%s]",fm,dm);  break;
     case aa_INITYPE_Unsigned:       uv=(HP)dm; aaStringCopyf(txt,"unsiged: %lu",*uv); break;
     case aa_INITYPE_Signed:         sv=(NP)dm; aaStringCopyf(txt," signed: %ld",*sv); break;
     case aa_INITYPE_Float:          fl=(DP)dm; aaStringCopyf(txt,"u float: %f",*fl); break;
     case aa_INITYPE_SignedFloat:    fl=(DP)dm; aaStringCopyf(txt,"s float: %f",*fl); break;
     case aa_INITYPE_On:                          aaStringCopyf(txt,"boolOn : %s",fm); break;
     case aa_INITYPE_Off:                        aaStringCopyf(txt,"boolOff: %s",fm); break;
     case aa_INITYPE_True:                       aaStringCopyf(txt,"boolTru: %s",fm); break;
     case aa_INITYPE_False:                      aaStringCopyf(txt,"boolFls: %s",fm); break;
     case aa_INITYPE_Yes:                        aaStringCopyf(txt,"boolYes: %s",fm); break;
     case aa_INITYPE_No:                         aaStringCopyf(txt,"boolNo : %s",fm); break;
     case aa_INITYPE_TagOpen:                    aaStringCopyf(txt,"Tagopen: %s",fm); break;
     case aa_INITYPE_TagClose:                   aaStringCopyf(txt,"Tagclos: %s",fm); break;
     default:                                    aaNote(0,"line=%i %i",__LINE__,ini->type[index]);   break;
     }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaFilePartsGet                      (VP filename,_fileparts*fileparts)
 {
 H sl,tmp;
 B txt[_1K];
 B str[_1K];
 H off,count;
 _parser pa;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileparts==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileparts,sizeof(_fileparts),0);
 if(filename==NULL) { return RET_BADPARM; }
 aaStringLen(filename,&sl);
 if(sl==0) { return RET_YES; }
 aaStringLower(filename,0,txt);
 if(txt[1]==':'&&(txt[0]>='a'&&txt[0]<='z'))
  {
  fileparts->drive=txt[0];
  aaMemoryCopy(txt,sl,&txt[2]);
  sl-=2;
  txt[sl]=NULL_CHAR;
  }
 aaStringCountChars(txt,sl,&count,BSLASH_CHAR,NO,YES); tmp=count;
 aaStringCountChars(txt,sl,&count,FSLASH_CHAR,NO,YES); count+=tmp;
   str[0]=BSLASH_CHAR;
   str[1]=FSLASH_CHAR;
   str[2]=str[3]=0;
 if(count>=1)
  {
  aaParserInit(&pa,txt,sl);
  while(1)
   {
   if(pa.is_end) { break; }
   aaParserSeekToCharList(&pa,str,NO);//,YES);
   //oof;
   aaStringFindCharList(pa.bp,pa.to_end,&off,str,YES,0,YES);
   //aaNote(0,"%i",off);
   if(off==F32) { break; }
   if(off==0) aaNote(0,"%i %s %s",pa.to_end,pa.bp,filename);
   aaStringNCopy(fileparts->path[fileparts->path_count],pa.bp,off,YES);
   aaParserSeek(&pa,off);
   fileparts->path_count++;
   }
  aaStringCopy(txt,pa.bp);
  sl=pa.to_end;
  }
 if(sl==0) { return RET_YES; }
 aaParserInit(&pa,txt,sl);
 aaStringFindChar(pa.bp,pa.to_end,&off,'.',YES,0,YES);
 if(off==F32)
  {
  aaStringCopy(fileparts->file,pa.bp);
  aaStringCopy(fileparts->filename,fileparts->file);
  return RET_YES;
  }
 aaStringNCopy(fileparts->file,pa.bp,off,YES);
 aaStringCopy(fileparts->filename,fileparts->file);
 aaParserSeek(&pa,off);

 aaStringAppend(fileparts->filename,pa.bp);
// BUG,"ex=%s",pa.bp);
 while(1)
  {
  if(pa.is_end) { break; }
  aaParserSeekToChar(&pa,'.',NO,YES);
  aaStringFindChar(pa.bp,pa.to_end,&off,'.',YES,0,YES);

  aaStringNCopy(fileparts->extension[fileparts->extension_count],pa.bp,off,YES);
  fileparts->extension_count++;
  if(off==F32) { break; }
  aaParserSeek(&pa,off);
  }
 return RET_YES;
 }




 B aaFileEqualsFile                    (VP filename,VP filename2)
 {
 _fileid fid,fidb;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(filename,0,0,0,0,&fid))!=RET_YES) {  return ret;  }
 if((ret=aaFileInfoGet(filename2,0,0,0,0,&fidb))!=RET_YES) {  return ret;  }
 if(fidb.volume!=fid.volume||fidb.object[0]!=fid.object[0]||fidb.object[1]!=fid.object[1])  { return RET_NO;  }
 return RET_YES;
 }

/*
__int64 size=( ((__int64)ffd.nFileSizeHigh)<<32 )+ffd.nFileSizeLow;
printf("Big size=%I64d bytes.\n", size);
*/

typedef struct _FILE_STANDARD_INFO {
  LARGE_INTEGER AllocationSize;
  LARGE_INTEGER EndOfFile;
  DWORD         NumberOfLinks;
  BOOLEAN        DeletePending;
  BOOLEAN       Directory;
} FILE_STANDARD_INFO,*PFILE_STANDARD_INFO;





 B aaFileInfoGet                       (VP filename,QP bytes,BP isfolder,_systime*ctime,_systime*mtime,_fileid*id)
 {
 DWORD a,er;
 HANDLE file_handle;
 SYSTEMTIME st;
 FILETIME fct,fmt,tmt;//,lft;
 BY_HANDLE_FILE_INFORMATION info;
 LARGE_INTEGER di;
 B isfold;
 Q fs;

 //FILE_STANDARD_INFO finfo={0};

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id) { id->volume=0; id->object[0]=id->object[1]=0; }
 if(bytes) { *bytes=0; }
 if(isfolder) { *isfolder=NO; }
 if(ctime) { aaTimeNull(ctime); }
 if(mtime) { aaTimeNull(mtime); }
 if(aaStringIsNull(filename)==YES) { return RET_BADPARM; }

 isfold=NO;
 a=GetFileAttributes(filename);
 if(a==INVALID_FILE_ATTRIBUTES) { return RET_NOTFOUND; }
 if(a&FILE_ATTRIBUTE_DIRECTORY)
  {
  isfold=YES;
  if(isfolder) { *isfolder=YES; }
  }

 if(ctime==NULL&&mtime==NULL&&id==NULL)
  {
  if(isfold) { return RET_YES; }
  }

//  aaNote(0,"%u %u %u ",isfold,a, a&FILE_ATTRIBUTE_DIRECTORY);

 file_handle=0;
 aaMemoryFill(&info,sizeof(info),0);
 SetLastError(0);
 if(isfold==NO) { file_handle=CreateFile(filename,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);  }
 else           { file_handle=CreateFile(filename,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_FLAG_BACKUP_SEMANTICS,NULL); }
 if(file_handle==INVALID_HANDLE_VALUE) //{ oow; aaNote(0,"m%s",filename); return RET_FAILED; }
  {
  er=GetLastError();
  if(er==ERROR_SHARING_VIOLATION||er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
  oow;
  aaLog(-777,"invalid handle in aa.c for createfile (fold=%i) %s",isfold,filename);
  return RET_FAILED;
  }

 //FlushFileBuffers(file_handle);
 if(GetFileInformationByHandle(file_handle,&info)==0)
  {
  di.QuadPart=0;
  if(GetFileSizeEx(file_handle,&di)==0) { oof; oow; }
  aaNote(0,"line=%i %I64u",__LINE__,di.QuadPart);
  //aaMemoryFill(&di,sizeof(di),0);
  //SetFilePointerEx(file_handle,0,li,FILE_END);
  //aaNote(0,"%I64u",li.QuadPart);
  CloseHandle(file_handle);
  return RET_FAILED;
  }

 //aaNote(0,"%u %u %u",info.dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY,info.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY);

  if((ctime||mtime))
   {
   if(GetFileTime(file_handle,(ctime)?&fct:NULL,NULL,(mtime)?&fmt:NULL)!=0)
    {
    if(ctime)
     {
     if(FileTimeToLocalFileTime(&fct,&tmt)==0) { oof; oow; oof;   CloseHandle(file_handle);    return RET_FAILED;    }
     if(FileTimeToSystemTime(&tmt,&st)==0) {   oof; oow; oof; CloseHandle(file_handle);    return RET_FAILED;    }
     WinSystemTimeToSysTime(&st,ctime);
     }
    if(mtime)
     {
     if(FileTimeToLocalFileTime(&fmt,&tmt)==0) {  oof;  oow; oof; CloseHandle(file_handle);    return RET_FAILED;    }
     if(FileTimeToSystemTime(&tmt,&st)==0) {    oof; oow; oof; CloseHandle(file_handle);    return RET_FAILED;    }
     WinSystemTimeToSysTime(&st,mtime);
     }
    }
   }

  if(id)
   {
   //aaMemoryFill(&info,sizeof(info),0);
   //if(GetFileInformationByHandle(file_handle,&info)==0)  { oow; oof; CloseHandle(file_handle);   return RET_FAILED;   }
   id->volume=info.dwVolumeSerialNumber;
   id->object[0]=info.nFileIndexLow;
   id->object[1]=info.nFileIndexHigh;
   }

  if(bytes)
   {
   fs=info.nFileSizeHigh;
   fs<<=32;
   fs|=info.nFileSizeLow;
   *bytes=fs;
   }


 if(file_handle!=0)
  {
  CloseHandle(file_handle);
  }

 return RET_YES;
 }




 B aaFileInformationGet                (VP filename,_fileinformation*fileinformation)
 {
 B ret;
 _fileinformation*fi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileinformation==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileinformation,sizeof(_fileinformation),0);
 if(filename==NULL) { return RET_BADPARM; }
 if(aaStringIsEmpty(filename,YES)!=NO) { return RET_BADPARM; }
 aaStringCopyf(fileinformation->file_name,"%s",filename);
 //if((ret=aaFileExists(fileinformation->file_name))==RET_YES) { fileinformation->is_exists=YES;  }
 //else                                                        { return ret;  }
 fi=(_fileinformation*)fileinformation;
 if((ret=aaFileInfoGet(fi->file_name,&fi->bytes,&fi->is_folder,&fi->created,&fi->modified,&fi->id))!=YES)
  {
  if(ret==RET_NOTFOUND) { fi->is_exists=NO; return RET_YES; }
  return ret;
  }
 fi->is_exists=YES;
 if((ret=aaFileAttributesGet(fi->file_name,&fi->attributes))!=YES) { return ret; }
 return RET_YES;
 }







 B aaFileExists                        (VP filename,...)
 {
 B isfold;
 va_list argptr;
 B str[_4K];
 DWORD a,er;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(filename,argptr,str);
 a=GetFileAttributes((CP)str);
 if(a==INVALID_FILE_ATTRIBUTES)
  {
  er=GetLastError();
  if(er==ERROR_ACCESS_DENIED) { oof; return RET_DENIED; }
  if(er==ERROR_SHARING_VIOLATION) { oof; return RET_DENIED; }
  if(er==ERROR_FILE_NOT_FOUND) { return RET_NO; }
//  oow;
  return RET_NO;
  }
 isfold=NO;
 if(a&FILE_ATTRIBUTE_DIRECTORY) { isfold=YES;  }
 if(isfold==YES) { return RET_NO; }
 return RET_YES;
 }




 B aaFileDelete                        (VP filename,...)
 {
 B ret;
 BOOL bo;
 DWORD er;
 va_list argptr;
 B str[_4K];

// _fileattributes fat;

 //B isfolder;
// aaVargsf(filename);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(filename,argptr,str);
 ret=aaFileExists(str);
 if(ret==RET_NO) { return RET_NOTFOUND; }
 if(ret!=RET_YES) { return ret; }
 //if((ret=aaFileInfoGet(filename,NULL,&isfolder,0,0,0))!=RET_YES) { return ret; }
 //if(isfolder==YES) { return RET_FAILED; }

 //ret=aaFileAttributesGet(str64k.buf,&fat);
 //aaDebugf("%s %i,%i,%i,%i,%i,%i,%i",arets, fat.is_archive,  fat.is_hidden, fat.is_normal, fat.is_offline, fat.is_read_only, fat.is_system, fat.is_temp);

 bo=DeleteFile((CP)str);
 if(bo==0)
  {
  er=GetLastError();
  if(er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
  if(er==ERROR_SHARING_VIOLATION) { return RET_DENIED; }
  if(er==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 return RET_YES;
 }






 B aaFileCopy                          (VP filename,VP destfilename,B allowoverwrite)
 {
 B ret;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(filename,NULL,&isfolder,0,0,0))!=RET_YES) { return ret; }
 if(isfolder==YES) { return RET_FAILED; }
 ret=aaFileInfoGet(destfilename,NULL,&isfolder,0,0,0);
 if(ret==YES&&isfolder==YES) { return RET_FAILED; }
 if(ret==YES&&isfolder==NO&&allowoverwrite!=YES) { return RET_EXISTS; }
 if(CopyFile(filename,destfilename,(allowoverwrite==YES)?FALSE:TRUE)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileRename                        (VP filename,VP destfilename)
 {
 B ret;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(filename,NULL,&isfolder,0,0,0))!=RET_YES) { return ret; }
 if(isfolder==YES) { return RET_FAILED; }
 if(MoveFileEx(filename,destfilename,MOVEFILE_REPLACE_EXISTING)==0) { return RET_FAILED; }
 return RET_YES;
 }









 B aaFileSaveFromMemory                (VP filename,H bytes,VP mem)
 {
 HANDLE han;
 H todo,off,done;
 BP bp;
 B block[_32K];
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 han=CreateFile(filename,GENERIC_READ|GENERIC_WRITE,3,NULL,CREATE_ALWAYS,0x08000000,NULL);
 if(han==INVALID_HANDLE_VALUE) { oow; aaNote(0,"%s",filename); return RET_FAILED; }
 if(bytes==F32) { aaStringLen(mem,&bytes); }
 if(bytes==0) { CloseHandle(han); return YES; }
 off=0;
 if(mem!=NULL) { aaCast(bp,BP,mem); }
 else          { aaCast(bp,BP,block); todo=aaNumRoof(bytes,sizeof(block)); aaMemoryFill(block,todo,0); }
 while(1)
  {
  todo=bytes;
  if(todo==0) { ret=YES; break; }
  todo=aaNumRoof(todo,sizeof(block));
  done=0;
  if(WriteFile(han,&bp[off],todo,&done,NULL)==0) { ret=RET_FAILED; oof; break; }
  if(done!=todo) {  ret=RET_FAILED; oof; break; }
  bytes-=done;
  if(mem!=NULL) { off+=todo; }
  }
 CloseHandle(han);
 if(ret!=YES) { DeleteFile(filename); }
 return ret;
 }







 B aaFileAppendFromMemory              (VP filename,H bytes,VP mem)
 {
 HANDLE han;
 H todo,off,done;
 BP bp;
 B block[_16K];
 B ret;
 LARGE_INTEGER zi;
 //Q sbytes;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 ret=aaFileExists(filename);
 if(ret==YES)
  {
  han=CreateFile(filename,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,0x08000000,NULL);
  if(han==INVALID_HANDLE_VALUE) { return RET_FAILED; }
  zi.QuadPart=0;
  if(SetFilePointerEx(han,zi,0,FILE_END)==0)
   {
   CloseHandle(han);
   return RET_FAILED;
   }
  if(GetFileSizeEx(han,&zi)!=0)
    {
//    aaNote(0,"%I64u",zi.QuadPart);
    }
   else
    {
    CloseHandle(han);
    return RET_FAILED;
    }
  }
 else
 if(ret==RET_NO)
  {
  han=CreateFile(filename,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,CREATE_ALWAYS,0x08000000,NULL);
  if(han==INVALID_HANDLE_VALUE) { return RET_FAILED; }
  }
 else
  {
  oops;
  return ret;
  }
 if(bytes==F32) { aaStringLen(mem,&bytes); }
 if(bytes==0) { CloseHandle(han); return YES; }
 off=0;
 if(mem!=NULL) { aaCast(bp,BP,mem); }
 else          { aaCast(bp,BP,block); todo=aaNumRoof(bytes,sizeof(block)); aaMemoryFill(block,todo,0); }
 while(1)
  {
  todo=bytes;
  if(todo==0) { ret=YES; break; }
  todo=aaNumRoof(todo,sizeof(block));
  done=0;
  if(WriteFile(han,&bp[off],todo,&done,NULL)==0) { ret=RET_FAILED; break; }
  if(done!=todo) {  ret=RET_FAILED; break; }
  bytes-=done;
  if(mem!=NULL) { off+=todo; }
  }
 CloseHandle(han);
 if(ret!=YES) { DeleteFile(filename); }
 return ret;
 }






 B aaFileAppendf                       (VP filename,VP fmt,...)
 {
 va_list argptr;
 B temp[_16K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,temp);
 return(aaFileAppendFromMemory(filename,F32,temp));
 }










 B aaFileLoadToMemory                  (VP filename,Q fromoffset,H bytes,PP mem,HP bytesloaded)
 {
 B ret;
 H file_handle;
 _filestreamstatus file_status;
 Q todo,off,to_end;
 BP new_mem;
 Q fo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytesloaded) { *bytesloaded=0; }
 if(mem==NULL) { return RET_BADPARM; }
 *mem=NULL;
 if(bytes==0)  { return RET_BADPARM; }
 if((ret=aaFileStreamCreate(&file_handle,filename,aa_FILECREATE_OPEN,aa_FILEMODE_R,aa_FILESHARE_RW,1,NO))!=RET_YES)
  {
  return ret;
  }
 aaFileStreamStatus(file_handle,&file_status);

 if((G)fromoffset>=(G)file_status.bytes)//(H)aaDoubleToLong(file_status.bytes)) // ningy added (H)
  {
 // aaNote(0,"%i %.0lf",fromoffset,file_status.bytes);
  aaFileStreamDestroy(file_handle);
  return RET_BOUNDS;
  }
 to_end=(file_status.bytes-fromoffset);//aaDoubleToLong(file_status.bytes-fromoffset);
 if(bytes==F32) { bytes=to_end; }
 if(bytes>to_end) { bytes=to_end; }//aaFileStreamDestroy(file_handle);  return RET_BOUNDS; }
 if(fromoffset!=0)
  {
//      aaQuadSet(&fo,fromoffset,0);
  fo=(Q)fromoffset;
  if((ret=aaFileStreamOffsetSet(file_handle,fo))!=RET_YES)
   {
   aaFileStreamDestroy(file_handle);
   return ret;
   }
  }
 if((ret=aaMemoryAllocate((VP)&new_mem,bytes))!=RET_YES)
  {
  aaFileStreamDestroy(file_handle);
  return ret;
  }
 aaMemoryNameSet(new_mem,"fileload");
 off=0;
 while(1)
  {
  todo=bytes;
  if(todo>_4K) { todo=_4K; }
  if((ret=aaFileStreamRead(file_handle,todo,&new_mem[off]))!=RET_YES)
   {
   aa_MemoryRelease(new_mem);
   aaFileStreamDestroy(file_handle);
   return ret;
   }
  bytes-=todo;
  off+=todo;
  if(bytes==0) { break; }
  }
 if(bytesloaded) { *bytesloaded=off; }
 aaFileStreamDestroy(file_handle);
 *mem=new_mem;
 return RET_YES;
 }











 B aaFileLoadToBuffer                  (VP filename,Q fromoffset,H bytes,VP mem,HP bytesloaded)
 {
 B ret;
 H file_handle;
 _filestreamstatus file_status;
 Q todo,off,to_end;
 BP new_mem;
 Q fo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytesloaded) { *bytesloaded=0; }
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0)  { return RET_BADPARM; }
 if((ret=aaFileStreamCreate(&file_handle,filename,aa_FILECREATE_OPEN,aa_FILEMODE_R,aa_FILESHARE_RW,1,NO))!=RET_YES)
  {
  return ret;
  }
 aaFileStreamStatus(file_handle,&file_status);
 if(fromoffset>=file_status.bytes) { aaFileStreamDestroy(file_handle); return RET_BOUNDS; } // ningy added (H)
 to_end=(file_status.bytes-fromoffset);//aaDoubleToLong(file_status.bytes-fromoffset);
 if(bytes==F32) { bytes=to_end; }
 if(bytes>to_end)  {  bytes=to_end; }  //aaFileStreamDestroy(file_handle);  return RET_BOUNDS;
 if(fromoffset!=0)
  {
//.  aaQuadSet(&fo,fromoffset,0);
  fo=fromoffset;
  if((ret=aaFileStreamOffsetSet(file_handle,fo))!=RET_YES)
   {
   //oops;
   aaFileStreamDestroy(file_handle);
   return ret;
   }
  }
 aaCast(new_mem,BP,mem);
 off=0;
 while(1)
  {
  todo=bytes;
  if(todo>_4K) { todo=_4K; }
  if((ret=aaFileStreamRead(file_handle,(H)todo,&new_mem[off]))!=RET_YES)
   {
   //oops;
   aaFileStreamDestroy(file_handle);
   return ret;
   }
  bytes-=todo;
  off+=todo;
  if(bytes==0) { break; }
  }
 if(bytesloaded) { *bytesloaded=(H)off; }
 aaFileStreamDestroy(file_handle);

 return RET_YES;
 }







 B aaFileUniqueCreate                  (VP filename,VP path,H chars,B alpha,B num,VP ext,B docreate)
 {
 B ret;
 B txt[_1K];
 B dir[_1K];
 B ful[_1K];
 B fex[_1K];
 H fh;
 B ch;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars==0||chars>64) { return RET_BOUNDS; }
 if(alpha!=YES&&num!=YES) { return RET_BADPARM; }
 if(filename) { aaStringNull(filename); }
 if(path==NULL)  {  if((ret=aaFileFolderWorkingGet(dir))!=YES) { return ret; }  }
 else            {  aaStringCopy(dir,path);  }
 if((ret=aaFileFolderExists(dir))!=YES) { return RET_FAILED; }
 if(aaStringIsNull(ext)==NO) { aaStringCopyf(fex,ext); }
 else                        { aaStringCopyf(fex,""); }
 while(1)
  {
  aaStringRandomSet(txt,chars,alpha,0,num,YES);
  aaStringCopyf(ful,"%s",dir);//
  aaStringLastCharGet(ful,0,&ch);
  if(ch==BSLASH_CHAR) { aaStringAppendf(ful,"%s.%s",txt,fex); }
  else                { aaStringAppendf(ful,"\\%s.%s",txt,fex); }
  if(aaFileExists(ful)==YES) { continue; }
  if(docreate==YES)
   {
   if((ret=aaFileStreamCreate(&fh,ful,YES,aa_FILEMODE_RW,aa_FILESHARE_RW,1,NO))!=RET_YES) {  oops; }
   aaFileStreamDestroy(fh);
   }
  if(filename) { aaStringCopyf(filename,"%s.%s",txt,fex); }
  break;
  }
 return RET_YES;
 }





 B aaFileTimeSet                       (VP filename,_systime*ctime,_systime*mtime)
 {
 HANDLE hfile;
 SYSTEMTIME sti;
 FILETIME ct,mt,tt;
 BOOL b;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(ctime==NULL&&mtime==NULL) { return RET_BADPARM; }
 if(filename==NULL) { return RET_BADPARM; }
 ret=aaFileExists(filename);
 if(ret==NO) { return RET_NOTFOUND; }
 if(ret!=YES) { return ret; }
 hfile=CreateFile(filename,GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
 if(hfile==INVALID_HANDLE_VALUE) { return RET_FAILED;  }
 if(ctime)
  {
  sti.wYear=ctime->year;
  sti.wMonth=ctime->month;
  sti.wDay=ctime->date;
  sti.wDayOfWeek=ctime->dow;
  sti.wHour=ctime->hour;
  sti.wMinute=ctime->minute;
  sti.wSecond=ctime->second;
  sti.wMilliseconds=0;
    SystemTimeToFileTime(&sti,&tt);  // Converts the current system time to file time format
    LocalFileTimeToFileTime(&tt,&ct);
    //FileTimeToLocalFileTime(&tt,&ct);  // Converts the current system time to file time format
  //if(FileTimeToLocalFileTime(&tt,&ct)==0) {   return RET_FAILED;    }
  }
 if(mtime)
  {
  sti.wYear=mtime->year;
  sti.wMonth=mtime->month;
  sti.wDay=mtime->date;
  sti.wDayOfWeek=mtime->dow;
  sti.wHour=mtime->hour;
  sti.wMinute=mtime->minute;
  sti.wSecond=mtime->second;
  sti.wMilliseconds=0;
   SystemTimeToFileTime(&sti,&tt);  // Converts the current system time to file time format
   LocalFileTimeToFileTime(&tt,&mt);
  ///FileTimeToLocalFileTime(&tt,&mt);
//  if(FileTimeToLocalFileTime(&tt,&mt)==0) {   return RET_FAILED;    }
  }
 b=1;
 if(ctime&&mtime)    {   b=SetFileTime(hfile,&ct,0,&mt);  } else
 if(ctime&&!mtime)   {   b=SetFileTime(hfile,&ct,0,0);  } else
 if(!ctime&&mtime)   {   b=SetFileTime(hfile,0,0,&mt);  }
 CloseHandle(hfile);
 if(b==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileSizeSet                       (VP filename,Q bytes)
 {
 Q by;
 B ret;
 _filestreamunit fsu;
 LARGE_INTEGER np;
 BOOL b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 if((ret=aaFileExists(filename))==NO) { return RET_NOTFOUND; }
 if(ret!=YES) { return ret; }
 if((ret=aaFileStreamCreate(&fsu.handle,filename,aa_FILECREATE_OPEN,3,3,1,0))!=RET_YES) { return ret;  }
 if((ret=aaFileStreamStatus(fsu.handle,&fsu.status))!=RET_YES)
  {
  aaFileStreamDestroy(fsu.handle);
  return ret;
  }
 np.QuadPart=bytes;
 b=SetFilePointerEx(fsu.status._handle,np,0,FILE_BEGIN);
 if(b==0) { oow; aaFileStreamDestroy(fsu.handle); return RET_FAILED; }

 b=SetEndOfFile(fsu.status._handle);
 if(b==0) { oow; aaFileStreamDestroy(fsu.handle); return RET_FAILED; }

 aaFileStreamDestroy(fsu.handle);
 if((ret=aaFileInfoGet(filename,&by,0,0,0,0))!=RET_YES) { return ret; }
 if(by!=bytes) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileIsUpxCompressed               (VP filename)
 {
 _filestreamunit fsu;
 H p,n,x,y;
 B file[_4K];
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL)  {  aaStringCopyf(file,"%s",aa.core_system.module_filename);  }
 else                {  aaStringCopyf(file,"%s",filename);  }
 if(aaFileExists(file)!=YES) { return RET_NOTFOUND; }
 if((ret=aaFileStreamCreate(&fsu.handle,file,aa_FILECREATE_OPEN,aa_FILEMODE_R,3,1,0))!=YES) { return RET_FAILED; }
 aaFileStreamStatus(fsu.handle,&fsu.status);
 aaFileStreamOffsetSet(fsu.handle,0x3c);
 aaFileStreamRead(fsu.handle,sizeof(H),&p);
 aaFileStreamOffsetSet(fsu.handle,p+0x74);
 aaFileStreamRead(fsu.handle,sizeof(H),&n);
 x=p+0x78+n*8;
 aaFileStreamOffsetSet(fsu.handle,x+0*0x28+0);
 aaFileStreamRead(fsu.handle,sizeof(H),&y);
 aaFileStreamDestroy(fsu.handle);
 if((y&0xFFFFFF)!=('U'+('P'<<8)+('X'<<16))) { return RET_NO; }
 return RET_YES;
 }




 B aaFileAttributesGet                 (VP filename,_fileattributes*fileattribs)
 {
 B ret;
 H dwa;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileattribs==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileattribs,sizeof(_fileattributes),0);
 if((ret=aaFileInfoGet(filename,0,&isfolder,NULL,NULL,NULL))!=YES) { return ret; }
 dwa=GetFileAttributes(filename);
 if(dwa==INVALID_FILE_ATTRIBUTES) { oow; return RET_FAILED; }
 if((dwa&FILE_ATTRIBUTE_ARCHIVE))   { fileattribs->is_archive=YES;   }
 if((dwa&FILE_ATTRIBUTE_HIDDEN))    { fileattribs->is_hidden=YES;    }
 if((dwa&FILE_ATTRIBUTE_NORMAL))    { fileattribs->is_normal=YES;    }
 if((dwa&FILE_ATTRIBUTE_OFFLINE))   { fileattribs->is_offline=YES;   }
 if((dwa&FILE_ATTRIBUTE_READONLY))  { fileattribs->is_read_only=YES; }
 if((dwa&FILE_ATTRIBUTE_SYSTEM))    { fileattribs->is_system=YES;    }
 if((dwa&FILE_ATTRIBUTE_TEMPORARY)) { fileattribs->is_temp=YES;      }
 return RET_YES;
 }




 B aaFileAttributesSet                 (VP filename,_fileattributes*fileattribs)
 {
 B ret;
 H dwa;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(fileattribs==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileattribs,sizeof(_fileattributes),0);
 if((ret=aaFileInfoGet(filename,0,&isfolder,NULL,NULL,NULL))!=YES) { return ret; }
 dwa=0;
 if(fileattribs->is_archive)   { dwa|=FILE_ATTRIBUTE_ARCHIVE;   }
 if(fileattribs->is_hidden)    { dwa|=FILE_ATTRIBUTE_HIDDEN;    }
 if(fileattribs->is_normal)    { dwa|=FILE_ATTRIBUTE_NORMAL;    }
 if(fileattribs->is_offline)   { dwa|=FILE_ATTRIBUTE_OFFLINE;   }
 if(fileattribs->is_read_only) { dwa|=FILE_ATTRIBUTE_READONLY;  }
 if(fileattribs->is_system)    { dwa|=FILE_ATTRIBUTE_SYSTEM;    }
 if(fileattribs->is_temp)      { dwa|=FILE_ATTRIBUTE_TEMPORARY; }
 if(SetFileAttributes(filename,dwa)==0) { oow; return RET_FAILED; }
 return RET_YES;
 }






 structure
 {
 W wLanguage;
 W wCodePage;
 }
 _LANGANDCODEPAGE;





 B aaFileDetailsGet                    (VP filename,_filedetails*filedetails,VP string)
 {
 B ret;
 //H dwb;
 B buf[_8K];
 B txt[_8K];
 B tok[_1K];
 BOOL bl;
 UINT size;
 TCHAR szQuery[256];
 TCHAR szsz[256];
 LPBYTE lpBuffer=0;
 VS_FIXEDFILEINFO*pFileInfo;
 _LANGANDCODEPAGE*lpTranslate;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 if(string) { aaStringNull(string); }
 if((ret=aaFileExists(filename))!=RET_YES) { oops; return ret; }
 if(filedetails==NULL) { return RET_BADPARM; }
 aaMemoryFill(filedetails,sizeof(_filedetails),0);
 //dwb=0;
// dwa=GetFileVersionInfoSize(filename,&dwb);
 if((bl=GetFileVersionInfo(filename,0,sizeof(buf),buf))==0) { oow; }
 if((bl=VerQueryValue(buf,"\\",(VP*)&lpBuffer,&size))==0) {oow; }
 pFileInfo=(VS_FIXEDFILEINFO*)lpBuffer;
 filedetails->major_version=HIWORD(pFileInfo->dwFileVersionMS);
 filedetails->minor_version=LOWORD(pFileInfo->dwFileVersionMS);
 filedetails->build_number=HIWORD(pFileInfo->dwFileVersionLS);
 filedetails->revision_number=LOWORD(pFileInfo->dwFileVersionLS);

 if((pFileInfo->dwFileFlags&VS_FF_DEBUG)) { filedetails->is_debug_info=YES; }
 if((pFileInfo->dwFileFlags&VS_FF_PRERELEASE)) { filedetails->is_pre_release=YES; }
 if((pFileInfo->dwFileFlags&VS_FF_PRIVATEBUILD)) { filedetails->is_private_build=YES; }
 if((pFileInfo->dwFileFlags&VS_FF_SPECIALBUILD)) { filedetails->is_special_build=YES; }

 if((pFileInfo->dwFileOS&VOS_DOS)) { filedetails->for_dos=YES; }
 if((pFileInfo->dwFileOS&VOS_NT)) { filedetails->for_nt=YES; }
 if((pFileInfo->dwFileOS&VOS__WINDOWS16)) { filedetails->for_win16=YES; }
 if((pFileInfo->dwFileOS&VOS__WINDOWS32)) { filedetails->for_win32=YES; }
 if((pFileInfo->dwFileOS&VOS_OS216)) { filedetails->for_os216=YES; }
 if((pFileInfo->dwFileOS&VOS_OS232)) { filedetails->for_os232=YES; }
 if((pFileInfo->dwFileOS&VOS__PM16)) { filedetails->for_pm16=YES; }
 if((pFileInfo->dwFileOS&VOS__PM32)) { filedetails->for_pm32=YES; }

 if((pFileInfo->dwFileOS&VOS_DOS_WINDOWS16)) { filedetails->for_dos16=YES; }
 if((pFileInfo->dwFileOS&VOS_DOS_WINDOWS32)) { filedetails->for_dos32=YES; }
 if((pFileInfo->dwFileOS&VOS_NT_WINDOWS32)) { filedetails->for_nt32=YES; }

 if((pFileInfo->dwFileType&VFT_APP)) { filedetails->is_application=YES; }
 if((pFileInfo->dwFileType&VFT_DLL)) { filedetails->is_dll=YES; }
 if((pFileInfo->dwFileType&VFT_DRV)) { filedetails->is_drv=YES; }
 if((pFileInfo->dwFileType&VFT_FONT)) { filedetails->is_font=YES; }
 if((pFileInfo->dwFileType&VFT_STATIC_LIB)) { filedetails->is_static_lib=YES; }
 if((pFileInfo->dwFileType&VFT_VXD)) { filedetails->is_vxd=YES; }

 if(filedetails->is_drv)
  {
  if((pFileInfo->dwFileSubtype&VFT2_DRV_COMM)) { filedetails->is_drv_comm=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_DISPLAY)) { filedetails->is_drv_display=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_INSTALLABLE)) { filedetails->is_drv_installable=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_KEYBOARD)) { filedetails->is_drv_keyboard=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_LANGUAGE)) { filedetails->is_drv_language=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_MOUSE)) { filedetails->is_drv_mouse=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_NETWORK)) { filedetails->is_drv_network=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_PRINTER)) { filedetails->is_drv_printer=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_SOUND)) { filedetails->is_drv_sound=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_DRV_SYSTEM)) { filedetails->is_drv_system=YES; }
  }

 if(filedetails->is_font)
  {
  if((pFileInfo->dwFileSubtype&VFT2_FONT_RASTER)) { filedetails->is_font_raster=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_FONT_TRUETYPE)) { filedetails->is_font_truetype=YES; }
  if((pFileInfo->dwFileSubtype&VFT2_FONT_VECTOR)) { filedetails->is_font_vector=YES; }
  }
 if((bl=VerQueryValue(buf,"\\VarFileInfo\\Translation",(VOID FAR* FAR*)&lpBuffer,&size))==0) { oow; }
 lpTranslate=(_LANGANDCODEPAGE*)lpBuffer;
 filedetails->language=lpTranslate->wLanguage;
 filedetails->codepage=lpTranslate->wCodePage;

 wsprintf(szQuery,"\\StringFileInfo\\%04x%04x",lpTranslate->wLanguage,lpTranslate->wCodePage);
 wsprintf(szsz,"%s\\CompanyName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->company_name,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\FileDescription",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->file_description,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\FileVersion",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->file_version,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\InternalName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->internal_name,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\LegalCopyright",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->legal_copyright,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\LegalTrademarks",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->legal_trademarks,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\OriginalFileName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->original_filename,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\ProductName",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->product_name,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\ProductVersion",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->product_version,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\Comments",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->comments,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\PrivateBuild",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->private_build,"%s",lpBuffer); }
 wsprintf(szsz,"%s\\SpecialBuild",szQuery);
 if((bl=VerQueryValue(buf,szsz,(VOID FAR* FAR*)&lpBuffer,&size))!=0) {  aaStringCopyf(filedetails->special_build,"%s",lpBuffer); }

 if(string)
  {
  aaStringNull(txt);
  aaStringCopyf(tok,"major_version=%i",filedetails->major_version); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"minor_version=%i",filedetails->minor_version); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"build_number=%i",filedetails->build_number); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"revision_number=%i",filedetails->revision_number); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"language=%x",filedetails->language); aaStringAppendf(txt,"%-25s\n",tok);
  aaStringCopyf(tok,"codepage=%x",filedetails->codepage); aaStringAppendf(txt,"%-25s\n",tok);
  if(filedetails->is_debug_info)    {  aaStringCopyf(tok,"is_debug_info=%i",filedetails->is_debug_info); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->is_pre_release)   {  aaStringCopyf(tok,"is_pre_release=%i",filedetails->is_pre_release); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->is_private_build) {  aaStringCopyf(tok,"is_private_build=%i",filedetails->is_private_build); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->is_special_build) {  aaStringCopyf(tok,"is_special_build=%i",filedetails->is_special_build); aaStringAppendf(txt,"%-25s\n",tok);  }
  if(filedetails->for_dos)   { aaStringCopyf(tok,"for_dos=%i",filedetails->for_dos); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_dos16) { aaStringCopyf(tok,"for_dos16=%i",filedetails->for_dos16); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_dos32) { aaStringCopyf(tok,"for_dos32=%i",filedetails->for_dos32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_nt)    { aaStringCopyf(tok,"for_nt=%i",filedetails->for_nt); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_nt32)  { aaStringCopyf(tok,"for_nt32=%i",filedetails->for_nt32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_win16) { aaStringCopyf(tok,"for_win16=%i",filedetails->for_win16); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_win32) { aaStringCopyf(tok,"for_win32=%i",filedetails->for_win32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_os216) { aaStringCopyf(tok,"for_os216=%i",filedetails->for_os216); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_os232) { aaStringCopyf(tok,"for_os232=%i",filedetails->for_os232); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_pm16)  { aaStringCopyf(tok,"for_pm16=%i",filedetails->for_pm16); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->for_pm32)  { aaStringCopyf(tok,"for_pm32=%i",filedetails->for_pm32); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_application)        { aaStringCopyf(tok,"is_application=%i",filedetails->is_application); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_dll)                { aaStringCopyf(tok,"is_dll=%i",filedetails->is_dll); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv)             { aaStringCopyf(tok,"is_drv=%i",filedetails->is_drv); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_comm)        { aaStringCopyf(tok,"is_drv_comm=%i",filedetails->is_drv_comm); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_display)     { aaStringCopyf(tok,"is_drv_display=%i",filedetails->is_drv_display); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_installable) { aaStringCopyf(tok,"is_drv_installable=%i",filedetails->is_drv_installable); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_keyboard)    { aaStringCopyf(tok,"is_drv_keyboard=%i",filedetails->is_drv_keyboard); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_language)    { aaStringCopyf(tok,"is_drv_language=%i",filedetails->is_drv_language); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_mouse)       { aaStringCopyf(tok,"is_drv_mouse=%i",filedetails->is_drv_mouse); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_network)     { aaStringCopyf(tok,"is_drv_network=%i",filedetails->is_drv_network); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_printer)     { aaStringCopyf(tok,"is_drv_printer=%i",filedetails->is_drv_printer); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_sound)       { aaStringCopyf(tok,"is_drv_sound=%i",filedetails->is_drv_sound); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_drv_system)      { aaStringCopyf(tok,"is_drv_system=%i",filedetails->is_drv_system); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font)          { aaStringCopyf(tok,"is_font=%i",filedetails->is_font); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font_raster)   { aaStringCopyf(tok,"is_font_raster=%i",filedetails->is_font_raster); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font_truetype) { aaStringCopyf(tok,"is_font_truetype=%i",filedetails->is_font_truetype); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_font_vector)   { aaStringCopyf(tok,"is_font_vector=%i",filedetails->is_font_vector); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_static_lib) { aaStringCopyf(tok,"is_static_lib=%i",filedetails->is_static_lib); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->is_vxd)        { aaStringCopyf(tok,"is_vxd=%i",filedetails->is_vxd); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->company_name[0])      { aaStringCopyf(tok,"company_name=%s",filedetails->company_name); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->file_description[0])  { aaStringCopyf(tok,"file_description=%s",filedetails->file_description); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->file_version[0])      { aaStringCopyf(tok,"file_version=%s",filedetails->file_version); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->internal_name[0])     { aaStringCopyf(tok,"internal_name=%s",filedetails->internal_name); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->legal_copyright[0])   { aaStringCopyf(tok,"legal_copyright=%s",filedetails->legal_copyright); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->legal_trademarks[0])  { aaStringCopyf(tok,"legal_trademarks=%s",filedetails->legal_trademarks); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->original_filename[0]) { aaStringCopyf(tok,"original_filename=%s",filedetails->original_filename); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->product_name[0])      { aaStringCopyf(tok,"product_name=%s",filedetails->product_name); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->product_version[0])   { aaStringCopyf(tok,"product_version=%s",filedetails->product_version); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->comments[0])          { aaStringCopyf(tok,"comments=%s",filedetails->comments); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->private_build[0])     { aaStringCopyf(tok,"private_build=%s",filedetails->private_build); aaStringAppendf(txt,"%-25s\n",tok); }
  if(filedetails->special_build[0])     { aaStringCopyf(tok,"special_build=%s",filedetails->special_build); aaStringAppendf(txt,"%-25s\n",tok); }
  aaStringCopyf(string,"%s",txt);
  }
 return RET_YES;
 }








 B aaFileFolderCreate                  (VP fmt,...)
 {
 B foldername[_2K];
 B ret;//,isfold;
 B fold[_1K];
 B path[_1K];
 H off,pos;
 B ch;
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 if(foldername[0]==NULL_CHAR) { return RET_BADPARM; }
 ret=aaFileFolderExists(foldername);
 if(ret==RET_YES) { return ret; }
 if(ret!=RET_NO)  { oops; }
 ////ret=aaFileInfoGet(foldername,NULL,&isfold,0,0,0);
 //if(ret==RET_YES&&isfold==YES) { return RET_YES; }
 aaStringCopy(fold,foldername);
 aaStringReplaceChar(fold,0,FSLASH_CHAR,BSLASH_CHAR);
 aaStringLastCharGet(fold,0,&ch);
 if(ch!=BSLASH_CHAR) { aaStringAppend(fold,"\\"); }
 off=0;
 while(1)
  {
  aaStringFindChar(&fold[off],0,&pos,BSLASH_CHAR,YES,0,YES);
  if(pos==F32) { break; }
  aaStringNCopy(path,foldername,off+pos,YES);
  aaStringAppend(path,"\\");
  //oof;
  if(aaFileFolderExists(path)!=YES)
 // if(aaFileInfoGet(path,NULL,NULL,0,0,0)!=RET_YES)
   {
//   log(Create %s",path);
   if(CreateDirectory((CP)path,NULL)==0) { return RET_FAILED; }
   }
  off+=(pos+1);
  }
 return RET_YES;
 }





 B aaFileFolderDelete                  (VP fmt,...)
 {
 BOOL bo;
 DWORD er;
 B foldername[_2K];
 B ret,isfold;
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 if(foldername[0]==NULL_CHAR) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(foldername,NULL,&isfold,0,0,0))!=RET_YES) { return ret; }
 if(isfold==NO) { return RET_FAILED; }
 bo=RemoveDirectory((CP)foldername);
 if(bo==0)
  {
  er=GetLastError();
  if(er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
  if(er==ERROR_SHARING_VIOLATION) { return RET_DENIED; }
  if(er==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  oow;
  return RET_FAILED;
  }

 return RET_YES;
 }



 B aaFileFolderExists                  (VP fmt,...)
 {
 B isfold;
 DWORD a;
 B foldername[_2K];
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 a=GetFileAttributes((CP)foldername);
 if(a==INVALID_FILE_ATTRIBUTES) { return RET_NO; }
 isfold=NO;
 if(a&FILE_ATTRIBUTE_DIRECTORY) { isfold=YES;  }
 if(isfold==NO) { return RET_NO; }
 return RET_YES;
 }




 B aaFileFolderWorkingSet              (VP fmt,...)
 {
 B foldername[_2K];
 B ret,isfold;
 B fold[_2K];
 aaVargsf(fmt)

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaStringCopyf(foldername,"%s",str64k.buf);
 if(foldername[0]==NULL_CHAR)
  {
  aaStringCopy(fold,aa.core_system.module_path);//aa.core_system.module_filename);
//  aaStringFindChar(fold,0,&pos,BSLASH_CHAR,YES,0,NO);
///  if(pos!=F32) { fold[pos+1]=NULL_CHAR; }
  }
 else
  {
  aaStringCopy(fold,foldername);
  }
 if((ret=aaFileInfoGet(fold,NULL,&isfold,0,0,0))!=RET_YES) { return ret; }
 if(isfold==NO) { return RET_FAILED; }
 if(SetCurrentDirectory((CP)fold)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileFolderWorkingGet              (VP foldername)
 {
 B fold[_2K];
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(foldername==NULL) { return RET_BADPARM; }
 aaStringNull(foldername);
 if(GetCurrentDirectory(_2K,(VP)fold)==0) { return RET_FAILED; }
 aaStringCharGet(fold,0,-1,&ascii);
 if(ascii!=BSLASH_CHAR) {  aaStringAppendChar(fold,BSLASH_CHAR); }
 aaStringCopy(foldername,fold);
 return RET_YES;
 }







 B aaFileFolderRename                  (VP foldername,VP newfoldername)
 {
 B ret;
 B isfolder;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaFileInfoGet(foldername,NULL,&isfolder,0,0,0))!=RET_YES) { return ret; }
 if(isfolder!=YES) { return RET_FAILED; }
 if(MoveFileEx(foldername,newfoldername,MOVEFILE_WRITE_THROUGH|MOVEFILE_COPY_ALLOWED)==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaFileFolderTreeCreate              (VP foldername,B levels,B hex)
 {
 B etc[_1K];
 B buf[_1K];
 B fmt[_1K];
 B txt[_1K];
 H i,l,c,s,p,off,z,mul;
 B rot[_1K];
 _syspath sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hex) mul=16;
 else    mul=10;
 if(levels>=4) { return RET_BOUNDS; }
 aaSysPathGet(&sp);
 if(aaStringIsNull(foldername)==NO)
  {
  aaStringCopyf(rot,"%s",foldername);
  if(rot[0]=='/') {  aaStringCopyf(rot,"%s%s",sp.current_dir,rot);   }
  }
 else  {  aaStringCopyf(rot,"%s",sp.current_dir);  }
 aaFileFolderCreate(rot);
 c=1;
 for(l=0;l<levels;l++) { c=c*mul;  }
 if(mul==10) aaStringCopyf(fmt,"%%0%ii",levels);
 else aaStringCopyf(fmt,"%%0%ix",levels);
 l=0;
 etc[0]=0;
 for(i=0;i<c;i++)
  {
  aaStringCopyf(buf,fmt,i);
  p=0;
  for(s=0;s<100;s++)
   {
   etc[p++]=buf[s];
   etc[p++]='/';
   }
  etc[p]=0;
  for(z=0;z<levels;z++)
   {
   aaStringCopyf(txt,"%s/%s",rot,etc);
   aaStringFindChar(txt,0,&off,'/',YES,(levels-z-1),NO);
   txt[off]=0;
   aaFileFolderCreate("%s",txt);
   txt[off]='/';
   }
  }
 return RET_YES;
 }




 B aaFileFolderTreeDelete              (VP foldername,B levels,B hex,B delfiles)
 {
 B etc[_1K];
 B buf[_1K];
 B fmt[_1K];
 B txt[_1K];
 H i,l,c,s,p,off,z,mul;
 B rot[_1K];
 _syspath sp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(hex) mul=16;
 else    mul=10;
 if(levels>=4) { return RET_BOUNDS; }
 aaSysPathGet(&sp);
 if(aaStringIsNull(foldername)==NO)
  {
  aaStringCopyf(rot,"%s",foldername);
  if(rot[0]=='/') {  aaStringCopyf(rot,"%s%s",sp.current_dir,rot);   }
  }
 else  {  aaStringCopyf(rot,"%s",sp.current_dir);  }
// aaFileFolderCreate(rot);
 c=1;
 for(l=0;l<levels;l++) { c=c*mul;  }
 if(mul==10) aaStringCopyf(fmt,"%%0%ii",levels);
 else aaStringCopyf(fmt,"%%0%ix",levels);
 l=0;
 etc[0]=0;
 for(i=0;i<c;i++)
  {
  aaStringCopyf(buf,fmt,i);
  p=0;
  for(s=0;s<100;s++)
   {
   etc[p++]=buf[s];
   etc[p++]='/';
   }
  etc[p]=0;
  for(z=0;z<levels;z++)
   {
   aaStringCopyf(txt,"%s/%s",rot,etc);
   aaStringFindChar(txt,0,&off,'/',YES,(levels-z-1),NO);
   txt[off]=0;
   if(delfiles) { oof; }
   aaFileFolderDelete(txt);
   txt[off]='/';
   }
  }
 aaFileFolderCreate(rot);
 return RET_YES;
 }



 B aaFileUnitLoad                      (_fileunit*unit,VP fmt,...)
 {
 B ret;
 H by;
 va_list argptr;
 B txt[_4K];

 //aaStringLen(txt,&sl);
 //aaMemoryFill(blkb,sizeof(blkb),32);
 //aaMemoryCopy(blkb,sl,txt);


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(unit==NULL) { return RET_BADPARM; }
 unit->magic=0;
 unit->mem=NULL;
 unit->bytes=0;
 //if(filename==NULL) { return RET_BADPARM; }
 if((ret=aaFileLoadToMemory(txt,0,F32,(VP)&unit->mem,&by))!=YES) { return ret; }
 unit->magic=aa_FILEUNIT_MAGIC;
 unit->bytes=(Q)by;
 return RET_YES;
 }




 B aaFileUnitRelease                   (_fileunit*unit)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(unit==NULL) { return RET_BADPARM; }
 if(unit->magic!=aa_FILEUNIT_MAGIC) { return RET_FAILED; }
 if(unit->mem!=NULL) { aaMemoryRelease(unit->mem); }
 unit->mem=NULL;
 unit->magic=0;
 unit->bytes=0;
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/


 B aaFileBoxOpen                       (H surfacehandle,VP initdir,VP initfile,VP fltr,B maxfiles,VP caption)
 {
 H sl,id;
 B ret;
 _aa_surfaceobject*surp;
 H mx;
 _fileboxstatus fs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.filebox_system.is_open==YES) { return RET_ALREADYOPEN; }
 if(maxfiles==0) { return RET_BADPARM; }
 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
 aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
 if(caption==NULL) { aaStringCopy(aa.filebox_system.caption,"FileBox");  }
 else                { aaStringCopy(aa.filebox_system.caption,caption);  }
 if(fltr!=NULL)
  {
  aaStringLen(fltr,&sl);
  if(sl>255) { return RET_BADPARM; }
  aaStringCopy(aa.filebox_system.filter,fltr);
  }
 if(initdir!=NULL)
  {
  aaStringLen(initdir,&sl);
  if(sl>255) { return RET_BADPARM; }
  aaStringCopy(aa.filebox_system.initial_dir,initdir);
  aaStringReplaceChar(aa.filebox_system.initial_dir,0,FSLASH_CHAR,BSLASH_CHAR);
  }
 if(initfile!=NULL)
  {
  aaStringLen(initfile,&sl);
  if(sl>255) { return RET_BADPARM; }
  aaStringCopy(aa.filebox_system.initial_file,initfile);
  }
 aa.filebox_system.max_files=maxfiles;
 if(surfacehandle!=0) { aa.filebox_system.parent_hwnd=surp->status.hwnd; }
 mx=(sizeof(fs.filename)/sizeof(fs.filename[0]));
 if(fs.count==mx) {  } // prevent: warning
 if((ret=aaMemoryAllocate((VP)&aa.filebox_system.selection,sizeof(fs.filename)+_1K))!=RET_YES)
  {
  aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
  return ret;
  }
 aa.filebox_system.is_open=YES;
 aa.filebox_system.handle=CreateThread(NULL,0,aa_FileBoxProc,&aa.filebox_system,0,&id);
 if(aa.filebox_system.handle==NULL)
  {
  aaMemoryRelease(aa.filebox_system.selection);
  aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
  return RET_FAILED;
  }
 return RET_YES;
 }




 B aaFileBoxClose                      (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.filebox_system.is_open!=YES) { return RET_NOTOPEN; }
 if(aa.filebox_system.is_close==YES) { return RET_YES; }
 if(TerminateThread((HANDLE)aa.filebox_system.handle,(UINT)0)==FALSE) { oof; oow; oof; }
 CloseHandle((HANDLE)aa.filebox_system.handle);
 if(aa.filebox_system.selection!=NULL) { aaMemoryRelease(aa.filebox_system.selection); }
 aaMemoryFill(&aa.filebox_system,sizeof(_aa_fileboxsystem),0);
 aa.filebox_system.is_close=YES;
 return RET_YES;
 }





 //B doner=0;



 B aaFileBoxStatus                     (_fileboxstatus*fileboxstatus)
 {
 BOOL q;
 B tok[_4K];
 H c,toklen,offset,ec;
 B mode;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(fileboxstatus==NULL) { return RET_BADPARM; }
 aaMemoryFill(fileboxstatus,sizeof(_fileboxstatus),0);
 if(aa.filebox_system.is_open!=YES) { return RET_NOTOPEN; }
 if(aa.filebox_system.is_failure)   { fileboxstatus->is_failure=YES;  }
 if(aa.filebox_system.is_cancelled)   { fileboxstatus->is_cancelled=YES;  }

 if(aa.filebox_system.is_cancelled) { return RET_CANCELLED; }
 if(aa.filebox_system.is_failure) { return RET_FAILED; }


 q=GetExitCodeThread(aa.filebox_system.handle,&ec);
 if(ec==STILL_ACTIVE) {  return RET_INUSE; }
 if(q==0||ec==0)
  {
  aa.filebox_system.is_cancelled=YES;
  fileboxstatus->is_cancelled=YES;
  return RET_CANCELLED;
  }

 aaMemoryFill(tok,sizeof(tok),0);
 aaStringCopyf(&tok[_0K],"%s",&aa.filebox_system.selection[0]);
 aaStringCopyf(&tok[_1K],"%s",&aa.filebox_system.selection[aa.filebox_system.of.nFileOffset]);
 aaStringCopyf(&tok[_2K],"%s",&aa.filebox_system.selection[aa.filebox_system.of.nFileExtension]);

 mode=0;

 if(aa.filebox_system.max_files<2)
  {
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension!=0) { mode=1; } // single-mode, one selected
  else
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension==0) { mode=2; }
  }
 else
 if(aa.filebox_system.max_files>=2)
  {
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension!=0) { mode=3; } // multi-mode, one selected
  else
  if(aa.filebox_system.of.nFileOffset!=0&&aa.filebox_system.of.nFileExtension==0) { mode=4; } // multi-mode, multi selected
  }

 offset=aa.filebox_system.of.nFileOffset;
 if(mode==0||offset==0)
  {
  aa.filebox_system.is_failure=YES;
  fileboxstatus->is_failure=YES;
  }


 c=0;
 toklen=0;
 tok[toklen]=NULL_CHAR;
 while(1)
  {
  ascii=aa.filebox_system.selection[offset++];
  if(ascii!=NULL_CHAR)   {   tok[toklen++]=ascii;   tok[toklen]=NULL_CHAR;   continue;   }
  tok[toklen]=ascii;
  if(toklen==0||(toklen>=sizeof(fileboxstatus->filename[0])))
   {
   oof;
   aa.filebox_system.is_failure=YES;
   fileboxstatus->is_failure=YES;
   break;
   }
  aaStringNCopy(fileboxstatus->filename[c],tok,toklen,YES);
  c++;
  ascii=aa.filebox_system.selection[offset];
  if(ascii==NULL_CHAR) { break; }
  toklen=0;
  tok[toklen]=NULL_CHAR;
  }

 fileboxstatus->count=c;
 aaStringNCopy(fileboxstatus->path,aa.filebox_system.selection,aa.filebox_system.of.nFileOffset,YES);

 if(aa.filebox_system.is_failure)
  {
  return RET_FAILED;
  }

 if(fileboxstatus->count!=0)
  {
  if(aaStringIsEmpty(fileboxstatus->path,YES)==NO)
   {
   fileboxstatus->is_success=YES;
   }
  }
 return RET_YES;
 }










/*-----------------------------------------------------------------------*/



 B aaFolderBoxOpen                     (H surfacehandle,VP initdir,VP caption)
 {
 H sl,id;
 B ret;
 _aa_surfaceobject*surp;
 //H mx;
 //_folderboxstatus fs;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.folderbox_system.is_open==YES) { return RET_ALREADYOPEN; }
 if(surfacehandle!=0)
  {
  if((ret=aa_ObjectCheck(aa.surface_system.object_id,surfacehandle,(VP)&surp,NULL))!=RET_YES) { return ret; }
  }
 aaMemoryFill(&aa.folderbox_system,sizeof(_aa_folderboxsystem),0);
 if(caption==NULL) { aaStringCopy(aa.folderbox_system.caption,"FolderBox");  }
 else                { aaStringCopy(aa.folderbox_system.caption,caption);  }
 if(initdir!=NULL)
  {
  aaStringLen(initdir,&sl);
  if(sl>512) { return RET_BADPARM; }
  aaStringCopy(aa.folderbox_system.initial_dir,initdir);
  }
 if(surfacehandle!=0) { aa.folderbox_system.surface_handle=surfacehandle;  }
 if(surfacehandle!=0) { aa.folderbox_system.parent_hwnd=surp->status.hwnd; }
   aa.folderbox_system.bi.hwndOwner=aa.folderbox_system.parent_hwnd;
   aa.folderbox_system.bi.pszDisplayName=aa.folderbox_system.szDir;//"Sss";
   aa.folderbox_system.bi.lpszTitle=(CP)aa.folderbox_system.caption;
   aa.folderbox_system.bi.ulFlags=BIF_USENEWUI;//0x00000001;
   aa.folderbox_system.bi.lpfn=aa_FolderBoxCallback;
   aa.folderbox_system.bi.lParam=(LPARAM)aa.folderbox_system.initial_dir;
   aa.folderbox_system.bi.iImage=-1;
 aa.folderbox_system.is_close=NO;
 aa.folderbox_system.is_cancelled=NO;
 aa.folderbox_system.is_open=YES;
 aa.folderbox_system.handle=CreateThread(NULL,0,aa_FolderBoxProc,&aa.folderbox_system,0,&id);
 if(aa.folderbox_system.handle==NULL)
  {
  aaMemoryFill(&aa.folderbox_system,sizeof(_aa_folderboxsystem),0);
  return RET_FAILED;
  }
 return RET_YES;
 }





 B aaFolderBoxClose                    (V)
 {
 T V (*def_cotaskmemfree) (LPVOID);
 def_cotaskmemfree my_cotaskmemfree;
 HMODULE lib;
 _folderboxstatus fs;
 DWORD ec;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(aa.folderbox_system.is_open!=YES) { return RET_NOTOPEN; }
 aaFolderBoxStatus(&fs);
 if(fs.is_cancelled!=YES&&fs.is_success!=YES)
  {
  aaFocusToHwnd(aa.folderbox_system.dialog_hwnd);
  if(EndDialog(aa.folderbox_system.dialog_hwnd,0)==0) { oof; oow; }
  while(1)
   {
   aaFolderBoxStatus(&fs);
   if(fs.is_cancelled==YES||fs.is_success==YES) break;
   aaYield(-1.0);
   }
  while(1)
   {
   if(GetExitCodeThread(aa.folderbox_system.handle,&ec)==0) { oof; oow; break; }
   if(ec!=STILL_ACTIVE) {  break; }
   aaYield(-1.0);
   }
  }

 CloseHandle((HANDLE)aa.folderbox_system.handle);
 if(aa.folderbox_system.pidl!=NULL)
  {
  if((lib=LoadLibrary("ole32.dll"))==NULL) { oof; }
  my_cotaskmemfree=(def_cotaskmemfree)     GetProcAddress(lib,"CoTaskMemFree");
  if(my_cotaskmemfree==NULL) oof;
  my_cotaskmemfree(aa.folderbox_system.pidl);
  FreeLibrary(lib);
  }
 aaMemoryFill(&aa.folderbox_system,sizeof(_aa_folderboxsystem),0);
 return RET_YES;
 }







 B aaFolderBoxStatus                   (_folderboxstatus*folderboxstatus)
 {
 BOOL q;
 DWORD ec=0;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(folderboxstatus==NULL) { return RET_BADPARM; }
 aaMemoryFill(folderboxstatus,sizeof(_folderboxstatus),0);
 if(aa.folderbox_system.is_open!=YES) { return RET_NOTOPEN; }

 if(aa.folderbox_system.is_failure)   { folderboxstatus->is_failure=YES;  }
 if(aa.folderbox_system.is_cancelled)   { folderboxstatus->is_cancelled=YES;  }

 if(aa.folderbox_system.is_cancelled) { return RET_CANCELLED; }
 if(aa.folderbox_system.is_failure) { return RET_FAILED; }


 q=GetExitCodeThread(aa.folderbox_system.handle,&ec);
 if(ec==STILL_ACTIVE) {  return RET_YES; }
 if(q==0||ec==0)
  {
  aa.folderbox_system.is_cancelled=YES;
  folderboxstatus->is_cancelled=YES;
  return RET_CANCELLED;
  }
 if(aa.folderbox_system.pidl==NULL)
  {
  folderboxstatus->is_cancelled=YES;
  }
 else
  {
  if(folderboxstatus->is_success!=YES)
   {
   if(SHGetPathFromIDList(aa.folderbox_system.pidl,(LPSTR)aa.folderbox_system.r_path)==FALSE) oof;
   }
  folderboxstatus->is_success=YES;
  }
 if(folderboxstatus->is_success==YES) { aaStringCopyf(folderboxstatus->path,"%s",aa.folderbox_system.r_path); }

 return RET_YES;
 }


/*-----------------------------------------------------------------------*/

 B aaDirOpen                           (HP handle,B gettimes,VP filespec)
 {
 B ret;
 _aa_dirobject*dirp;
 HANDLE h;
 H c;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.dir_system.object_id,handle,(VP)&dirp))!=RET_YES) { oops; return ret; }
 dirp->self_handle=*handle;
 dirp->status.in_progress=YES;
 gettimes&=1;
 dirp->status.is_gettimes=gettimes;
 h=FindFirstFile(filespec,&dirp->wfd);
 if(h==INVALID_HANDLE_VALUE) { dirp->status.is_completed=YES; }
 else
  {
  dirp->handle=h;
  c=128;
  aaMemoryAllocate((VP)&dirp->mem,c*sizeof(_direntry));
  aaCast(dirp->status.entry,_direntry*,dirp->mem);
  dirp->slots=c;
  }
 aaStringCopy(dirp->status.file_spec,filespec);
 return RET_YES;
 }




 B aaDirClose                          (H handle)
 {
 B ret;
 _aa_dirobject*dirp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dir_system.object_id,handle,(VP)&dirp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(dirp->handle!=NULL)
  {
  FindClose(dirp->handle);
  }
 if(dirp->slots!=0)
  {
  aaMemoryRelease(dirp->mem);
  }
 aa_ObjectDestroy(aa.dir_system.object_id,handle);
 return RET_YES;
 }




 B aaDirStatus                         (H handle,_dirstatus*dirstatus,H iterations)
 {
 B ret;
 _aa_dirobject*dirp;
 H left,toadd,go;
 _direntry*ep;
 H i;
 BP old_mem;
 BOOL bl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.dir_system.object_id,handle,(VP)&dirp,NULL))!=RET_YES) { return ret; }
 if(dirp->status.in_progress!=YES) { return RET_FAILED; }
 if(iterations==0) { iterations=1; }
 //iterations=aaNumClamp(iterations,1,65535);
  for(go=0;go<iterations;go++)
   {
   if(dirp->status.is_completed==YES) { break; }
   left=dirp->slots-dirp->status.total_entries;
   if(left<4)
    {
    old_mem=dirp->mem;
    toadd=(dirp->slots)+(dirp->slots/4)+128;
    aaMemoryReAllocate((VP)&old_mem,(dirp->slots+toadd)*sizeof(_direntry));
    dirp->mem=old_mem;
    dirp->slots+=toadd;
    //aaDebugf("aloc");
    }
   aaCast(ep,_direntry*,dirp->mem);
   i=dirp->status.total_entries;
   ep[i].attributes=dirp->wfd.dwFileAttributes;
   if(dirp->wfd.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY) { ep[i].is_folder=YES; }
   else                                                      { ep[i].is_folder=NO; }
   aaStringCopy(ep[i].file_name,dirp->wfd.cFileName);
   aaStringCopy(ep[i].alt_file,dirp->wfd.cAlternateFileName);
   ep[i].file_bytes=(Q)(dirp->wfd.nFileSizeHigh*F32)+dirp->wfd.nFileSizeLow;
   ep[i].is_dotty=0;
    if(ep[i].is_folder)
     {
     dirp->status.dir_entries++;
     if(ep[i].file_name[0]=='.'&&ep[i].file_name[1]==NULL_CHAR) { ep[i].is_dotty=1; } else
     if(ep[i].file_name[0]=='.'&&ep[i].file_name[1]=='.'&&ep[i].file_name[2]==NULL_CHAR) { ep[i].is_dotty=2; }
     if(ep[i].is_dotty==0) {      dirp->status.folder_entries++; }
     }
    else                   { dirp->status.file_entries++; }
   if(dirp->status.is_gettimes)
    {
    WinFileTimeToSysTime(&dirp->wfd.ftCreationTime,&ep[i].created);
    WinFileTimeToSysTime(&dirp->wfd.ftLastWriteTime,&ep[i].modified);
    }

    dirp->status.total_entries++;
    bl=FindNextFile(dirp->handle,&dirp->wfd);
    if(bl==0)
     {
     if(GetLastError()==ERROR_NO_MORE_FILES)
      {
      FindClose(dirp->handle);
      dirp->handle=0;
      dirp->status.is_completed=YES;
      }
     else oof;
     }
    }
 aaCast(dirp->status.entry,_direntry*,dirp->mem);
 if(dirstatus) { aaMemoryCopy(dirstatus,sizeof(_dirstatus),&dirp->status); }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/



 B aaDirWalkerCreate                   (HP handle,VP root,VP spec,B incfiles,H maxdepth,B(*proc)(H,VP,_dirwalkerstatus*,_direntry*))
 {
 B ret;
 _aa_dirwalkerobject*dwlkp;
 B txt[_2K];
 H pos;
 B ascii;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 if((ret=aa_ObjectCreate(aa.dirwalker_system.object_id,handle,(VP)&dwlkp))!=RET_YES) { oops; return ret; }
 #endif
 dwlkp->self_handle=*handle;
 dwlkp->status.in_progress=YES;
 if(incfiles) { dwlkp->status.is_incfiles=YES; }
 dwlkp->status.max_depth=maxdepth;
 if(aaStringIsEmpty(root,YES)==NO)
  {
  aaStringCopyf(dwlkp->status.root,"%s",root);
  }
 else
  {
  aaStringCopyf(dwlkp->status.root,"%s",root);
  if((ret=aaFileFolderWorkingGet(dwlkp->status.root))!=YES) { oops; }
  }
 aaStringReplaceChar(dwlkp->status.root,0,BSLASH_CHAR,FSLASH_CHAR);
 aaStringLastCharGet(dwlkp->status.root,0,&ascii);
 if(ascii==FSLASH_CHAR) { aaStringLastCharSet(dwlkp->status.root,0,NULL_CHAR,YES); }

 aaStringCopyf(dwlkp->status.spec,"%s",spec);
 aaMiniStackInit(&dwlkp->dms);
 dwlkp->stage=20;
 dwlkp->status.proc=proc;
 aaStringLen(dwlkp->status.root,&dwlkp->root_sl);
 aaStringCopyf(txt,"%s/%s",dwlkp->status.root,dwlkp->status.spec);
   //aaDebugf("dir open %s",txt);
   dwlkp->ti=0;
   //aaDebugf("diropenA=%s",txt);
   if((ret=aaDirOpen(&dwlkp->status.dir.handle,(dwlkp->status.is_incfiles),txt))!=YES) { oops;  }
   if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,100))!=YES) { oops; }
   aaStringCopyf(dwlkp->status.cur_dir,"%s",dwlkp->status.dir.status.file_spec);
   aaStringFindChar(dwlkp->status.cur_dir,0,&pos,'/',YES,0,NO);
   if(pos!=F32) {  dwlkp->status.cur_dir[pos+1]=NULL_CHAR; }

  if((ret=aaListNew(&dwlkp->status.list))!=YES) { oops; }
  //if((ret=aaListAllowDuplicates(&dwlkp->status.list,YES))!=YES) { oops; }

   dwlkp->stage=20;

 return RET_YES;
 }




 B aaDirWalkerDestroy                  (H handle)
 {
 B ret;
 _aa_dirwalkerobject*dwlkp;
 B isprot;
 H han;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 if((ret=aa_ObjectCheck(aa.dirwalker_system.object_id,handle,(VP)&dwlkp,&isprot))!=RET_YES) { return ret; }
 #endif
 if(isprot) { return RET_FORBIDDEN; }
 if(dwlkp->status.dir.handle!=0)
  {
  aaDirClose(dwlkp->status.dir.handle);
  dwlkp->status.dir.handle=0;
  }
 while(1)
  {
  if(dwlkp->dms.bytes<8) { break; }
  if(aaMiniStackPopDword(&dwlkp->dms,&han)!=YES) { break; }
  if(aaMiniStackPopDword(&dwlkp->dms,&han)!=YES) { break; }
  aaDirClose(han);
  }
 aaListDelete(&dwlkp->status.list);


 #ifdef aa_VERSION
 aa_ObjectDestroy(aa.dirwalker_system.object_id,handle);
 #endif
 return RET_YES;
 }






 B aaDirWalkerStatus                   (H handle,_dirwalkerstatus*dirwalkerstatus,H iterationsa,H iterationsb)
 {
 B ret;
 _aa_dirwalkerobject*dwlkp;
 H pos,ti,han,go,index,fulls,flag;
 H depth;
 B needs_status=YES;
 B is_cancelled=NO;
 B txt[_2K];
 B str[_2K];
 B(*proc)(H,VP,_dirwalkerstatus*,_direntry*);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 if((ret=aa_ObjectCheck(aa.dirwalker_system.object_id,handle,(VP)&dwlkp,NULL))!=RET_YES) { return ret; }
 #endif
 if(dwlkp->status.in_progress!=YES) { return RET_FAILED; }
 if(iterationsa==0) { iterationsa=1; }
 if(iterationsb==0) { iterationsb=1; }
 //iterationsa=aaNumClamp(iterationsa,1,65535);
 //iterationsb=aaNumClamp(iterationsb,1,65535);

 if(dwlkp->in_proc)
  {
  if(dirwalkerstatus) { aaMemoryCopy(dirwalkerstatus,sizeof(_dirwalkerstatus),&dwlkp->status); }
  return RET_YES;
  }


 //aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1);
 fulls=0;
 for(go=0;go<iterationsa;go++)
  {
  if(dwlkp->status.is_completed==YES) { break; }
  if(is_cancelled==YES)  { dwlkp->stage=60; break; }
//  if(go>1) {  if(dwlkp->status.dir.status.is_completed!=YES) { break; }   }
  //if(dwlkp->stage==20&&fulls>0) { break; }

  switch(dwlkp->stage)
   {
   case 10:
   break;


   case 20:
   fulls++;
   if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,iterationsb))!=YES) { oops; dwlkp->stage=666; break; }
   //if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,iterations))!=YES) { oops; dwlkp->stage=666; break; }
   if(dwlkp->status.dir.status.is_completed!=YES) { break; }
   needs_status=YES;
   dwlkp->stage=30;
   break;


   case 30:
   if(needs_status)
    {
    if(aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1)!=YES) oof;
    needs_status=NO;
    }
   ti=dwlkp->ti;
   if(ti>=dwlkp->status.dir.status.total_entries)  { dwlkp->stage=40;    break;    }

   aaStringCopyf(dwlkp->status.cur_dir,"%s",dwlkp->status.dir.status.file_spec);
   aaStringFindChar(dwlkp->status.cur_dir,0,&pos,'/',YES,0,NO);
   if(pos!=F32) {  dwlkp->status.cur_dir[pos+1]=NULL_CHAR; }

   aaStringCopyf(str,"%s%s",dwlkp->status.cur_dir,dwlkp->status.dir.status.entry[ti].file_name);
   aaStringCopyf(str,"%s",&str[dwlkp->root_sl]);
   //aaDebugf("tru ti=%i isdotty=%i isfold=%i [%s] st=[%s]",ti,dwlkp->status.dir.status.entry[ti].is_dotty,dwlkp->status.dir.status.entry[ti].is_folder,dwlkp->status.dir.status.entry[ti].file_name,str);

   if(dwlkp->status.dir.status.entry[ti].is_dotty==NO)//&&dwlkp->status.dir.status.entry[ti].is_folder==YES)
    {
    while(1)
     {
     depth=dwlkp->dms.height/2;
     if(depth>dwlkp->status.max_depth) { break; }
     if(dwlkp->status.is_incfiles==NO&&dwlkp->status.dir.status.entry[ti].is_folder==NO) { break; }

     flag=YES;
     if(dwlkp->status.proc)
      {
      dwlkp->in_proc=YES;
      proc=dwlkp->status.proc;
      //ret=dwlkp->status.proc(handle,str,&dwlkp->status,&dwlkp->status.dir.status.entry[ti]);
      ret=proc(handle,str,&dwlkp->status,&dwlkp->status.dir.status.entry[ti]);
      if(ret!=RET_YES) { flag=NO; }
      if(ret==RET_CANCELLED) { is_cancelled=YES; }
      dwlkp->in_proc=NO;
      }

     if(flag==YES)
      {
      if((ret=aaListAppend(&dwlkp->status.list,&index,str,sizeof(_direntry),&dwlkp->status.dir.status.entry[ti]))!=YES)
       {
       aaNote(0,"%s %s",ret_string[ret],str);
       aaNote(0,"index=%i ti=%i",index,ti);
       aaNote(0,"%s",dwlkp->status.dir.status.entry[ti].file_name);
       aaNote(0,"%s",&dwlkp->status.list.mun.mem[dwlkp->status.list.entry[index].key_off]);
       }
      if(dwlkp->status.dir.status.entry[ti].is_folder==NO) { dwlkp->status.total_files_added++; }
      else                                                 { dwlkp->status.total_folders_added++; }
      }

     break;
     }
    }
   //aaDebugf("lc=%i ti=%i",dwlkp->status.list.count,ti);

   if(dwlkp->status.dir.status.entry[ti].is_dotty==NO&&dwlkp->status.dir.status.entry[ti].is_folder==YES)
    {
    depth=dwlkp->dms.height/2;
    if(depth<=dwlkp->status.max_depth)
     {
     aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1);
     aaStringCopyf(txt,"%s",dwlkp->status.dir.status.file_spec);
     aaStringCharSet(txt,0,-3,0);
     aaStringAppendf(txt,"%s",dwlkp->status.dir.status.entry[dwlkp->ti].file_name);
     aaStringAppendf(txt,"/%s",dwlkp->status.spec);
     dwlkp->ti++;
     aaMiniStackPushDword(&dwlkp->dms,dwlkp->status.dir.handle);
     aaMiniStackPushDword(&dwlkp->dms,dwlkp->ti);
     dwlkp->ti=0;
     //aaDebugf("diropenB=%s",txt);
     if((ret=aaDirOpen(&dwlkp->status.dir.handle,(dwlkp->status.is_incfiles),txt))!=YES) { oops;  }
     if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1))!=YES) { oops; }
     aaStringCopyf(dwlkp->status.cur_dir,"%s",dwlkp->status.dir.status.file_spec);
     aaStringFindChar(dwlkp->status.cur_dir,0,&pos,'/',YES,0,NO);
     if(pos!=F32) {  dwlkp->status.cur_dir[pos+1]=NULL_CHAR; }
     dwlkp->stage=20;
     dwlkp->status.total_folders_found++;
     break;
     }
    dwlkp->ti++;
    dwlkp->status.total_folders_found++;
    break;
    }
   if(dwlkp->status.dir.status.entry[ti].is_dotty==NO&&dwlkp->status.dir.status.entry[ti].is_folder==NO)
    {
    dwlkp->status.total_files_found++;
    }
   dwlkp->ti++;
   break;

   case 40:
 //  if(dwlkp->status.dir.status.folder_entries==0&&aaMathRand32(0,20)==10)   {    aaDebugf("tf=%-9i tfo=%-6i td=%-6i %s",dwlkp->status.dir.status.file_entries,dwlkp->status.dir.status.folder_entries,dwlkp->status.dir.status.dir_entries,dwlkp->status.dir.status.file_spec);    }
   aaDirClose(dwlkp->status.dir.handle);
   dwlkp->status.dir.handle=0;
   if(dwlkp->dms.bytes<8) { dwlkp->stage=50; break; }
   if((ret=aaMiniStackPopDword(&dwlkp->dms,&ti))!=YES)  { oops; dwlkp->stage=666; break; }
   if((ret=aaMiniStackPopDword(&dwlkp->dms,&han))!=YES) { oops; dwlkp->stage=666; break; }
   dwlkp->status.dir.handle=han;
   if((ret=aaDirStatus(dwlkp->status.dir.handle,&dwlkp->status.dir.status,1))!=YES) { oops; dwlkp->stage=666; break; }
   dwlkp->ti=ti;
   if(dwlkp->dms.bytes==0)
    {
    aaStringCopyf(txt,"%s",dwlkp->status.dir.status.file_spec);
    aaStringCharSet(txt,0,-3,0);
    aaStringAppendf(txt,"%s",dwlkp->status.dir.status.entry[dwlkp->ti].file_name);
    aaStringAppendf(txt,"/");
    }
   dwlkp->stage=20;
   //aaDebugf("popped ti=%i",dwlkp->ti);
   break;

   case 80:
   oof;
   break;

   case 50:
   dwlkp->status.is_completed=YES;
   break;

   case 60:
   dwlkp->status.is_cancelled=YES;
   break;

   case 666:
   return RET_FAILED;
   }
  }

 //if(dwlkp->status.is_completed==YES) { break; }



// aaCast(dwlkp->status.entry,_direntry*,dwlkp->mem);
 if(dirwalkerstatus) { aaMemoryCopy(dirwalkerstatus,sizeof(_dirwalkerstatus),&dwlkp->status); }
 return RET_YES;
 }







/*-----------------------------------------------------------------------*/



 B aaDriveEject                        (B drive,B state)
 {
 MCI_OPEN_PARMS op;
 //MCI_STATUS_PARMS st;
 H flags;
 C name[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(drive>='A'&&drive<='Z') drive+=(C)32;
 if(drive<'a'||drive>'z') { return RET_BADPARM; }
 aaStringCopyf(name,"%c:\\",drive);
 aaMemoryFill(&op,sizeof(op),0);
 op.lpstrDeviceType=(LPCSTR)MCI_DEVTYPE_CD_AUDIO;
 op.lpstrElementName=name;
 flags=MCI_OPEN_TYPE|MCI_OPEN_TYPE_ID|MCI_OPEN_ELEMENT|MCI_OPEN_SHAREABLE;
 if(!mciSendCommand(0,MCI_OPEN,flags,(H)&op))
  {
  //st.dwItem=MCI_STATUS_READY;
  if(state) mciSendCommand(op.wDeviceID,MCI_SET,MCI_SET_DOOR_OPEN,0);
  else      mciSendCommand(op.wDeviceID,MCI_SET,MCI_SET_DOOR_CLOSED,0);
  mciSendCommand(op.wDeviceID,MCI_CLOSE,MCI_WAIT,0);
  }
 return RET_YES;
 }




 B aaDriveInfoGet                      (B drive,_driveinfo*driveinfo)
 {
 UINT u;
 B bin[100];
 H val;
 C rootpath[129];
 B ty;
 LPCTSTR szHD;//="f:\\";
 UCHAR szFileSys[255],szVolNameBuff[255];
 DWORD dwSerial,dwMFL,dwSysFlags;
 BOOL bSuccess;
 B etc[_1K];
 H va,vb,vc,vd;
 D d0,d1,d2;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(driveinfo==NULL) { return RET_BADPARM; }
 aaMemoryFill(driveinfo,sizeof(_driveinfo),0);
 aaStringCopy(driveinfo->type_txt,"???");
 driveinfo->type=aa_DRIVETYPE_UNKNOWN;
 if(drive>='A'&&drive<='Z') drive+=(C)32;
 if(drive<'a'||drive>'z') { return RET_BADPARM; }
 rootpath[0]=drive;
 rootpath[1]=':';
 rootpath[2]=0;
 u=GetDriveType(rootpath);
 ty=(B)u;
 driveinfo->type=ty;
 driveinfo->drive=drive;
  switch(ty)
   {
   case aa_DRIVETYPE_UNKNOWN: aaStringCopy(driveinfo->type_txt,"???"); break;
   case aa_DRIVETYPE_ERROR: aaStringCopy(driveinfo->type_txt,"ERR"); break;
   case aa_DRIVETYPE_REMOVABLE: aaStringCopy(driveinfo->type_txt,"RMV"); break;
   case aa_DRIVETYPE_FIXED: aaStringCopy(driveinfo->type_txt,"FXD"); break;
   case aa_DRIVETYPE_REMOTE: aaStringCopy(driveinfo->type_txt,"REM"); break;
   case aa_DRIVETYPE_CDROM: aaStringCopy(driveinfo->type_txt,"C.D"); break;
   case aa_DRIVETYPE_RAMDISK: aaStringCopy(driveinfo->type_txt,"RAM"); break;
   default: aaStringCopy(driveinfo->type_txt,"BAD"); break;
   }
 if(ty==aa_DRIVETYPE_UNKNOWN) { return RET_NOTFOUND;  }
 if(ty==aa_DRIVETYPE_ERROR) { return RET_NOTFOUND; }
 szHD=(VP)etc;
 aaStringCopyf((VP)szHD,"%c:\\",drive);
 bSuccess=GetVolumeInformation(szHD,(LPTSTR)szVolNameBuff,255,&dwSerial,&dwMFL,&dwSysFlags,(LPTSTR)szFileSys,255);
 if(!bSuccess){ return RET_FAILED;}

 driveinfo->volume_id=dwSerial;
 driveinfo->max_filename_len=dwMFL;
 if(szVolNameBuff[0]==NULL_CHAR) { aaStringCopy(driveinfo->volume_name,"NOTPRESENT"); }
 else                            { aaStringCopy(driveinfo->volume_name,szVolNameBuff); }
  if(ty>=aa_DRIVETYPE_REMOVABLE)
   {
   if(GetDiskFreeSpace(rootpath,&va,&vb,&vc,&vd)==0) { oow; }
   d0=(D)vd*va*vb;
   d1=(D)vc*va*vb;
   d2=d0-d1; // usage
   va=va*vb; // pagesize
   driveinfo->size=(Q)d0;
   driveinfo->left=(Q)d2;
   driveinfo->used=(Q)d1;
   driveinfo->page_size=va;
   #if 1
   aaDigestQuickf(aa_DIGESTTYPE_Sha1,driveinfo->digest,"%u:%I64u:%u:%s",driveinfo->type,driveinfo->size,driveinfo->volume_id,driveinfo->volume_name);
   for(u=0;u<40;u+=2)
    {
    val=driveinfo->digest[u+0];
    if(aaCharIsNum(val)) { val-='0';          }
    else                 { val-='a'; val+=10; }
    bin[(u/2)]=(val<<4);
    val=driveinfo->digest[u+1];
    if(aaCharIsNum(val)) { val-='0';          }
    else                 { val-='a'; val+=10; }
    bin[(u/2)]+=(val);
    }
   for(u=0;u<5;u++)
    {
    val=*(HP)&bin[u*4];
    if(u==0) {    driveinfo->crc=val; }
    else     {    driveinfo->crc^=val; }
    }
   #endif
   return RET_YES;
   }

 return RET_NOTFOUND;
 }






 B aaDriveListGet                      (_drivelist*drivelist)
 {
 B d;
 UINT em;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(drivelist==NULL) { return RET_BADPARM; }
 aaMemoryFill(drivelist,sizeof(_drivelist),0);
 em=SetErrorMode(SEM_FAILCRITICALERRORS);
 for(d=0;d<26;d++)
  {
  drivelist->ret[d]=aaDriveInfoGet('a'+d,&drivelist->info[d]);
  if(drivelist->ret[d]!=YES) { continue; }
  drivelist->num_found++;
  }
 SetErrorMode(em);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 B aaFileStreamCreate                  (HP handle,VP filename,B create,B rwmode,B shmode,B cmode,B deleteon)
 {
 B ret;
 _aa_filestreamobject*fsp;
 DWORD access_mode=0;
 DWORD share_mode=0;
 DWORD er;
 B isfolder;
 H opt;
 _fileid id;
 BP bp;
 N which;//,lo;
 LARGE_INTEGER li;
 BY_HANDLE_FILE_INFORMATION info;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(handle) { *handle=0; }
 if(rwmode>3||shmode>3) { return RET_BADPARM; }
 if(filename==NULL/*&&create!=YES*/) { return RET_BADPARM; }

 which=-1;
 aaCast(bp,BP,filename);
 if(bp[0]=='$') {  aaStringIsIString(bp,&which,"$stdin","$stdout",NULL);  }
 if((ret=aa_ObjectCreate(aa.filestream_system.object_id,handle,(VP)&fsp))!=RET_YES) {oops; return ret; }
 fsp->self_handle=*handle;
 if(rwmode==aa_FILEMODE_NONE)  { access_mode=0; }               else
 if(rwmode==aa_FILEMODE_R)     { access_mode=GENERIC_READ; }    else
 if(rwmode==aa_FILEMODE_W)     { access_mode=GENERIC_WRITE; }   else
 if(rwmode==aa_FILEMODE_RW)    { access_mode=GENERIC_READ|GENERIC_WRITE; }
 if(shmode==aa_FILESHARE_NONE)  { share_mode=0; }                 else
 if(shmode==aa_FILESHARE_R)     { share_mode=FILE_SHARE_READ; }   else
 if(shmode==aa_FILESHARE_W)     { share_mode=FILE_SHARE_WRITE; }  else
 if(shmode==aa_FILESHARE_RW)    { share_mode=FILE_SHARE_READ|FILE_SHARE_WRITE; }
 opt=0;
 if(aaBitGet(cmode,0)) { opt|=FILE_FLAG_SEQUENTIAL_SCAN; }
 if(aaBitGet(cmode,1)) { opt|=FILE_FLAG_RANDOM_ACCESS;  }
 if(aaBitGet(cmode,2)) { opt|=FILE_FLAG_WRITE_THROUGH; }

// if(aaBitGet(cmode,3)) { opt|=FILE_FLAG_NO_BUFFERING; }
 if(which!=-1)
  {
  if(deleteon) { aa_ObjectDestroy(aa.filestream_system.object_id,*handle);   *handle=0;   return RET_FAILED;   }
  fsp->status.is_created=NO;
  aaStringCopy(fsp->status.filename,filename);
  if(which==0)   {   fsp->status.is_std_input=YES;   fsp->handle=GetStdHandle(STD_INPUT_HANDLE);   }
  else
  if(which==1)   {   fsp->status.is_std_output=YES;   fsp->handle=GetStdHandle(STD_OUTPUT_HANDLE);   }
  if(fsp->handle==INVALID_HANDLE_VALUE) {  aa_ObjectDestroy(aa.filestream_system.object_id,*handle);   *handle=0;   return RET_FAILED;   }
  fsp->status.id.volume=0;
  fsp->status.id.object[0]=0;
  fsp->status.id.object[1]=0;
  fsp->status.bytes=0;
  fsp->status.offset=0;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
  if(SetNamedPipeHandleState(fsp->handle,PIPE_READMODE_BYTE|PIPE_WAIT,0,0)==0) oof;
  fsp->is_stdio=YES;
  fsp->status._handle=fsp->handle;
  return RET_YES;
  }

 if(deleteon) { fsp->status.is_delete=YES; }
 else         { fsp->status.is_delete=NO; }

 if(fsp->status.is_delete) { opt|=FILE_FLAG_DELETE_ON_CLOSE; }

 if(create==aa_FILECREATE_CREATENEW)
  {
  if(filename==NULL)   { oof;    }
  else                   { aaStringCopy(fsp->status.filename,filename);   }
  if((fsp->handle=CreateFile(filename,access_mode,share_mode,NULL,CREATE_ALWAYS,opt,NULL))==INVALID_HANDLE_VALUE)
   {
   aa_ObjectDestroy(aa.filestream_system.object_id,*handle);
   *handle=0;
   return RET_FAILED;
   }
  fsp->status.is_created=YES;
  }
 else
  {
  ret=aaFileInfoGet(filename,NULL,&isfolder,0,0,&id);
  if(isfolder==YES) { oof; ret=RET_FAILED; }
  if(ret!=RET_YES)
   {
   if(ret==RET_NOTFOUND&&create==aa_FILECREATE_CREATE) {}
   else
    {
    //oof;
    aa_ObjectDestroy(aa.filestream_system.object_id,*handle);
    *handle=0;
    return ret;
    }
   }
  if((fsp->handle=CreateFile(filename,access_mode,share_mode,NULL,(create==aa_FILECREATE_CREATE)?OPEN_ALWAYS:OPEN_EXISTING,opt,NULL))==INVALID_HANDLE_VALUE)
   {
   er=GetLastError();
   //if(er!=ERROR_ACCESS_DENIED)    {    oow;    }
   aa_ObjectDestroy(aa.filestream_system.object_id,*handle);
   *handle=0;
   if(er==ERROR_ACCESS_DENIED) { return RET_DENIED; }
   //oof;
   return RET_FAILED;
   }
  fsp->status.is_created=NO;
  }
 fsp->status.id.volume=id.volume;
 fsp->status.id.object[0]=id.object[0];
 fsp->status.id.object[1]=id.object[1];

  if(GetFileInformationByHandle(fsp->handle,&info)==0) { oof; oow; }
  else
   {
   li.LowPart=info.nFileSizeLow;
   li.HighPart=info.nFileSizeHigh;
   //aaNote(0,",.,%u  %u %I64u ",li.LowPart,li.HighPart,li.QuadPart);
//   fsp->status.bytes=(Q)(info.nFileSizeHigh*F32)+info.nFileSizeLow;//((D)hi*_4Bd)+lo;
   fsp->status.bytes=li.QuadPart;
   }


 //lo=GetFileSize(fsp->handle,&hi);
 ///fsp->status.bytes=(Q)(hi*F32)+lo;//((D)hi*_4Bd)+lo;
 fsp->status.left=fsp->status.bytes-fsp->status.offset;

 aaStringCopy(fsp->status.filename,filename);
 if(create==aa_FILECREATE_CREATENEW)
  {
  aaFileStreamFlush(*handle);
  }
 fsp->gfs_required=YES;
 fsp->status._handle=fsp->handle;
 return RET_YES;
 }




 B aaFileStreamDestroy                 (H handle)
 {
 B ret;
 _aa_filestreamobject*fsp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { oof; Boop; return RET_FORBIDDEN; }
 //if(fsp->status.is_std_output!=YES) {  aaFileStreamFlush(handle); } // commented out may 2012
 CloseHandle(fsp->handle);
 aa_ObjectDestroy(aa.filestream_system.object_id,handle);
 return RET_YES;
 }






 B aaFileStreamStatus                  (H handle,_filestreamstatus*filestreamstatus)
 {
 B ret;
 _aa_filestreamobject*fsp;
 //H bytes,hi;
 LARGE_INTEGER li;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(fsp->status.is_std_input!=YES&&fsp->status.is_std_output!=YES)
  {
  aa_stats[7]++;
  if(GetFileSizeEx(fsp->handle,&li)==0)
   {
   if(GetLastError()!=NO_ERROR) { oof; oow; return RET_FAILED; }
   }
  fsp->status.bytes=li.QuadPart;
  fsp->gfs_required=NO;
  //if(hi!=0) oof;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
  }
 if(filestreamstatus) {   aaMemoryCopy(filestreamstatus,sizeof(_filestreamstatus),&fsp->status); }
 return RET_YES;
 }




 B aaFileStreamInfoGet                 (H handle,QP bytes,_systime*ctime,_systime*mtime,_fileid*id)
 {
 B ret;
 _aa_filestreamobject*fsp;
 //H v,hi;
 SYSTEMTIME st;
 FILETIME fct,fmt,tmt;//,lft;
 BY_HANDLE_FILE_INFORMATION info;
 LARGE_INTEGER li;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(id)  { id->volume=0; id->object[0]=id->object[1]=0; }
 if(bytes) { *bytes=0; }
 if(ctime) { aaTimeNull(ctime); }
 if(mtime) { aaTimeNull(mtime); }
 if(bytes)
  {
  if(GetFileSizeEx(fsp->handle,&li)==0)
   {
   if(GetLastError()!=NO_ERROR) { oof; }
   }


  if(bytes) { *bytes=li.QuadPart; } //(Q)(hi*F32)+v; } //(hi*_4Bd)+v;  }
//  if(v!=0xFFFFFFFF)  { *bytes=(hi*_4Bd)+v; }
//  else { oof; }
  }
 if(ctime||mtime)
  {
  if(GetFileTime(fsp->handle,(ctime)?&fct:NULL,NULL,(mtime)?&fmt:NULL)!=0)
   {
   if(ctime)
    {
    if(FileTimeToLocalFileTime(&fct,&tmt)==0) {        return RET_FAILED;    }
    if(FileTimeToSystemTime(&tmt,&st)==0) {        return RET_FAILED;    }
    WinSystemTimeToSysTime(&st,ctime);
    }
   if(mtime)
    {
    if(FileTimeToLocalFileTime(&fmt,&tmt)==0) {        return RET_FAILED;    }
    if(FileTimeToSystemTime(&tmt,&st)==0) {        return RET_FAILED;    }
    WinSystemTimeToSysTime(&st,mtime);
    }
   }
  }
 if(id)
  {
  if(GetFileInformationByHandle(fsp->handle,&info)==0)  {   return RET_FAILED;   }
  id->volume=info.dwVolumeSerialNumber;
  id->object[0]=info.nFileIndexLow;
  id->object[1]=info.nFileIndexHigh;
  }
 return RET_YES;
 }





 /* see readfile win32 api help: for pipes ...

lpNumberOfBytesRead
Points to the number of bytes read. ReadFile sets this value to zero before doing any work or error radioing. If this parameter is zero when ReadFile returns TRUE on a named pipe, the other end of the message-mode pipe called the WriteFile function with nNumberOfBytesToWrite set to zero.
If lpOverlapped is NULL, lpNumberOfBytesRead cannot be NULL.
If lpOverlapped is not NULL, lpNumberOfBytesRead can be NULL. If this is an overlapped read operation, you can get the number of bytes read by calling GetOverlappedResult. If hFile is associated with an I/O completion port, you can get the n
 */


 B aaFileStreamRead                    (H handle,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 H oked;
 // Z err;
 BOOL result;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(bytes==0)  {  return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 if((fsp->status.offset+bytes)>fsp->status.bytes) { return RET_BOUNDS; }
 //aa_FileStreamCacheRead((VP)&fsp,bytes,data);
 SetLastError(0);
 result=ReadFile(fsp->handle,data,bytes,&oked,NULL);
 if(result&&oked==0) { oow;aaNote(0,"bytes=%I64d",bytes);  return RET_FAILED; } // were at eof
 if(result&&oked==bytes)
  {
  //aaNote(0,"fromoff=%I64u , bytes ..=%u",fsp->status.offset,bytes);
  aa_stats[8]++;
  // i took this out mar 2015,, //aaFileStreamStatus(handle,0);
  fsp->crlf_state=0;
  fsp->status.offset+=(Q)oked;//(D)oked;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
  return RET_YES;
  }
 if(result)
  {
  //oof;
//  if(oked!=0) { aaNote(0,"res=%i bytes=%u oked=%u",result,bytes,oked);   return RET_BOUNDS; }
  oow;
  //aaNote(0,"res=%i bytes=%u oked=%u",result,bytes,oked);
  }
 aaNote(0,"fromoff=%I64u left=%I64u byt=%I64u bytes=u oked=%u result=%u",fsp->status.offset,fsp->status.left,fsp->status.bytes,bytes,oked,result);

 //    BUGGY;
 return RET_FAILED;
 }






 B aaFileStreamPeek                    (H handle,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q pos;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 aaFileStreamStatus(handle,0);
 pos=fsp->status.offset;
 //aaDebugf("pos ass %I64d",pos);
 if((ret=aaFileStreamRead(handle,bytes,data))!=YES) { oops; }
 if((ret=aaFileStreamOffsetSet(handle,pos))!=RET_YES) oops;
 aaFileStreamStatus(handle,0);
 //aaDebugf("then %I64d",fsp->status.offset);
 return ret;
 }





 B aaFileStreamWriteEof                (H handle)
 {
 B ret;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES)  {  return ret; }
 if(SetEndOfFile(fsp->handle)==0)  {  return RET_FAILED;  }
 fsp->cycle=0; // force getfilesize
 fsp->gfs_required=YES;
 aaFileStreamStatus(handle,0);
 return RET_YES;
 }





 B aaFileStreamWrite                   (H handle,H bytes,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 H oked;
 Q ilef;
 B resetcycle;
 Q remaining,todo;
 BP bp;


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES)  {  return ret; }
 if(bytes==0)  { return RET_YES; }
 if(data==NULL) {  return RET_BADPARM; }
 //aa_FileStreamCacheWrite((VP)&fsp,bytes,data);
 bp=(BP)data;
 remaining=(Q)bytes;
 while(1)
  {
  if(remaining==0) { break; }
  todo=aaNumRoof(remaining,_4K);//sizeof(block));
  ilef=fsp->status.left;
  if((Q)bytes>=ilef) { resetcycle=YES; }
  else               { resetcycle=NO; }
  SetLastError(0);
  fsp->gfs_required=YES;
  if(WriteFile(fsp->handle,bp,(H)todo,&oked,NULL)==0) { oow; }
  if(oked!=(H)todo) { oof; }
  if(resetcycle==YES) fsp->cycle=0; // force getfilesize
  // if((poff+(Q)oked)>psiz) { aaFileStreamStatus(handle,0); }

  //aaFileStreamStatus(handle,0);
  fsp->status.offset+=(Q)oked;
  if(fsp->status.offset>=fsp->status.bytes)
   {
   aaFileStreamStatus(handle,0);
   fsp->status.left=fsp->status.bytes-fsp->status.offset;
   }
  remaining-=todo;
  bp+=todo;
  }
 aaFileStreamStatus(handle,0);
 return RET_YES;
 }




 B aaFileStreamWritef                  (H handle,VP fmt,...)
 {
 B ret;
 _aa_filestreamobject*fsp;
 va_list argptr;
 B temp[_16K];
 BP tmp=NULL_POINTR;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,temp);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_64K,aa_MEMORYTEMP_FileWritef))!=RET_YES) { return ret; }
  }
// if((ret=aa_MemoryTemp((VP)&tmp,_64K,47))!=RET_YES) { return ret; }
 aaFmt(fmt,argptr,tmp);
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES)  {  return ret; }
 aaStringLen(tmp,&sl);
 ret=aaFileStreamWrite(handle,sl,tmp);
 return(ret);
 }




 B aaFileStreamWriteByte               (H handle,B beo,B val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) {}
 return(aaFileStreamWrite(handle,1,&val));
 }



 B aaFileStreamWriteWord               (H handle,B beo,W val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) { val=aaNumSwapWord(val);   }
// val=aaNumSwapWord(val);
 return(aaFileStreamWrite(handle,2,&val));
 }


 B aaFileStreamWriteDword              (H handle,B beo,H val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) { val=aaNumSwapDword(val);   }
 return(aaFileStreamWrite(handle,4,&val));
 }



 B aaFileStreamWriteQuad               (H handle,B beo,Q val)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(beo) { val=aaNumSwapQuad(val); }
 return(aaFileStreamWrite(handle,8,&val));
 }



 B aaFileStreamWriteFloat              (H handle,B beo,F val)
 {
 B tmp[4];
 B buf[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sizeof(F)!=4) { oof; }
 *(FP)&buf[0]=val;
 if(beo)
  {
  tmp[0]=buf[3];  tmp[1]=buf[2];
  tmp[2]=buf[1];  tmp[3]=buf[0];
  return(aaFileStreamWrite(handle,4,tmp));
  }
 return(aaFileStreamWrite(handle,4,buf));
 }




 B aaFileStreamWriteDouble             (H handle,B beo,D val)
 {
 B tmp[8];
 B buf[8];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sizeof(D)!=8) { oof; }
 *(DP)&buf[0]=val;
 if(beo)
  {
  tmp[0]=buf[7];  tmp[1]=buf[6];
  tmp[2]=buf[5];  tmp[3]=buf[4];
  tmp[4]=buf[3];  tmp[5]=buf[2];
  tmp[6]=buf[1];  tmp[7]=buf[0];
  return(aaFileStreamWrite(handle,8,tmp));
  }
 return(aaFileStreamWrite(handle,8,buf));
 }





 B aaFileStreamReadByte                (H handle,B beo,BP val)
 {
 B ret;
 B v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,1,&v))!=RET_YES) { return ret; }
 if(beo) {}
 *val=v;
 return RET_YES;
 }


 B aaFileStreamReadWord                (H handle,B beo,WP val)
 {
 B ret;
 W v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,2,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapWord(v); }
 *val=v;
 return RET_YES;
 }


 B aaFileStreamReadDword               (H handle,B beo,HP val)
 {
 B ret;
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,4,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapDword(v); }
 *val=v;
 return RET_YES;
 }


 B aaFileStreamReadQuad                (H handle,B beo,QP val)
 {
 B ret;
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,8,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapQuad(v); }
 *val=v;
 return RET_YES;
 }



 B aaFileStreamReadFloat               (H handle,B beo,FP val)
 {
 B ret;
 B buf[4];
 B tmp[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,4,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[3];  tmp[1]=buf[2];
  tmp[2]=buf[1];  tmp[3]=buf[0];
  *val=*(FP)&tmp[0];
  return RET_YES;
  }
 *val=*(FP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamReadDouble              (H handle,B beo,DP val)
 {
 B ret;
 B buf[8];
 B tmp[8];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamRead(handle,8,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[7];  tmp[1]=buf[6];
  tmp[2]=buf[5];  tmp[3]=buf[4];
  tmp[4]=buf[3];  tmp[5]=buf[2];
  tmp[6]=buf[1];  tmp[7]=buf[0];
  *val=*(DP)&tmp[0];
  return RET_YES;
  }
 *val=*(DP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamPeekByte                (H handle,B beo,BP val)
 {
 B ret;
 B v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,1,&v))!=RET_YES) { return ret; }
 if(beo) {}
 *val=v;
 return RET_YES;
 }


 B aaFileStreamPeekWord                (H handle,B beo,WP val)
 {
 B ret;
 W v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,2,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapWord(v); }
 *val=v;
 return RET_YES;
 }




 B aaFileStreamPeekDword               (H handle,B beo,HP val)
 {
 B ret;
 H v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,4,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapDword(v); }
 *val=v;
 return RET_YES;
 }



 B aaFileStreamPeekQuad                (H handle,B beo,QP val)
 {
 B ret;
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,8,&v))!=RET_YES) { return ret; }
 if(beo) { v=aaNumSwapQuad(v); }
 *val=v;
 return RET_YES;
 }



 B aaFileStreamPeekFloat               (H handle,B beo,FP val)
 {
 B ret;
 B buf[4];
 B tmp[4];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,4,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[3];  tmp[1]=buf[2];
  tmp[2]=buf[1];  tmp[3]=buf[0];
  *val=*(FP)&tmp[0];
  return RET_YES;
  }
 *val=*(FP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamPeekDouble              (H handle,B beo,DP val)
 {
 B ret;
 B buf[8];
 B tmp[8];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(val==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamPeek(handle,8,buf))!=RET_YES) { return ret; }
 if(beo)
  {
  tmp[0]=buf[7];  tmp[1]=buf[6];
  tmp[2]=buf[5];  tmp[3]=buf[4];
  tmp[4]=buf[3];  tmp[5]=buf[2];
  tmp[6]=buf[1];  tmp[7]=buf[0];
  *val=*(DP)&tmp[0];
  return RET_YES;
  }
 *val=*(DP)&buf[0];
 return RET_YES;
 }




 B aaFileStreamOffsetSet               (H handle,Q offset)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q of,dd;
 LARGE_INTEGER li;
 LARGE_INTEGER np;
 LARGE_INTEGER zi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
// BUG,"curoff=%.0lf , curlen=%.0lf seeking to offset %.0lf",fsp->status.offset,fsp->status.bytes,offset);

 //if(offset==fsp->status.offset)  {  return RET_YES;  }



 SetLastError(0);
 aaMemoryFill(&np,sizeof(np),0);


 if(offset!=F64)
  {
  dd=fsp->status.bytes;
  if(offset==dd) { offset=F64; }
  }

 if(offset!=F64)
  {
  dd=fsp->status.bytes;
  if(offset==F64) { of=dd; }
  else            { of=offset; }
  if(((G)of<0)||((Q)of>dd))
   {
   //BUG,"problem seeking, of=%I64d dd=%I64d",of,dd);
   aaNote(0,"waqa offset=%I64d of=%I64d dd=%I64d",offset,of,dd);
   return RET_BOUNDS;
   }
  if(of>dd) { oof; return RET_BOUNDS; }
  }

 if(offset==F64)
  {
  zi.QuadPart=0;
  if(SetFilePointerEx(fsp->handle,zi,&np,FILE_END)==0)  {  oof; return RET_FAILED;   }
  fsp->status.offset=np.QuadPart;//(Q)(hi*F32)+pos;//(hi*_4Bd)+pos;
  fsp->status.left=fsp->status.bytes-fsp->status.offset;
  return RET_YES;
  }
 li.QuadPart=offset;
 if(SetFilePointerEx(fsp->handle,li,&np,FILE_BEGIN)==0)
  {
  if(GetLastError()!=NO_ERROR)
   {
   oof;
   return RET_FAILED;
   }
  }
 fsp->status.offset=np.QuadPart;//(Q)(hi*F32)+pos;//(hi*_4Bd)+pos;
 fsp->status.left=fsp->status.bytes-fsp->status.offset;
 return RET_YES;
 }








 B aaFileStreamOffsetAdjust            (H handle,G offsetamount)
 {
 B ret;
 _aa_filestreamobject*fsp;
 //H pos;
 ///H lo,hi;
 LARGE_INTEGER li;
 LARGE_INTEGER np;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(offsetamount==0) { return RET_YES; }
 SetLastError(0);
 aaMemoryFill(&np,sizeof(np),0);
 //aaDoubleToLongs(offsetamount,&lo,&hi);
 //lo=(H)offsetamount;//&F32;
 //hi=(offsetamount>>32);///F32;
 li.QuadPart=offsetamount;
 if(SetFilePointerEx(fsp->handle,li,&np,FILE_CURRENT)==0)
  {
  if(GetLastError()!=NO_ERROR)
   {
   return RET_FAILED;
   }
  }
 fsp->status.offset=np.QuadPart;
 fsp->status.left=fsp->status.bytes-fsp->status.offset;
 return RET_YES;
 }




 B aaFileStreamSizeSet                 (H handle,Q bytes)
 {
 B ret;
 _aa_filestreamobject*fsp;
 LARGE_INTEGER li;
 Q off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 aaFileStreamStatus(handle,0);
 if(bytes<=fsp->status.bytes) { return RET_YES; }
 off=fsp->status.offset;
 li.QuadPart=bytes;
 if(SetFilePointerEx(fsp->status._handle,li,0,FILE_BEGIN)==0) { oof; }
 if(aaFileStreamWriteEof(handle)!=YES) { oof; }
 if((ret=aaFileStreamOffsetSet(handle,off))!=YES) { oops; }
 if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
 if((G)fsp->status.bytes!=li.QuadPart) { oof; }
 return RET_YES;
 }



 B aaFileStreamSizeAdjust              (H handle,G bytes)
 {
 B ret;
 _aa_filestreamobject*fsp;
 LARGE_INTEGER li;
 Q off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 aaFileStreamStatus(handle,0);
 if(bytes==0) { return RET_YES; }
 if(bytes<0)
  {
  bytes=aaNumAbs(bytes);
  off=fsp->status.offset;
  li.QuadPart=fsp->status.bytes-bytes;
  if(SetFilePointerEx(fsp->status._handle,li,0,FILE_BEGIN)==0) { oof; }
  if(aaFileStreamWriteEof(handle)!=YES) { oof; }
  if((ret=aaFileStreamOffsetSet(handle,off))!=YES) { oops; }
  if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
  if((G)fsp->status.bytes!=li.QuadPart) { oof; }
  return RET_YES;
  }

 off=fsp->status.offset;
 li.QuadPart=fsp->status.bytes+bytes;
 if(SetFilePointerEx(fsp->status._handle,li,0,FILE_BEGIN)==0) { oof; }
 if(aaFileStreamWriteEof(handle)!=YES) { oof; }
 if((ret=aaFileStreamOffsetSet(handle,off))!=YES) { oops; }
 if((ret=aaFileStreamStatus(handle,0))!=YES) { oops; }
 if((G)fsp->status.bytes!=li.QuadPart) { oof; }
 return RET_YES;
 }




 B aaFileStreamFlush                   (H handle)
 {
 B ret;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 FlushFileBuffers(fsp->handle);
 fsp->cycle=0;
 fsp->gfs_required=YES;
 return RET_YES;
 }



 B aaFileStreamOffsetPush              (H handle)
 {
 B ret;
 H mx,i;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 mx=aaElementCount(fsp->status.offset_stack);
 if(fsp->status.offset_stack_count>=mx) { return RET_BOUNDS; }
 i=mx-1-(fsp->status.offset_stack_count);
 //aaDebugf("push to slot %i, %I64u",i,fsp->status.offset);
 fsp->status.offset_stack[i]=fsp->status.offset;
 fsp->status.offset_stack_count++;
 return RET_YES;
 }




 B aaFileStreamOffsetPop               (H handle)
 {
 B ret;
 H mx,i;
 _aa_filestreamobject*fsp;
 Q off;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 mx=aaElementCount(fsp->status.offset_stack);
 if(fsp->status.offset_stack_count==0) { return RET_FAILED; }
 i=mx-1-(fsp->status.offset_stack_count-1);
 off=fsp->status.offset_stack[i];
// aaDebugf("pop to slot %i %I64u",i,off);
 if((ret=aaFileStreamOffsetSet(handle,off))!=RET_YES) { oops; }
 fsp->status.offset_stack[i]=0;
 fsp->status.offset_stack_count--;
 return RET_YES;
 }





 B aaFileStreamStringLen               (H handle,HP chars,BP stringmode)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q off,from,at,dif;
 B block[_8K];
 H atatime;
 H i,j,flag;
 Q cando;
 B first;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(chars==NULL)  {  return RET_BADPARM;  }
 *chars=0;
 if(stringmode) { *stringmode=0; }
 atatime=_2K;//512;//_1K;

 if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { return ret; }
 from=off=fsp->status.offset;
 first=YES;
 while(1)
  {
  if(first==NO) // we just call status, so no need first loop
   {
   if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { oops; return ret; }
   }
  first=NO;
  if(fsp->status.left==0) { break; }
  cando=aaNumRoof(fsp->status.left,atatime);
  if((ret=aaFileStreamRead(handle,(H)cando,block))!=RET_YES) { oops; }
  for(i=0;i<cando;i++)
   {
   j=cando-i;
   if(j<2) { break; }
   flag=0;
   while(1)
    {
    if(block[i+0]==CR_CHAR&&block[i+1]==LF_CHAR) { flag=1; break; }
    if(block[i+0]==LF_CHAR&&block[i+1]==CR_CHAR) { flag=2; break; }
    if(block[i+0]==CR_CHAR)                      { flag=3; break; }
    if(block[i+0]==LF_CHAR)                      { flag=4; break; }
    break;
    }
   if(flag)
    {
    at=off+i;
    dif=at-from;
    if(flag==1||flag==2) { dif+=2; }
    else                 { dif+=1; }
    *chars=(H)dif;
    if(flag==1) { *stringmode=aa_STRINGMODE_CRLF; } else
    if(flag==2) { *stringmode=aa_STRINGMODE_LFCR; } else
    if(flag==3) { *stringmode=aa_STRINGMODE_CR;   } else
    if(flag==4) { *stringmode=aa_STRINGMODE_LF;   }
    if((ret=aaFileStreamOffsetSet(handle,from))!=RET_YES) { oops; }
    if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { oops; }
    ///aaDebugf("found mode=%i at %I64u, chars=%u",*stringmode,from,*chars);
    return RET_YES;
    }
   }
  ///aaDebugf("new off half=%I64u",off+(atatime/2)+1);
  off+=(atatime/2)+1;
  if((ret=aaFileStreamOffsetSet(handle,off))!=RET_YES) { oops; }
  }
 if((ret=aaFileStreamOffsetSet(handle,from))!=RET_YES) { oops; }
 if((ret=aaFileStreamStatus(handle,0))!=RET_YES) { oops; }
 return RET_NOTREADY;
 }






 B aaFileStreamStringRead              (H handle,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H ch,len;
 B mo;
 BP bp;
 _aa_filestreamobject*fsp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(buf) { aaStringNull(buf); }
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(stringmode) { *stringmode=0; }
 if(chars==NULL) { return RET_BADPARM; }
 *chars=0;
 if(maxchars==0) { return RET_BADPARM; }
 if(buf==NULL) { return RET_BADPARM; }
 ret=aaFileStreamStringLen(handle,&len,&mo);
 if(stringmode) { *stringmode=mo; }
 if(ret!=RET_NOTREADY&&ret!=RET_YES) {  return ret; }
 if(ret==RET_YES)
  {
  ch=len;
  if(mo==aa_STRINGMODE_LF||mo==aa_STRINGMODE_CR) { ch=len-1; }  else
  if(mo==aa_STRINGMODE_CRLF)                     { ch=len-2; }  else
  if(mo==aa_STRINGMODE_LFCR)
   {
   ch=len;
   aaNote(0,"!mo=%i len=%i off=%I64u toend=%I64u bytes=%I64u file=%s",mo,len,fsp->status.offset,fsp->status.left,fsp->status.bytes,fsp->status.filename);
   }
  *chars=ch;
  if(ch>maxchars) { oof;  return RET_BOUNDS; }
  if((ret=aaFileStreamRead(handle,len,buf))!=RET_YES) { oops; }
  fsp->crlf_state=0;
  aaCast(bp,BP,buf);
  bp[ch]=NULL_CHAR;
  return RET_YES;
  }
  //oops;
 return RET_NOTREADY;
 }





 B aaFileStreamStringLook              (H handle,H fromoff,H index,HP count,HP offset,HP chars,BP stringmode,H maxchars,VP buf)
 {
 B ret;
 H off,cnt,frm;
 H todo,k,sl,to;
 H atatime,prevatatime,have,go;
 B tmp[_16K];
 B was_found;
 Q poff,soff;
  _aa_filestreamobject*fsp;
 BP bp;
 B mo;
 H ma;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 if(count) *count=0;
 if(offset) *offset=0;
 if(chars) *chars=0;
 if(stringmode) *stringmode=0;
 if(buf) { aaStringNull(buf); }
 aaFileStreamStatus(handle,0);
 //if((ret=aa_ObjectCheck(aa.net_system.tcpcall_object_id,handle,(VP)&calp,NULL))!=RET_YES) {return ret; }
 prevatatime=atatime=_4K;//_16K-100;
 //aaNetTcpCallStatus(handle,0);
 have=(H)fsp->status.left;//to_end;///calp->status.rcve_bytes;
 soff=fsp->status.offset;
 if(fromoff>=have) { return RET_NOTREADY; }
 have-=fromoff;
 off=cnt=frm=0;
 was_found=NO;
 mo=0;
 ma=0;
 go=0;
 while(1)
  {
  todo=have-off;//calp->status.rcve_bytes-off;
  //if(todo<1) break;
  if(todo<2) break;
  todo=aaNumRoof(todo,atatime);
  //aaFileStreamStatus(handle,&fs);
  //poff=fsp->status.offset;
  poff=soff;
  aaFileStreamOffsetSet(handle,poff+fromoff+off);
  aaFileStreamPeek(handle,todo,tmp);//                   (H handle,H bytes,VP data);
  aaFileStreamOffsetSet(handle,poff);
  mo=0;
  for(k=0;k<todo-1;k++)
   {
   mo=0;
   if(tmp[k+0]==LF_CHAR&&tmp[k+1]!=CR_CHAR) { mo=aa_STRINGMODE_LF; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]!=LF_CHAR) { mo=aa_STRINGMODE_CR; ma=1; }   else
   if(tmp[k+0]==CR_CHAR&&tmp[k+1]==LF_CHAR) { mo=aa_STRINGMODE_CRLF; ma=2; } else { continue; }
   to=off+k;
   sl=to-frm;
   if(was_found!=YES)
    {
    if(offset) *offset=frm;
    if(chars) *chars=sl;
    if(stringmode) *stringmode=mo;//aa_STRINGMODE_CRLF;
    }
   if(cnt==index)
    {
    was_found=YES;
    if(buf)
     {
     if(sl>=maxchars) { return RET_BOUNDS; }
     //aaFileStreamStatus(handle,&fs);
     //poff=fsp->status.offset;
     poff=soff;
     aaFileStreamOffsetSet(handle,poff+fromoff+frm);
     aaFileStreamPeek(handle,sl,buf);
     aaFileStreamOffsetSet(handle,poff);
     bp=(BP)buf;
     bp[sl]=NULL_CHAR;
     if(count==NULL) { return RET_YES; }
     }
    }
   frm=to+ma;
   cnt++;
   off+=(sl+ma);
   break;
   }
  go++;
  if(mo==0)
   {
   atatime=(go+1)*256;
   if(atatime>=_8K) { break; }
   if(go>32) {  break; }
   atatime=aaNumRoof(atatime,_8K);
   aaFileStreamStatus(handle,0);//&fs);
   have=(H)fsp->status.left;//to_end;//calp->status.rcve_bytes;
   have-=fromoff;
   atatime=aaNumRoof(atatime,have);
   if(atatime==prevatatime)  { break; }
   prevatatime=atatime;
   off=cnt=frm=0;
   mo=0;
   ma=0;
   continue;
   }
  }
 if(count) { *count=cnt; }
 if(was_found) { return RET_YES; }
 return RET_NOTREADY;
 }






 B aaFileStreamSearch                  (H handle,H entrybytes,QP offset,VP data)
 {
 B ret;
 _aa_filestreamobject*fsp;
 Q fb,eb,ic;
 Q mid,lo,hi,oo;
 N res;
 B blka[_4K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(offset) { *offset=0; }
 if(entrybytes==0) { return RET_BADPARM; }
 if(data==NULL)   { return RET_BADPARM; }
 if((ret=aa_ObjectCheck(aa.filestream_system.object_id,handle,(VP)&fsp,NULL))!=RET_YES) { return ret; }
 oo=fsp->status.offset;
 fb=fsp->status.bytes;
 eb=(Q)entrybytes;
 if(eb>=4000) { return RET_BOUNDS; }
 aaMemoryFill(blka,sizeof(blka),0);
 if((fb%eb)!=0) { return RET_CORRUPTED; }
// appGuilogg("[%s]",data);
 ic=fb/eb;
 lo=0;
 hi=ic-1;
 while((G)lo<=(G)hi)
  {
  mid=(lo+hi)/2;
  if(offset) { *offset=mid*eb;  }
  //appLog(-2,"lo=%I64u hi=%I64u mid=%I64u",lo,hi,mid);
  if((ret=aaFileStreamOffsetSet(handle,mid*eb))!=YES) { oops; return ret; }
  if((ret=aaFileStreamRead(handle,(H)eb,blka))!=YES) { oops; return ret; }
//  appGuilogg("[[%s]]",blka);
  aaMemoryCompare(data,(H)eb,blka,&res);
  if(res==0)
   {
   if(offset) { *offset=mid*eb;  }
   aaFileStreamOffsetSet(handle,mid*eb);
   return RET_YES;
   }
  else
  if(res>0)  {  lo=mid+1;   }
  else       {  hi=mid-1;   }
  }
 aaFileStreamOffsetSet(handle,oo);
 return RET_NOTFOUND;
 }




 B aaFileStreamSearchf                 (H handle,H entrybytes,QP offset,VP fmt,...)
 {
 va_list argptr;
 B txt[_4K];
 //B blkb[_4K];
 //H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(txt,sizeof(txt),0);
 aaFmt(fmt,argptr,txt);
 //aaStringLen(txt,&sl);
 //aaMemoryFill(blkb,sizeof(blkb),32);
 //aaMemoryCopy(blkb,sl,txt);
 return(aaFileStreamSearch(handle,entrybytes,offset,txt));
 }




/*-----------------------------------------------------------------------*/

 B aaTextReaderNew                     (_textreader*textreader,H bytes,VP mem)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 aaMemoryFill(textreader,sizeof(_textreader),0);
 if(mem==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(mem,&bytes); }
 if(bytes==0) { oof; }
 textreader->magic=(H)(PP)aaTextReaderNew;
 textreader->is_initialized=YES;

 if((ret=aaMemoryUnitAllocate(&textreader->mun,bytes))!=YES) { oops; }
 aaMemoryCopy(textreader->mun.mem,bytes,mem);
 if((ret=aaStringLineCountGetToMemory(textreader->mun.mem,(H)textreader->mun.bytes,&textreader->line_count,F32,(VP)&textreader->line_offset,(VP)&textreader->line_chars))!=YES) { oops; return ret; }
 return RET_YES;
 }





 B aaTextReaderOpen                    (_textreader*textreader,VP filename,H startline,H maxlines)
 {
 B ret;
 Q filebytes;
 Q fromoff;
 Q forbytes;
 Q todo;
 H pos,lc;
 B block[_4K];
 H add;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 aaMemoryFill(textreader,sizeof(_textreader),0);
 if(aaStringIsEmpty(filename,YES)!=NO) { return RET_BADPARM; }
 textreader->magic=(H)(PP)aaTextReaderNew;
 textreader->is_initialized=YES;
 aaStringCopyf(textreader->file_name,"%s",filename);
 lc=0;
 if(maxlines!=0)
  {
  if((ret=aaFileInfoGet(textreader->file_name,&filebytes,0,0,0,0))!=YES) { return ret; }
  fromoff=0;
  while(1)
   {
   todo=filebytes-fromoff;
   todo=aaNumRoof(todo,sizeof(block));
   if(todo==0) { break; }
   forbytes=todo;
   if((ret=aaFileLoadToBuffer(textreader->file_name,fromoff,forbytes,block,NULL))!=YES) { oops; break; }
   add=2;
   if((ret=aaStringFindFirstIString(block,(H)forbytes,"\r\n",2,&pos))!=YES)
    {
    if((ret=aaStringFindFirstIString(block,(H)forbytes,"\n",1,&pos))!=YES)
     {
     oops;
     break;
     }
    add=1;
    }
   if(pos==F32) { oof;  }
   fromoff+=(Q)pos+add;
   if(startline>lc) { lc++; continue; }
   lc++;
   textreader->line_count++;
   ///if(maxlines==F32) { maxlines=textreader->line_count-1; }
   if(textreader->line_count>=maxlines) { break; }
   }
  filebytes=fromoff;
  if((ret=aaMemoryUnitAllocate(&textreader->mun,(H)filebytes))!=YES) { oops; }
  if((ret=aaFileLoadToBuffer(textreader->file_name,0,(H)filebytes,textreader->mun.mem,0))!=YES) { oops; }
  if((ret=aaStringLineCountGetToMemory(textreader->mun.mem,(H)textreader->mun.bytes,&textreader->line_count,F32,(VP)&textreader->line_offset,(VP)&textreader->line_chars))!=YES) { oops; return ret; }
  return RET_YES;
  }
 if((ret=aaFileInfoGet(textreader->file_name,&filebytes,0,0,0,0))!=YES) { oops; }
 if((ret=aaMemoryUnitAllocate(&textreader->mun,(H)filebytes))!=YES) { oops; }
 if((ret=aaFileLoadToBuffer(textreader->file_name,0,(H)filebytes,textreader->mun.mem,0))!=YES) { oops; }
 if((ret=aaStringLineCountGetToMemory(textreader->mun.mem,(H)filebytes,&textreader->line_count,F32,(VP)&textreader->line_offset,(VP)&textreader->line_chars))!=YES) { oops; return ret; }
 return RET_YES;
 }



 B aaTextReaderDelete                  (_textreader*textreader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 if(textreader->magic!=(H)(PP)aaTextReaderNew) { return RET_NOTINITIALIZED; }
 if(textreader->is_initialized!=YES) {  return RET_NOTINITIALIZED; }
 ///if(textreader->fun.filebytes) { aaFileUnitRelease(&textreader->fun); }
 if(textreader->line_offset) { aaMemoryRelease(textreader->line_offset); }
 if(textreader->line_chars) { aaMemoryRelease(textreader->line_chars); }
 if(textreader->mun.bytes) { aaMemoryUnitRelease(&textreader->mun); }
 aaMemoryFill(textreader,sizeof(_textreader),0);
 return RET_YES;
 }




 B aaTextReaderLineGet                 (_textreader*textreader,H line,VP txt)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textreader==NULL) { return RET_BADPARM; }
 if(textreader->magic!=(H)(PP)aaTextReaderNew) { return RET_NOTINITIALIZED; }
 if(textreader->is_initialized!=YES) {  return RET_NOTINITIALIZED; }
 if(txt) { aaStringNull(txt); }
 if(line>=textreader->line_count) { return RET_BOUNDS; }
 if(txt==NULL) { return RET_YES; }
 if(textreader->line_chars[line]==0) { return RET_YES; }
 aaStringNCopy(txt,&textreader->mun.mem[textreader->line_offset[line]],textreader->line_chars[line],YES);
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/


 B aaTextLoaderNew                     (_textloader*textloader,Q offset,VP file,B(*proc)(_textloader*,Q,H,VP))
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textloader==NULL) { return RET_BADPARM; }
 aaMemoryFill(textloader,sizeof(_textloader),0);
 //if(proc==NULL) { return RET_BADPARM; }
 if((ret=aaFileStreamCreate(&textloader->fsu.handle,file,0,3,3,0,0))!=YES) { return ret; }
 textloader->magic=aaHPP(aaTextLoaderNew);
 textloader->stage=100;
 aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
 if(offset>=textloader->fsu.status.bytes) { return RET_BOUNDS; }
 if((ret=aaFileStreamOffsetSet(textloader->fsu.handle,offset))!=YES) { oops; }
 aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
 aaMemoryUnitAllocate(&textloader->bulk_mem,_8MEG);
 aaListNew(&textloader->list);
 textloader->proc=proc;
 return RET_YES;
 }



 B aaTextLoaderDelete                  (_textloader*textloader)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textloader==NULL) { return RET_BADPARM; }
 if(textloader->magic!=aaHPP(aaTextLoaderNew)) { return RET_NOTINITIALIZED; }
 if(textloader->fsu.handle) { aaFileStreamDestroy(textloader->fsu.handle); }
 if(textloader->bulk_mem.bytes) { aaMemoryUnitRelease(&textloader->bulk_mem); }
 if(textloader->list.magic) { aaListDelete(&textloader->list); }
 aaMemoryFill(textloader,sizeof(_textloader),0);
 return RET_YES;
 }



 B aaTextLoaderYield                   (_textloader*textloader,H ita)
 {
 B ret;
 H go,pos;
 Q todo;
 B txt[_4K];
 //B mat[4];
 H flag;
 B(*proc)(_textloader*,Q,H,VP);

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(textloader==NULL) { return RET_BADPARM; }
 if(textloader->magic!=aaHPP(aaTextLoaderNew)) { return RET_NOTINITIALIZED; }
 if(ita==0) { ita=1; }
 proc=textloader->proc;
 switch(textloader->stage)
  {
  case 100:
  while(1)
   {
   aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
   textloader->prev_file_off=textloader->fsu.status.offset;
   todo=aaNumRoof(textloader->fsu.status.left,textloader->bulk_mem.bytes);
   if(todo==0) { textloader->stage=500; break; }
   textloader->bulk_len=todo;
   textloader->bulk_off=0;
   if(aaFileStreamRead(textloader->fsu.handle,(H)todo,&textloader->bulk_mem.mem[textloader->bulk_off])!=YES) oof;
   aaFileStreamStatus(textloader->fsu.handle,&textloader->fsu.status);
   textloader->stage=200;
   break;
   }
  break;


  case 200:
  for(go=0;go<ita;go++)
   {
   todo=textloader->bulk_len-textloader->bulk_off;
   if(todo==0) { textloader->stage=100; break; }

//   mat[0]='\n';
 //  mat[1]=0;
   if(aaStringFindChar(&textloader->bulk_mem.mem[(H)textloader->bulk_off],(H)todo,&pos,'\n',YES,0,YES)!=YES)
   //if(aaStringFindFirstIString(&textloader->bulk_mem.mem[(H)textloader->bulk_off],(H)todo,mat,1,&pos)!=YES)
    {
    ///aaDebugf("ne");
    aaFileStreamOffsetSet(textloader->fsu.handle,textloader->prev_file_off+textloader->bulk_off);
    textloader->stage=100;
    break;
    }
   flag=0;
//   aaDebugf("todo=%I64u posa=%i %I64u %02x %02x",todo,pos,textloader->bulk_off,textloader->bulk_mem.mem[(H)textloader->bulk_off],textloader->bulk_mem.mem[(H)textloader->bulk_off+1]);
   if(pos>0)
    {
    if(textloader->bulk_mem.mem[((H)textloader->bulk_off+pos)-1]==CR_CHAR) { pos--; flag=1; }
    }
  //  aaDebugf("posb=%i",pos);


   aaStringNCopy(txt,&textloader->bulk_mem.mem[textloader->bulk_off],pos,YES);

   if(proc!=NULL)
    {
    ret=proc(textloader,textloader->line_number,pos,txt);
    if(ret==RET_CANCELLED) { textloader->stage=300; break;   }
    if(ret==RET_YES)
     {
     ret=aaListAppend(&textloader->list,NULL,NULL,pos,&textloader->bulk_mem.mem[textloader->bulk_off]);
     if(ret!=RET_YES) { oops; }
     }
    }
   else
    {
    ret=aaListAppend(&textloader->list,NULL,NULL,pos,&textloader->bulk_mem.mem[textloader->bulk_off]);
    if(ret!=RET_YES) { oops; }
    //aaDebugf(".. %i %i",textloader->list.slots,textloader->list.count);
    }


   textloader->bulk_off+=(pos+1);
   if(flag) { textloader->bulk_off++; }
   textloader->line_number++;
   }
  break;

  case 300:
  return RET_CANCELLED;


  case 500:
  return RET_YES;
  }
 return RET_NOTREADY;
 }




//http://www.drdobbs.com/architecture-and-design/text-editors-algorithms-and-architecture/184408975?pgno=2







 B aa_SysIsWinServer                   (V)
 {
 H flag;
 OSVERSIONINFOEX osvi;
 DWORDLONG mask;
 Z op;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&osvi,sizeof(OSVERSIONINFOEX),0);
 osvi.dwOSVersionInfoSize=sizeof(OSVERSIONINFOEX);
 osvi.dwMajorVersion=5;
 osvi.dwMinorVersion=0;
 osvi.wServicePackMajor=0;
 osvi.wServicePackMinor=0;
 osvi.wProductType=VER_NT_SERVER;
 mask=0;
 op=VER_GREATER_EQUAL;
 VER_SET_CONDITION(mask,VER_MAJORVERSION,op);
 VER_SET_CONDITION(mask,VER_MINORVERSION,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMAJOR,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMINOR,op);
 VER_SET_CONDITION(mask,VER_PRODUCT_TYPE,VER_EQUAL);
 flag=VER_MAJORVERSION|VER_MINORVERSION;
 flag|=VER_SERVICEPACKMAJOR|VER_SERVICEPACKMINOR;
 flag|=VER_PRODUCT_TYPE;
 if(VerifyVersionInfo(&osvi,flag,mask))  {  return RET_YES;  }
 return RET_NO;
 }




 B aa_SysIsWinXpSp2OrGreater           (V)
 {
 H flag;
 OSVERSIONINFOEX osvi;
 DWORDLONG mask;
 Z op;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaMemoryFill(&osvi,sizeof(OSVERSIONINFOEX),0);
 osvi.dwOSVersionInfoSize=sizeof(OSVERSIONINFOEX);
 osvi.dwMajorVersion=5;
 osvi.dwMinorVersion=1;
 osvi.wServicePackMajor=2;
 osvi.wServicePackMinor=0;
 mask=0;
 op=VER_GREATER_EQUAL;
 VER_SET_CONDITION(mask,VER_MAJORVERSION,op);
 VER_SET_CONDITION(mask,VER_MINORVERSION,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMAJOR,op);
 VER_SET_CONDITION(mask,VER_SERVICEPACKMINOR,op);
 flag=VER_MAJORVERSION|VER_MINORVERSION;
 flag|=VER_SERVICEPACKMAJOR|VER_SERVICEPACKMINOR;
 if(VerifyVersionInfo(&osvi,flag,mask)) { return RET_YES;  }
 return RET_NO;
 }


/*-----------------------------------------------------------------------*/


 B aaSysRgbaGet                        (_sysrgba*sysrgba)
 {
 H i,mx;
 _rgba*pn;
 B tmp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysrgba==NULL) { return RET_BADPARM; }
 *(HP)&sysrgba->col_scrollbar=GetSysColor(COLOR_SCROLLBAR);
 *(HP)&sysrgba->col_activecaption=GetSysColor(COLOR_ACTIVECAPTION);
 *(HP)&sysrgba->col_inactivecaption=GetSysColor(COLOR_INACTIVECAPTION);
 *(HP)&sysrgba->col_activecaption_right=GetSysColor(27);
 *(HP)&sysrgba->col_inactivecaption_right=GetSysColor(28);
 *(HP)&sysrgba->col_menu=GetSysColor(COLOR_MENU);
 *(HP)&sysrgba->col_window=GetSysColor(COLOR_WINDOW);
 *(HP)&sysrgba->col_windowframe=GetSysColor(COLOR_WINDOWFRAME);
 *(HP)&sysrgba->col_menutext=GetSysColor(COLOR_MENUTEXT);
 *(HP)&sysrgba->col_windowtext=GetSysColor(COLOR_WINDOWTEXT);
 *(HP)&sysrgba->col_captiontext=GetSysColor(COLOR_CAPTIONTEXT);
 *(HP)&sysrgba->col_activeborder=GetSysColor(COLOR_ACTIVEBORDER);
 *(HP)&sysrgba->col_inactiveborder=GetSysColor(COLOR_INACTIVEBORDER);
 *(HP)&sysrgba->col_appworkspace=GetSysColor(COLOR_APPWORKSPACE);
 *(HP)&sysrgba->col_highlight=GetSysColor(COLOR_HIGHLIGHT);
 *(HP)&sysrgba->col_highlighttext=GetSysColor(COLOR_HIGHLIGHTTEXT);
 *(HP)&sysrgba->col_graytext=GetSysColor(COLOR_GRAYTEXT);
 *(HP)&sysrgba->col_btntext=GetSysColor(COLOR_BTNTEXT);
 *(HP)&sysrgba->col_inactivecaptiontext=GetSysColor(COLOR_INACTIVECAPTIONTEXT);
 *(HP)&sysrgba->col_3ddkshadow=GetSysColor(COLOR_3DDKSHADOW);
 *(HP)&sysrgba->col_3dlight=GetSysColor(COLOR_3DLIGHT);
 *(HP)&sysrgba->col_infotext=GetSysColor(COLOR_INFOTEXT);
 *(HP)&sysrgba->col_infobk=GetSysColor(COLOR_INFOBK);
 *(HP)&sysrgba->col_desktop=GetSysColor(COLOR_DESKTOP);
 *(HP)&sysrgba->col_3dface=GetSysColor(COLOR_3DFACE);
 *(HP)&sysrgba->col_3dshadow=GetSysColor(COLOR_3DSHADOW);
 *(HP)&sysrgba->col_3dhighlight=GetSysColor(COLOR_3DHIGHLIGHT);
 *(HP)&sysrgba->col_3dhilight=GetSysColor(COLOR_3DHILIGHT);
 *(HP)&sysrgba->col_btnface=GetSysColor(COLOR_BTNFACE);
 *(HP)&sysrgba->col_btnhilight=GetSysColor(COLOR_BTNHILIGHT);
 mx=sizeof(_sysrgba)/sizeof(_rgba);
 aaCast(pn,_rgba*,sysrgba);
 for(i=0;i<mx;i++) {  pn[i].a=255;  tmp=pn[i].b;  pn[i].b=pn[i].r;  pn[i].r=tmp;  }
 return RET_YES;
 }




 B aaSysMetricsGet                     (_sysmetrics*sysmetrics)
 {
 NONCLIENTMETRICS ncm;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysmetrics==NULL) { return RET_BADPARM; }
 aaMemoryFill(sysmetrics,sizeof(_sysmetrics),0);
 aaMemoryFill(&ncm,sizeof(ncm),0);
 ncm.cbSize=sizeof(ncm);
 if(SystemParametersInfo(SPI_GETNONCLIENTMETRICS,sizeof(ncm),&ncm,0)==0)  {  oow;  }

 sysmetrics->caption_size.h=GetSystemMetrics(SM_CYCAPTION);
 sysmetrics->caption_button_size.w=GetSystemMetrics(SM_CXSIZE);
 sysmetrics->caption_button_size.h=GetSystemMetrics(SM_CYSIZE);
 sysmetrics->caption_button_size_small.w=GetSystemMetrics(SM_CXSMSIZE);
 sysmetrics->caption_button_size_small.h=GetSystemMetrics(SM_CYSMSIZE);

 aaStringCopyf(sysmetrics->caption_font,"%s",ncm.lfSmCaptionFont.lfFaceName);

 sysmetrics->caption_icon_size.w=GetSystemMetrics(SM_CXSMICON);// 49
 sysmetrics->caption_icon_size.h=GetSystemMetrics(SM_CYSMICON);// 50

 return RET_YES;
 }





 B aaSysPathGet                        (_syspath*syspath)
 {
 LPITEMIDLIST pidl;
 CP cp;
 C buf[_1K+1];
 B ch;
 H i,len,type;
 HKEY sub;
 LONG r;
 B sz_ls[64],sz_tif[64];
 HWND hwnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(syspath==NULL)  {  return RET_BADPARM;  }
 aaMemoryFill(syspath,sizeof(_syspath),0);

 // envlen=GetEnvironmentVariable("path",envbuf,sizeof(envbuf));
 // if(envlen>=sizeof(envbuf)) { envlen=0; }
 GetWindowsDirectory((CP)syspath->windows,MAX_PATH);
 GetSystemDirectory((CP)syspath->system,MAX_PATH);
 GetTempPath(MAX_PATH,(CP)syspath->temp);
 aaFileFolderWorkingGet(syspath->current_dir);

 if(syspath->windows[0]==NULL_CHAR)     { return RET_FAILED; }
 if(syspath->system[0]==NULL_CHAR)      { return RET_FAILED; }
 if(syspath->temp[0]==NULL_CHAR)        { return RET_FAILED; }
 if(syspath->current_dir[0]==NULL_CHAR)  { return RET_FAILED; }

 // create a temp window, as SHGet function steals focus of active window
 // we could use currently_active=GetActiveWindow and then replace as we do in VidCapProcs
 // but this is just another method,,, see if vidcap method works better or this....

 hwnd=0;
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_DESKTOPDIRECTORY,&pidl)==NOERROR) { SHGetPathFromIDList(pidl,(CP)syspath->desktop);   }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_STARTMENU,&pidl)==NOERROR)        { SHGetPathFromIDList(pidl,(CP)syspath->start_menu); }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_SENDTO,&pidl)==NOERROR)           { SHGetPathFromIDList(pidl,(CP)syspath->send_to);    }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_PROGRAMS,&pidl)==NOERROR)         { SHGetPathFromIDList(pidl,(CP)syspath->programs);  }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_PROGRAM_FILES,&pidl)==NOERROR)    { SHGetPathFromIDList(pidl,(CP)syspath->program_files);  }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_PROGRAM_FILESX86,&pidl)==NOERROR) { SHGetPathFromIDList(pidl,(CP)syspath->program_filesx86);  }
 if(SHGetSpecialFolderLocation(hwnd,CSIDL_COMMON_FAVORITES,&pidl)==NOERROR) { SHGetPathFromIDList(pidl,(CP)syspath->favorites);  }
 if(SHGetSpecialFolderLocation(hwnd,0x1a,&pidl)==NOERROR)                   { SHGetPathFromIDList(pidl,(CP)syspath->roaming);  }
 if(SHGetSpecialFolderLocation(hwnd,0x23,&pidl)==NOERROR)                   { SHGetPathFromIDList(pidl,(CP)syspath->program_data);  }
    //if(hwnd!=NULL)  {  DestroyWindow(hwnd);  }

 // check registry for more paths
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=_1K; type=REG_SZ;
  r=RegQueryValueEx(sub,"ProgramFilesDir",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->program_files,buf);  }
  }

 // append backslashes
 aaCast(cp,CP,syspath->windows); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->system);  aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->desktop); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->start_menu); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->send_to); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->programs); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->program_files); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->program_filesx86); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->favorites); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->temp); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }
 aaCast(cp,CP,syspath->current_dir); aaStringLastCharGet(cp,0,&ch); if(ch!=BSLASH_CHAR) { aaStringInsertChar(cp,0,F32,BSLASH_CHAR);  }

 aaStringCopy(syspath->module,aa.core_system.module_path);//filename);

 aaStringCopy(sz_tif,"Temporary Internet Files");
 aaStringCopy(sz_ls,"Local Settings");
 for(i=0;i<2; i++)
  {
  aaMemoryFill(buf,sizeof(buf),0);
  if(i==0) { aaStringCopy(buf,syspath->windows); }
  else     { GetEnvironmentVariable("USERPROFILE",buf,sizeof(buf)); }
  if(buf[0]==NULL_CHAR) { continue; }
  aaStringLastCharGet(buf,0,&ch);
  if(ch!=BSLASH_CHAR) { aaStringInsertChar(buf,0,F32,BSLASH_CHAR); }
  if(i==1) {aaStringAppend(buf,sz_ls); }
  aaStringLastCharGet(buf,0,&ch);
  if(ch!=BSLASH_CHAR) { aaStringInsertChar(buf,0,F32,BSLASH_CHAR); }
  aaStringAppend(buf,sz_tif);
  aaStringLastCharGet(buf,0,&ch);
  if(ch!=BSLASH_CHAR) { aaStringInsertChar(buf,0,F32,BSLASH_CHAR); }
  if(i==0) { aaStringCopy(syspath->temp_ie_a,buf); }
  else     { aaStringCopy(syspath->temp_ie_b,buf); }
  }

 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(syspath->start_up)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"Startup",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->start_up,buf);  }
  }

 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(syspath->local_app_data)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"Local AppData",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->local_app_data,buf);  }
  }


 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(syspath->documents)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"Personal",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(syspath->documents,buf);  }
  }

 return RET_YES;
 }






 B aaSysPathToString                   (_syspath*syspath,VP str)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(syspath==NULL) { return RET_BADPARM; }
  aaStringAppendf(str,"window=%s\n",syspath->windows);
  aaStringAppendf(str,"system=%s\n",syspath->system);
  aaStringAppendf(str,"desktop=%s\n",syspath->desktop);
  aaStringAppendf(str,"start_menu=%s\n",syspath->start_menu);
  aaStringAppendf(str,"start_up=%s\n",syspath->start_up);
  aaStringAppendf(str,"send_to=%s\n",syspath->send_to);
  aaStringAppendf(str,"programs=%s\n",syspath->programs);
  aaStringAppendf(str,"program_files=%s\n",syspath->program_files);
  aaStringAppendf(str,"program_filesx86=%s\n",syspath->program_filesx86);
  aaStringAppendf(str,"temp=%s\n",syspath->temp);
  aaStringAppendf(str,"roaming=%s\n",syspath->roaming);
  aaStringAppendf(str,"program_data=%s\n",syspath->program_data);
  aaStringAppendf(str,"app_data=%s\n",syspath->local_app_data);
  aaStringAppendf(str,"favorites=%s\n",syspath->favorites);
  aaStringAppendf(str,"documents=%s\n",syspath->documents);
  aaStringAppendf(str,"module=%s\n",syspath->module);
  aaStringAppendf(str,"current_dir=%s\n",syspath->current_dir);
  aaStringAppendf(str,"temp_ie_a=%s\n",syspath->temp_ie_a);
  aaStringAppendf(str,"temp_ie_b=%s",syspath->temp_ie_b);
 return RET_YES;
 }



 B aaSysVarsGet                        (_sysvars*sysvars)
 {
 LPVOID lpvEnv;
 B ascii,bscii;
 BP bp,sp;
 H soff,len;
 H state,i;
 H pos,mx;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysvars==NULL) { return RET_BADPARM; }
 aaMemoryFill(sysvars,sizeof(_sysvars),0);
 if((lpvEnv=GetEnvironmentStringsA())==NULL) { return RET_FAILED; }
 sp=(BP)(LPTSTR)lpvEnv;
 soff=0;
 state=0;
 len=0;
 mx=aaElementCount(sysvars->key_ptr);
 while(1)
  {
  if(state==0)
   {
   sysvars->key_off[sysvars->count]=soff;
   sysvars->val_off[sysvars->count]=soff;
   sysvars->key_len[sysvars->count]=0;
   sysvars->val_len[sysvars->count]=0;
   state=1;
   }
  ascii=sp[soff+0];
  bscii=sp[soff+1];
  if(ascii==NULL_CHAR&&bscii==NULL_CHAR) { break; }
  if(ascii!=NULL_CHAR) { soff++; len++; continue; }
  soff++;
  len++;
  sysvars->key_len[sysvars->count]=soff-sysvars->key_off[sysvars->count];
  sysvars->val_len[sysvars->count]=soff-sysvars->val_off[sysvars->count];
  sysvars->count++;
  if(sysvars->count==mx)   {   oof;   }
  state=0;
  }
 aaMemoryCopy(sysvars->buf,len,(BP)lpvEnv);
 for(i=0;i<sysvars->count;i++)
  {
  aaCast(bp,BP,&sysvars->buf[sysvars->key_off[i]]);
  if(aaStringFindChar(bp,sysvars->key_len[i],&pos,'=',YES,0,YES)!=YES) { oof; }
  sysvars->buf[sysvars->key_off[i]+pos]=NULL_CHAR;
  sysvars->val_off[i]+=pos+1;
  sysvars->val_len[i]=sysvars->key_len[i]-pos;
  sysvars->key_len[i]=pos;
  sysvars->key_ptr[i]=&sysvars->buf[sysvars->key_off[i]];
  sysvars->val_ptr[i]=&sysvars->buf[sysvars->val_off[i]];
  aaStringHashGet(sysvars->key_ptr[i],sysvars->key_len[i],&sysvars->key_hash[i],NO);
  }

 FreeEnvironmentStringsA((LPTSTR)lpvEnv);
 return RET_YES;
 }



 B aaSysvarsExplode                    (_sysvars*sysvars,H index,_stringexplode*stringexplode)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysvars==NULL) { return RET_BADPARM; }
 if(index>=sysvars->count) { return RET_BOUNDS; }
 if(stringexplode==NULL) { return RET_BADPARM; }
 return(aaStringExplode(sysvars->val_ptr[index],sysvars->val_len[index],stringexplode,';'));
 }




 B aaSysVarsSet                        (VP name,VP fmt,...)
 {
 BOOL bo;

 aaVargsf(fmt);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsEmpty(name,YES)!=NO) { return RET_BADPARM; }
 if(str64k.len==0)  {  bo=SetEnvironmentVariable(name,NULL);  }
 else               {  bo=SetEnvironmentVariable(name,(CP)str64k.buf);  }
 if(bo==0) { return RET_FAILED; }
 return RET_YES;
 }




 B aaSysVarsToString                   (_sysvars*sysvars,VP str)
 {
 H i;
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(sysvars==NULL) { return RET_BADPARM; }
 for(i=0;i<sysvars->count;i++)
  {
  aaStringCopyf(txt,"var[%-3i]",i);
  aaStringAppendf(str,"%s.key=%s\n",txt,sysvars->key_ptr[i]);
  aaStringAppendf(str,"%s.val=%s\n",txt,sysvars->val_ptr[i]);
  }
 return RET_YES;
 }



   //KEY_WOW64_64KEY	0x0100	Access a 64-bit key from either a 32-bit or 64-bit application.
   //KEY_WOW64_32KEY	0x0200	Access a 32-bit key from either a 32-bit or 64-bit application.

 B aaSysInfoGet                        (_sysinfo*sysinfo)
 {
 H bytes;//,mx;//,mx;//,sl;//,off;
 B txt[_1K];
 //B ascii;
 B buf[_8K];
 _mswinver ver;
// TIME_ZONE_INFORMATION tzi;
 DWORD rr;
// N b;
 SYSTEM_INFO si;
 ///_parser pa,pb;
 H len,type;//,sl,i;
 //BP bp;
 //BP tp;
 HKEY sub;
 LONG r;
 SID_IDENTIFIER_AUTHORITY NtAuthority={SECURITY_NT_AUTHORITY};
 PSID AdministratorsGroup;
 BOOL IsInAdminGroup;
 N parm;
 BOOL vr1,vr2;
 _fileparts fp;
 N res;
 Z CPUInfo[4]={-1};
 Z i,nExIds;
 S B proc_brand[129]={NULL_CHAR};


 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(sysinfo==NULL) { return RET_BADPARM; }
 if(aa.timer_system.is_timezone_ready!=YES)
  {
  aa_TimerSystemTimezoneGet();
  if(aa.timer_system.is_timezone_ready!=YES) { oof; return RET_FAILED; }
  }
 if(aa.timer_system.cpu_mhz==0.0)
  {
  aa_TimerSystemCpuSpeedGet();
  if(aa.timer_system.cpu_mhz==0.0) { oof; return RET_FAILED; }
  }

 aaMemoryFill(sysinfo,sizeof(_sysinfo),0);
 res=GetSystemMetrics(SM_CLEANBOOT);
 if(res==1||res==2) { sysinfo->is_safemode=YES; }
 sysinfo->version=aa.core_system.version;
 aaStringCopy(sysinfo->author,"Created Ashod Apakian");
 aaStringCopy(sysinfo->copyright,"(c) Copyright Apakian Pty.Ltd.");
 //if(aa.net_system.local_email_checked!=YES) {  aa_NetSystemLocalEmailCheck();  }
 //aaMemoryCopy(sysinfo->local_email,sizeof(sysinfo->local_email[0])*aa.net_system.local_email_count,aa.net_system.local_email);
 //sysinfo->local_email_count=aa.net_system.local_email_count;
 sysinfo->cpu_mhz=aa.timer_system.cpu_mhz;
 sysinfo->profiler_hz=aa.core_system.perf_frequency;
 bytes=200;
 sysinfo->via_shortcut=aa.core_system.via_shortcut;
 aaStringCopy(sysinfo->command_line,aa.core_system.command_line);
 sysinfo->show_state=aa.core_system.command_show;
 sysinfo->instance=aa.core_system.this_instance;
 sysinfo->process_id=aa.core_system.process_id;
 sysinfo->thread_id=aa.core_system.thread_id;
 sysinfo->process_handle=(H)aa.core_system.process_handle;
 sysinfo->thread_handle=(H)aa.core_system.thread_handle;
 aaStringCopyf(sysinfo->class_name,"%s",aa.core_system.class_name);

 sysinfo->std_input_handle=GetStdHandle(STD_INPUT_HANDLE);
 sysinfo->std_output_handle=GetStdHandle(STD_OUTPUT_HANDLE);
 sysinfo->std_error_handle=GetStdHandle(STD_ERROR_HANDLE);

 aaMemoryFill(&ver,sizeof(ver),0);
 ver.cb=sizeof(ver);
 if(GetVersionEx((OSVERSIONINFO*)&ver)!=0)
  {
  sysinfo->os_version[0]=ver.majmin[0];
  sysinfo->os_version[1]=ver.majmin[1];
  sysinfo->os_version[2]=ver.build;
  sysinfo->os_platform=ver.platform;
  sysinfo->os_service_pack[0]=ver.spack[0];
  sysinfo->os_service_pack[1]=ver.spack[1];
  sysinfo->os_flags=ver.smask<<16;
  sysinfo->os_flags+=ver.type;
  /*
 switch (ver.platform)
 {
 case VER_PLATFORM_WIN32_WINDOWS:   aaStringCopy(sysinfo->os_string,"WIN32"); break;
 case VER_PLATFORM_WIN32_NT:
                         if(ver.majmin[0] == 6) { aaStringCopy(sysinfo->os_string,"Vista"); break; }
                         if(ver.majmin[0] == 4) { aaStringCopy(sysinfo->os_string,"WinNT"); break; }
                         if(ver.majmin[0] == 5) { aaStringCopy(sysinfo->os_string,"WinXp"); break; }
                                       aaStringCopy(sysinfo->os_string,"Win??");
                                       break;
    default: aaStringCopy(sysinfo->os_string,"?????"); break;
 }
 */

 vr1=VerifyVersionInfo((OSVERSIONINFOEX*)&ver,VER_MAJORVERSION,VerSetConditionMask(0,VER_MAJORVERSION,VER_EQUAL));
 vr2=VerifyVersionInfo((OSVERSIONINFOEX*)&ver,VER_MINORVERSION,VerSetConditionMask(0,VER_MINORVERSION,VER_EQUAL));
 if(vr1==0||vr2==0)  {}
 //if(vr1==0||vr2==0) { aaNote(0,"vr=%i,%i %i %i %i",vr1,vr2,sysinfo->os_version[0],sysinfo->os_version[1],sysinfo->os_version[2]); }
 if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==2&&ver.type==VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"win8"); } else
 if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==2&&ver.type!=VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winServer2012"); } else
 if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==1&&ver.type==VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"win7"); } else
 if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==1&&ver.type!=VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winServer2008"); } else
 if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==0&&ver.type!=VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winServer2008"); } else
 if(sysinfo->os_version[0]==6&&sysinfo->os_version[1]==0&&ver.type==VER_NT_WORKSTATION) { aaStringCopyf(sysinfo->os_string,"winVista"); } else
 if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==2&&GetSystemMetrics(SM_SERVERR2)!=0) { aaStringCopyf(sysinfo->os_string,"winServer2003"); } else
 if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==2&&GetSystemMetrics(SM_SERVERR2)==0) { aaStringCopyf(sysinfo->os_string,"winServer2003"); } else
 if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==1) { aaStringCopyf(sysinfo->os_string,"winXP"); } else
 if(sysinfo->os_version[0]==5&&sysinfo->os_version[1]==0) { aaStringCopyf(sysinfo->os_string,"win2000"); }
  }
 GetSystemInfo(&si);
 if(aa.memory_system.status.os_hardware_page_size==0)
  {
  aa.memory_system.status.os_hardware_page_size=si.dwPageSize;
  }
 sysinfo->os_hardware_page_size=aa.memory_system.status.os_hardware_page_size;
 sysinfo->processor_count=si.dwNumberOfProcessors;

  if(proc_brand[0]==NULL_CHAR)
   {
   aaCpuIdGet(CPUInfo,0x80000000);
   nExIds=CPUInfo[0];
   if((H)nExIds>=0x80000000)
    {
    // Get the information associated with each extended ID.
    for(i=0x80000000;i<=nExIds;++i)
     {
     aaCpuIdGet(CPUInfo,i);
     if((H)i==0x80000002) aaMemoryCopy(&proc_brand[0],sizeof(CPUInfo),CPUInfo);
     else
     if((H)i==0x80000003) aaMemoryCopy(&proc_brand[16],sizeof(CPUInfo),CPUInfo);
     else
     if((H)i==0x80000004) aaMemoryCopy(&proc_brand[32],sizeof(CPUInfo),CPUInfo);
     }
    aaStringCleanup(proc_brand,0,1,0);
    }
   }
  aaStringCopy(sysinfo->processor_brand,proc_brand);


 GetCurrentDirectory(MAX_PATH,(CP)txt);
 sysinfo->allocation_granularity=si.dwAllocationGranularity;
// GetWindowsDirectory((CP)txt,300);
// aaStringCopyf(sysinfo->aa_trace_filename,"%s\\aa_trace.txt",txt);
// aaStringCopyf(sysinfo->aa_history_filename,"%s\\aa_history.txt",txt);
 aaStringCopy(sysinfo->process_filename,aa.core_system.module_filename);
 aaFilePartsGet(sysinfo->process_filename,&fp);
 aaStringCopyf(sysinfo->process_file,"%s",fp.filename);


 /* level 0: if basic info, excluding time zone info
    level 1: includes timezone
    level 2: includes username, pc name, language
 */
 sysinfo->timezone_bias=aa.timer_system.timezone_bias;
 sysinfo->is_dls=aa.timer_system.is_dls;
 sysinfo->is_std=aa.timer_system.is_std;
 aaStringCopy(sysinfo->timezone_string,aa.timer_system.timezone_string);
 sysinfo->timezone_bias_total=aa.timer_system.timezone_bias_total;
 ///if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Internet Explorer\\Registration", 0L, KEY_READ,&sub)==ERROR_SUCCESS)
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(sysinfo->product_key)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,"ProductId",NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS)
   {
   aaMemoryCopy(sysinfo->product_key,len,buf);
   aaStringHashGet(sysinfo->product_key,0,&sysinfo->product_key_hash,NO);
   }
  }
  if(RegOpenKeyEx(HKEY_CLASSES_ROOT,"http\\shell\\open\\command",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
   {
   len=sizeof(sysinfo->default_browser_cmd)-1;
   type=REG_SZ;
   r=RegQueryValueEx(sub,NULL,NULL,&type,(BP)buf,&len);
   RegCloseKey(sub);
   if(r==ERROR_SUCCESS) {  aaStringCopy(sysinfo->default_browser_cmd,buf);  }
   }
 if(RegOpenKeyEx(HKEY_CURRENT_USER,"Software\\Clients\\StartMenuInternet",0L,KEY_READ|0x100,&sub)==ERROR_SUCCESS)
  {
  len=sizeof(sysinfo->default_browser)-1;
  type=REG_SZ;
  r=RegQueryValueEx(sub,NULL,NULL,&type,(BP)buf,&len);
  RegCloseKey(sub);
  if(r==ERROR_SUCCESS) {  aaStringCopy(sysinfo->default_browser,buf);  }
  }

 if(aaStringIsNull(sysinfo->default_browser)==NO)
  {

  }

  aaFileInfoGet(sysinfo->process_filename,&sysinfo->process_filebytes,0,0,&sysinfo->process_filedate,0);
  bytes=sizeof(txt);
  if(AllocateAndInitializeSid(&NtAuthority,2,SECURITY_BUILTIN_DOMAIN_RID,DOMAIN_ALIAS_RID_ADMINS,0,0,0,0,0,0,&AdministratorsGroup))
   {
   IsInAdminGroup=FALSE;
   if(CheckTokenMembership(NULL,AdministratorsGroup,&IsInAdminGroup)) { }
   FreeSid(AdministratorsGroup);
   if(IsInAdminGroup) sysinfo->is_admin=YES;
   }

  if(GetUserName((CP)txt,&bytes)!=0)
   {
   if(bytes<sizeof(sysinfo->user_name)) { aaStringCopy(sysinfo->user_name,txt);  }
   }
  bytes=sizeof(txt);
  if(GetComputerName((CP)txt,&bytes)!=0)
   {
   if(bytes<sizeof(sysinfo->computer_name)) { aaStringCopy(sysinfo->computer_name,txt);  }
   }
  sysinfo->language_id=GetSystemDefaultLangID();
  rr=VerLanguageName(sysinfo->language_id,(LPTSTR)sysinfo->language_string,sizeof(sysinfo->language_string));
  sysinfo->language_string[rr]=NULL_CHAR;
  sysinfo->is_restart_on_crash=aa.core_system.is_restart_on_crash;
  if(sysinfo->is_restart_on_crash) { sysinfo->crash_msrunning_required=aa.core_system.crash_msrunning_required; }
  aaStringCopyf(sysinfo->fqdn_name,"%s@%s",sysinfo->user_name,sysinfo->computer_name);

 bytes=GetEnvironmentVariable("comspec",(CP)sysinfo->comspec,sizeof(sysinfo->comspec));
 if(bytes==0||bytes>=sizeof(sysinfo->comspec)) { aaStringNull(sysinfo->comspec); }

 //SPI_GETWHEELSCROLLLINES=104
 if(SystemParametersInfo(104,0,&parm,0)!=0) { sysinfo->wheel_lines=parm; }


 if(aa.core_system.is_console_ever_attached==YES)   {  sysinfo->is_console=YES; }  else
 if(aa.core_system.is_console_ever_attached==OTHER) {  sysinfo->is_console=NO;  }  else
 if(aa.core_system.is_console_ever_attached==NO)
  {
  if(aaConsoleAttach()==RET_YES)   {   sysinfo->is_console=YES;   aaConsoleDetach();   }
  }
 return RET_YES;
 }




 B aaSysInfoToString                   (_sysinfo*sysinfo,VP str)
 {
 B txt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(str==NULL) { return RET_BADPARM; }
 aaStringNull(str);
 if(sysinfo==NULL) { return RET_BADPARM; }
  aaStringAppendf(str,"version=%u\n",sysinfo->version);
  aaStringAppendf(str,"author=%s\n",sysinfo->author);
  aaStringAppendf(str,"copyright=%s\n",sysinfo->copyright);
  aaStringAppendf(str,"is_safemode=%u\n",sysinfo->is_safemode);
  aaStringAppendf(str,"cpu_mhz=%.2f\n",sysinfo->cpu_mhz);
  aaStringAppendf(str,"processor_count=%u\n",sysinfo->processor_count);
  aaStringAppendf(str,"processor_brand=%s\n",sysinfo->processor_brand);
  aaStringAppendf(str,"os_hardware_page_size=%u\n",sysinfo->os_hardware_page_size);
  aaStringAppendf(str,"profiler_hz=%.2f\n",sysinfo->profiler_hz);
  aaStringAppendf(str,"allocation_granularity=%u\n",sysinfo->allocation_granularity);
  aaStringAppendf(str,"show_state=%u\n",sysinfo->show_state);
  aaStringAppendf(str,"command_line=%s\n",sysinfo->command_line);
  aaStringAppendf(str,"via_shortcut=%i\n",sysinfo->via_shortcut);
  aaStringAppendf(str,"process_filename=%s\n",sysinfo->process_filename);
  aaStringAppendf(str,"process_file=%s\n",sysinfo->process_file);
  aaStringAppendf(str,"process_id=%u\n",sysinfo->process_id);
  aaStringAppendf(str,"thread_id=%u\n",sysinfo->thread_id);
  aaStringAppendf(str,"process_handle=0x%08x\n",sysinfo->process_handle);
  aaStringAppendf(str,"thread_handle=0x%08x\n",sysinfo->thread_handle);
  aaStringAppendf(str,"class_name=%s\n",sysinfo->class_name);
  aaStringAppendf(str,"instance=%u\n",sysinfo->instance);
  aaStringAppendf(str,"std_input_handle=0x%08x\n",sysinfo->std_input_handle);
  aaStringAppendf(str,"std_output_handle=0x%08x\n",sysinfo->std_output_handle);
  aaStringAppendf(str,"std_error_handle=0x%08x\n",sysinfo->std_error_handle);
  aaStringAppendf(str,"default_browser=%s\n",sysinfo->default_browser);
  aaStringAppendf(str,"default_browser_cmd=%s\n",sysinfo->default_browser_cmd);
  aaStringAppendf(str,"os_version=%u,%u,%u",sysinfo->os_version[0],sysinfo->os_version[1],sysinfo->os_version[2]);
  aaStringAppendf(str,"os_platform=%u\n",sysinfo->os_platform);
  aaStringAppendf(str,"os_service_path=%u,%u",sysinfo->os_service_pack[0],sysinfo->os_service_pack[1]);
  aaStringAppendf(str,"os_flags=%u\n",sysinfo->os_flags);
  aaStringAppendf(str,"os_string=%s\n",sysinfo->os_string);
  aaStringAppendf(str,"timezone_bias=%i\n",sysinfo->timezone_bias);
  aaStringAppendf(str,"timezone_string=%s\n",sysinfo->timezone_string);
  aaStringAppendf(str,"is_dls=%u\n",sysinfo->is_dls);
  aaStringAppendf(str,"is_std=%u\n",sysinfo->is_std);
  aaStringAppendf(str,"timezone_bias_total=%i\n",sysinfo->timezone_bias_total);
  aaStringAppendf(str,"is_admin=%u\n",sysinfo->is_admin);
  aaStringAppendf(str,"user_name=%s\n",sysinfo->user_name);
  aaStringAppendf(str,"computer_name=%s\n",sysinfo->computer_name);
  aaStringAppendf(str,"fqdn_name=%s\n",sysinfo->fqdn_name);
  aaStringAppendf(str,"process_filebytes=%I64u\n",sysinfo->process_filebytes);
  aaTimeToString(&sysinfo->process_filedate,txt,0,0);
  aaStringAppendf(str,"process_filedate=%s\n",txt);
  aaStringAppendf(str,"language_id=%u\n",sysinfo->language_id);
  aaStringAppendf(str,"language_string=%s\n",sysinfo->language_string);
  aaStringAppendf(str,"is_restart_on_crash=%u\n",sysinfo->is_restart_on_crash);
  aaStringAppendf(str,"crash_msrunning_required=%u\n",sysinfo->crash_msrunning_required);
  aaStringAppendf(str,"comspec=%s\n",sysinfo->comspec);
  aaStringAppendf(str,"product_key=%s\n",sysinfo->product_key);
  aaStringAppendf(str,"product_key_hash=0x%08x\n",sysinfo->product_key_hash);
  aaStringAppendf(str,"wheel_lines=%i\n",sysinfo->wheel_lines);
  aaStringAppendf(str,"is_console=%u",sysinfo->is_console);
 return RET_YES;
 }



 B aaSysPowerGet                       (_syspower*syspower)
 {
 SYSTEM_POWER_STATUS sps;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(syspower==NULL) { return RET_BADPARM; }
 aaMemoryFill(syspower,sizeof(_syspower),0);
 aaMemoryFill(&sps,sizeof(sps),0);
 if(GetSystemPowerStatus(&sps)==0) {  return RET_FAILED; }
 if(sps.ACLineStatus==1) syspower->is_plugged_in=YES;
 //if(sps.BatteryFlag<128) syspower->is_battery=YES;
 if(aaBitGet(sps.BatteryFlag,3)) syspower->is_charging=YES;
 if(aaBitGet(sps.BatteryFlag,7)) syspower->is_battery=NO;
 else                            syspower->is_battery=YES;
 syspower->level=(F)sps.BatteryLifePercent;
 if(syspower->is_battery==NO) { syspower->level=100.0; }
 else                         { syspower->level=(F)sps.BatteryLifePercent; }
 return RET_YES;
 }




 B aaSysBenchmark                      (B testnum,DP time)
 {
 B ret;
 Q c1,c2,c3;
 D tt;
 B bufa[_8K];
 B bufb[_8K];
 H val;
 Q c;
 D da,db;
 Q qa,qb;
 _memoryunit mum[1000];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(time==NULL) { return RET_BADPARM; }
 *time=0;
 val=0;
 da=db=0;
 qa=qb=0;
 aaMemoryFill(bufa,sizeof(bufa),0);
 aaMemoryFill(bufb,sizeof(bufb),0);
 aaMemoryFill(mum,sizeof(mum),0);
 switch(testnum)
  {
  case 0:
  aaTimerProfilerGet(&c1);
  for(c=0;c<10000;c++)   {   aaMemoryFill(bufa,sizeof(bufa),0);   }
  break;

  case 1:
  aaTimerProfilerGet(&c1);
  for(c=0;c<100;c++)   { aaStringRandomSet(bufa,128,1,1,1,1); }
  break;

  case 2:
  aaTimerProfilerGet(&c1);
  da=1.000;
  for(c=0;c<25000;c++)  {   qa=(Q)da;   if((qa%10)==0) { da+=0.5; }   else   { da+=0.1; }   }
  break;

  case 3:
  aaTimerProfilerGet(&c1);
  aaStringRandomSet(bufa,128,1,1,1,1);
  for(c=0;c<5000;c++)   {   aaStringReverse(bufa,128,bufb,YES);   }
  break;

  case 4:
  aaTimerProfilerGet(&c1);
  val=8;
  for(c=0;c<500;c++)
   {
   val=aaNumRoof(val,_8K);
   if((ret=aaMemoryUnitAllocate(&mum[c],val))!=YES) { oops; break; }
   val+=val;
   }
  for(c=0;c<500;c++)   {   if(aaMemoryUnitRelease(&mum[c])!=YES) { oof; break; }   }
  break;

  case 5:
  aaTimerProfilerGet(&c1);
  if((ret=aaFileUniqueCreate(bufa,0,10,1,1,"delme",1))!=YES) { oops; break; }
  aaStringRandomSet(bufb,_4K,1,1,1,1);
  for(c=0;c<4;c++) {   if((ret=aaFileAppendFromMemory(bufa,_4K,bufb))!=YES) { oops; break; }   }
  aaFileDelete(bufa);
  break;


  default:
  aaTimerProfilerGet(&c1);
  break;
  }

 aaTimerProfilerGet(&c2);
 c3=c2-c1;
 tt=(c3*1000000)/aa.core_system.perf_frequency;
 if(da) { *time=0; }
 *time=tt;
 return RET_YES;
 }




 B aaSysRemoteSessionGet               (BP type)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(type) *type=0;
 return RET_YES;
 }





 B aaSysFileIconGet                    (VP filename)
 {
 B ret;
 B isfold;
 Q bytes;
 SHFILEINFO  sfi;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(filename,&bytes,&isfold,0,0,0))==RET_NOTFOUND) { return ret; }
 if(ret!=YES) { oops; return ret; }
 if(isfold) { return RET_FAILED; }
 if(SHGetFileInfo(filename,0,&sfi,sizeof(sfi),SHGFI_SYSICONINDEX|SHGFI_SMALLICON)==0) { return RET_FAILED; }
 return RET_YES;
 }



 B aaSysTrayGet                        (HWND*wnd,_rect*rect)
 {
 RECT rc;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(wnd) { *wnd=0; }
 if(rect) { rect->x=rect->y=rect->w=rect->h=0; }
 if(wnd==NULL&&rect==NULL) { return RET_BADPARM; }
 if(aa.input_system.tray_hwnd==NULL)
  {
  if((aa.input_system.tray_hwnd=FindWindow("Shell_TrayWnd",NULL))==NULL) { oof; }
  if(aa.input_system.tray_hwnd==NULL) { return RET_BADPARM; }
  }
 if(rect)
  {
  GetWindowRect(aa.input_system.tray_hwnd,&rc);
  rect->x=rc.left;
  rect->y=rc.top;
  rect->w=rc.right-rc.left;
  rect->h=rc.bottom-rc.top;
  }
 if(wnd)
  {
  *wnd=aa.input_system.tray_hwnd;
  }
 return RET_YES;
 }




 B aaSysRestartOnCrashSet              (B state,H msrunreq)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(state==YES)
  {
  if(aa.core_system.is_restart_on_crash==YES) { return RET_YES; }
  aa.core_system.is_restart_on_crash=YES;
  aa.core_system.crash_msrunning_required=msrunreq;
  }
 else
  {
  if(aa.core_system.is_restart_on_crash==NO) { return RET_YES; }
  aa.core_system.is_restart_on_crash=NO;
  aa.core_system.crash_msrunning_required=0;
  }
 return RET_YES;
 }








 B aaSysCpuLoadRefresh                 (V)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 ret=aa_CoreSystemCpuLoadGet();
 aa_CoreSystemTime();
 aa.core_system.prev_msrunning[aa_COREPREVMS_CpuLoadGet]=aa_msrunning;
 return ret;
 }





 B aaSysShortCutCreate                 (VP filename,VP shortcutname,VP workingpath,VP iconfile,H iconindex)
 {
 B ret;
 H sl;
 HRESULT rc;
 Q filebytes;
 B isfold;
// T __stdcall HRESULT (*def_cocreateinstance) (REFCLSID,LPUNKNOWN,DWORD,REFIID,LPVOID);
 T HRESULT (*def_cocreateinstance) (REFCLSID,LPUNKNOWN,DWORD,REFIID,LPVOID);
 T HRESULT (*def_coinitialize) (LPVOID reserved);
 T V (*def_couninitialize) (V);
 IShellLink *shell;
 IPersistFile *file;
 WORD name[MAX_PATH];
 def_cocreateinstance my_cocreateinstance;
 def_coinitialize my_coinitialize;
 def_couninitialize my_couninitialize;
 HMODULE lib;
 GUID HI_IID_IPersistFile={0x10B,0,0,{0xC0,0,0,0,0,0,0,0x46}};
 GUID HI_IID_IShellLink={0x000214EE,0,0,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(filename,&sl))!=RET_YES) {  return ret; }
 if(sl==0||sl>255) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(filename,&filebytes,&isfold,NULL,NULL,NULL))!=RET_YES) {  return ret; }
 if(isfold==YES&&filebytes!=0) {  return RET_FAILED; }
 if((ret=aaStringLen(shortcutname,&sl))!=RET_YES) {  return ret; }
 if(sl==0||sl>255) { return RET_BADPARM; }
 if(workingpath)
  {
  aaStringLen(workingpath,&sl);
  if(sl==0||sl>255) { return RET_BADPARM; }
  if((ret=aaFileInfoGet(workingpath,&filebytes,&isfold,NULL,NULL,NULL))!=RET_YES) {  return ret; }
  if(isfold==NO||filebytes!=0) {  oof; return RET_FAILED; }
  }
 if(iconfile)
  {
  aaStringLen(iconfile,&sl);
  if(sl==0||sl>255) { return RET_BADPARM; }
  if((ret=aaFileInfoGet(iconfile,&filebytes,&isfold,NULL,NULL,NULL))!=RET_YES) {  return ret; }
  if(isfold==YES) {  return RET_FAILED; }
  if(filebytes==0) { oof; return RET_FAILED; }
  }

 if((lib=LoadLibrary("ole32.dll"))==NULL) { return RET_FAILED; }
    my_coinitialize=(def_coinitialize)     GetProcAddress(lib,"CoInitialize");
  my_couninitialize=(def_couninitialize)   GetProcAddress(lib,"CoUninitialize");
 my_cocreateinstance=(def_cocreateinstance) GetProcAddress(lib,"CoCreateInstance");
 if(my_coinitialize==NULL||my_couninitialize==NULL||my_cocreateinstance==NULL) { FreeLibrary(lib); return RET_FAILED; }
 my_coinitialize(NULL);
 rc=my_cocreateinstance(&CLSID_ShellLink,NULL,CLSCTX_INPROC_SERVER,&HI_IID_IShellLink,(VP)&shell);
 if(!SUCCEEDED(rc))
  {
  my_couninitialize();
  FreeLibrary(lib);
  oof;
  return RET_FAILED;
  }
 shell->lpVtbl->SetPath(shell,filename);
 // shell->lplVtbl->SetArguments
 // shell->lplVtbl->SetHot
/// if(description) { shell->lpVtbl->SetDescription(shell, description); }
 if(workingpath) { shell->lpVtbl->SetWorkingDirectory(shell,workingpath); }
 if(iconfile) { shell->lpVtbl->SetIconLocation(shell,iconfile,iconindex); }
 shell->lpVtbl->SetShowCmd(shell,SW_SHOWMAXIMIZED);
 rc=shell->lpVtbl->QueryInterface(shell,&HI_IID_IPersistFile,(VP)&file);
 if(SUCCEEDED(rc))
  {
  MultiByteToWideChar(CP_ACP,0,(CP)shortcutname,-1,name,MAX_PATH);
  rc=file->lpVtbl->Save(file,name,TRUE);
  if(SUCCEEDED(rc)) { ret=RET_YES; }
  else              { ret=RET_FAILED; }
 file->lpVtbl->Release(file);
  }
 else
  {
  ret=RET_FAILED;
  }
 shell->lpVtbl->Release(shell);
 my_couninitialize();
 FreeLibrary(lib);
 return ret;
 }




 B aaSysUnInstallSet                   (CP applicationname,CP displayname,CP uninstallexepath)
 {
 H sl;
 C dn[129];
 B ret;

 HKEY hOpen;
 HKEY sub;
 DWORD disp;
 DWORD rc;
// H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(uninstallexepath==NULL) { return RET_BADPARM; }
 if(applicationname==NULL) { return RET_BADPARM; }
 aaStringLen(uninstallexepath,&sl);
 if(sl==0||sl>1023) return RET_BADPARM;
 aaStringLen(applicationname,&sl);
 if(sl==0||sl>63) return RET_BADPARM;
 if(displayname)
  {
  aaStringLen(displayname,&sl);
  if(sl==0||sl>63) return RET_BADPARM;
  aaStringCopy(dn,displayname);
  }
 else
  {
  aaStringCopy(dn,applicationname);
  }

 ret=RET_YES;
 if((rc=RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall",0,KEY_ALL_ACCESS|0x100,&hOpen))==ERROR_SUCCESS)
  {
  rc=RegCreateKeyEx(hOpen,applicationname,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp);
  if(rc!=ERROR_SUCCESS)
   {
   RegCloseKey(hOpen);
   return RET_FAILED;
   }
  aaStringLen(dn,&sl);
  rc=RegSetValueEx(sub,"DisplayName",0,REG_SZ,(BP)dn,sl+1);
  if(rc!=ERROR_SUCCESS)
   {
   RegCloseKey(sub);
   RegDeleteKey(hOpen,applicationname);
   RegCloseKey(hOpen);
   return RET_FAILED;
   }
  aaStringLen(uninstallexepath,&sl);
  rc=RegSetValueEx(sub,"UninstallString",0,REG_SZ,(BP)uninstallexepath,sl+1);
  if(rc!=ERROR_SUCCESS)
   {
   RegCloseKey(sub);
   RegDeleteKey(hOpen,applicationname);
   RegCloseKey(hOpen);
   return RET_FAILED;
   }
  RegCloseKey(sub);
  RegCloseKey(hOpen);
  }
 else ret=RET_FAILED;
 return ret;
 }




 B aaSysUnInstallRemove                (CP applicationname)
 {
 B ret;
 H sl;
 HKEY hOpen;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(applicationname==NULL) { return RET_BADPARM; }
 aaStringLen(applicationname,&sl);
 if(sl==0||sl>63) return RET_BADPARM;

 ret=RET_YES;
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall",0,KEY_ALL_ACCESS|0x100,&hOpen)==ERROR_SUCCESS)
  {
  if(RegDeleteKey(hOpen,applicationname)!=ERROR_SUCCESS) {  RegCloseKey(hOpen);   return RET_FAILED;   }
  RegFlushKey(hOpen);
  if(RegCloseKey(hOpen)!=ERROR_SUCCESS) return RET_FAILED;
  }
 else {  ret=RET_FAILED; }
 return ret;
 }





 B aaSysStartupAppSet                  (VP applicationname,VP applicationexepath)
 {
 B ret;
 HKEY sub;
 H sl,len;
 C buf[_1K+1];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(applicationname,&sl))!=YES) { return ret; }
 if(sl==0||sl>63) { return RET_BADPARM; }
 if((ret=aaStringLen(applicationexepath,&sl))!=YES) { return ret; }
 if(sl==0||sl>1023) { return RET_BADPARM; }
 len=sl+1;
 aaStringCopy(buf,applicationexepath);
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0L,KEY_ALL_ACCESS|0x100,&sub)!=ERROR_SUCCESS)
  {
  oof;
  oow; oof;
  return RET_FAILED;
  }
 if(RegSetValueEx(sub,applicationname,0,REG_SZ,(BP)buf,len)!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  return RET_FAILED;
  }
 RegCloseKey(sub);
 return RET_YES;
 }




 B aaSysStartupAppGet                  (VP applicationname,VP applicationexepath)
 {
 B ret;
 C buf[_1K+1];
 DWORD len,type;
 HKEY sub;
 LONG r;
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(applicationexepath==NULL) { return RET_BADPARM; }
 aaStringNull(applicationexepath);
 if((ret=aaStringLen(applicationname,&sl))!=YES) { return ret; }
 if(sl==0||sl>63) { return RET_BADPARM; }
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0L,KEY_READ|0x100,&sub)!=ERROR_SUCCESS) { return RET_FAILED; }
 len=_1K;
 type=REG_SZ;
 r=RegQueryValueEx(sub,applicationname,NULL,&type,(BP)buf,&len);
 RegCloseKey(sub);
 if(r==ERROR_MORE_DATA) { return RET_FAILED;  }
 if(r!=ERROR_SUCCESS)   { return RET_NOTFOUND;  }
 aaStringCopy(applicationexepath,buf);
 return RET_YES;
 }





 B aaSysStartupAppRemove               (VP applicationname)
 {
 B ret;
 C buf[_1K+1];
 LONG r;
 HKEY sub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(applicationname==NULL) { return RET_BADPARM; }
 if((ret=aaSysStartupAppGet(applicationname,buf))!=RET_YES) { return ret; }
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"Software\\Microsoft\\Windows\\CurrentVersion\\Run",0L,KEY_ALL_ACCESS|0x100,&sub)!=ERROR_SUCCESS) { return RET_FAILED; }
 r=RegDeleteValue(sub,applicationname);
 RegCloseKey(sub);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 return RET_YES;
 }



   /*


 aaSysContextMenuSet("rrer","Yo you",0,"c:\\windows\\notepad.exe %1");
 //B aaSysContextMenuRemove              (CP extension,CP menuname);

 */
 B aaSysFileAssociationSet             (CP extension,CP mimetype,CP appcmdline,CP deficon,CP description)
 {
 B ext;
 B mim;
 H sl;
 DWORD disp;
 LONG r;
 HKEY sub,mre;
 H v;
 C txt[_1K];
 C pt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(appcmdline==NULL) return RET_BADPARM;
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') { ext=1; }
 else                    { ext=0; }
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;
 if(mimetype) { mim=1; }
 else           { mim=0; }
 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);
 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);
 r=RegCreateKeyEx(HKEY_CLASSES_ROOT,txt,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 aaStringCopy(txt,pt);
 aaStringLen(txt,&sl);
 sl++;
 if((r=RegSetValueEx(sub,NULL,0,REG_SZ,(CONST BYTE*)txt,sl))!=ERROR_SUCCESS) {  RegCloseKey(sub);  return RET_FAILED;  }
 if(mim)
  {
  aaStringCopy(txt,mimetype);
  aaStringLen(txt,&sl);
  sl++;
  r=RegSetValueEx(sub,"Content Type",0,REG_SZ,(CONST BYTE*)txt,sl);
  if(r!=ERROR_SUCCESS)  {   RegCloseKey(sub);   return RET_FAILED;   }
  }
// if(RegFlushKey(sub)!=ERROR_SUCCESS) oof;
 if((r=RegCloseKey(sub))!=ERROR_SUCCESS) {  RegCloseKey(sub);  return RET_FAILED;  }
 if((r=RegCreateKeyEx(HKEY_CLASSES_ROOT,pt,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp))!=ERROR_SUCCESS) { return RET_FAILED; }
 if(description)
  {
  aaStringCopy(txt,description);
  aaStringLen(txt,&sl);
  sl++;
  r=RegSetValueEx(sub,NULL,0,REG_SZ,(CONST BYTE*)txt,sl);
  if(r!=ERROR_SUCCESS)   {   RegCloseKey(sub);   return RET_FAILED;   }
  }
 v=1;//0x1000;//0x00010001;//0x00010004;//2;//(2<<15);
 r=RegSetValueEx(sub,"EditFlags",0,REG_DWORD,(CONST BYTE*)&v,4);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 if(deficon)
  {
  r=RegCreateKeyEx(sub,"DefaultIcon",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
  if(r!=ERROR_SUCCESS)   {   RegCloseKey(sub);   return RET_FAILED;   }
  aaStringCopy(txt,deficon);
  aaStringLen(txt,&sl);
  sl++;
  if((r=RegSetValueEx(mre,NULL,0,REG_SZ,(CONST BYTE*)txt,sl))!=ERROR_SUCCESS)
   {
   RegCloseKey(mre);
   RegCloseKey(sub);
   return RET_FAILED;
   }
  r=RegCloseKey(mre);
  if(r!=ERROR_SUCCESS)
   {
   RegCloseKey(sub);
   return RET_FAILED;
   }
  }
 r=RegCreateKeyEx(sub,"shell",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCloseKey(mre);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCreateKeyEx(sub,"shell\\open",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 if((r=RegCloseKey(mre))!=ERROR_SUCCESS) {  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCreateKeyEx(sub,"shell\\open\\command",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&mre,&disp);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 aaStringCopyf(txt,appcmdline);
 aaStringLen(txt,&sl);
 sl++;
 r=RegSetValueEx(mre,NULL,0,REG_SZ,(CONST BYTE*)txt,sl);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(mre);  RegCloseKey(sub);  return RET_FAILED;  }
 r=RegCloseKey(mre);
 if(r!=ERROR_SUCCESS)  {  RegCloseKey(sub);  return RET_FAILED;  }
 if(RegFlushKey(sub)!=ERROR_SUCCESS) oof;
 if((r=RegCloseKey(sub))!=ERROR_SUCCESS)  {  return RET_FAILED;  }
 SHChangeNotify(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,0,0);
 return RET_YES;
 }




 B aaSysFileAssociationRemove          (CP extension)
 {
 B ext;
 H sl;
 C txt[_1K];
 C pt[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') ext=1;
 else                    ext=0;
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;
 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);
 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);
 if(RegDeleteKey(HKEY_CLASSES_ROOT,txt)!=ERROR_SUCCESS) { return RET_FAILED; }
 if(RegDeleteKey(HKEY_CLASSES_ROOT,pt)!=ERROR_SUCCESS)  { return RET_FAILED; }
 if(RegFlushKey(HKEY_CLASSES_ROOT)!=ERROR_SUCCESS) oof;
  {
  HANDLE mo;
  T V (*_shchnfy) (LONG,UINT,LPVOID,LPVOID);
  _shchnfy shchnfy;

  if((mo=LoadLibrary("shell32.dll"))!=NULL)
   {
   shchnfy=(_shchnfy)GetProcAddress(mo,"SHChangeNotify");
   if(shchnfy!=NULL)    {    shchnfy(SHCNE_ASSOCCHANGED,SHCNF_IDLIST,0,0);    }
   FreeLibrary(mo);
   }
  }
 return RET_YES;
 }







 B aaSysContextMenuSet                 (CP extension,CP menuname,VP deficon,CP appcmdline)
 {
 H sl;
 B txt[_1K];
 B pt[_1K];
 B ext;
 LONG r;
 B tmp[_1K];
 HKEY hkey;
 H dispo;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(menuname==NULL) { return RET_BADPARM; }
 if(appcmdline==NULL) { return RET_BADPARM; }
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') ext=1;
 else                    ext=0;
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;

 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);
 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);

 aaStringCopyf(tmp,"%s\\shell\\%s\\command",pt,menuname);
 dispo=0;
 r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)tmp,0,"",REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hkey,&dispo);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 aaStringLen(appcmdline,&sl);
 RegSetValueEx(hkey,NULL,0,REG_SZ,(CONST BYTE*)appcmdline,sl);
 RegCloseKey(hkey);
 dispo=0;
 r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)txt,0,"",REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hkey,&dispo);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 aaStringLen(pt,&sl);
 RegSetValueEx(hkey,NULL,0,REG_SZ,(CONST BYTE*)pt,sl);
 RegCloseKey(hkey);

 if(aaStringIsNull(deficon)==NO)
  {
  aaStringCopyf(tmp,"%s\\DefaultIcon",pt);
  dispo=0;
  r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)tmp,0,"",REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&hkey,&dispo);
  if(r!=ERROR_SUCCESS) { return RET_FAILED; }
  aaStringLen(deficon,&sl);
  RegSetValueEx(hkey,NULL,0,REG_SZ,(CONST BYTE*)deficon,sl);
  RegCloseKey(hkey);
  }
 return RET_YES;
 }



 B aaSysContextMenuRemove              (CP extension,CP menuname)
 {
 B pt[_1K];
 B ext;
 B tmp[_1K];
 B txt[_1K];
 H sl;
 LONG r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(menuname==NULL) { return RET_BADPARM; }
 if(extension==NULL) return RET_BADPARM;
 if(extension[0]=='.') ext=1;
 else                    ext=0;
 aaStringLen(extension,&sl);
 if(ext==1&&sl==1) return RET_BADPARM;
 if(sl>8) return RET_FAILED;

 if(ext==1) { txt[0]=0; }
 else         { txt[0]='.'; txt[1]=0; }
 aaStringAppend(txt,extension);

 aaStringCopy(pt,"Target_");
 aaStringAppend(pt,&txt[1]);
 aaStringCopyf(tmp,"%s\\shell\\%s\\command",pt,menuname);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 aaStringCopyf(tmp,"%s\\shell\\%s",pt,menuname);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 aaStringCopyf(tmp,"%s\\shell",pt);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
// aaStringCopyf(tmp,"%s\\DefaultIcon",pt);
// r=RegDeleteKey(HKEY_CLASSES_ROOT,tmp);
//if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 aaStringCopyf(tmp,"%s",pt);
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)tmp);
 if(r!=ERROR_SUCCESS) {  return RET_FAILED; }
 r=RegDeleteKey(HKEY_CLASSES_ROOT,(CP)txt);
 if(r!=ERROR_SUCCESS) { return RET_FAILED; }
 if(RegFlushKey(HKEY_CLASSES_ROOT)!=ERROR_SUCCESS) { return RET_FAILED; }
 return RET_YES;
 }



//aaSchemeHandlerSet("bitto","\"c:\\BitCoinIM\\bitcoinim.exe\",0","\"c:\\bitcoinim\\bitcoinim.exe\" \"/uri:%l\"")
 B aaSysSchemeHandlerSet               (VP scheme,VP deficon,VP appcmdline)
 {
 H disp,go;
 HKEY sub,subb;
 _str1k str;
 B path[_1K];
 N r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 sub=subb=0;
 for(go=0;go<2;go++)
  {
  if(go==0)   { aaStringCopyf(path,"%s",scheme);  }
  else        { aaStringCopyf(path,"SOFTWARE\\Classes\\%s",scheme); }
  if(go==0)   { if((r=RegCreateKeyEx(HKEY_CLASSES_ROOT,(CP)path,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp))!=ERROR_SUCCESS)   {  break;    }   }
  else        { if((r=RegCreateKeyEx(HKEY_LOCAL_MACHINE,(CP)path,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp))!=ERROR_SUCCESS)  { break; }   }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  aaStringCopyfLen(str.buf,&str.len,"URL:%s Protocol",scheme);
  str.len++;
  if((r=RegSetValueEx(sub,NULL,0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS) {  break;  }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  str.len=1;
  if((r=RegSetValueEx(sub,"URL Protocol",0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS)  {  break;  }
  if((r=RegCreateKeyEx(sub,"DefaultIcon",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS) {  break;  }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  aaStringCopyfLen(str.buf,&str.len,"%s",deficon);
  str.len++;
  if((r=RegSetValueEx(subb,NULL,0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS)   {   break;   }
  RegCloseKey(subb); subb=0;
  if((r=RegCreateKeyEx(sub,"shell",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS)   {   break;   }
  RegCloseKey(subb); subb=0;
  if((r=RegCreateKeyEx(sub,"shell\\open",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS)   {  break; }
  RegCloseKey(subb); subb=0;
  if((r=RegCreateKeyEx(sub,"shell\\open\\command",0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS)   {   break; }
  aaMemoryFill(str.buf,sizeof(str.buf),0);
  aaStringCopyfLen(str.buf,&str.len,"%s",appcmdline);
  str.len++;
  if((r=RegSetValueEx(subb,NULL,0,REG_SZ,str.buf,str.len))!=ERROR_SUCCESS)  {  break;  }
  RegCloseKey(subb); subb=0;
  RegCloseKey(sub); sub=0;
  }
 if(subb!=0) RegCloseKey(subb);
 if(sub!=0) RegCloseKey(sub);
 if(go!=2) { return RET_FAILED; }
 return RET_YES;
 }




 B aaSysTweak                          (V)
 {
 H val,e;
 HKEY sub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters",0L,KEY_ALL_ACCESS|0x100,&sub)!=ERROR_SUCCESS) { return RET_FAILED;  }
 e=0;
 val=30;       if(RegSetValueEx(sub,"TcpTimedWaitDelay",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=65534;    if(RegSetValueEx(sub,"MaxUserPort",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=32767;    if(RegSetValueEx(sub,"MaxHashTableSize",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=16000;    if(RegSetValueEx(sub,"MaxFreeTcbs",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=16777214; if(RegSetValueEx(sub,"TcpNumConnections",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=1048576;  if(RegSetValueEx(sub,"TcpWindowSize",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=1048576;  if(RegSetValueEx(sub,"GlobalMaxTcpWindowSize",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=100;      if(RegSetValueEx(sub,"DefaultTTL",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=3;        if(RegSetValueEx(sub,"Tcp1323Opts",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 val=1;        if(RegSetValueEx(sub,"SackOpts",0,REG_DWORD,(CONST BYTE*)&val,4)!=ERROR_SUCCESS) { e++; }
 RegCloseKey(sub);
 if(e!=0) {  return RET_FAILED; }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/




 B aaResourceInfoGet                   (H num,HP bytes)
 {
 HRSRC r;
 H b;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if((r=FindResource(NULL,MAKEINTRESOURCE(num),RT_RCDATA))==NULL) {  return RET_NOTFOUND;  }
 b=SizeofResource(NULL,r);
 if(b==0) { return RET_FAILED; }
 if(bytes) { *bytes=b; }
 return RET_YES;
 }






 B aaResourceToMemory                  (H num,HP bytes,PP mem)
 {
 HGLOBAL h;
 HRSRC r;
 BP bmp,mm;
 H b;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if((r=FindResource(NULL,MAKEINTRESOURCE(num),RT_RCDATA))==NULL) {  oof; oow; oof; return RET_NOTFOUND;  }
 if((h=LoadResource(NULL,r))==NULL)  {  return RET_NOMEMORY;  }
 if((bmp=LockResource(h))==NULL)
  {
  FreeResource(h);
  return RET_NOMEMORY;
  }
 b=SizeofResource(NULL,r);
 if(bytes!=NULL) { *bytes=b; }
 if(b==0)
  {
  FreeResource(h);
  return RET_FAILED;
  }
 if(mem==NULL) { return RET_YES; }
 if((ret=aaMemoryAllocate((VP)&mm,b))!=RET_YES)
  {
  FreeResource(h);
  return ret;
  }
 aaMemoryCopy(mm,b,bmp);
 FreeResource(h);
 *mem=mm;
 return RET_YES;
 }







 B aaResourceToFile                    (H num,HP bytes,VP filename)
 {
 HGLOBAL h;
 HRSRC r;
 BP bmp;
 B ret;
 H b,fh,todo,done;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes!=NULL) { *bytes=0; }
 if(filename==NULL) { return RET_BADPARM; }

 if((r=FindResource(NULL,MAKEINTRESOURCE(num),RT_RCDATA))==NULL) {   return RET_NOTFOUND;  }
 if((h=LoadResource(NULL,r))==NULL)  {  return RET_NOMEMORY;  }
 if((bmp=LockResource(h))==NULL)
  {
  FreeResource(h);
  return RET_NOMEMORY;
  }
 b=SizeofResource(NULL,r);
 if(bytes!=NULL) { *bytes=b; }
 if(b==0)
  {
  FreeResource(h);
  return RET_FAILED;
  }
 if((ret=aaFileStreamCreate(&fh,filename,YES,aa_FILEMODE_RW,aa_FILESHARE_RW,1,NO))!=RET_YES)
  {
  FreeResource(h);
  return ret;
  }
 done=0;
 while(1)
  {
  todo=b-done;
  todo=aaNumRoof(todo,_8K);
  if(todo==0) { break; }
  aaFileStreamWrite(fh,todo,&bmp[done]);
  done+=todo;
  }
 if(bytes) { *bytes=b; }
 FreeResource(h);
 aaFileStreamDestroy(fh);
 return ret;
 }



/*-----------------------------------------------------------------------*/




 B aaDigestCreate                      (HP handle,B type)
 {
 B ret;
 _aa_digestobject*digp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.digest_system.object_id,handle,(VP)&digp))!=RET_YES) { oops; return ret; }
 digp->self_handle=*handle;
 if(type==aa_DIGESTTYPE_Ripemd160)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Md5)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Sha1)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Crc32)
  {
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0;
  digp->status.digest[2]=0;
  digp->status.digest[3]=0;
  digp->status.digest[4]=0;
  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
 if(type==aa_DIGESTTYPE_Sha256)
  {
  digp->len[0]=digp->len[1]=0;
  /*
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  */
  digp->status.digest[0]=0x6a09e667;
  digp->status.digest[1]=0xbb67ae85;
  digp->status.digest[2]=0x3c6ef372;
  digp->status.digest[3]=0xa54ff53a;
  digp->status.digest[4]=0x510e527f;
  digp->status.digest[5]=0x9b05688c;
  digp->status.digest[6]=0x1f83d9ab;
  digp->status.digest[7]=0x5be0cd19;

  digp->counter=0;
  digp->count=0;
  digp->status.type=type;
  }
 else
  {
  aa_ObjectDestroy(aa.digest_system.object_id,*handle);
  *handle=0;
  return RET_BADPARM;
  }
 return RET_YES;
 }




 B aaDigestDestroy                     (H handle)
 {
 B ret;
 _aa_digestobject*digp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 aa_ObjectDestroy(aa.digest_system.object_id,handle);
 return RET_YES;
 }



 B aaDigestStatus                      (H handle,_digeststatus*digeststatus)
 {
 B ret;
 _aa_digestobject*digp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(digeststatus) { aaMemoryCopy(digeststatus,sizeof(_digeststatus),&digp->status); }
 return RET_YES;
 }





 B aaDigestWrite                       (H handle,H bytes,VP data,B finish,VP rdig,VP rdigstr)
 {
 B ret,temp;
 _aa_digestobject*digp;
 H tocopy,have,oldbytes;
 H totlo,tothi,t;//,i,j;//,len;
 H i,j,by,remainder,index,curpos;
 BP ptr;
 B finalcount[8];
 B di[20];
 B txt[20];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(rdigstr) { aaStringNull(rdigstr); }
 if(bytes!=0&&data==NULL) { oof; return RET_BADPARM; }
 if(bytes==0&&data!=NULL) { aaStringLen(data,&bytes);  }
 if(digp->requires_reset==YES)  {  if(aaDigestReset(handle)!=YES) oof;  }

 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  aa_DigestSystemMd5(digp,data,bytes);
  if(finish)
   {
   aa_DigestSystemMd5(digp,NULL,0);
   tothi=0;
   t=digp->counter;
   if((totlo=t<<6)<t) tothi++;
   tothi+=t>>26;
   t=totlo;
   if((totlo=t+digp->count)<t) tothi++;
   t=totlo;
   if((totlo=t<<3)<t) tothi++;
   tothi+=t>>29;
   if(digp->count<56)
    {
    digp->block[digp->count++]=0x80;
    while(digp->count<56) digp->block[digp->count++]=0;
    }
   else
    {
    digp->block[digp->count++]=0x80;
    while(digp->count<64) digp->block[digp->count++]=0;
    aa_DigestSystemMd5(digp,NULL,0);
    aaMemoryFill(digp->block,56,0);
//    memset(digp->block,0,56);
    }
   digp->block[56]=(B)(totlo);
   digp->block[57]=(B)(totlo>>8);
   digp->block[58]=(B)(totlo>>16);
   digp->block[59]=(B)(totlo>>24);
   digp->block[60]=(B)(tothi);
   digp->block[61]=(B)(tothi>>8);
   digp->block[62]=(B)(tothi>>16);
   digp->block[63]=(B)(tothi>>24);
   aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
   digp->requires_reset=YES;
   }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
    by=bytes;
    aaCast(ptr,BP,data);
    j=(digp->len[0]>>3)&63;
    if((digp->len[0]+=by<<3)<(by<<3)) { digp->len[1]++; }
    digp->len[1]+=(by>>29);
    if((j+by)>63)
     {
     aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
     aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
     for(;i+63<by;i+=64) {aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
     }
    else i=0;
    aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
  if(finish)
   {
    for(i=0;i<8;i++) {  finalcount[i]=(B)((digp->len[(i>=4?0:1)]>>((3-(i&3))*8))&255);  }
    aaMemoryCopy(txt,1,(BP)"\200");
//    SHA1Update(context,(BP)"\200", 1);
    by=1;//bytes;
    aaCast(ptr,BP,txt);
    j=(digp->len[0]>>3)&63;
    if((digp->len[0]+=by<<3)<(by<<3)) { digp->len[1]++; }
    digp->len[1]+=(by>>29);
    if((j+by)>63)
     {
     aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
     aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
     for(;i+63<by;i+=64) {aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
     }
    else i=0;
    aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
    while((digp->len[0]&504)!=448)
     {
 //    SHA1Update(context, (BP)"\0", 1);
   txt[0]=0;
    by=1;//bytes;
    aaCast(ptr,BP,txt);
    j=(digp->len[0]>>3)&63;
    if((digp->len[0]+=by<<3)<(by<<3)) { digp->len[1]++; }
    digp->len[1]+=(by>>29);
    if((j+by)>63)
     {
     aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
     aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
     for(;i+63<by;i+=64) { aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
     }
    else i=0;
    aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
     }
//    SHA1Update(context, finalcount, 8);
    by=8;//bytes;
    aaCast(ptr,BP,finalcount);//txt);
    j=(digp->len[0]>>3)&63;
    if((digp->len[0]+=by<<3)<(by<< 3)) { digp->len[1]++; }
    digp->len[1]+=(by>> 29);
    if((j+by)>63)
     {
     aaMemoryCopy(&digp->block[j],(i=64-j),ptr);
     aa_DigestSystemCompress((VP)&digp,(HP)digp->block);
     for(;i+63<by;i+=64) {aa_DigestSystemCompress((VP)&digp,(HP)&ptr[i]); }  j=0;
     }
    else i=0;
    aaMemoryCopy(&digp->block[j],by-i,&ptr[i]);
    for(i=0;i<20;i++)  {  di[i]=(B)((digp->status.digest[i>>2]>>((3-(i&3))*8))&255); }
    aaCast(ptr,BP,&digp->status.digest[0]);
    for(i=0;i<20;i++) ptr[i]=di[i];
   // i=j=0;
   digp->requires_reset=YES;
   }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  oldbytes=digp->len[0];
  have=oldbytes%64;
  digp->len[0]=(H)(digp->len[0]+bytes);//&F32;
  if(digp->len[0]<oldbytes) { digp->len[1]++; }
  aaCast(ptr,BP,data);
  while(bytes>0)
   {
   if(have==0&&bytes>=64)  {  aa_DigestSystemCompress((VP)&digp,(VP)ptr);  ptr+=64;   bytes-=64;  continue;   }
   tocopy=64-have;
   if(tocopy>0)
    {
    if(tocopy>bytes)  tocopy=bytes;
    aaMemoryCopy(&digp->block[have],tocopy,ptr);
    ptr+=tocopy;  bytes-=tocopy; have+=tocopy;
    if(have==64)  {  aa_DigestSystemCompress((VP)&digp,(VP)digp->block);   have=0;    }
    }
   }
  if(finish)
   {
   temp=0x80;
   totlo=digp->len[0];
   tothi=digp->len[1];
   bytes=1;
   oldbytes=digp->len[0];
   have=oldbytes%64;
   digp->len[0]=(H)(digp->len[0]+bytes);//&F32;
   if(digp->len[0]<oldbytes) { digp->len[1]++; }
   aaCast(ptr,BP,&temp);
   while(bytes>0)
    {
    if(have==0&&bytes>=64)  {  aa_DigestSystemCompress((VP)&digp,(VP)ptr);  ptr+=64;   bytes-=64;  continue;   }
    tocopy=64-have;
    if(tocopy>0)
     {
     if(tocopy>bytes)  tocopy=bytes;
     aaMemoryCopy(&digp->block[have],tocopy,ptr);
     ptr+=tocopy;  bytes-=tocopy; have+=tocopy;
     if(have==64)  {  aa_DigestSystemCompress((VP)&digp,(VP)digp->block);   have=0;    }
     }
    }
   have=digp->len[0]%64;
//   padding=(64-(have+9)%64)%64;
   if(have>56)
    {
    aaMemoryFill(&digp->block[have],64-have,0);
//    padding-=(64 - have);
    aa_DigestSystemCompress((VP)&digp,(VP)digp->block);
    have=0;
    }
   tothi<<=3; tothi+=(totlo>>29);  totlo<<=3;
   *(HP)&digp->block[60]=tothi;
   *(HP)&digp->block[56]=totlo;
   if((64-have-8)>0)  {  aaMemoryFill(&digp->block[have],64-have-8,0);   }
   aa_DigestSystemCompress((VP)&digp,(VP)digp->block);
   digp->requires_reset=YES;
   }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Crc32)
  {
  oof;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  H inputLen=bytes;
  curpos=0;
  index=((digp->len[0]>>3)&0x3f);
  remainder=(inputLen&0x3f);
  ///appLog(2,"inputlen=%i rem=%i",inputLen,remainder);
  if((digp->len[0]+=(inputLen<<3))<(inputLen<<3)) digp->len[1]++;
  digp->len[1]+=(inputLen>>29);
  ptr=(BP)data;
  for(i=0;i+63<inputLen;i+=64)
   {
   for(j=index;j<64;j++)
    {
    digp->block[j]=ptr[curpos++];
    }
   aa_DigestSystemSha256Transform(digp);
   index=0;
   }
  ptr=(BP)data;
  for(j=0;j<remainder;j++)
   {
   digp->block[j]=ptr[curpos++];
   }
  if(finish)
   {
   ///appLog(2,"fnin len[0]=%i len[1]=%i",digp->len[0],digp->len[1]);
   index=((digp->len[0]>>3)&0x3f);
   ///appLog(2,"index=%i",index);
   digp->block[index++]=0x80;
   if(index<=56)
    {
    for(i=index;i<56; i++)   {   digp->block[i]=0;   }
    }
   else
    {
    for(i=index;i<64; i++)   { digp->block[i]=0;   }
    aa_DigestSystemSha256Transform(digp);
    for(i=0;i<56; i++)   { digp->block[i]=0;   }
    }
   digp->block[56]=(digp->len[1]>>24)&0xff;
   digp->block[57]=(digp->len[1]>>16)&0xff;
   digp->block[58]=(digp->len[1]>>8)&0xff;
   digp->block[59]= digp->len[1]&0xff;
   digp->block[60]=(digp->len[0]>>24)&0xff;
   digp->block[61]=(digp->len[0]>>16)&0xff;
   digp->block[62]=(digp->len[0]>>8)&0xff;
   digp->block[63]=digp->len[0]&0xff;
   aa_DigestSystemSha256Transform(digp);
   digp->requires_reset=YES;
   for(i=0;i<8;i++)    {    digp->status.digest[i]=aaNumSwapDword(digp->status.digest[i]);    }
   }
  }



 if(rdig!=NULL)
  {
  if(digp->status.type==aa_DIGESTTYPE_Ripemd160) {  aaMemoryCopy(rdig,20,digp->status.digest);  }
  else
  if(digp->status.type==aa_DIGESTTYPE_Md5)       {  aaMemoryCopy(rdig,16,digp->status.digest); }//block);  }
  else
  if(digp->status.type==aa_DIGESTTYPE_Sha1)      {  aaMemoryCopy(rdig,20,digp->status.digest); }//block);  }
  else
  if(digp->status.type==aa_DIGESTTYPE_Sha256)    {  aaMemoryCopy(rdig,32,digp->status.digest); }//block);  }

  }
 if(rdigstr)
  {
  aaDigestToString(handle,rdigstr);
  }
 return RET_YES;
 }








 B aaDigestReset                       (H handle)
 {
 B ret;
 _aa_digestobject*digp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->counter=0;
  digp->count=0;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0xefcdab89UL;
  digp->status.digest[2]=0x98badcfeUL;
  digp->status.digest[3]=0x10325476UL;
  digp->status.digest[4]=0xc3d2e1f0UL;
  digp->counter=0;
  digp->count=0;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Crc32)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x67452301UL;
  digp->status.digest[1]=0;
  digp->status.digest[2]=0;
  digp->status.digest[3]=0;
  digp->status.digest[4]=0;
  digp->counter=0;
  digp->count=0;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  aaMemoryFill(digp->block,64,0);
  digp->len[0]=digp->len[1]=0;
  digp->status.digest[0]=0x6a09e667;
  digp->status.digest[1]=0xbb67ae85;
  digp->status.digest[2]=0x3c6ef372;
  digp->status.digest[3]=0xa54ff53a;
  digp->status.digest[4]=0x510e527f;
  digp->status.digest[5]=0x9b05688c;
  digp->status.digest[6]=0x1f83d9ab;
  digp->status.digest[7]=0x5be0cd19;

  digp->counter=0;
  digp->count=0;
  }

 digp->requires_reset=NO;
 return RET_YES;
 }








 B aaDigestToString                    (H handle,VP string)
 {
 B ret;
 _aa_digestobject*digp;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(string==NULL) { return RET_BADPARM; }
 aaStringNull(string);
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 aaCast(bp,BP,digp->status.digest);
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  aaStringCopyf(string,"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
  bp[0],bp[1],bp[2],bp[3],bp[4],bp[5],bp[6],bp[7],bp[8],bp[9],
  bp[10],bp[11],bp[12],bp[13],bp[14],bp[15],bp[16],bp[17],bp[18],bp[19]);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  aaStringCopyf(string,"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
  bp[0],bp[1],bp[2],bp[3],bp[4],bp[5],bp[6],bp[7],bp[8],bp[9],
  bp[10],bp[11],bp[12],bp[13],bp[14],bp[15]);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  aaStringCopyf(string,"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
  bp[0],bp[1],bp[2],bp[3],bp[4],bp[5],bp[6],bp[7],bp[8],bp[9],
  bp[10],bp[11],bp[12],bp[13],bp[14],bp[15],bp[16],bp[17],bp[18],bp[19]);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Crc32)
  {
  aaStringCopyf(string,"%02x%02x%02x%02x",bp[0],bp[1],bp[2],bp[3]);
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  aaStringCopyf(string,"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x",
  bp[0],bp[1],bp[2],bp[3],bp[4],bp[5],bp[6],bp[7],bp[8],bp[9],
  bp[10],bp[11],bp[12],bp[13],bp[14],bp[15],bp[16],bp[17],bp[18],bp[19],
  bp[20],bp[21],bp[22],bp[23],bp[24],bp[25],bp[26],bp[27],bp[28],bp[29],bp[30],bp[31]);
  }


 return RET_YES;
 }





 B aaDigestMac                         (H handle,H keylen,VP key,H bytes,VP data,VP rdig,VP rdigstr)
 {
 B ret;
 B k_ipad[65];
 B k_opad[65];
 B tk[32];
 B cx[32];
 B dx[32];
 B buf[64];
 B isha[32],osha[32];
 H i;
 BP keyptr;
 _aa_digestobject*digp;
 BP src;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.digest_system.object_id,handle,(VP)&digp,NULL))!=RET_YES) { return ret; }
 if(rdigstr) { aaStringNull(rdigstr); }
 if((ret=aaDigestReset(handle))!=RET_YES) { return ret; }
 if(keylen==0) { aaStringLen(key,&keylen); }
 if(keylen==0) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(data,&bytes); }
 if(bytes==0) { return RET_BADPARM; } // what about empty data ?? like in vectors
 aaCast(keyptr,BP,key);
 if(digp->status.type==aa_DIGESTTYPE_Ripemd160)
  {
  oof;
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha1)
  {
  aaCast(keyptr,BP,key);
  if(keylen>64)
   {
   aaDigestWrite(handle,keylen,keyptr,YES,tk,0);
   aaCast(keyptr,BP,tk);
   keylen=20;
   }
  for(i=0;i<keylen;++i)  { buf[i]=(B)(keyptr[i]^0x36);  } // was { buf[i]=(B)(keyptr[i]^0x36);  }
  for(i=keylen;i<64;++i) { buf[i]=0x36; }
  aaDigestWrite(handle,64,buf,NO,NULL,0);
  aaDigestWrite(handle,bytes,data,YES,isha,0);
  for(i=0;i<keylen;++i)  { buf[i]=(B)(keyptr[i]^0x5c); } // was { buf[i]=keyptr[i]^0x5c ; }
  for(i=keylen;i<64;++i) { buf[i]=0x5c; }
  aaDigestWrite(handle,64,buf,NO,NULL,0);
  aaDigestWrite(handle,20,isha,YES,osha,rdigstr);
  if(rdig) { aaMemoryCopy(rdig,20,osha); }
  }
 else
 if(digp->status.type==aa_DIGESTTYPE_Sha256)
  {
  H gap=0;
  #define HMAC_IPAD_VAL 0x36
  #define HMAC_OPAD_VAL 0x5C
  B hmac_buf[64+32]={0};
  aaMemoryFill(hmac_buf,sizeof(hmac_buf),0);
  aaCast(src,BP,data);
  //appLog(2,"bytes=%i keylen=%i",bytes,keylen);
  if(keylen<64)  {   aaMemoryCopy(hmac_buf,keylen,key);   }
  else   {   oof;   aaDigestReset(handle);   aaDigestWrite(handle,keylen,key,YES,hmac_buf,0);   }
  for(i=0;i<64;i++)   hmac_buf[i]^=HMAC_IPAD_VAL;
  aaDigestReset(handle);
  aaDigestWrite(handle,64,hmac_buf,NO,0,0);
  if(gap<=0) {  aaDigestWrite(handle,bytes,src,YES,&hmac_buf[64],0); }
  else
   { //skip 32 bytes used for storing digest
   oof;
   aaDigestWrite(handle,gap,src,NO,0,0);
   aaDigestWrite(handle,bytes-gap-32,&src[gap+32],YES,&hmac_buf[64],0);
   }
  for(i=0;i<64;i++)   {   hmac_buf[i]^=HMAC_IPAD_VAL^HMAC_OPAD_VAL;   }
  aaDigestReset(handle);
  aaDigestWrite(handle,64+32,hmac_buf,YES,osha,rdigstr);
  if(rdig) { aaMemoryCopy(rdig,32,osha); }
  }

 else
 if(digp->status.type==aa_DIGESTTYPE_Md5)
  {
  // verify md5 func works here:
  // while im here retest sha
  if(keylen>64)
   {
   aaDigestWrite(handle,keylen,key,YES,tk,0);
   aaCast(keyptr,BP,tk);
   keylen=16;
   }
  aaMemoryFill(k_ipad,sizeof(k_ipad),0);
  aaMemoryFill(k_opad,sizeof(k_opad),0);
  aaMemoryCopy(k_ipad,keylen,keyptr);
  aaMemoryCopy(k_opad,keylen,keyptr);
  for(i=0;i<64;i++)
   {
   k_ipad[i]^=0x36;
   k_opad[i]^=0x5c;
   }
  aaDigestWrite(handle,64,k_ipad,NO,NULL,0);
  aaDigestWrite(handle,bytes,data,YES,cx,0);
  aaDigestWrite(handle,64,k_opad,NO,NULL,0);
  aaDigestWrite(handle,16,cx,YES,dx,rdigstr);
  if(rdig) { aaMemoryCopy(rdig,16,dx); }
  }

 //if(rdigstr)  {  aaDigestToString(handle,rdigstr);  }

 return RET_YES;
 }



 B aaDigestQuick                       (B type,VP digstr,H bytes,VP data)
 {
 B ret;
 _digestunit digu;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aaDigestCreate(&digu.handle,type))!=YES) { return ret; }
 aaDigestReset(digu.handle);
 if(bytes==0&&data!=NULL)  {  aaStringLen(data,&bytes);  }
 ret=aaDigestWrite(digu.handle,bytes,data,YES,0,digstr);
 aaDigestDestroy(digu.handle);
 return ret;
 }





 B aaDigestQuickf                      (B type,VP digstr,VP fmt,...)
 {
 aaVargsf(fmt);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaDigestQuick(type,digstr,0,str64k.buf));
 }



/*-----------------------------------------------------------------------*/



 B aaCryptoCreate                      (HP handle,B type,B keylen,VP key)
 {
 B ret;
 _aa_cryptoobject*cryp;
 H sl,i;
 B i1,i2,newkey[257],v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(key==NULL) { return RET_BADPARM; }
 if(keylen==0) { aaStringLen(key,&sl); if(sl==0||sl>255) { return RET_BADPARM; } keylen=(B)sl; }
 if(type<aa_CRYPTOTYPE_Arc4||type>aa_CRYPTOTYPE_Des3) { return RET_BADPARM; }
 if(type==aa_CRYPTOTYPE_Des1&&keylen!=8) { return RET_FAILED; }
 if(type==aa_CRYPTOTYPE_Des2&&keylen!=16) { return RET_FAILED; }
 if(type==aa_CRYPTOTYPE_Des3&&keylen!=24) { return RET_FAILED; }
 if((ret=aa_ObjectCreate(aa.crypto_system.object_id,handle,(VP)&cryp))!=RET_YES) { oops; return ret; }
 cryp->self_handle=*handle;
 aaMemoryCopy(newkey,keylen,key);
 if(type==aa_CRYPTOTYPE_Arc4)
  {
  for(sl=0;sl<256;sl++) cryp->state[2+sl]=(B)sl;
  i1=i2=0;
  for(sl=0;sl<256;sl++)
   {
   i2=(B)((newkey[i1]+cryp->state[2+sl]+i2)%256);
   v=cryp->state[2+i2];
   cryp->state[2+i2]=cryp->state[2+sl];
   cryp->state[2+sl]=v;
   i1=(B)((i1+1)%keylen);
   }
  // miss the initial results for security,, remove for test vectoring
 // aaMemoryFill(newkey,256,0);
  //aaCryptoTranscode(*handle,256,newkey,0);
  }
 else
 if(type==aa_CRYPTOTYPE_Des1)
  {
  aa_CryptoSystemProcess(cryp->des_context.esk,newkey);
  for(i=0;i<32;i+=2)
   {
   cryp->des_context.dsk[i]=cryp->des_context.esk[30-i];
   cryp->des_context.dsk[i+1]=cryp->des_context.esk[31-i];
   }
  }
 else
 if(type==aa_CRYPTOTYPE_Des2)
  {
  aa_CryptoSystemProcess(cryp->des3_context.esk,newkey);
  aa_CryptoSystemProcess(cryp->des3_context.dsk+32,&newkey[8]);
  for(i=0;i<32;i+=2)
    {
        cryp->des3_context.dsk[i]=cryp->des3_context.esk[30-i];
        cryp->des3_context.dsk[i+1]=cryp->des3_context.esk[31-i];
        cryp->des3_context.esk[i+32]=cryp->des3_context.dsk[62-i];
        cryp->des3_context.esk[i+33]=cryp->des3_context.dsk[63-i];
        cryp->des3_context.esk[i+64]=cryp->des3_context.esk[i];
        cryp->des3_context.esk[i+65]=cryp->des3_context.esk[1+i];
        cryp->des3_context.dsk[i+64]=cryp->des3_context.dsk[i];
        cryp->des3_context.dsk[i+65]=cryp->des3_context.dsk[1+i];
    }
  }
 else
 if(type==aa_CRYPTOTYPE_Des3)
  {
  aa_CryptoSystemProcess(cryp->des3_context.esk,newkey);
  aa_CryptoSystemProcess(cryp->des3_context.dsk+32,&newkey[8]);
  aa_CryptoSystemProcess(cryp->des3_context.esk+64,&newkey[16]);
    for(i=0;i<32;i+=2)
     {
     cryp->des3_context.dsk[i]=cryp->des3_context.esk[94-i];
     cryp->des3_context.dsk[i+1]=cryp->des3_context.esk[95-i];
     cryp->des3_context.esk[i+32]=cryp->des3_context.dsk[62-i];
     cryp->des3_context.esk[i+33]=cryp->des3_context.dsk[63-i];
     cryp->des3_context.dsk[i+64]=cryp->des3_context.esk[30-i];
     cryp->des3_context.dsk[i+65]=cryp->des3_context.esk[31-i];
     }
  }
 cryp->type=type;
 return RET_YES;
 }



 B aaCryptoDestroy                     (H handle)
 {
 B ret;
 _aa_cryptoobject*cryp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.crypto_system.object_id,handle,(VP)&cryp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 aa_ObjectDestroy(aa.crypto_system.object_id,handle);
 return RET_YES;
 }





 B aaCryptoTranscode                   (H handle,H bytes,VP data,B dir)
 {
 B ret;
 _aa_cryptoobject*cryp;
 B v,x,y,xi;
 BP bp;
 H c;
 H XX,YY,TT;
 HP SK;
 BP inpu,outpu;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.crypto_system.object_id,handle,(VP)&cryp,NULL))!=RET_YES) { return ret; }
 if(bytes==0) { return RET_YES; }
 if(data==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,data);
 if(cryp->type==aa_CRYPTOTYPE_Arc4)
  {
  x=cryp->state[0];
  y=cryp->state[1];
  for(c=0;c<bytes;c++)
   {
   x=(B)((x+1)%256);
   y=(B)((cryp->state[2+x]+y)%256);
   v=cryp->state[2+y];
   cryp->state[2+y]=cryp->state[2+x];
   cryp->state[2+x]=v;
   xi=(B)((cryp->state[2+x]+cryp->state[2+y])%256);
   bp[c]^=cryp->state[2+xi];
   }

     /* rule 1
  if(cryp->crc[0xfe]==0xf119eef1)
   {
   z=(x+(y*(cryp->state[1+x])));
   if(!z) { z++; }
   _asm_
    {
    mov eax,0xfe
    sub edx,eax
    jz _maincryp
    jmp _subscryp
    storsd
   _maincryp:
    jne _maincryp


   }
   */
  cryp->state[0]=x;
  cryp->state[1]=y;
  }
 else
 if(cryp->type==aa_CRYPTOTYPE_Des1)
  {
  aaCast(inpu,BP,data);
  aaCast(outpu,BP,data);
  if(dir) { SK=cryp->des_context.esk; }
  else    { SK=cryp->des_context.dsk; }
  (XX)=((H)(inpu)[(0)]<<24)|((H)(inpu)[(0)+1]<<16)|((H)(inpu)[(0)+2]<<8)|((H)(inpu)[(0)+3]);
  (YY)=((H)(inpu)[(4)]<<24)|((H)(inpu)[(4)+1]<<16)|((H)(inpu)[(4)+2]<<8)|((H)(inpu)[(4)+3]);
  aaDES_IP(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_FP(YY,XX);
  (outpu)[(0)]=(B)((YY)>>24); (outpu)[(0)+1]=(B)((YY)>>16); (outpu)[(0)+2]=(B)((YY)>>8); (outpu)[(0)+3]=(B)((YY));
  (outpu)[(4)]=(B)((XX)>>24); (outpu)[(4)+1]=(B)((XX)>>16); (outpu)[(4)+2]=(B)((XX)>>8); (outpu)[(4)+3]=(B)((XX));
  }
 else
 if(cryp->type==aa_CRYPTOTYPE_Des2||cryp->type==aa_CRYPTOTYPE_Des3)
  {
  aaCast(inpu,BP,data);
  aaCast(outpu,BP,data);
  if(dir) { SK=cryp->des3_context.esk; }
  else    { SK=cryp->des3_context.dsk; }
  (XX)=((H)(inpu)[(0)]<<24)|((H)(inpu)[(0)+1]<<16)|((H)(inpu)[(0)+2]<<8)|((H)(inpu)[(0)+3]);
  (YY)=((H)(inpu)[(4)]<<24)|((H)(inpu)[(4)+1]<<16)|((H)(inpu)[(4)+2]<<8)|((H)(inpu)[(4)+3]);
  aaDES_IP(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(XX,YY);  aaDES_ROUND(YY,XX);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_ROUND(YY,XX);  aaDES_ROUND(XX,YY);
  aaDES_FP(YY,XX);
  (outpu)[(0)]=(B)((YY)>>24); (outpu)[(0)+1]=(B)((YY)>>16); (outpu)[(0)+2]=(B)((YY)>>8); (outpu)[(0)+3]=(B)((YY));
  (outpu)[(4)]=(B)((XX)>>24); (outpu)[(4)+1]=(B)((XX)>>16); (outpu)[(4)+2]=(B)((XX)>>8); (outpu)[(4)+3]=(B)((XX));
  }

 return RET_YES;
 }





/*-----------------------------------------------------------------------*/




 B aaJsonCreate                        (HP handle,B encflag)
 {
 B ret;
 _aa_jsonobject*jsonp;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCreate(aa.json_system.object_id,handle,(VP)&jsonp))!=RET_YES) { oops; return ret; }
 jsonp->self_handle=*handle;
// jsonp->depth=-1;
 if(encflag)  {  jsonp->status.is_encode=YES;  }
 else  {  jsonp->status.is_encode=NO;  }
 return RET_YES;
 }



 B aaJsonDestroy                       (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(jsonp->bytes_allocated) { if(aa_MemoryRelease(jsonp->status.mem)!=YES) oof; }
 if(jsonp->lines_allocated) { if(aaMemoryRelease(jsonp->status.line)!=YES) oof; }
 aa_ObjectDestroy(aa.json_system.object_id,handle);
 return RET_YES;
 }



 B aaJsonStatus                        (H handle,_jsonstatus*jsonstatus)
 {
 B ret;
 _aa_jsonobject*jsonp;
 H go;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_decoding==YES)
  {
  go=0;
   while(1)
    {
    if((go++)>1000) break;
    if((ret=aa_jsonSystemDecode((VP)&jsonp))!=YES) { oops; break; }
    if(jsonp->status.is_decoding==NO)      {      break;      }
    }
  }
 if(jsonstatus) { aaMemoryCopy(jsonstatus,sizeof(_jsonstatus),&jsonp->status); }
 return RET_YES;
 }




 B aaJsonReset                         (H handle,B encflag)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(encflag)  {  jsonp->status.is_encode=YES;  }
 else  {  jsonp->status.is_encode=NO;  }
 jsonp->status.is_decoding=NO;
 jsonp->status.decode_success=NO;
 jsonp->status.decode_failure=NO;
 jsonp->status.mem_bytes=0;
 jsonp->status.lines=0;
 jsonp->bytes_left=jsonp->bytes_allocated;
 jsonp->dec_stage=0;
 return RET_YES;
 }





 B aaJsonAppendf                       (H handle,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==YES) { return RET_FORBIDDEN; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_YES; }
 if((sl+_1K)>=jsonp->bytes_left) { if(aa_JsonSystemExtendMemory((VP)&jsonp,sl+_4K)!=YES) oof; }
 aaStringNCopy(&jsonp->status.mem[jsonp->status.mem_bytes],txt,sl,YES);
 jsonp->status.mem_bytes+=sl;
 jsonp->bytes_left=jsonp->bytes_allocated-jsonp->status.mem_bytes;
 return RET_YES;
 }





 B aaJsonAppendBytes                   (H handle,H bytes,VP data)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==YES) { return RET_FORBIDDEN; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes==0) { aaStringLen(data,&bytes); }
 if(bytes==0) { return RET_YES; }
 if((bytes+_1K)>=jsonp->bytes_left) { if(aa_JsonSystemExtendMemory((VP)&jsonp,bytes+_4K)!=YES) oof; }
 aaStringNCopy(&jsonp->status.mem[jsonp->status.mem_bytes],data,bytes,YES);
 jsonp->status.mem_bytes+=bytes;
 jsonp->bytes_left=jsonp->bytes_allocated-jsonp->status.mem_bytes;
 return RET_YES;
 }




 B aaJsonDecode                        (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;
 B inq;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_decoding) { return RET_INUSE; }
 if(jsonp->dec_stage!=0) { aaNote(0,"stag=%i",jsonp->dec_stage); }
 if(jsonp->status.mem_bytes==0) { return RET_NOTREADY; }
 //if(mode>1) { mode=1; }
 //mode=mode&1;
 //jsonp->status.decode_mode=mode;
 //jsonp->status.is_decoded=NO;
 jsonp->status.is_decoding=YES;
 jsonp->status.decode_success=NO;
 jsonp->status.decode_failure=NO;
 i=0;
 inq=NO;
   while(1)
    {
    if(jsonp->status.mem[i]==0)
     {
     jsonp->status.mem_bytes=i;
     aaParserInit(&jsonp->pa,jsonp->status.mem,(H)jsonp->status.mem_bytes);
     break;
     }
    if(i>=jsonp->status.mem_bytes) { aaNote(0,"line=%i i=%i",__LINE__,i); break; }
    if(inq==0)
     {
     if(jsonp->status.mem[i]==DQUOTE_CHAR) { inq=jsonp->status.mem[i]; i++; continue; }
     }
    else
     {
     if(jsonp->status.mem[i]==BSLASH_CHAR&&jsonp->status.mem[i+1]==inq) { i+=2; continue; }
     if(jsonp->status.mem[i]==inq) { inq=0; i++; continue; }
     }
    if(inq==0)
     {
     if(aaCharIsVisible(jsonp->status.mem[i])==NO&&aaCharIsVisible(jsonp->status.mem[i+1])==NO)
      {
      aaStringDeleteChars(jsonp->status.mem,0,i,1);
      continue;
      }
     }
    i++;
    }
 aaStringLen(jsonp->status.mem,&jsonp->status.mem_bytes);
 return RET_YES;
 }





 B aaJsonEncodeObjectOpen              (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"{"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_OBJOPEN;
 jsonp->status.is_encode=YES;
 jsonp->in_array=NO;
 return RET_YES;
 }




 B aaJsonEncodeObjectClose             (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"}"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_OBJCLOSE;
 jsonp->status.is_encode=YES;
 jsonp->in_array=NO;
 return RET_YES;
 }




 B aaJsonEncodeArrayOpen               (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"["))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_ARRAYOPEN;
 jsonp->in_array=YES;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }



 B aaJsonEncodeArrayClose              (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"]"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_ARRAYCLOSE;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeKey                     (H handle,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_FAILED; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if(jsonp->last_enc_type>=JSON_TYPE_STRING||jsonp->last_enc_type==JSON_TYPE_ARRAYCLOSE||jsonp->last_enc_type==JSON_TYPE_OBJCLOSE)
   {
   if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
   }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"\"%s\"",txt))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_KEY;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }





 B aaJsonEncodeString                  (H handle,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 aaFmt(fmt,argptr,txt);
 aaStringLen(txt,&sl);
 if(sl==0) { return RET_FAILED; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,"\"%s\"",txt))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_STRING;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeFloat                   (H handle,D val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,",%f",val))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_FLOAT;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeInt                     (H handle,G val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,",%I64d",val))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_INT;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeBool                    (H handle,B val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(val=='t'||val=='T') { val=1; } else
 if(val=='f'||val=='F') { val=0; }
 if(val!=0&&val!=1) { return RET_BADPARM; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if(val==0)
  {
  if((ret=aaJsonAppendf(handle,",false"))!=YES) { oops; }
  }
 else
 if(val==1)
  {
  if((ret=aaJsonAppendf(handle,",true"))!=YES) { oops; }
  }
 jsonp->last_enc_type=JSON_TYPE_FALSE+val;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeNull                    (H handle)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 jsonp->status.is_encode=NO;
 if(jsonp->last_enc_type==JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,":"))!=YES) { oops; }
  }
 else
 if(jsonp->last_enc_type!=JSON_TYPE_KEY)
  {
  if((ret=aaJsonAppendf(handle,","))!=YES) { oops; }
  }
 jsonp->status.is_encode=NO;
 if((ret=aaJsonAppendf(handle,",null"))!=YES) { oops; }
 jsonp->last_enc_type=JSON_TYPE_NULL;
 jsonp->status.is_encode=YES;
 return RET_YES;
 }




 B aaJsonEncodeKeyString               (H handle,VP key,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B txt[_32K+_8K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { oops; return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 aaFmt(fmt,argptr,txt);
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { oops; return ret; }
 if((ret=aaJsonEncodeString(handle,"%s",txt))!=YES) {oops;  return ret; }
 return RET_YES;
 }







 B aaJsonEncodeKeyFloat                (H handle,VP key,D val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeFloat(handle,val))!=YES) { return ret; }
 return RET_YES;
 }




 B aaJsonEncodeKeyInt                  (H handle,VP key,G val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeInt(handle,val))!=YES) { return ret; }
 return RET_YES;
 }



 B aaJsonEncodeKeyBool                 (H handle,VP key,B val)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeBool(handle,val))!=YES) { return ret; }
 return RET_YES;
 }





 B aaJsonEncodeKeyNull                 (H handle,VP key)
 {
 B ret;
 _aa_jsonobject*jsonp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(jsonp->status.is_encode==NO) { return RET_FORBIDDEN; }
 if(aaStringIsNull(key)!=NO) { return RET_BADPARM; }
 if((ret=aaJsonEncodeKey(handle,"%s",key))!=YES) { return ret; }
 if((ret=aaJsonEncodeNull(handle))!=YES) { return ret; }
 return RET_YES;
 }






 B aaJsonParserLineGet                 (H handle,H line,_jsonline*jsonline,VP str)
 {
 B ret;
 _aa_jsonobject*jsonp;
 H sl;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(str) { aaStringNull(str); }
 if(jsonp->status.decode_success!=YES) { return RET_NOTREADY; }
 if(line>=jsonp->status.lines) { return RET_BOUNDS; }
 if(jsonline)
  {
  aaMemoryCopy(jsonline,sizeof(_jsonline),&jsonp->status.line[line]);
  }
 if(str==NULL) { return RET_YES;  }
 sl=jsonp->status.line[line].len;
 if(str&&sl){  aaStringNCopy(str,&jsonp->status.mem[jsonp->status.line[line].off],sl,YES);  }
 return RET_YES;
 }




 B aaJsonParserKeyFind                 (H handle,HP line,H from,Z depth,VP val,VP fmt,...)
 {
 B ret;
 _aa_jsonobject*jsonp;
 va_list argptr;
 B str[_4K];
 B txt[_4K];
 H sl,l;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(val) { aaStringNull(val); }
 if(jsonp->status.decode_success!=YES) { return RET_NOTREADY; }
 if(line) { *line=F32; }
 aaFmt(fmt,argptr,str);
 aaStringLen(str,&sl);
 if(sl==0) { return RET_BADPARM; }
 if(from>=jsonp->status.lines) { return RET_BOUNDS; }
 for(l=from;l<jsonp->status.lines;l++)
  {
  if(jsonp->status.line[l].type!=JSON_TYPE_KEY) { continue; }
  if(depth!=-1&&jsonp->status.line[l].depth!=depth) { continue; }
  aaStringNCopy(txt,&jsonp->status.mem[jsonp->status.line[l].off],jsonp->status.line[l].len,YES);
  if(aaStringCompare(str,txt,0)!=YES) { continue; }
  if(line) { *line=l; }
  if(val)  { aaStringNCopy(val,&jsonp->status.mem[jsonp->status.line[l+1].off],jsonp->status.line[l+1].len,YES);   }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }



 B aaJsonDumpLineGet                   (H handle,HP line,H maxchars,VP str)
 {
 B ret;
 _aa_jsonobject*jsonp;
 _jsonline jl;
 _jsonline jlb;
 B spc[_1K];
 B aok[_1K];
 H li,sl;
 BP bp;
 BP tmp=NULL_POINTR;
 BP bmp=NULL_POINTR;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.json_system.object_id,handle,(VP)&jsonp,NULL))!=RET_YES) { return ret; }
 if(str) { aaStringNull(str); }
 if(aa.is_ready!=YES)  {  return RET_NOTREADY; }
 if(jsonp->status.decode_success!=YES) { return RET_NOTREADY; }
 if((ret=aa_MemoryTemp((VP)&tmp,maxchars+_1K,aa_MEMORYTEMP_JsonDumpA))!=RET_YES) { return ret; }
 if((ret=aa_MemoryTemp((VP)&bmp,_1MEG,aa_MEMORYTEMP_JsonDumpB))!=RET_YES) { return ret; }
 if(line==NULL) { return RET_BADPARM; }
 li=*line;
 if(li>=jsonp->status.lines) { return RET_BOUNDS; }
 if((ret=aaJsonParserLineGet(handle,li,&jl,aok))!=RET_YES) { oops; }
 aaStringFill(spc,jl.depth,32,YES);
 if(jsonp->status.line[li].type==JSON_TYPE_KEY||jsonp->status.line[li].type==JSON_TYPE_STRING)
  {
  aaStringQuotify(aok,0,DQUOTE_CHAR);
  }
 if(jsonp->status.line[li].type==JSON_TYPE_KEY)
  {
  if(jsonp->status.line[li+1].type==JSON_TYPE_STRING||jsonp->status.line[li+1].type==JSON_TYPE_INT||
     jsonp->status.line[li+1].type==JSON_TYPE_FLOAT||jsonp->status.line[li+1].type==JSON_TYPE_FALSE||
     jsonp->status.line[li+1].type==JSON_TYPE_TRUE||jsonp->status.line[li+1].type==JSON_TYPE_NULL)
     {
     if((ret=aaJsonParserLineGet(handle,li+1,&jlb,bmp))!=RET_YES) { oops; }
     if(jl.depth!=jlb.depth) oof;
     if(jlb.type==JSON_TYPE_STRING) { aaStringQuotify(bmp,0,DQUOTE_CHAR); }
     aaStringCopyf(tmp,"%5i/%-5i %-3i %-5i %i,%i,%i %s %s : %s",li,jsonp->status.lines,jl.type,jl.depth,jl.is_keyobj,jl.is_keyarray,jl.is_keyvalue,spc,aok,bmp);
     tmp[maxchars]=NULL_CHAR;
     aaStringLen(tmp,&sl);
     if(str) { aaMemoryCopy(str,sl+1,tmp); }
     if(str) { bp=(BP)str; bp[sl+1]=NULL_CHAR; }
     //BUG,"%-5i/%5i %-3i %-5i %s %s : %s",li,jsonp->status.lines,jl.type,jl.depth,spc,aok,bok);
     li+=2;
     *line=li;
     return RET_YES;
     }
  }
 aaStringCopyf(tmp,"%5i/%-5i %-3i %-5i %i,%i,%i %s %s",li,jsonp->status.lines,jl.type,jl.depth,jl.is_keyobj,jl.is_keyarray,jl.is_keyvalue,spc,aok);
 tmp[maxchars]=NULL_CHAR;
 aaStringLen(tmp,&sl);
 if(str) { aaMemoryCopy(str,sl+1,tmp); }
if(str) { bp=(BP)str; bp[sl+1]=NULL_CHAR; }
 //if(str) { str[sl+1]=NULL_CHAR; }
 li++;
 *line=li;
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaClassEmptyIdGet                   (BP id)
 {
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==NULL) { return RET_BADPARM; }
 *id=F8;
 for(i=1;i<128;i++)
  {
  if(aa.object_system.object[i+128].instance_limit==0)
   {
   *id=(B)i;
   return RET_YES;
   }
  }
 return RET_NOTFOUND;
 }





 B aaClassCreate                       (B id,H limit,H bytes,H initial,B(*Destructor)(H))
 {
 B ret;
 B txt[129];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 aaStringCopyf(txt,"Class#%i",id-128);
 ret=aa_ObjectDefine(id,bytes,limit,initial,Destructor,txt);
 return ret;
 }





 B aaClassDestroy                      (B id)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 ret=aa_ObjectUndefine(id);
 return ret;
 }





 B aaClassStatus                       (B id,_classstatus*classstatus)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 if(aa.object_system.object[id].instance_limit==0) { return RET_BADHANDLE; }
 if(classstatus)
  {
  classstatus->instance_limit=aa.object_system.object[id].instance_limit;
  classstatus->instance_count=aa.object_system.object[id].instance_count;
  classstatus->instance_bytes=aa.object_system.object[id].instance_bytes;
  classstatus->instance_initial=aa.object_system.object[id].instance_initial;
  }
 return RET_YES;
 }






 B aaClassNew                          (B id,HP handle,PP mem)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(handle) { *handle=0; }
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 ret=aa_ObjectCreate(id,handle,mem);
 if(ret!=RET_YES) { oops; }
 return ret;
 }






 B aaClassDelete                       (B id,H handle)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 ret=aa_ObjectDestroy(id,handle);
 return ret;
 }





 B aaClassCheck                        (B id,H handle,PP mem,BP isprotected)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 ret=aa_ObjectCheck(id,handle,mem,isprotected);
 return ret;
 }




 B aaClassIndexGet                     (B id,H handle,HP index)
 {
 B ret;
 H base;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(index==NULL) { return RET_BADPARM; }
 *index=F32;
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 if((ret=aa_ObjectCheck(id,handle,NULL,NULL))!=RET_YES) {return ret; }
 base=(H)id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 *index=(handle-base);
 return RET_YES;
 }




 B aaClassProtect                      (B id,H handle,B state)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 ret=aa_ObjectProtect(id,handle,state);
 return ret;
 }






 B aaClassNext                         (B id,HP handle,PP mem)
 {
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 ret=aa_ObjectNext(id,handle,mem,&aa.class_system.next_iteration[id-128]);
 return ret;
 }




 B aaClassGet                          (B id,H instanceindex,HP handle,PP mem)
 {
 H base;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(mem) { *mem=NULL; }
 if(handle) { *handle=0; }
 if(id==0||id>127) { return RET_FAILED; }
 id+=(B)128;
 base=id*aa_OBJ_MAX_PER_ID;
 base+=aa_OBJ_BASE_HANDLE;
 if(instanceindex>=aa.object_system.object[id].instance_limit) { return RET_BADHANDLE; }
 ret=aa_ObjectCheck(id,base+instanceindex,mem,NULL);
 if(ret!=RET_YES) { return ret; }
 if(handle) { *handle=base+instanceindex; }
 return RET_YES;
 }



 B aaClassIdGet                        (BP id,H handle)
 {
 B ret;
 B i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(id) { *id=0; }
 ret=aa_ObjectFromHandle(&i,handle);
 if(ret!=RET_YES) { return ret; }
 if(id) { *id=(B)(i-128); }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/


 B aaTaskNew                           (_task*task,H id,B(*proc)(_task*))
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(task==NULL) { return RET_BADPARM; }
 //aaDebugf(">> 0x%08x",aaHPP(task));
 aaMemoryFill(task,sizeof(_task),0);
 task->magic=aaHPP(task);
 task->proc=proc;
 task->boost=0;
 task->local_ram=&task->ram[0];
 task->id=id;
 return RET_YES;
 }




 B aaTaskDelete                        (_task*task)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(task==NULL) { return RET_BADPARM; }
 if(task->magic!=aaHPP(task)) { return RET_NOTINITIALIZED; }
 aaMemoryFill(task,sizeof(_task),0);
 return RET_YES;
 }





 B aaTaskStageSet                      (_task*task,H stage)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(task==NULL) { return RET_BADPARM; }
 if(task->magic!=aaHPP(task)) { return RET_NOTINITIALIZED; }
 task->stage=stage;
 return RET_YES;
 }





 B aaTaskExit                          (_task*task)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(task==NULL) { return RET_BADPARM; }
 if(task->magic!=aaHPP(task)) { return RET_NOTINITIALIZED; }
 task->is_exit=YES;
 return RET_YES;
 }




 B aaTaskYield                         (_task*task)
 {
 B(*proc)(_task*);
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(task==NULL) { return RET_BADPARM; }
 if(task->magic!=aaHPP(task)) { return RET_NOTINITIALIZED; }
 proc=task->proc;
 proc(task);
 task->cycle++;
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaTaskGroupNew                      (_taskgroup*taskgroup,H idbase)
 {
 B ret;
 H add;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(taskgroup==NULL) { return RET_BADPARM; }
 //aaDebugf(">> 0x%08x",aaHPP(taskgroup));
 aaMemoryFill(taskgroup,sizeof(_taskgroup),0);
 taskgroup->magic=aaHPP(taskgroup);
 taskgroup->task_slots=10;
 taskgroup->id_base=idbase;
 add=sizeof(_task)*taskgroup->task_slots;
 ret=aaMemoryAllocate((VP)&taskgroup->task,add);
 if(ret!=YES) { oops; }
 //*(HP)&taskgroup->shared_ram[0]=0x22332299;
 return RET_YES;
 }





 B aaTaskGroupDelete                   (_taskgroup*taskgroup)
 {
 B ret;
 H i;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(taskgroup==NULL) { return RET_BADPARM; }
 if(taskgroup->magic!=aaHPP(taskgroup)) { return RET_NOTINITIALIZED; }
 ///aaDebugf("about to exit all tasks");
 for(i=0;i<taskgroup->task_slots;i++)
  {
  if(taskgroup->task[i].magic==0) { continue; }
  ///aaDebugf("task %i",i);
  if(taskgroup->task[i].is_exit!=YES)
   {
   ret=aaTaskExit(&taskgroup->task[i]);
   if(ret!=YES) { oops; }
   ret=aaTaskYield(&taskgroup->task[i]);
   if(ret!=YES) { oops; }
   }
  ret=aaTaskDelete(&taskgroup->task[i]);
  if(ret!=YES) { oops; }
  taskgroup->task_count--;
  }
 if(taskgroup->task_count!=0) { oof; }
 if(taskgroup->task_slots!=0)
  {
  aaMemoryRelease(taskgroup->task);
  }

 aaMemoryFill(taskgroup,sizeof(_taskgroup),0);
 return RET_YES;
 }






 B aaTaskGroupAdd                      (_taskgroup*taskgroup,HP id,H boost,B(*proc)(_task*))
 {
 H i,left,add;
 B ret;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(taskgroup==NULL) { return RET_BADPARM; }
 if(taskgroup->magic!=aaHPP(taskgroup)) { return RET_NOTINITIALIZED; }
 left=taskgroup->task_slots-taskgroup->task_count;
 if(left<2)
  {
  add=(taskgroup->task_slots+10)*sizeof(_task);
  ret=aaMemoryReAllocate((VP)&taskgroup->task,add);
  if(ret!=YES) { oops; }
  taskgroup->task_slots+=10;
  }
 for(i=0;i<taskgroup->task_slots;i++)
  {
  if(taskgroup->task[i].magic!=0) { continue; }
  ret=aaTaskNew(&taskgroup->task[i],i,proc);
  if(ret!=YES) { oops; }
  taskgroup->task[i].id_base=taskgroup->id_base;
  taskgroup->task[i].boost=aaNumRoof(boost,1000);
  taskgroup->task[i].shared_ram=&taskgroup->shared_ram[0];
  if(id) { *id=i; }
  //shared=(VP)&taskgroup->task[i].ram[8000];
  //*(shared)=*(&taskgroup->shared_ram[0]);
  //taskgroup->task[i].ram[8000]=
  //taskgroup
  taskgroup->task_count++;

  break;
  }
 if(i==taskgroup->task_slots) { oof; }
 return RET_YES;
 }






 B aaTaskGroupYield                    (_taskgroup*taskgroup)
 {
 H pf,i;
 H rem;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(taskgroup==NULL) { return RET_BADPARM; }
 if(taskgroup->magic!=aaHPP(taskgroup)) { return RET_NOTINITIALIZED; }
 taskgroup->task_pf++;
 if(taskgroup->task_pf>=taskgroup->task_slots)
  {
  taskgroup->task_pf=0;
  }
 pf=taskgroup->task_pf;
 rem=NO;
 if(taskgroup->task[pf].magic!=0)
  {
  for(i=0;i<=taskgroup->task[pf].boost;i++)
   {
   if(taskgroup->task[pf].is_exit)
    {
    rem=YES;
    }
   aaTaskYield(&taskgroup->task[pf]);
   if(rem==RET_CANCELLED)
    {
    aaTaskDelete(&taskgroup->task[pf]);
    taskgroup->task_count--;
    break;
    }
   ///if(taskgroup->task[pf].is_exit)  { rem=YES; break; } // stop boost
   //if(taskgroup->task[pf].magic==0) { rem=YES; break; } // ditto
   }
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/



 B aaSettingsCreate                    (VP category)
 {
 B ret;
 H sl,disp;
 B path[_1K];
 HKEY sub,subb;
 N r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if((ret=aaStringLen(category,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 aaStringCopyf(path,"Software\\%s",aa_SETTINGS_ROOT);

 if((r=RegOpenKeyEx(HKEY_CURRENT_USER,(CP)path,0L,KEY_ALL_ACCESS|0x100,&sub))!=ERROR_SUCCESS)
  {
  oof;
  if(r==ERROR_FILE_NOT_FOUND)   {   return RET_NOTFOUND;   }
  return RET_FAILED;
  }
 if((r=RegCreateKeyEx(sub,category,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&subb,&disp))!=ERROR_SUCCESS)
  {
  oof;
  RegCloseKey(sub);
  return RET_FAILED;
  }
 RegCloseKey(subb);
 RegCloseKey(sub);
 return RET_YES;
 }



 B aaSettingsDestroy                   (VP category)
 {
 B ret;
 H sl;
 B path[_1K];
 N r;
 HKEY sub;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(category,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 aaStringCopyf(path,"Software\\%s",aa_SETTINGS_ROOT);
 if((r=RegOpenKeyEx(HKEY_CURRENT_USER,(CP)path,0L,KEY_ALL_ACCESS|0x100,&sub))!=ERROR_SUCCESS)
  {
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 if((r=RegDeleteKey(sub,category))!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  if(r==ERROR_FILE_NOT_FOUND) { return RET_YES; }
  return RET_FAILED;
  }
 RegCloseKey(sub);
 return RET_YES;
 }





 B aaSettingsRead                      (VP category,VP name,HP bytes,H maxbytes,VP data)
 {
 B ret;
 H sl,len,type,ml;
 HKEY sub;
 LONG r;
 B path[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes) { *bytes=0;}
 if(data) { aaStringNull(data); }
 if((ret=aaStringLen(category,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 if((ret=aaStringLen(name,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }

 if(maxbytes==0||maxbytes>=_16K) { return RET_BADPARM; }
 if((ret=aaSettingsLengthGet(category,name,&ml))!=YES) { return ret; }
 if(bytes) { *bytes=ml; }
 if(data==NULL) { return RET_BADPARM; }
 if(ml>maxbytes) { return RET_BOUNDS; }
 aaStringCopyf(path,"Software\\%s\\%s",aa_SETTINGS_ROOT,category);
 if((r=RegOpenKeyEx(HKEY_CURRENT_USER,(CP)path,0L,KEY_READ|0x100,&sub))==ERROR_SUCCESS)
  {
  len=maxbytes;
  type=REG_BINARY;
  r=RegQueryValueEx(sub,name,NULL,&type,(BP)data,&len);
  RegCloseKey(sub);
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  if(type!=REG_BINARY) { return RET_FAILED; }
  return RET_YES;
  }
 if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
 return RET_FAILED;
 }






 B aaSettingsWrite                     (VP category,VP name,H bytes,VP data,B allowoverwrite)
 {
 B ret;
 H sl,disp,len,type;
 HKEY sub;
 N r;
 B path[_1K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(category,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 if((ret=aaStringLen(name,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 if(data==NULL) { return RET_BADPARM; }
 if(bytes>=_16K) { return RET_BADPARM; }
 if(bytes==0)
  {
  aaStringLen(data,&bytes);
  if(bytes==0) { return RET_BADPARM; }
  bytes++; // for null char
  if(bytes>=_16K) { return RET_BADPARM; }
  }
 aaStringCopyf(path,"Software\\%s\\%s",aa_SETTINGS_ROOT,category);
 if(RegCreateKeyEx(HKEY_CURRENT_USER,(CP)path,0,NULL,REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,NULL,&sub,&disp)!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  return RET_FAILED;
  }

 if(allowoverwrite!=YES)
  {
  len=bytes; type=REG_BINARY;
  r=RegQueryValueEx(sub,name,NULL,&type,NULL,&len);
  if(r==ERROR_SUCCESS) { RegCloseKey(sub); return RET_EXISTS; }
  if(r!=ERROR_FILE_NOT_FOUND) { RegCloseKey(sub); return RET_FAILED; }
  }



 if((r=RegSetValueEx(sub,name,0,REG_BINARY,data,bytes))!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 RegCloseKey(sub);
 return RET_YES;
 }



 B aaSettingsDelete                    (VP category,VP name)
 {
 B ret;
 H sl;
 B path[_1K];
 HKEY sub;
 N r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(category,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 if((ret=aaStringLen(name,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 aaStringCopyf(path,"Software\\%s\\%s",aa_SETTINGS_ROOT,category);
 if((r=RegOpenKeyEx(HKEY_CURRENT_USER,(CP)path,0L,KEY_ALL_ACCESS|0x100,&sub))!=ERROR_SUCCESS)
  {
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 if((r=RegDeleteValue(sub,name))!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 RegCloseKey(sub);
 return RET_YES;
 }





 B aaSettingsLengthGet                 (VP category,VP name,HP bytes)
 {
 B ret;
 H sl,type,len;
 B path[_1K];
 HKEY sub;
 N r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(bytes) { *bytes=0; }
 if((ret=aaStringLen(category,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 if((ret=aaStringLen(name,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 aaStringCopyf(path,"Software\\%s\\%s",aa_SETTINGS_ROOT,category);
 if((r=RegOpenKeyEx(HKEY_CURRENT_USER,(CP)path,0L,KEY_ALL_ACCESS|0x100,&sub))!=ERROR_SUCCESS)
  {
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 len=0; type=REG_BINARY;
 if((r=RegQueryValueEx(sub,name,NULL,&type,NULL,&len))!=ERROR_SUCCESS)
  {
  RegCloseKey(sub);
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 if(type!=REG_BINARY||len==0)
  {
  RegCloseKey(sub);
  return RET_FAILED;
  }
 if(bytes) { *bytes=(H)len; }
 RegCloseKey(sub);
 return RET_YES;
 }





 B aaSettingsEnumStart                 (VP category)
 {
 B ret;
 H sl;//,type,len;
 B path[_1K];
 HKEY sub;
 N r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aaStringLen(category,&sl))!=RET_YES) { return ret; }
 if(sl==0||sl>512) { return RET_BADPARM; }
 if(aa.settings_system.enum_key!=0) { return RET_INUSE; }
 aaStringCopyf(path,"Software\\%s\\%s",aa_SETTINGS_ROOT,category);
 if((r=RegOpenKeyEx(HKEY_CURRENT_USER,(CP)path,0L,KEY_ALL_ACCESS|0x100,&sub))!=ERROR_SUCCESS)
  {
  if(r==ERROR_FILE_NOT_FOUND) { return RET_NOTFOUND; }
  return RET_FAILED;
  }
 aa.settings_system.enum_key=sub;
 if(aa.settings_system.enum_key==0)
  {
  if(RegCloseKey(aa.settings_system.enum_key)!=ERROR_SUCCESS) { return RET_FAILED; }
  return RET_NOTFOUND;
  }

 return RET_YES;
 }




 B aaSettingsEnumStep                  (H index,VP name,HP bytes,VP data)
 {
// B ret;
 H type,nlen,dlen;
// B path[_1K];
 N r;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name==NULL&&bytes==NULL) { return RET_BADPARM; }
 if(bytes) { *bytes=0; }
 if(name) { aaStringNull(name); }
 if(data) { aaStringNull(data); }
 if(aa.settings_system.enum_key==0) { return RET_NOTSTARTED; }
 nlen=512;
 dlen=_16K;
 type=REG_BINARY;
 r=RegEnumValue(aa.settings_system.enum_key,index,name?name:NULL,&nlen,NULL,&type,data,&dlen);
 if(r!=ERROR_SUCCESS)
  {
  if(r==ERROR_NO_MORE_ITEMS) { return RET_FINISHED; }
  return RET_FAILED;
  }
 if(type!=REG_BINARY)  { return RET_FAILED; }
 if(bytes) { *bytes=dlen; }
 return RET_YES;
 }





 B aaSettingsEnumStop                  (V)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aa.settings_system.enum_key==0) { return RET_YES; }
 if(RegCloseKey(aa.settings_system.enum_key)!=ERROR_SUCCESS) { return RET_FAILED; }
 aa.settings_system.enum_key=0;
 return RET_YES;
 }






 B aaSettingsDrop                      (VP name)
 {
 B txt[_2K];
 B str[_2K];

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name==NULL) { return RET_BADPARM; }
 aaStringCopyf(txt,"%s",name);
 aaStringCopyf(str,"data");
 return(aaSettingsDelete(txt,str));
 }







 B aaSettingsSave                      (VP name,H bytes,VP data)
 {
 B ret;
 B txt[_2K];
 B str[_2K];
 B dat[_8K];
 H off;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name==NULL) { return RET_BADPARM; }
 aaStringCopyf(txt,"%s",name);
 aaStringCopyf(str,"data");
 bp=(BP)data;
 off=0;
 *(HP)&dat[off]=bytes; off+=4;
 aaMemoryCopy(&dat[off],bytes,&bp[0]);
 off+=bytes;
 //aaDebugf("save cat=[%s] nane=[%s] off=%i",txt,str,off);
 if((ret=aaSettingsWrite(txt,str,off,dat,YES))!=YES) { oops; return ret; }
 return RET_YES;
 }







 B aaSettingsLoad                      (VP name,HP bytes,H maxbytes,VP data)
 {
 B ret;
 B txt[_2K];
 B str[_2K];
 B dat[_8K];
 H off,by,val;
 BP bp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(name==NULL) { return RET_BADPARM; }
 if(maxbytes) {}
 aaStringCopyf(txt,"%s",name);
 aaStringCopyf(str,"data");
 if((ret=aaSettingsCreate(txt))!=YES) { oops;  }
 bp=(BP)data;
 if((ret=aaSettingsRead(txt,str,&by,sizeof(dat),dat))!=YES)
  {
  if(bytes) { *bytes=0; }
  if(aaSettingsDestroy(txt)!=YES) { oof; return RET_FAILED; }
  return ret;
  }
 off=0;
 val=*(HP)&dat[off]; off+=4; // : the size of this structure
 if(val) {}
 if(bytes) { *bytes=by-off; }
 aaMemoryCopy(&bp[0],by-off,&dat[off]);
 return RET_YES;
 }





/*-----------------------------------------------------------------------*/



 B aaClipBoardTextWritef               (B global,VP fmt,...)
 {
 B ret;
 H sl;
 HGLOBAL h;
 CP string;
 va_list argptr;
 B txt[_16K+_8K];
 BP tmp=NULL_POINTR;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaCast(tmp,BP,txt);
 if(aa.is_ready==YES)
  {
  if((ret=aa_MemoryTemp((VP)&tmp,_128K,aa_MEMORYTEMP_ClipWritef))!=RET_YES) { return ret; }
  }
 aaFmt(fmt,argptr,tmp);
 if((ret=aaStringLen(tmp,&sl))!=RET_YES) { return ret; }
 tmp[sl]=NULL_CHAR;
 if((h=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sl+32))==NULL) { return RET_NOMEMORY; }
 if((string=GlobalLock(h))==NULL) {  GlobalFree(h);  return RET_FAILED; }
 aaStringCopy(string,tmp);
 if(GlobalUnlock(h)==TRUE) {  GlobalFree(h);  return RET_FAILED; }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE)  {  GlobalFree(h);  return RET_FAILED; }
 if(EmptyClipboard()==FALSE)  {  CloseClipboard();  GlobalFree(h);  return RET_FAILED; }
 if(SetClipboardData(CF_OEMTEXT,h)==NULL)  {  GlobalFree(h);  CloseClipboard();  return RET_FAILED; }
 if(CloseClipboard()==FALSE) {  GlobalFree(h);  return RET_FAILED; }
 return RET_YES;
 }



 B aaClipBoardTextWrite                (B global,H chars,VP text)
 {
 HGLOBAL h;
 CP string;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(text==NULL) { return RET_BADPARM; }
 if(chars==0) { aaStringLen(text,&chars); }
 global&=1;
 if(chars==0) { return(aaClipBoardDiscard(global)); }
 if((h=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,chars+32))==NULL) { return RET_NOMEMORY; }
 if((string=GlobalLock(h))==NULL) {  GlobalFree(h);  return RET_FAILED; }
 aaMemoryCopy(string,chars,text);
 if(GlobalUnlock(h)==TRUE) {  GlobalFree(h);  return RET_FAILED; }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE)  {  GlobalFree(h);  return RET_FAILED; }
 if(EmptyClipboard()==FALSE)  {  CloseClipboard();  GlobalFree(h);  return RET_FAILED; }
 if(SetClipboardData(CF_OEMTEXT,h)==NULL)  {  GlobalFree(h);  CloseClipboard();  return RET_FAILED; }
 if(CloseClipboard()==FALSE) {  GlobalFree(h);  return RET_FAILED; }
 return RET_YES;
 }




 B aaClipBoardTextRead                 (B global,HP chars,H maxchars,VP text)
 {
 HGLOBAL hh;
 CP string;
 H sl;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars!=NULL) { *chars=0; }
 if(maxchars!=0&&text==NULL) { return RET_BADPARM; }
 if(text!=NULL)  { aaStringNull(text); }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==0) { return RET_NOTREADY; }
 if((hh=GetClipboardData(CF_TEXT))==NULL) { CloseClipboard(); return RET_NOTREADY; }
 if((string=GlobalLock(hh))==NULL)  { oow; CloseClipboard(); return RET_FAILED; }
 aaStringLen(string,&sl);
 if(chars)                   { *chars=sl; }
 if(sl>maxchars)              { sl=maxchars; }
 if(sl!=0&&text!=NULL)        { aaStringNCopy(text,string,sl,YES);  }
 if(GlobalUnlock(hh)==FALSE)  { oow; CloseClipboard(); return RET_FAILED; }
 if(CloseClipboard()==FALSE)  { return RET_NOTREADY; }
 return RET_YES;
 }




 B aaClipBoardDiscard                  (B global)
 {
 BOOL x;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if((x=OpenClipboard(wnd))==FALSE) {  return RET_FAILED; }
 x=EmptyClipboard();
 CloseClipboard();
 if(x==FALSE) {  return RET_FAILED; }
 return RET_YES;
 }





 B aaClipBoardTextPaste                (B global,VP fmt,...)
 {
 B txt[_1K];
 va_list argptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 aaClipBoardTextWritef(global,"%s",txt);
 aaInputKeySimulate(VK_CONTROL,NO,YES);
 aaInputKeySimulate('V',NO,YES);
 aaSleep(30);
 aaInputKeySimulate('V',NO,NO);
 aaInputKeySimulate(VK_CONTROL,NO,NO);
 aaInputKeySimulate(VK_RETURN,NO,YES);
 aaSleep(30);
 aaInputKeySimulate(VK_RETURN,NO,NO);
 return RET_YES;
 }





 B aaClipBoardFileSet                  (B global,VP filename)
 {
 B ret;
 H sl,i,off;
 HGLOBAL h;
 BP string;
 B txt[_4K];
 BP bp;
 DROPFILES df;
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(filename==NULL) { return RET_BADPARM; }
 aaStringCopy(txt,filename);
 if((ret=aaStringLen(txt,&sl))!=RET_YES) { return ret; }
 if(sl==0) { return RET_BADPARM; }
 if((ret=aaFileInfoGet(txt,NULL,NULL,NULL,NULL,NULL))!=RET_YES) { return ret; }
 aaMemoryFill(&df,sizeof(df),0);
 df.pFiles=20;
 df.fWide=TRUE;
 if((h=GlobalAlloc(GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof(df)+((sl*2)+5)))==NULL) { return RET_NOMEMORY; }
 if((string=GlobalLock(h))==NULL) {  GlobalFree(h);  return RET_FAILED; }
 aaCast(bp,BP,string);
 aaMemoryCopy(bp,sizeof(df),&df);
 bp+=sizeof(df);
 off=0;
 for(i=0;i<sl;i++)
  {
  bp[off++]=txt[i];
  bp[off++]=0;
  }
 if(GlobalUnlock(h)==TRUE) {  GlobalFree(h);  return RET_FAILED; }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE)  {  GlobalFree(h);  return RET_FAILED; }
 if(EmptyClipboard()==FALSE)  {  CloseClipboard();  GlobalFree(h);  return RET_FAILED; }
 if(SetClipboardData(CF_HDROP,h)==NULL)  {  GlobalFree(h);  CloseClipboard();  return RET_FAILED; }
 if(CloseClipboard()==FALSE) {  GlobalFree(h);  return RET_FAILED; }
 return RET_YES;
 }




 B aaClipBoardFileRead                 (B global,HP chars,H maxchars,VP text)
 {
 HGLOBAL hh;
 H sl;
 H count;
 B tmp[_2K];
 HWND wnd;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(chars!=NULL) { *chars=0; }
 if(maxchars!=0&&text==NULL) { return RET_BADPARM; }
 if(text!=NULL) { aaStringNull(text); }
 if(global)  {  wnd=GetDesktopWindow();  } else { wnd=NULL; }
 if(OpenClipboard(wnd)==FALSE) { return RET_FAILED; }
 if((hh=GetClipboardData(CF_HDROP))==NULL) {  CloseClipboard(); return RET_NOTREADY; }
 count=DragQueryFile(hh,-1,NULL,0);
 if(count==0) {  CloseClipboard(); return RET_NOTREADY; }
 if(DragQueryFile(hh,0,(CP)tmp,_1K)!=0)
  {
  aaStringLen(tmp,&sl);
  if(chars) { *chars=sl; }
  if(sl>maxchars) { sl=maxchars; }
  if(sl!=0)  {  aaStringNCopy(text,tmp,sl,YES);  }
  }
 if(CloseClipboard()==FALSE)  {  return RET_FAILED; }
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/



 B aaIpcCreate                         (HP handle,B incoming,H bytes,VP name)
 {
 B ret;
 _aa_ipcobject*ipcp;
 B xname[_1K];
 _ipcramhdr ramhdr;
 _ipcramhdr*ramhdrptr;
 DWORD e;
 BP bp;
 _aa_objectinstanceheader*oih;
 Q v;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(aaStringIsNull(name)!=NO) { return RET_BADPARM; }
 if(incoming==YES)
  {
  if(bytes<4||bytes>_1MEG) { return RET_BOUNDS; }
  }
 else
  {
  if(bytes!=0) { return RET_BOUNDS; }
  }
 if((ret=aa_ObjectCreate(aa.ipc_system.object_id,handle,(VP)&ipcp))!=RET_YES) { oops; return ret; }
 ipcp->self_handle=*handle;
 ipcp->object_handle=NULL;
 ipcp->mutex_handle=NULL;
 ipcp->page_memory=NULL;
 ipcp->status.is_exited=NO;
 aaStringCopy(xname,name);

 if(incoming==YES)//||incoming==EITHER)
  {
  while(1)
   {
   //bytes=aa_IPCUSER_BYTES+sizeof(_ipcramhdr);
   if((ipcp->object_handle=CreateFileMapping((HANDLE)F32,NULL,PAGE_EXECUTE_READWRITE,0,bytes+sizeof(_ipcramhdr),(LPCTSTR)xname))==NULL) { ret=RET_FAILED; break; }
   e=GetLastError();
   if(e==ERROR_ALREADY_EXISTS) { ret=RET_EXISTS; break; }
   if(e!=0) { ret=RET_FAILED; break; }
   if((ipcp->page_memory=MapViewOfFile(ipcp->object_handle,FILE_MAP_ALL_ACCESS,0,0,bytes+sizeof(_ipcramhdr)))==NULL) { ret=RET_FAILED; break; }
   xname[0]+=(B)1; ipcp->mutex_handle=CreateMutex(NULL,TRUE,(LPCTSTR)xname);  xname[0]-=(B)1;
   e=GetLastError();
   if(ipcp->mutex_handle==NULL)  {   if(e==ERROR_ALREADY_EXISTS||e==ERROR_INVALID_HANDLE)  {oof; }    ret=RET_FAILED;    break;    }
   if(e!=0) {  ret=RET_FAILED; break; }
   aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);
   ramhdrptr->total_bytes=bytes+sizeof(_ipcramhdr);
   ramhdrptr->user_bytes=bytes;//ramhdrptr->total_bytes-sizeof(_ipcramhdr);
   ipcp->status.is_incoming=YES;
   ipcp->status.is_locked=YES;
   ret=RET_YES;
   break;
   }
  }
 //else
 if(incoming==NO)//||incoming==EITHER)
  {
  while(1)
   {
   if(incoming==EITHER&&ipcp->status.is_locked==YES&&ret==RET_YES) { oof; break; }  // either mode worked, so skip
   ipcp->object_handle=OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,(LPCTSTR)xname);
   e=GetLastError();

   if(ipcp->object_handle==NULL&&e==ERROR_FILE_NOT_FOUND) {  ret=RET_NOTFOUND; break; }
   if(ipcp->object_handle==NULL&&e!=ERROR_FILE_NOT_FOUND) {  ret=RET_FAILED; break; }
   //bytes=sizeof(_ipcramhdr);
   if((ipcp->page_memory=MapViewOfFile(ipcp->object_handle,FILE_MAP_ALL_ACCESS,0,0,sizeof(_ipcramhdr)))==NULL) { oof; ret=RET_FAILED;  break; }
   aaMemoryCopy(&ramhdr,sizeof(_ipcramhdr),ipcp->page_memory);
   bytes=ramhdr.user_bytes;
   if(UnmapViewOfFile(ipcp->page_memory)!=TRUE) { oof; }
   if(bytes<4||bytes>_1MEG) { oof; return RET_BOUNDS; }
   ipcp->page_memory=NULL;
   if((ipcp->page_memory=MapViewOfFile(ipcp->object_handle,FILE_MAP_ALL_ACCESS,0,0,bytes+sizeof(_ipcramhdr)))==NULL) { ret=RET_FAILED;  break; }
   xname[0]+=(B)1; ipcp->mutex_handle=OpenMutex(MUTEX_ALL_ACCESS,FALSE,(LPCTSTR)xname); xname[0]-=(B)1;
   e=GetLastError();
   if(ipcp->mutex_handle==NULL) { aaNote(0,"e=%i",e); ret=RET_FAILED; break; }
   ipcp->status.is_incoming=NO;
   ipcp->status.is_locked=NO;
   ret=RET_YES;
   break;
   }
  }
 if(ret!=YES)
  {
  if(ipcp->mutex_handle!=NULL) { CloseHandle(ipcp->mutex_handle); ipcp->mutex_handle=NULL; }
  if(ipcp->page_memory!=NULL) {  if(UnmapViewOfFile(ipcp->page_memory)!=TRUE) { oof; } ipcp->page_memory=NULL; }
  if(ipcp->object_handle!=NULL) { CloseHandle(ipcp->object_handle); ipcp->object_handle=NULL; }
  aa_ObjectDestroy(aa.ipc_system.object_id,*handle);
  *handle=0;
  return ret;
  }
 aaCast(bp,BP,ipcp);
 bp-=sizeof(_aa_objectinstanceheader);
 aaCast(oih,_aa_objectinstanceheader*,bp);
 aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);
// aaQuadSet(&ipcp->status.session,oih->sesh.lo,aa.core_system.process_id);
 //v=((Q)aa.core_system.process_id<<32);
 v=(Q)aa.core_system.process_id<<32;//*42949672946;
 v=(v+(oih->sesh>>32));
 ipcp->status.session=v;//(aa.core_system.process_id<<32)+(H)(oih->sesh>>32);//session,oih->sesh; //ashod
 ipcp->status.bytes=ramhdrptr->user_bytes;
 aa_ObjectHandleToIndex(aa.ipc_system.object_id,*handle,&ipcp->status.index);
 return RET_YES;
 }



 B aaIpcDestroy                        (H handle)
 {
 B ret;
 _aa_ipcobject*ipcp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.ipc_system.object_id,handle,(VP)&ipcp,&isprot))!=RET_YES) { return ret; }
 if(isprot) { return RET_FORBIDDEN; }
 if(UnmapViewOfFile(ipcp->page_memory)!=TRUE) { oof; }
 CloseHandle(ipcp->object_handle);
 aa_ObjectDestroy(aa.ipc_system.object_id,handle);
 return RET_YES;
 }





 B aaIpcStatus                         (H handle,_ipcstatus*ipcstatus,B logicstate)
 {
 B ret;
 _aa_ipcobject*ipcp;
 DWORD res;
 _ipcramhdr*ramhdrptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 //if(ram) { *ram=NULL; }
 if((ret=aa_ObjectCheck(aa.ipc_system.object_id,handle,(VP)&ipcp,NULL))!=RET_YES) { return ret; }
 aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);
 ipcp->status.hog_level=ramhdrptr->lock_deny_count;
 if(ipcstatus)
  {
  aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status);
  ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)];
  }
 //if(ram)        { *ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
 if(logicstate>aa_IPCLOGICSTATE_Both) { return RET_BADPARM; }
 if(logicstate==aa_IPCLOGICSTATE_None)  {  return RET_YES;  }
 aaCast(ramhdrptr,_ipcramhdr*,&ipcp->page_memory[0]);
 // why would i do a lock+release at the same time ??  - im sure there was a reason
 if(aaBitGet(logicstate,0)) // lock
  {
  if(ipcp->status.is_locked==YES) { return RET_YES; }
  if((res=WaitForSingleObject(ipcp->mutex_handle,0))==WAIT_FAILED) { oof; oow; oof; return RET_FAILED; }
  if(res==WAIT_TIMEOUT)
   {
   ramhdrptr->lock_deny_count++;
   ipcp->status.hog_level=ramhdrptr->lock_deny_count;
   if(ipcstatus)  { ipcstatus->hog_level=ipcp->status.hog_level; }
   return RET_DENIED;
   }
  if(res==WAIT_ABANDONED)
   {
   ipcp->status.is_locked=NO;
   ipcp->status.is_exited=YES;
   if(ipcstatus)  { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status); }
   if(ipcstatus)  { ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
//   if(ram)        { *ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
   }
  else
   {
   if(res!=WAIT_OBJECT_0)  { oof; oow; oof; }
   ipcp->status.is_locked=YES;
   ipcp->status.hog_level=ramhdrptr->lock_deny_count;
   if(ipcstatus)  { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status); }
   if(ipcstatus)  { ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
//   if(ram)        { *ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
   }
  }

 if(aaBitGet(logicstate,1)) // release
  {
  if(ipcp->status.is_locked==NO)   {   return RET_YES;   }
  ramhdrptr->lock_deny_count=0;
  if(ReleaseMutex(ipcp->mutex_handle)==0) { oof; oow; oof; return RET_FAILED; }
  ipcp->status.is_locked=NO;
  ipcp->status.hog_level=ramhdrptr->lock_deny_count;
  if(ipcstatus)  { aaMemoryCopy(ipcstatus,sizeof(_ipcstatus),&ipcp->status); }
  if(ipcstatus)  { ipcstatus->ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
  //if(ram)        { *ram=&ipcp->page_memory[sizeof(_ipcramhdr)]; }
  }
 return RET_YES;
 }




/*-----------------------------------------------------------------------*/





 B aaDesktopCreate                     (HP handle,VP fmt,...)
 {
 B ret;
 _aa_desktopobject*detp;
 va_list argptr;
 B txt[_2K];
 H sl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 aaFmt(fmt,argptr,txt);
 if(handle==NULL) { return RET_BADPARM; }
 *handle=0;
 aaStringLen(txt,&sl);
 if(sl<4||sl>63) { return RET_BADPARM; }
 if((ret=aa_ObjectCreate(aa.desktop_system.object_id,handle,(VP)&detp))!=RET_YES) { oops; return ret; }
 detp->self_handle=*handle;
 aaStringCopy(detp->status.name,txt);
 detp->thread_id=GetCurrentThreadId();
 detp->original_handle=GetThreadDesktop(detp->thread_id);
 detp->desk_handle=CreateDesktop((CP)txt,0,0,0,GENERIC_ALL,0);
 detp->status.tid=detp->thread_id;
 detp->status.initial_handle=detp->original_handle;
 detp->status.desktop_handle=detp->desk_handle;
 detp->status.is_active=NO;
 return RET_YES;
 }



 B aaDesktopDestroy                    (H handle)
 {
 B ret;
 _aa_desktopobject*detp;
 B isprot;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.desktop_system.object_id,handle,(VP)&detp,&isprot))!=RET_YES) { return ret; }
 if(isprot==YES) { return RET_FORBIDDEN; }
 aa_ObjectDestroy(aa.desktop_system.object_id,handle);
 return RET_YES;
 }



 B aaDesktopStatus                     (H handle,_desktopstatus*desktopstatus)
 {
 B ret;
 _aa_desktopobject*detp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.desktop_system.object_id,handle,(VP)&detp,NULL))!=RET_YES) { return ret; }
 if(desktopstatus)  {  aaMemoryCopy(desktopstatus,sizeof(_desktopstatus),&detp->status); }
 return RET_YES;
 }


 B aaDesktopSwitch                     (H handle,B state)
 {
 B ret;
 _aa_desktopobject*detp;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if((ret=aa_ObjectCheck(aa.desktop_system.object_id,handle,(VP)&detp,NULL))!=RET_YES) { return ret; }
 if(state)
  {
  if(detp->status.is_active==NO)
   {
   SwitchDesktop(detp->desk_handle);
   detp->status.is_active=YES;
   }
  }
 else
  {
  if(detp->status.is_active==YES)
   {
   SwitchDesktop(detp->original_handle);
   detp->status.is_active=NO;
   }
  }
 return RET_YES;
 }


/*-----------------------------------------------------------------------*/

 structure
 {
 B name[50];
 H name_len;
 H proc_len;
 VP proc;
 }
 _vmprocentry;

/*-----------------------------------------------------------------------*/


 B aaVmNew                             (_vm*vm)
 {
 B ret;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 aaMemoryFill(vm,sizeof(_vm),0);
 vm->magic=(H)(PP)aaVmNew;
 aaVmRamSwap(vm,NULL,NULL);
 if((ret=aaVectorNew(&vm->proc_data,sizeof(_vmprocentry),2000))!=YES) { oops; }
 vm->is_sys_func=YES;

 aaVmProcAdd(vm,0,"aaDummyFunction1",&aaDummyFunction1);
 aaVmProcAdd(vm,0,"aaDummyFunction2",&aaDummyFunction2);
 aaVmProcAdd(vm,0,"aaStart",&aaStart);
 aaVmProcAdd(vm,0,"aaStop",&aaStop);
 aaVmProcAdd(vm,0,"aaExitCodeSet",&aaExitCodeSet);
 aaVmProcAdd(vm,0,"aaMain",&aaMain);
 aaVmProcAdd(vm,0,"aaAbort",&aaAbort);
 aaVmProcAdd(vm,0,"aaQuit",&aaQuit);
 aaVmProcAdd(vm,0,"aaTrace",&aaTrace);
 aaVmProcAdd(vm,0,"aaTraceFileSet",&aaTraceFileSet);
 aaVmProcAdd(vm,0,"aaCallStackGet",&aaCallStackGet);
 aaVmProcAdd(vm,0,"aaCpuIdGet",&aaCpuIdGet);
 aaVmProcAdd(vm,0,"aaMsRunning",&aaMsRunning);
 aaVmProcAdd(vm,0,"aaMicrosecsRunning",&aaMicrosecsRunning);
 aaVmProcAdd(vm,0,"aaConsoleAttach",&aaConsoleAttach);
 aaVmProcAdd(vm,0,"aaConsoleDetach",&aaConsoleDetach);
 aaVmProcAdd(vm,0,"aaConsolePrintf",&aaConsolePrintf);
 aaVmProcAdd(vm,0,"aaLog",&aaLog);
 aaVmProcAdd(vm,0,"aaLogX",&aaLogX);
 aaVmProcAdd(vm,0,"aaAaFilesBackup",&aaAaFilesBackup);
 aaVmProcAdd(vm,0,"aaAaFilesDelete",&aaAaFilesDelete);
 aaVmProcAdd(vm,0,"aaAaFilesBackupOnSize",&aaAaFilesBackupOnSize);
 aaVmProcAdd(vm,0,"aaAaFilesDeleteOnSize",&aaAaFilesDeleteOnSize);
 aaVmProcAdd(vm,0,"aaHistory",&aaHistory);
 aaVmProcAdd(vm,0,"aaJournal",&aaJournal);
 aaVmProcAdd(vm,0,"aaNotes",&aaNotes);
 aaVmProcAdd(vm,0,"aaBeep",&aaBeep);
 aaVmProcAdd(vm,0,"aaWinErrorGet",&aaWinErrorGet);
 aaVmProcAdd(vm,0,"aaWinEventLog",&aaWinEventLog);
 aaVmProcAdd(vm,0,"aaNote",&aaNote);
 aaVmProcAdd(vm,0,"aaNotex",&aaNotex);
 aaVmProcAdd(vm,0,"aaField",&aaField);
 aaVmProcAdd(vm,0,"aaYesNoBox",&aaYesNoBox);
 aaVmProcAdd(vm,0,"aaSleep",&aaSleep);
 aaVmProcAdd(vm,0,"aaSleepPrecise",&aaSleepPrecise);
 aaVmProcAdd(vm,0,"aaSleepHz",&aaSleepHz);
 aaVmProcAdd(vm,0,"aaSleepLoad",&aaSleepLoad);
 aaVmProcAdd(vm,0,"aaStageSet",&aaStageSet);
 aaVmProcAdd(vm,0,"aaStageAndNextSet",&aaStageAndNextSet);
 aaVmProcAdd(vm,0,"aaStageAdjust",&aaStageAdjust);
 aaVmProcAdd(vm,0,"aaStagePrev",&aaStagePrev);
 aaVmProcAdd(vm,0,"aaStageNext",&aaStageNext);
 aaVmProcAdd(vm,0,"aaFocusToDbg",&aaFocusToDbg);
 aaVmProcAdd(vm,0,"aaFocusToBorland",&aaFocusToBorland);
 aaVmProcAdd(vm,0,"aaFocusToCodeBlocks",&aaFocusToCodeBlocks);
 aaVmProcAdd(vm,0,"aaFocusToFirefox",&aaFocusToFirefox);
 aaVmProcAdd(vm,0,"aaFocusToHwnd",&aaFocusToHwnd);
 aaVmProcAdd(vm,0,"aaHwndGroupGet",&aaHwndGroupGet);
 aaVmProcAdd(vm,0,"aaHwndInfoGet",&aaHwndInfoGet);
 aaVmProcAdd(vm,0,"aaHwndIsObscured",&aaHwndIsObscured);
 aaVmProcAdd(vm,0,"aaIsRemoteSession",&aaIsRemoteSession);
 aaVmProcAdd(vm,0,"aaIsDebug",&aaIsDebug);
 aaVmProcAdd(vm,0,"aaIsRemoteDebug",&aaIsRemoteDebug);
 aaVmProcAdd(vm,0,"aaIsProfiling",&aaIsProfiling);
 aaVmProcAdd(vm,0,"aaProfilingPause",&aaProfilingPause);
 aaVmProcAdd(vm,0,"aaDebugf",&aaDebugf);
 aaVmProcAdd(vm,0,"aaDebugfBlankLine",&aaDebugfBlankLine);
 aaVmProcAdd(vm,0,"aaDebugfLogWriteSet",&aaDebugfLogWriteSet);
 aaVmProcAdd(vm,0,"aaDebugfLogStyleSet",&aaDebugfLogStyleSet);
 aaVmProcAdd(vm,0,"aaDebugfMemoryDump",&aaDebugfMemoryDump);
 aaVmProcAdd(vm,0,"aaLimiterSet",&aaLimiterSet);
 aaVmProcAdd(vm,0,"aaLimiterCheck",&aaLimiterCheck);
 aaVmProcAdd(vm,0,"aaLimiterPost",&aaLimiterPost);
 aaVmProcAdd(vm,0,"aaLimiterPostf",&aaLimiterPostf);
 aaVmProcAdd(vm,0,"aaLimiterNullProc",&aaLimiterNullProc);
 aaVmProcAdd(vm,0,"aaRetroMain",&aaRetroMain);
 aaVmProcAdd(vm,0,"aaMorph",&aaMorph);
 aaVmProcAdd(vm,0,"aaRestart",&aaRestart);
 aaVmProcAdd(vm,0,"aaReboot",&aaReboot);
 aaVmProcAdd(vm,0,"aaRoutineAdd",&aaRoutineAdd);
 aaVmProcAdd(vm,0,"aaCopyDataProcSet",&aaCopyDataProcSet);
 aaVmProcAdd(vm,0,"aaCopyDataPost",&aaCopyDataPost);
 aaVmProcAdd(vm,0,"aaYieldRaw",&aaYieldRaw);
 aaVmProcAdd(vm,0,"aaYield",&aaYield);
 aaVmProcAdd(vm,0,"aaSwitch",&aaSwitch);
 aaVmProcAdd(vm,0,"aaCheck",&aaCheck);
 aaVmProcAdd(vm,0,"aaJump",&aaJump);
 aaVmProcAdd(vm,0,"aaFall",&aaFall);
 aaVmProcAdd(vm,0,"aaSubStageInit",&aaSubStageInit);
 aaVmProcAdd(vm,0,"aaSubStageSet",&aaSubStageSet);
 aaVmProcAdd(vm,0,"aaSubStageAdjust",&aaSubStageAdjust);
 aaVmProcAdd(vm,0,"aaSubStagePrev",&aaSubStagePrev);
 aaVmProcAdd(vm,0,"aaSubStageNext",&aaSubStageNext);
 aaVmProcAdd(vm,0,"aaSubStageNextSet",&aaSubStageNextSet);
 aaVmProcAdd(vm,0,"aaSubStageAndNextSet",&aaSubStageAndNextSet);
 aaVmProcAdd(vm,0,"aaFlagMapInit",&aaFlagMapInit);
 aaVmProcAdd(vm,0,"aaFlagMapSet",&aaFlagMapSet);
 aaVmProcAdd(vm,0,"aaFlagMapCheckSet",&aaFlagMapCheckSet);
 aaVmProcAdd(vm,0,"aaFlagMapClear",&aaFlagMapClear);
 aaVmProcAdd(vm,0,"aaFlagMapCheck",&aaFlagMapCheck);
 aaVmProcAdd(vm,0,"aaFlagMapAck",&aaFlagMapAck);
 aaVmProcAdd(vm,0,"aaTimerNull",&aaTimerNull);
 aaVmProcAdd(vm,0,"aaTimerInit",&aaTimerInit);
 aaVmProcAdd(vm,0,"aaTimerUpdate",&aaTimerUpdate);
 aaVmProcAdd(vm,0,"aaTimerPulse",&aaTimerPulse);
 aaVmProcAdd(vm,0,"aaTimerElapsed",&aaTimerElapsed);
 aaVmProcAdd(vm,0,"aaTimerAdjust",&aaTimerAdjust);
 aaVmProcAdd(vm,0,"aaTimerProfilerNull",&aaTimerProfilerNull);
 aaVmProcAdd(vm,0,"aaTimerProfilerInit",&aaTimerProfilerInit);
 aaVmProcAdd(vm,0,"aaTimerProfilerUpdate",&aaTimerProfilerUpdate);
 aaVmProcAdd(vm,0,"aaTimerProfilerAdjust",&aaTimerProfilerAdjust);
 aaVmProcAdd(vm,0,"aaTimerProfilerPulse",&aaTimerProfilerPulse);
 aaVmProcAdd(vm,0,"aaTimerProfilerRead",&aaTimerProfilerRead);
 aaVmProcAdd(vm,0,"aaTimerProfilerGet",&aaTimerProfilerGet);
 aaVmProcAdd(vm,0,"aaTimerProfilerElapsed",&aaTimerProfilerElapsed);
 aaVmProcAdd(vm,0,"aaTimerCalculate",&aaTimerCalculate);
 aaVmProcAdd(vm,0,"aaTimerTikGet",&aaTimerTikGet);
 aaVmProcAdd(vm,0,"aaTimerTikAdjust",&aaTimerTikAdjust);
 aaVmProcAdd(vm,0,"aaTimerTikElapsed",&aaTimerTikElapsed);
 aaVmProcAdd(vm,0,"aaTimerTikElapsedUsingTik",&aaTimerTikElapsedUsingTik);
 aaVmProcAdd(vm,0,"aaTimerTikToDuration",&aaTimerTikToDuration);
 aaVmProcAdd(vm,0,"aaTimerMsToDuration",&aaTimerMsToDuration);
 aaVmProcAdd(vm,0,"aaTimerPrimitive",&aaTimerPrimitive);
 aaVmProcAdd(vm,0,"aaTimeNull",&aaTimeNull);
 aaVmProcAdd(vm,0,"aaTimeIsNull",&aaTimeIsNull);
 aaVmProcAdd(vm,0,"aaTimeIsValid",&aaTimeIsValid);
 aaVmProcAdd(vm,0,"aaTimeEqualsTime",&aaTimeEqualsTime);
 aaVmProcAdd(vm,0,"aaTimeCopy",&aaTimeCopy);
 aaVmProcAdd(vm,0,"aaTimeSet",&aaTimeSet);
 aaVmProcAdd(vm,0,"aaTimeLocalGet",&aaTimeLocalGet);
 aaVmProcAdd(vm,0,"aaTimeSystemGet",&aaTimeSystemGet);
 aaVmProcAdd(vm,0,"aaTimeApply",&aaTimeApply);
 aaVmProcAdd(vm,0,"aaTimeToCookieTimeString",&aaTimeToCookieTimeString);
 aaVmProcAdd(vm,0,"aaTimeDayOfWeekGet",&aaTimeDayOfWeekGet);
 aaVmProcAdd(vm,0,"aaTimeFirstDayOfMonthGet",&aaTimeFirstDayOfMonthGet);
 aaVmProcAdd(vm,0,"aaTimeIsLeapYear",&aaTimeIsLeapYear);
 aaVmProcAdd(vm,0,"aaTimeDaysInMonthGet",&aaTimeDaysInMonthGet);
 aaVmProcAdd(vm,0,"aaTimeToString",&aaTimeToString);
 aaVmProcAdd(vm,0,"aaTimeFromString",&aaTimeFromString);
 aaVmProcAdd(vm,0,"aaTimeCompare",&aaTimeCompare);
 aaVmProcAdd(vm,0,"aaTimeAdjust",&aaTimeAdjust);
 aaVmProcAdd(vm,0,"aaTimeMsRunning",&aaTimeMsRunning);
 aaVmProcAdd(vm,0,"aaTimeLaunchTikGet",&aaTimeLaunchTikGet);
 aaVmProcAdd(vm,0,"aaTimeUtcGet",&aaTimeUtcGet);
 aaVmProcAdd(vm,0,"aaTimeSecsToDuration",&aaTimeSecsToDuration);
 aaVmProcAdd(vm,0,"aaTimeToUnixTime",&aaTimeToUnixTime);
 aaVmProcAdd(vm,0,"aaTimeFromUnixTime",&aaTimeFromUnixTime);
 aaVmProcAdd(vm,0,"aaTimeGetOfDay",&aaTimeGetOfDay);
 aaVmProcAdd(vm,0,"aaGeoLookup",&aaGeoLookup);
 aaVmProcAdd(vm,0,"aaGeoCountryNameToIndex",&aaGeoCountryNameToIndex);
 aaVmProcAdd(vm,0,"aaGeoCountryCodeToIndex",&aaGeoCountryCodeToIndex);
 aaVmProcAdd(vm,0,"aaMemoryStatus",&aaMemoryStatus);
 aaVmProcAdd(vm,0,"aaMemoryTableGet",&aaMemoryTableGet);
 aaVmProcAdd(vm,0,"aaMemoryZero",&aaMemoryZero);
 aaVmProcAdd(vm,0,"aaMemoryFill",&aaMemoryFill);
 aaVmProcAdd(vm,0,"aaMemoryCopy",&aaMemoryCopy);
 aaVmProcAdd(vm,0,"aaMemoryMove",&aaMemoryMove);
 aaVmProcAdd(vm,0,"aaMemorySwap",&aaMemorySwap);
 aaVmProcAdd(vm,0,"aaMemoryTemp",&aaMemoryTemp);
 aaVmProcAdd(vm,0,"aaMemoryAllocate",&aaMemoryAllocate);
 aaVmProcAdd(vm,0,"aaMemoryReAllocate",&aaMemoryReAllocate);
 aaVmProcAdd(vm,0,"aaMemoryResize",&aaMemoryResize);
 aaVmProcAdd(vm,0,"aaMemoryDuplicate",&aaMemoryDuplicate);
 aaVmProcAdd(vm,0,"aaMemoryMake",&aaMemoryMake);
 aaVmProcAdd(vm,0,"aaMemoryIsAllocated",&aaMemoryIsAllocated);
 aaVmProcAdd(vm,0,"aaMemoryNameSet",&aaMemoryNameSet);
 aaVmProcAdd(vm,0,"aaMemoryNameGet",&aaMemoryNameGet);
 aaVmProcAdd(vm,0,"aaMemoryBytesGet",&aaMemoryBytesGet);
 aaVmProcAdd(vm,0,"aaMemoryBlockGet",&aaMemoryBlockGet);
 aaVmProcAdd(vm,0,"aaMemoryRelease",&aaMemoryRelease);
 aaVmProcAdd(vm,0,"aaMemoryAdlerCrcGet",&aaMemoryAdlerCrcGet);
 aaVmProcAdd(vm,0,"aaMemoryCrcGet",&aaMemoryCrcGet);
 aaVmProcAdd(vm,0,"aaMemoryCrc64Get",&aaMemoryCrc64Get);
 aaVmProcAdd(vm,0,"aaMemoryHashGet",&aaMemoryHashGet);
 aaVmProcAdd(vm,0,"aaMemoryValueFill",&aaMemoryValueFill);
 aaVmProcAdd(vm,0,"aaMemoryPokeByte",&aaMemoryPokeByte);
 aaVmProcAdd(vm,0,"aaMemoryPokeWord",&aaMemoryPokeWord);
 aaVmProcAdd(vm,0,"aaMemoryPokeDword",&aaMemoryPokeDword);
 aaVmProcAdd(vm,0,"aaMemoryPokeQuad",&aaMemoryPokeQuad);
 aaVmProcAdd(vm,0,"aaMemoryPeekByte",&aaMemoryPeekByte);
 aaVmProcAdd(vm,0,"aaMemoryPeekWord",&aaMemoryPeekWord);
 aaVmProcAdd(vm,0,"aaMemoryPeekDword",&aaMemoryPeekDword);
 aaVmProcAdd(vm,0,"aaMemoryPokeDwordAndInc",&aaMemoryPokeDwordAndInc);
 aaVmProcAdd(vm,0,"aaMemoryPeekDwordAndInc",&aaMemoryPeekDwordAndInc);
 aaVmProcAdd(vm,0,"aaMemoryCompare",&aaMemoryCompare);
 aaVmProcAdd(vm,0,"aaMemoryRandomSet",&aaMemoryRandomSet);
 aaVmProcAdd(vm,0,"aaMemoryRandomDwordSet",&aaMemoryRandomDwordSet);
 aaVmProcAdd(vm,0,"aaMemoryRandomHit",&aaMemoryRandomHit);
 aaVmProcAdd(vm,0,"aaMemoryPageAllocate",&aaMemoryPageAllocate);
 aaVmProcAdd(vm,0,"aaMemoryPageRelease",&aaMemoryPageRelease);
 aaVmProcAdd(vm,0,"aaMemoryPageProtect",&aaMemoryPageProtect);
 aaVmProcAdd(vm,0,"aaMemoryPageGet",&aaMemoryPageGet);
 aaVmProcAdd(vm,0,"aaMemoryCodeAllocate",&aaMemoryCodeAllocate);
 aaVmProcAdd(vm,0,"aaMemoryCodeRelease",&aaMemoryCodeRelease);
 aaVmProcAdd(vm,0,"aaMemorySearch",&aaMemorySearch);
 aaVmProcAdd(vm,0,"aaMemorySort",&aaMemorySort);
 aaVmProcAdd(vm,0,"aaMemoryCompareProc",&aaMemoryCompareProc);
 aaVmProcAdd(vm,0,"aaMemoryOrderSort",&aaMemoryOrderSort);
 aaVmProcAdd(vm,0,"aaMemoryUnitAllocate",&aaMemoryUnitAllocate);
 aaVmProcAdd(vm,0,"aaMemoryUnitReAllocate",&aaMemoryUnitReAllocate);
 aaVmProcAdd(vm,0,"aaMemoryUnitMake",&aaMemoryUnitMake);
 aaVmProcAdd(vm,0,"aaMemoryUnitRelease",&aaMemoryUnitRelease);
 aaVmProcAdd(vm,0,"aaMemoryWorkingSetSizeSet",&aaMemoryWorkingSetSizeSet);
 aaVmProcAdd(vm,0,"aaMemoryWorkingSetFlush",&aaMemoryWorkingSetFlush);
 aaVmProcAdd(vm,0,"aaMemoryModuleLoad",&aaMemoryModuleLoad);
 aaVmProcAdd(vm,0,"aaMemoryModuleRelease",&aaMemoryModuleRelease);
 aaVmProcAdd(vm,0,"aaMemoryModuleAttach",&aaMemoryModuleAttach);
 aaVmProcAdd(vm,0,"aaScrapNew",&aaScrapNew);
 aaVmProcAdd(vm,0,"aaScrapDelete",&aaScrapDelete);
 aaVmProcAdd(vm,0,"aaScrapBytesGet",&aaScrapBytesGet);
 aaVmProcAdd(vm,0,"aaScrapInfoFromMemory",&aaScrapInfoFromMemory);
 aaVmProcAdd(vm,0,"aaScrapInfoFromOffset",&aaScrapInfoFromOffset);
 aaVmProcAdd(vm,0,"aaScrapAllocate",&aaScrapAllocate);
 aaVmProcAdd(vm,0,"aaScrapReAllocate",&aaScrapReAllocate);
 aaVmProcAdd(vm,0,"aaScrapRelease",&aaScrapRelease);
 aaVmProcAdd(vm,0,"aaGroupofCreate",&aaGroupofCreate);
 aaVmProcAdd(vm,0,"aaGroupofDestroy",&aaGroupofDestroy);
 aaVmProcAdd(vm,0,"aaGroupofNew",&aaGroupofNew);
 aaVmProcAdd(vm,0,"aaGroupofGet",&aaGroupofGet);
 aaVmProcAdd(vm,0,"aaSerialMemNew",&aaSerialMemNew);
 aaVmProcAdd(vm,0,"aaSerialMemDelete",&aaSerialMemDelete);
 aaVmProcAdd(vm,0,"aaSerialMemMalloc",&aaSerialMemMalloc);
 aaVmProcAdd(vm,0,"aaSerialMemFree",&aaSerialMemFree);
 aaVmProcAdd(vm,0,"aaSerialMemInfoToString",&aaSerialMemInfoToString);
 aaVmProcAdd(vm,0,"aaSerialMemMap",&aaSerialMemMap);
 aaVmProcAdd(vm,0,"aaSerialMemUnMap",&aaSerialMemUnMap);
 aaVmProcAdd(vm,0,"aaSerialMemPhys",&aaSerialMemPhys);
 aaVmProcAdd(vm,0,"aaSerialMemVirt",&aaSerialMemVirt);
 aaVmProcAdd(vm,0,"aaBloomNew",&aaBloomNew);
 aaVmProcAdd(vm,0,"aaBloomLoad",&aaBloomLoad);
 aaVmProcAdd(vm,0,"aaBloomDelete",&aaBloomDelete);
 aaVmProcAdd(vm,0,"aaBloomSave",&aaBloomSave);
 aaVmProcAdd(vm,0,"aaBloomFind",&aaBloomFind);
 aaVmProcAdd(vm,0,"aaBloomFindf",&aaBloomFindf);
 aaVmProcAdd(vm,0,"aaBloomAdd",&aaBloomAdd);
 aaVmProcAdd(vm,0,"aaBloomAddf",&aaBloomAddf);
 aaVmProcAdd(vm,0,"aaChainNew",&aaChainNew);
 aaVmProcAdd(vm,0,"aaChainDelete",&aaChainDelete);
 aaVmProcAdd(vm,0,"aaChainLinkClear",&aaChainLinkClear);
 aaVmProcAdd(vm,0,"aaChainLinkNew",&aaChainLinkNew);
 aaVmProcAdd(vm,0,"aaChainLinkLengthSet",&aaChainLinkLengthSet);
 aaVmProcAdd(vm,0,"aaChainLinkSet",&aaChainLinkSet);
 aaVmProcAdd(vm,0,"aaChainLinkGet",&aaChainLinkGet);
 aaVmProcAdd(vm,0,"aaChainLinkTraverse",&aaChainLinkTraverse);
 aaVmProcAdd(vm,0,"aaChainLinkInsert",&aaChainLinkInsert);
 aaVmProcAdd(vm,0,"aaChainLinkRemove",&aaChainLinkRemove);
 aaVmProcAdd(vm,0,"aaSorterNew",&aaSorterNew);
 aaVmProcAdd(vm,0,"aaSorterDelete",&aaSorterDelete);
 aaVmProcAdd(vm,0,"aaSorterSort",&aaSorterSort);
 aaVmProcAdd(vm,0,"aaListNew",&aaListNew);
 aaVmProcAdd(vm,0,"aaListOpen",&aaListOpen);
 aaVmProcAdd(vm,0,"aaListSave",&aaListSave);
 aaVmProcAdd(vm,0,"aaListClone",&aaListClone);
 aaVmProcAdd(vm,0,"aaListDelete",&aaListDelete);
 aaVmProcAdd(vm,0,"aaListAppend",&aaListAppend);
 aaVmProcAdd(vm,0,"aaListAppendf",&aaListAppendf);
 aaVmProcAdd(vm,0,"aaListFind",&aaListFind);
 aaVmProcAdd(vm,0,"aaListRemove",&aaListRemove);
 aaVmProcAdd(vm,0,"aaListPointerGet",&aaListPointerGet);
 aaVmProcAdd(vm,0,"aaListPointerGetByNumber",&aaListPointerGetByNumber);
 aaVmProcAdd(vm,0,"aaListReset",&aaListReset);
 aaVmProcAdd(vm,0,"aaOptionsNew",&aaOptionsNew);
 aaVmProcAdd(vm,0,"aaOptionsDelete",&aaOptionsDelete);
 aaVmProcAdd(vm,0,"aaOptionsSet",&aaOptionsSet);
 aaVmProcAdd(vm,0,"aaOptionsGet",&aaOptionsGet);
 aaVmProcAdd(vm,0,"aaDataAllocate",&aaDataAllocate);
 aaVmProcAdd(vm,0,"aaDataRelease",&aaDataRelease);
 aaVmProcAdd(vm,0,"aaDataReset",&aaDataReset);
 aaVmProcAdd(vm,0,"aaDataFieldAdd",&aaDataFieldAdd);
 aaVmProcAdd(vm,0,"aaDataFieldRemove",&aaDataFieldRemove);
 aaVmProcAdd(vm,0,"aaDataFieldWrite",&aaDataFieldWrite);
 aaVmProcAdd(vm,0,"aaDataFieldWritef",&aaDataFieldWritef);
 aaVmProcAdd(vm,0,"aaDataFieldRead",&aaDataFieldRead);
 aaVmProcAdd(vm,0,"aaDataFieldSizeSet",&aaDataFieldSizeSet);
 aaVmProcAdd(vm,0,"aaDataFieldInfoGetByNumber",&aaDataFieldInfoGetByNumber);
 aaVmProcAdd(vm,0,"aaDataFieldInfoGetByAlias",&aaDataFieldInfoGetByAlias);
 aaVmProcAdd(vm,0,"aaDataFieldInfoGetByIndex",&aaDataFieldInfoGetByIndex);
 aaVmProcAdd(vm,0,"aaStringNull",&aaStringNull);
 aaVmProcAdd(vm,0,"aaStringIsNull",&aaStringIsNull);
 aaVmProcAdd(vm,0,"aaStringIsEmpty",&aaStringIsEmpty);
 aaVmProcAdd(vm,0,"aaStringCopy",&aaStringCopy);
 aaVmProcAdd(vm,0,"aaStringNCopy",&aaStringNCopy);
 aaVmProcAdd(vm,0,"aaStringCopyLen",&aaStringCopyLen);
 aaVmProcAdd(vm,0,"aaStringLen",&aaStringLen);
 aaVmProcAdd(vm,0,"aaStringNLen",&aaStringNLen);
 aaVmProcAdd(vm,0,"aaStringLenSet",&aaStringLenSet);
 aaVmProcAdd(vm,0,"aaStringFill",&aaStringFill);
 aaVmProcAdd(vm,0,"aaStringAppendChar",&aaStringAppendChar);
 aaVmProcAdd(vm,0,"aaStringAppendChars",&aaStringAppendChars);
 aaVmProcAdd(vm,0,"aaStringAppend",&aaStringAppend);
 aaVmProcAdd(vm,0,"aaStringVSprintf",&aaStringVSprintf);
 aaVmProcAdd(vm,0,"aaStringNCopyf",&aaStringNCopyf);
 aaVmProcAdd(vm,0,"aaStringCopyf",&aaStringCopyf);
 aaVmProcAdd(vm,0,"aaStringCopyfLen",&aaStringCopyfLen);
 aaVmProcAdd(vm,0,"aaStringAppendCopyf",&aaStringAppendCopyf);
 aaVmProcAdd(vm,0,"aaStringConcat",&aaStringConcat);
 aaVmProcAdd(vm,0,"aaStringAppendf",&aaStringAppendf);
 aaVmProcAdd(vm,0,"aaStringAppendfLen",&aaStringAppendfLen);
 aaVmProcAdd(vm,0,"aaStringSpacedAppendf",&aaStringSpacedAppendf);
 aaVmProcAdd(vm,0,"aaStringCopyx",&aaStringCopyx);
 aaVmProcAdd(vm,0,"aaStringCompare",&aaStringCompare);
 aaVmProcAdd(vm,0,"aaStringICompare",&aaStringICompare);
 aaVmProcAdd(vm,0,"aaStringNCompare",&aaStringNCompare);
 aaVmProcAdd(vm,0,"aaStringNICompare",&aaStringNICompare);
 aaVmProcAdd(vm,0,"aaStringUpper",&aaStringUpper);
 aaVmProcAdd(vm,0,"aaStringLower",&aaStringLower);
 aaVmProcAdd(vm,0,"aaStringReverse",&aaStringReverse);
 aaVmProcAdd(vm,0,"aaStringInsertChar",&aaStringInsertChar);
 aaVmProcAdd(vm,0,"aaStringInsertChars",&aaStringInsertChars);
 aaVmProcAdd(vm,0,"aaStringDeleteChar",&aaStringDeleteChar);
 aaVmProcAdd(vm,0,"aaStringDeleteChars",&aaStringDeleteChars);
 aaVmProcAdd(vm,0,"aaStringDeleteCharsTillChar",&aaStringDeleteCharsTillChar);
 aaVmProcAdd(vm,0,"aaStringCharGet",&aaStringCharGet);
 aaVmProcAdd(vm,0,"aaStringCharSet",&aaStringCharSet);
 aaVmProcAdd(vm,0,"aaStringCharUpper",&aaStringCharUpper);
 aaVmProcAdd(vm,0,"aaStringCharLower",&aaStringCharLower);
 aaVmProcAdd(vm,0,"aaStringLastCharGet",&aaStringLastCharGet);
 aaVmProcAdd(vm,0,"aaStringLastCharSet",&aaStringLastCharSet);
 aaVmProcAdd(vm,0,"aaStringIsLastChar",&aaStringIsLastChar);
 aaVmProcAdd(vm,0,"aaStringLastCharNonVisibleRemove",&aaStringLastCharNonVisibleRemove);
 aaVmProcAdd(vm,0,"aaStringFirstCharNonVisibleRemove",&aaStringFirstCharNonVisibleRemove);
 aaVmProcAdd(vm,0,"aaStringInsertString",&aaStringInsertString);
 aaVmProcAdd(vm,0,"aaStringInsertStringf",&aaStringInsertStringf);
 aaVmProcAdd(vm,0,"aaStringIsString",&aaStringIsString);
 aaVmProcAdd(vm,0,"aaStringIsIString",&aaStringIsIString);
 aaVmProcAdd(vm,0,"aaStringIsStringPartial",&aaStringIsStringPartial);
 aaVmProcAdd(vm,0,"aaStringIsIStringPartial",&aaStringIsIStringPartial);
 aaVmProcAdd(vm,0,"aaStringIsNumerical",&aaStringIsNumerical);
 aaVmProcAdd(vm,0,"aaStringIsDeliminated",&aaStringIsDeliminated);
 aaVmProcAdd(vm,0,"aaStringCountNumbers",&aaStringCountNumbers);
 aaVmProcAdd(vm,0,"aaStringCountHex",&aaStringCountHex);
 aaVmProcAdd(vm,0,"aaStringCountAlpha",&aaStringCountAlpha);
 aaVmProcAdd(vm,0,"aaStringCountAlphaNum",&aaStringCountAlphaNum);
 aaVmProcAdd(vm,0,"aaStringCountVisibleChars",&aaStringCountVisibleChars);
 aaVmProcAdd(vm,0,"aaStringIsPrintable",&aaStringIsPrintable);
 aaVmProcAdd(vm,0,"aaStringCountPrintable",&aaStringCountPrintable);
 aaVmProcAdd(vm,0,"aaStringToDouble",&aaStringToDouble);
 aaVmProcAdd(vm,0,"aaStringToNumber",&aaStringToNumber);
 aaVmProcAdd(vm,0,"aaStringHexToNumber",&aaStringHexToNumber);
 aaVmProcAdd(vm,0,"aaStringFromBinary",&aaStringFromBinary);
 aaVmProcAdd(vm,0,"aaStringCountChars",&aaStringCountChars);
 aaVmProcAdd(vm,0,"aaStringFindChar",&aaStringFindChar);
 aaVmProcAdd(vm,0,"aaStringFindCharList",&aaStringFindCharList);
 aaVmProcAdd(vm,0,"aaStringFindFirstAlpha",&aaStringFindFirstAlpha);
 aaVmProcAdd(vm,0,"aaStringFindFirstNumber",&aaStringFindFirstNumber);
 aaVmProcAdd(vm,0,"aaStringFindCharVisible",&aaStringFindCharVisible);
 aaVmProcAdd(vm,0,"aaStringReplaceChar",&aaStringReplaceChar);
 aaVmProcAdd(vm,0,"aaStringReplaceString",&aaStringReplaceString);
 aaVmProcAdd(vm,0,"aaStringFindFirstIString",&aaStringFindFirstIString);
 aaVmProcAdd(vm,0,"aaStringCleanup",&aaStringCleanup);
 aaVmProcAdd(vm,0,"aaStringRemoveMultipleSpaces",&aaStringRemoveMultipleSpaces);
 aaVmProcAdd(vm,0,"aaStringRemoveSpaces",&aaStringRemoveSpaces);
 aaVmProcAdd(vm,0,"aaStringRemoveChars",&aaStringRemoveChars);
 aaVmProcAdd(vm,0,"aaStringDespace",&aaStringDespace);
 aaVmProcAdd(vm,0,"aaStringFindFirstIStrings",&aaStringFindFirstIStrings);
 aaVmProcAdd(vm,0,"aaStringIsQuoted",&aaStringIsQuoted);
 aaVmProcAdd(vm,0,"aaStringIsBraced",&aaStringIsBraced);
 aaVmProcAdd(vm,0,"aaStringIsBracketed",&aaStringIsBracketed);
 aaVmProcAdd(vm,0,"aaStringIsParenthesized",&aaStringIsParenthesized);
 aaVmProcAdd(vm,0,"aaStringQuotify",&aaStringQuotify);
 aaVmProcAdd(vm,0,"aaStringRandomSet",&aaStringRandomSet);
 aaVmProcAdd(vm,0,"aaStringHashGet",&aaStringHashGet);
 aaVmProcAdd(vm,0,"aaStringHashIsTrue",&aaStringHashIsTrue);
 aaVmProcAdd(vm,0,"aaStringHashBothGet",&aaStringHashBothGet);
 aaVmProcAdd(vm,0,"aaStringGuid",&aaStringGuid);
 aaVmProcAdd(vm,0,"aaStringIsGuid",&aaStringIsGuid);
 aaVmProcAdd(vm,0,"aaStringFromWideString",&aaStringFromWideString);
 aaVmProcAdd(vm,0,"aaStringToWideString",&aaStringToWideString);
 aaVmProcAdd(vm,0,"aaStringPathSanitize",&aaStringPathSanitize);
 aaVmProcAdd(vm,0,"aaStringRot13",&aaStringRot13);
 aaVmProcAdd(vm,0,"aaStringTranspose",&aaStringTranspose);
 aaVmProcAdd(vm,0,"aaStringFromDword",&aaStringFromDword);
 aaVmProcAdd(vm,0,"aaStringFromArrayHex",&aaStringFromArrayHex);
 aaVmProcAdd(vm,0,"aaStringHexDump",&aaStringHexDump);
 aaVmProcAdd(vm,0,"aaStringSplit",&aaStringSplit);
 aaVmProcAdd(vm,0,"aaStringSplitChar",&aaStringSplitChar);
 aaVmProcAdd(vm,0,"aaStringExplode",&aaStringExplode);
 aaVmProcAdd(vm,0,"aaStringExplodeTokenGet",&aaStringExplodeTokenGet);
 aaVmProcAdd(vm,0,"aaStringExplodePtrGet",&aaStringExplodePtrGet);
 aaVmProcAdd(vm,0,"aaStringEncode",&aaStringEncode);
 aaVmProcAdd(vm,0,"aaStringDecode",&aaStringDecode);
 aaVmProcAdd(vm,0,"aaStringEntityToPseudoEnglish",&aaStringEntityToPseudoEnglish);
 aaVmProcAdd(vm,0,"aaStringLineCountGet",&aaStringLineCountGet);
 aaVmProcAdd(vm,0,"aaStringLineCountGetToMemory",&aaStringLineCountGetToMemory);
 aaVmProcAdd(vm,0,"aaStringLineCountGetToBuffer",&aaStringLineCountGetToBuffer);
 aaVmProcAdd(vm,0,"aaStringLineGet",&aaStringLineGet);
 aaVmProcAdd(vm,0,"aaStringMatchCount",&aaStringMatchCount);
 aaVmProcAdd(vm,0,"aaStringLengthModeAdjust",&aaStringLengthModeAdjust);
 aaVmProcAdd(vm,0,"aaStringToker",&aaStringToker);
 aaVmProcAdd(vm,0,"aaStringTokerMini",&aaStringTokerMini);
 aaVmProcAdd(vm,0,"aaStringTokerMaxi",&aaStringTokerMaxi);
 aaVmProcAdd(vm,0,"aaStringTokerMiniStringGet",&aaStringTokerMiniStringGet);
 aaVmProcAdd(vm,0,"aaStringTokerMaxiStringGet",&aaStringTokerMaxiStringGet);
 aaVmProcAdd(vm,0,"aaStringUnicodeToClosestEnglish",&aaStringUnicodeToClosestEnglish);
 aaVmProcAdd(vm,0,"aaStringContract",&aaStringContract);
 aaVmProcAdd(vm,0,"aaStringUtfLen",&aaStringUtfLen);
 aaVmProcAdd(vm,0,"aaStringUtfPosGet",&aaStringUtfPosGet);
 aaVmProcAdd(vm,0,"aaStringUtfTypeGet",&aaStringUtfTypeGet);
 aaVmProcAdd(vm,0,"aaStringToUtf8",&aaStringToUtf8);
 aaVmProcAdd(vm,0,"aaStringTokenGet",&aaStringTokenGet);
 aaVmProcAdd(vm,0,"aaStringFix",&aaStringFix);
 aaVmProcAdd(vm,0,"aaStringWildCompare",&aaStringWildCompare);
 aaVmProcAdd(vm,0,"aaStringStartsWithContains",&aaStringStartsWithContains);
 aaVmProcAdd(vm,0,"aaf",&aaf);
 aaVmProcAdd(vm,0,"aaBase64Encode",&aaBase64Encode);
 aaVmProcAdd(vm,0,"aaBase64Decode",&aaBase64Decode);
 aaVmProcAdd(vm,0,"aaGuidInit",&aaGuidInit);
 aaVmProcAdd(vm,0,"aaGuidSet",&aaGuidSet);
 aaVmProcAdd(vm,0,"aaGuidToString",&aaGuidToString);
 aaVmProcAdd(vm,0,"aaParserInit",&aaParserInit);
 aaVmProcAdd(vm,0,"aaParserCopy",&aaParserCopy);
 aaVmProcAdd(vm,0,"aaParserSeek",&aaParserSeek);
 aaVmProcAdd(vm,0,"aaParserOffsetSet",&aaParserOffsetSet);
 aaVmProcAdd(vm,0,"aaParserDeleteChars",&aaParserDeleteChars);
 aaVmProcAdd(vm,0,"aaParserReset",&aaParserReset);
 aaVmProcAdd(vm,0,"aaParserSeekToChar",&aaParserSeekToChar);
 aaVmProcAdd(vm,0,"aaParserSeekToCharList",&aaParserSeekToCharList);
 aaVmProcAdd(vm,0,"aaParserSeekToNumber",&aaParserSeekToNumber);
 aaVmProcAdd(vm,0,"aaParserSeekToVisibleChar",&aaParserSeekToVisibleChar);
 aaVmProcAdd(vm,0,"aaParserSeekToString",&aaParserSeekToString);
 aaVmProcAdd(vm,0,"aaParserSeekToStringf",&aaParserSeekToStringf);
 aaVmProcAdd(vm,0,"aaParserStringCopy",&aaParserStringCopy);
 aaVmProcAdd(vm,0,"aaParserStackPush",&aaParserStackPush);
 aaVmProcAdd(vm,0,"aaParserStackPop",&aaParserStackPop);
 aaVmProcAdd(vm,0,"aaParserStackPeek",&aaParserStackPeek);
 aaVmProcAdd(vm,0,"aaParserStackDiscard",&aaParserStackDiscard);
 aaVmProcAdd(vm,0,"aaParserStackString",&aaParserStackString);
 aaVmProcAdd(vm,0,"aaCordNull",&aaCordNull);
 aaVmProcAdd(vm,0,"aaCordSet",&aaCordSet);
 aaVmProcAdd(vm,0,"aaCordGet",&aaCordGet);
 aaVmProcAdd(vm,0,"aaCordCopy",&aaCordCopy);
 aaVmProcAdd(vm,0,"aaCordAdjust",&aaCordAdjust);
 aaVmProcAdd(vm,0,"aaCordsAdjust",&aaCordsAdjust);
 aaVmProcAdd(vm,0,"aaCordEqualsCord",&aaCordEqualsCord);
 aaVmProcAdd(vm,0,"aaCordSubtract",&aaCordSubtract);
 aaVmProcAdd(vm,0,"aaCordAdd",&aaCordAdd);
 aaVmProcAdd(vm,0,"aaCordIsWithinRect",&aaCordIsWithinRect);
 aaVmProcAdd(vm,0,"aaCordIsWithinRects",&aaCordIsWithinRects);
 aaVmProcAdd(vm,0,"aaCordsSet",&aaCordsSet);
 aaVmProcAdd(vm,0,"aaCordsToRect",&aaCordsToRect);
 aaVmProcAdd(vm,0,"aaCordIsZero",&aaCordIsZero);
 aaVmProcAdd(vm,0,"aaCordCopyFromRect",&aaCordCopyFromRect);
 aaVmProcAdd(vm,0,"aaSizeNull",&aaSizeNull);
 aaVmProcAdd(vm,0,"aaSizeSet",&aaSizeSet);
 aaVmProcAdd(vm,0,"aaSizeGet",&aaSizeGet);
 aaVmProcAdd(vm,0,"aaSizeCopy",&aaSizeCopy);
 aaVmProcAdd(vm,0,"aaSizeAdjust",&aaSizeAdjust);
 aaVmProcAdd(vm,0,"aaSizeEqualsSize",&aaSizeEqualsSize);
 aaVmProcAdd(vm,0,"aaSizeToRect",&aaSizeToRect);
 aaVmProcAdd(vm,0,"aaSizeIsValid",&aaSizeIsValid);
 aaVmProcAdd(vm,0,"aaSizeCordCenterGet",&aaSizeCordCenterGet);
 aaVmProcAdd(vm,0,"aaRectNull",&aaRectNull);
 aaVmProcAdd(vm,0,"aaRectIsEmpty",&aaRectIsEmpty);
 aaVmProcAdd(vm,0,"aaRectSet",&aaRectSet);
 aaVmProcAdd(vm,0,"aaRectGet",&aaRectGet);
 aaVmProcAdd(vm,0,"aaRectCopy",&aaRectCopy);
 aaVmProcAdd(vm,0,"aaRectAdjust",&aaRectAdjust);
 aaVmProcAdd(vm,0,"aaRectCordSet",&aaRectCordSet);
 aaVmProcAdd(vm,0,"aaRectSizeSet",&aaRectSizeSet);
 aaVmProcAdd(vm,0,"aaRectEqualsRect",&aaRectEqualsRect);
 aaVmProcAdd(vm,0,"aaRectIntersect",&aaRectIntersect);
 aaVmProcAdd(vm,0,"aaRectIsInsideRect",&aaRectIsInsideRect);
 aaVmProcAdd(vm,0,"aaRectIsOutsideRect",&aaRectIsOutsideRect);
 aaVmProcAdd(vm,0,"aaRectIsOverlappingRect",&aaRectIsOverlappingRect);
 aaVmProcAdd(vm,0,"aaRectAdd",&aaRectAdd);
 aaVmProcAdd(vm,0,"aaRectSubtract",&aaRectSubtract);
 aaVmProcAdd(vm,0,"aaRectToCords",&aaRectToCords);
 aaVmProcAdd(vm,0,"aaRectToSize",&aaRectToSize);
 aaVmProcAdd(vm,0,"aaRectIsValid",&aaRectIsValid);
 aaVmProcAdd(vm,0,"aaRectCordCenterGet",&aaRectCordCenterGet);
 aaVmProcAdd(vm,0,"aaRectExpand",&aaRectExpand);
 aaVmProcAdd(vm,0,"aaRectToCornerCords",&aaRectToCornerCords);
 aaVmProcAdd(vm,0,"aaRectToSideCords",&aaRectToSideCords);
 aaVmProcAdd(vm,0,"aaRectAlignRect",&aaRectAlignRect);
 aaVmProcAdd(vm,0,"aaRectFromWinRect",&aaRectFromWinRect);
 aaVmProcAdd(vm,0,"aaGridToCord",&aaGridToCord);
 aaVmProcAdd(vm,0,"aaGridToCords",&aaGridToCords);
 aaVmProcAdd(vm,0,"aaGridToRect",&aaGridToRect);
 aaVmProcAdd(vm,0,"aaGridRectToCord",&aaGridRectToCord);
 aaVmProcAdd(vm,0,"aaGridRectToCords",&aaGridRectToCords);
 aaVmProcAdd(vm,0,"aaGridRectToRect",&aaGridRectToRect);
 aaVmProcAdd(vm,0,"aaCordToGrid",&aaCordToGrid);
 aaVmProcAdd(vm,0,"aaCordToGrids",&aaCordToGrids);
 aaVmProcAdd(vm,0,"aaRectToGrid",&aaRectToGrid);
 aaVmProcAdd(vm,0,"aaGridFromFloats",&aaGridFromFloats);
 aaVmProcAdd(vm,0,"aaFCordSet",&aaFCordSet);
 aaVmProcAdd(vm,0,"aaFCordCopy",&aaFCordCopy);
 aaVmProcAdd(vm,0,"aaFSizeSet",&aaFSizeSet);
 aaVmProcAdd(vm,0,"aaFsizeCopy",&aaFsizeCopy);
 aaVmProcAdd(vm,0,"aaFRectSet",&aaFRectSet);
 aaVmProcAdd(vm,0,"aaFRectCopy",&aaFRectCopy);
 aaVmProcAdd(vm,0,"aaRgbaSet",&aaRgbaSet);
 aaVmProcAdd(vm,0,"aaRgbaCopy",&aaRgbaCopy);
 aaVmProcAdd(vm,0,"aaRgbaCopyWithAlpha",&aaRgbaCopyWithAlpha);
 aaVmProcAdd(vm,0,"aaRgbaAdjust",&aaRgbaAdjust);
 aaVmProcAdd(vm,0,"aaRgbaEqualsRgba",&aaRgbaEqualsRgba);
 aaVmProcAdd(vm,0,"aaRgbaGradientArray",&aaRgbaGradientArray);
 aaVmProcAdd(vm,0,"aaRgbaDwordSet",&aaRgbaDwordSet);
 aaVmProcAdd(vm,0,"aaRgbaYuvaSet",&aaRgbaYuvaSet);
 aaVmProcAdd(vm,0,"aaRgbaSetUsingHlsa",&aaRgbaSetUsingHlsa);
 aaVmProcAdd(vm,0,"aaRgbaMix",&aaRgbaMix);
 aaVmProcAdd(vm,0,"aaRgbaAdjustUsingHlsa",&aaRgbaAdjustUsingHlsa);
 aaVmProcAdd(vm,0,"aaRgbaShadeSet",&aaRgbaShadeSet);
 aaVmProcAdd(vm,0,"aaRgbaSwap",&aaRgbaSwap);
 aaVmProcAdd(vm,0,"aaRgbabfSet",&aaRgbabfSet);
 aaVmProcAdd(vm,0,"aaRgbabfCopy",&aaRgbabfCopy);
 aaVmProcAdd(vm,0,"aaYuvaSet",&aaYuvaSet);
 aaVmProcAdd(vm,0,"aaYuvaCopy",&aaYuvaCopy);
 aaVmProcAdd(vm,0,"aaYuvaAdjust",&aaYuvaAdjust);
 aaVmProcAdd(vm,0,"aaYuvaToRgba",&aaYuvaToRgba);
 aaVmProcAdd(vm,0,"aaYuvaFromRgba",&aaYuvaFromRgba);
 aaVmProcAdd(vm,0,"aaHlsaSet",&aaHlsaSet);
 aaVmProcAdd(vm,0,"aaHlsaCopy",&aaHlsaCopy);
 aaVmProcAdd(vm,0,"aaHlsaAdjust",&aaHlsaAdjust);
 aaVmProcAdd(vm,0,"aaHlsaToRgba",&aaHlsaToRgba);
 aaVmProcAdd(vm,0,"aaHlsaFromRgba",&aaHlsaFromRgba);
 aaVmProcAdd(vm,0,"aaGfxClawInit",&aaGfxClawInit);
 aaVmProcAdd(vm,0,"aaThreadCreate",&aaThreadCreate);
 aaVmProcAdd(vm,0,"aaThreadDestroy",&aaThreadDestroy);
 aaVmProcAdd(vm,0,"aaThreadExit",&aaThreadExit);
 aaVmProcAdd(vm,0,"aaThreadStatus",&aaThreadStatus);
 aaVmProcAdd(vm,0,"aaThreadWait",&aaThreadWait);
 aaVmProcAdd(vm,0,"aaThreadPause",&aaThreadPause);
 aaVmProcAdd(vm,0,"aaThreadLock",&aaThreadLock);
 aaVmProcAdd(vm,0,"aaThreadUnLock",&aaThreadUnLock);
 aaVmProcAdd(vm,0,"aaProcessCreate",&aaProcessCreate);
 aaVmProcAdd(vm,0,"aaProcessCreateWithLogin",&aaProcessCreateWithLogin);
 aaVmProcAdd(vm,0,"aaProcessDestroy",&aaProcessDestroy);
 aaVmProcAdd(vm,0,"aaProcessExit",&aaProcessExit);
 aaVmProcAdd(vm,0,"aaProcessPause",&aaProcessPause);
 aaVmProcAdd(vm,0,"aaProcessStatus",&aaProcessStatus);
 aaVmProcAdd(vm,0,"aaProcessStatusToString",&aaProcessStatusToString);
 aaVmProcAdd(vm,0,"aaProcessUnresponsiveTimeoutSet",&aaProcessUnresponsiveTimeoutSet);
 aaVmProcAdd(vm,0,"aaProcessRetry",&aaProcessRetry);
 aaVmProcAdd(vm,0,"aaProcessSpawn",&aaProcessSpawn);
 aaVmProcAdd(vm,0,"aaProcessLaunch",&aaProcessLaunch);
 aaVmProcAdd(vm,0,"aaProcessIsRunning",&aaProcessIsRunning);
 aaVmProcAdd(vm,0,"aaProcessThreadList",&aaProcessThreadList);
 aaVmProcAdd(vm,0,"aaProcessThreadListDestroy",&aaProcessThreadListDestroy);
 aaVmProcAdd(vm,0,"aaProcessTerminateByHandle",&aaProcessTerminateByHandle);
 aaVmProcAdd(vm,0,"aaProcessTerminateByPid",&aaProcessTerminateByPid);
 aaVmProcAdd(vm,0,"aaProcessRestart",&aaProcessRestart);
 aaVmProcAdd(vm,0,"aaProcessListGather",&aaProcessListGather);
 aaVmProcAdd(vm,0,"aaProcessListRelease",&aaProcessListRelease);
 aaVmProcAdd(vm,0,"aaFiberCreate",&aaFiberCreate);
 aaVmProcAdd(vm,0,"aaFiberDestroy",&aaFiberDestroy);
 aaVmProcAdd(vm,0,"aaFiberStatus",&aaFiberStatus);
 aaVmProcAdd(vm,0,"aaFiberConvert",&aaFiberConvert);
 aaVmProcAdd(vm,0,"aaFiberSwitch",&aaFiberSwitch);
 aaVmProcAdd(vm,0,"aaFiberReturn",&aaFiberReturn);
 aaVmProcAdd(vm,0,"aaFiberExtraDataSet",&aaFiberExtraDataSet);
 aaVmProcAdd(vm,0,"aaPoolCreate",&aaPoolCreate);
 aaVmProcAdd(vm,0,"aaPoolDestroy",&aaPoolDestroy);
 aaVmProcAdd(vm,0,"aaPoolStatus",&aaPoolStatus);
 aaVmProcAdd(vm,0,"aaPoolStatusToString",&aaPoolStatusToString);
 aaVmProcAdd(vm,0,"aaPoolBlockNew",&aaPoolBlockNew);
 aaVmProcAdd(vm,0,"aaPoolBlockDelete",&aaPoolBlockDelete);
 aaVmProcAdd(vm,0,"aaPoolBlockDeleteByIndex",&aaPoolBlockDeleteByIndex);
 aaVmProcAdd(vm,0,"aaPoolBlockInfoGet",&aaPoolBlockInfoGet);
 aaVmProcAdd(vm,0,"aaPoolBlockGetByIndex",&aaPoolBlockGetByIndex);
 aaVmProcAdd(vm,0,"aaWinEnumCreate",&aaWinEnumCreate);
 aaVmProcAdd(vm,0,"aaWinEnumDestroy",&aaWinEnumDestroy);
 aaVmProcAdd(vm,0,"aaWinEnumStatus",&aaWinEnumStatus);
 aaVmProcAdd(vm,0,"aaDynbufCreate",&aaDynbufCreate);
 aaVmProcAdd(vm,0,"aaDynbufDestroy",&aaDynbufDestroy);
 aaVmProcAdd(vm,0,"aaDynbufStatus",&aaDynbufStatus);
 aaVmProcAdd(vm,0,"aaDynbufReset",&aaDynbufReset);
 aaVmProcAdd(vm,0,"aaDynbufSeek",&aaDynbufSeek);
 aaVmProcAdd(vm,0,"aaDynbufAppendByte",&aaDynbufAppendByte);
 aaVmProcAdd(vm,0,"aaDynbufAppendWord",&aaDynbufAppendWord);
 aaVmProcAdd(vm,0,"aaDynbufAppendDword",&aaDynbufAppendDword);
 aaVmProcAdd(vm,0,"aaDynbufAppend",&aaDynbufAppend);
 aaVmProcAdd(vm,0,"aaDynbufAppendf",&aaDynbufAppendf);
 aaVmProcAdd(vm,0,"aaDynbufAppendBits",&aaDynbufAppendBits);
 aaVmProcAdd(vm,0,"aaArrayCreate",&aaArrayCreate);
 aaVmProcAdd(vm,0,"aaArrayDestroy",&aaArrayDestroy);
 aaVmProcAdd(vm,0,"aaArrayStatus",&aaArrayStatus);
 aaVmProcAdd(vm,0,"aaArrayLengthSet",&aaArrayLengthSet);
 aaVmProcAdd(vm,0,"aaArrayWrite",&aaArrayWrite);
 aaVmProcAdd(vm,0,"aaArrayRead",&aaArrayRead);
 aaVmProcAdd(vm,0,"aaArrayFill",&aaArrayFill);
 aaVmProcAdd(vm,0,"aaQueCreate",&aaQueCreate);
 aaVmProcAdd(vm,0,"aaQueDestroy",&aaQueDestroy);
 aaVmProcAdd(vm,0,"aaQueStatus",&aaQueStatus);
 aaVmProcAdd(vm,0,"aaQueWrite",&aaQueWrite);
 aaVmProcAdd(vm,0,"aaQueWritef",&aaQueWritef);
 aaVmProcAdd(vm,0,"aaQueWriteByte",&aaQueWriteByte);
 aaVmProcAdd(vm,0,"aaQueWriteWord",&aaQueWriteWord);
 aaVmProcAdd(vm,0,"aaQueWriteDword",&aaQueWriteDword);
 aaVmProcAdd(vm,0,"aaQueWriteQuad",&aaQueWriteQuad);
 aaVmProcAdd(vm,0,"aaQueRead",&aaQueRead);
 aaVmProcAdd(vm,0,"aaQueReadByte",&aaQueReadByte);
 aaVmProcAdd(vm,0,"aaQueReadWord",&aaQueReadWord);
 aaVmProcAdd(vm,0,"aaQueReadDword",&aaQueReadDword);
 aaVmProcAdd(vm,0,"aaQueReadQuad",&aaQueReadQuad);
 aaVmProcAdd(vm,0,"aaQuePeek",&aaQuePeek);
 aaVmProcAdd(vm,0,"aaQuePeekByte",&aaQuePeekByte);
 aaVmProcAdd(vm,0,"aaQuePeekWord",&aaQuePeekWord);
 aaVmProcAdd(vm,0,"aaQuePeekDword",&aaQuePeekDword);
 aaVmProcAdd(vm,0,"aaQuePeekQuad",&aaQuePeekQuad);
 aaVmProcAdd(vm,0,"aaQueFindByte",&aaQueFindByte);
 aaVmProcAdd(vm,0,"aaQueDiscard",&aaQueDiscard);
 aaVmProcAdd(vm,0,"aaQueStringLen",&aaQueStringLen);
 aaVmProcAdd(vm,0,"aaQueStringRead",&aaQueStringRead);
 aaVmProcAdd(vm,0,"aaQueReturn",&aaQueReturn);
 aaVmProcAdd(vm,0,"aaQueTrim",&aaQueTrim);
 aaVmProcAdd(vm,0,"aaVectorNew",&aaVectorNew);
 aaVmProcAdd(vm,0,"aaVectorDelete",&aaVectorDelete);
 aaVmProcAdd(vm,0,"aaVectorExtendSlots",&aaVectorExtendSlots);
 aaVmProcAdd(vm,0,"aaVectorDataBytesSet",&aaVectorDataBytesSet);
 aaVmProcAdd(vm,0,"aaVectorSlotGet",&aaVectorSlotGet);
 aaVmProcAdd(vm,0,"aaVectorUsageAdjust",&aaVectorUsageAdjust);
 aaVmProcAdd(vm,0,"aaHuffNew",&aaHuffNew);
 aaVmProcAdd(vm,0,"aaHuffDelete",&aaHuffDelete);
 aaVmProcAdd(vm,0,"aaHuffEncode",&aaHuffEncode);
 aaVmProcAdd(vm,0,"aaHuffDecode",&aaHuffDecode);
 aaVmProcAdd(vm,0,"aaLz4Encode",&aaLz4Encode);
 aaVmProcAdd(vm,0,"aaLz4Decode",&aaLz4Decode);
 aaVmProcAdd(vm,0,"aaMiniQueInit",&aaMiniQueInit);
 aaVmProcAdd(vm,0,"aaMiniQueWrite",&aaMiniQueWrite);
 aaVmProcAdd(vm,0,"aaMiniQueRead",&aaMiniQueRead);
 aaVmProcAdd(vm,0,"aaMiniQuePeek",&aaMiniQuePeek);
 aaVmProcAdd(vm,0,"aaMiniQueDiscard",&aaMiniQueDiscard);
 aaVmProcAdd(vm,0,"aaMiniQueReturn",&aaMiniQueReturn);
 aaVmProcAdd(vm,0,"aaMiniStackInit",&aaMiniStackInit);
 aaVmProcAdd(vm,0,"aaMiniStackPush",&aaMiniStackPush);
 aaVmProcAdd(vm,0,"aaMiniStackPushByte",&aaMiniStackPushByte);
 aaVmProcAdd(vm,0,"aaMiniStackPushWord",&aaMiniStackPushWord);
 aaVmProcAdd(vm,0,"aaMiniStackPushDword",&aaMiniStackPushDword);
 aaVmProcAdd(vm,0,"aaMiniStackPushQuad",&aaMiniStackPushQuad);
 aaVmProcAdd(vm,0,"aaMiniStackPushStringf",&aaMiniStackPushStringf);
 aaVmProcAdd(vm,0,"aaMiniStackPushMulti",&aaMiniStackPushMulti);
 aaVmProcAdd(vm,0,"aaMiniStackPop",&aaMiniStackPop);
 aaVmProcAdd(vm,0,"aaMiniStackPopByte",&aaMiniStackPopByte);
 aaVmProcAdd(vm,0,"aaMiniStackPopWord",&aaMiniStackPopWord);
 aaVmProcAdd(vm,0,"aaMiniStackPopDword",&aaMiniStackPopDword);
 aaVmProcAdd(vm,0,"aaMiniStackPopQuad",&aaMiniStackPopQuad);
 aaVmProcAdd(vm,0,"aaMiniStackPopString",&aaMiniStackPopString);
 aaVmProcAdd(vm,0,"aaMiniStackPopMulti",&aaMiniStackPopMulti);
 aaVmProcAdd(vm,0,"aaMiniStackPeek",&aaMiniStackPeek);
 aaVmProcAdd(vm,0,"aaMiniStackPeekByte",&aaMiniStackPeekByte);
 aaVmProcAdd(vm,0,"aaMiniStackPeekWord",&aaMiniStackPeekWord);
 aaVmProcAdd(vm,0,"aaMiniStackPeekDword",&aaMiniStackPeekDword);
 aaVmProcAdd(vm,0,"aaMiniStackPeekQuad",&aaMiniStackPeekQuad);
 aaVmProcAdd(vm,0,"aaMiniStackPeekString",&aaMiniStackPeekString);
 aaVmProcAdd(vm,0,"aaMiniStackDiscard",&aaMiniStackDiscard);
 aaVmProcAdd(vm,0,"aaGeneralEventWaitingGet",&aaGeneralEventWaitingGet);
 aaVmProcAdd(vm,0,"aaGeneralEventWrite",&aaGeneralEventWrite);
 aaVmProcAdd(vm,0,"aaGeneralEventWritef",&aaGeneralEventWritef);
 aaVmProcAdd(vm,0,"aaGeneralEventRead",&aaGeneralEventRead);
 aaVmProcAdd(vm,0,"aaGeneralEventPeek",&aaGeneralEventPeek);
 aaVmProcAdd(vm,0,"aaGeneralEventDiscard",&aaGeneralEventDiscard);
 aaVmProcAdd(vm,0,"aaGeneralEventPurge",&aaGeneralEventPurge);
 aaVmProcAdd(vm,0,"aaNetStatus",&aaNetStatus);
 aaVmProcAdd(vm,0,"aaNetLocalIpGet",&aaNetLocalIpGet);
 aaVmProcAdd(vm,0,"aaNetInfoGet",&aaNetInfoGet);
 aaVmProcAdd(vm,0,"aaNetInfoToString",&aaNetInfoToString);
 aaVmProcAdd(vm,0,"aaNetOnlineStateGet",&aaNetOnlineStateGet);
 aaVmProcAdd(vm,0,"aaNetMacGet",&aaNetMacGet);
 aaVmProcAdd(vm,0,"aaNetIpPublicNext",&aaNetIpPublicNext);
 aaVmProcAdd(vm,0,"aaNetIpFromString",&aaNetIpFromString);
 aaVmProcAdd(vm,0,"aaNetIpToString",&aaNetIpToString);
 aaVmProcAdd(vm,0,"aaNetIpIsValid",&aaNetIpIsValid);
 aaVmProcAdd(vm,0,"aaNetIpIsLoopBack",&aaNetIpIsLoopBack);
 aaVmProcAdd(vm,0,"aaNetIpIsInternal",&aaNetIpIsInternal);
 aaVmProcAdd(vm,0,"aaNetIpIsReserved",&aaNetIpIsReserved);
 aaVmProcAdd(vm,0,"aaNetIpIsPublic",&aaNetIpIsPublic);
 aaVmProcAdd(vm,0,"aaNetIpTypeGet",&aaNetIpTypeGet);
 aaVmProcAdd(vm,0,"aaNetIpToDword",&aaNetIpToDword);
 aaVmProcAdd(vm,0,"aaNetIpClassGet",&aaNetIpClassGet);
 aaVmProcAdd(vm,0,"aaNetEmailIsValid",&aaNetEmailIsValid);
 aaVmProcAdd(vm,0,"aaNetHostToDomain",&aaNetHostToDomain);
 aaVmProcAdd(vm,0,"aaNetRfcCrcGet",&aaNetRfcCrcGet);
 aaVmProcAdd(vm,0,"aaNetBrowserWritef",&aaNetBrowserWritef);
 aaVmProcAdd(vm,0,"aaNetMimeToExtension",&aaNetMimeToExtension);
 aaVmProcAdd(vm,0,"aaNetExtensionToMime",&aaNetExtensionToMime);
 aaVmProcAdd(vm,0,"aaNetHostsFileEntryGet",&aaNetHostsFileEntryGet);
 aaVmProcAdd(vm,0,"aaNetHostsFileEntrySet",&aaNetHostsFileEntrySet);
 aaVmProcAdd(vm,0,"aaNetIsPortAvailable",&aaNetIsPortAvailable);
 aaVmProcAdd(vm,0,"aaNetRandomUser",&aaNetRandomUser);
 aaVmProcAdd(vm,0,"aaNetCgiEnvGet",&aaNetCgiEnvGet);
 aaVmProcAdd(vm,0,"aaNetCgiClientCreate",&aaNetCgiClientCreate);
 aaVmProcAdd(vm,0,"aaNetCgiClientDestroy",&aaNetCgiClientDestroy);
 aaVmProcAdd(vm,0,"aaNetCgiClientStatus",&aaNetCgiClientStatus);
 aaVmProcAdd(vm,0,"aaNetCgiClientWrite",&aaNetCgiClientWrite);
 aaVmProcAdd(vm,0,"aaNetCgiClientWritef",&aaNetCgiClientWritef);
 aaVmProcAdd(vm,0,"aaNetCgiClientRead",&aaNetCgiClientRead);
 aaVmProcAdd(vm,0,"aaNetCgiClientPeek",&aaNetCgiClientPeek);
 aaVmProcAdd(vm,0,"aaNetCgiClientDiscard",&aaNetCgiClientDiscard);
 aaVmProcAdd(vm,0,"aaNetCgiClientStringLen",&aaNetCgiClientStringLen);
 aaVmProcAdd(vm,0,"aaNetCgiClientStringRead",&aaNetCgiClientStringRead);
 aaVmProcAdd(vm,0,"aaNetCgiClientStringPeek",&aaNetCgiClientStringPeek);
 aaVmProcAdd(vm,0,"aaNetCgiClientStringReadQuick",&aaNetCgiClientStringReadQuick);
 aaVmProcAdd(vm,0,"aaNetCgiClientInactivityReset",&aaNetCgiClientInactivityReset);
 aaVmProcAdd(vm,0,"aaNetCgiClientChildrenTerminate",&aaNetCgiClientChildrenTerminate);
 aaVmProcAdd(vm,0,"aaNetUrlSimplify",&aaNetUrlSimplify);
 aaVmProcAdd(vm,0,"aaNetUrlDecode",&aaNetUrlDecode);
 aaVmProcAdd(vm,0,"aaNetUrlPartsGet",&aaNetUrlPartsGet);
 aaVmProcAdd(vm,0,"aaNetUrlPartsToString",&aaNetUrlPartsToString);
 aaVmProcAdd(vm,0,"aaNetUrlToFilename",&aaNetUrlToFilename);
 aaVmProcAdd(vm,0,"aaNetSetCookieDecode",&aaNetSetCookieDecode);
 aaVmProcAdd(vm,0,"aaNetAdrSet",&aaNetAdrSet);
 aaVmProcAdd(vm,0,"aaNetAdrSetFromString",&aaNetAdrSetFromString);
 aaVmProcAdd(vm,0,"aaNetAdrCopy",&aaNetAdrCopy);
 aaVmProcAdd(vm,0,"aaNetAdrToString",&aaNetAdrToString);
 aaVmProcAdd(vm,0,"aaNetAdrFromString",&aaNetAdrFromString);
 aaVmProcAdd(vm,0,"aaNetAdrEqualsAdr",&aaNetAdrEqualsAdr);
 aaVmProcAdd(vm,0,"aaNetAdrToHashGet",&aaNetAdrToHashGet);
 aaVmProcAdd(vm,0,"aaNetAdrFromFtpAdr",&aaNetAdrFromFtpAdr);
 aaVmProcAdd(vm,0,"aaNetSubnetFromIp",&aaNetSubnetFromIp);
 aaVmProcAdd(vm,0,"aaNetDnsCreate",&aaNetDnsCreate);
 aaVmProcAdd(vm,0,"aaNetDnsDestroy",&aaNetDnsDestroy);
 aaVmProcAdd(vm,0,"aaNetDnsStatus",&aaNetDnsStatus);
 aaVmProcAdd(vm,0,"aaNetSniffCreate",&aaNetSniffCreate);
 aaVmProcAdd(vm,0,"aaNetSniffDestroy",&aaNetSniffDestroy);
 aaVmProcAdd(vm,0,"aaNetSniffStatus",&aaNetSniffStatus);
 aaVmProcAdd(vm,0,"aaNetSniffPktRead",&aaNetSniffPktRead);
 aaVmProcAdd(vm,0,"aaNetSniffPktPeek",&aaNetSniffPktPeek);
 aaVmProcAdd(vm,0,"aaNetSniffPktDiscard",&aaNetSniffPktDiscard);
 aaVmProcAdd(vm,0,"aaNetSniffPktReturn",&aaNetSniffPktReturn);
 aaVmProcAdd(vm,0,"aaNetIcmpPktSet",&aaNetIcmpPktSet);
 aaVmProcAdd(vm,0,"aaNetIcmpPktCopy",&aaNetIcmpPktCopy);
 aaVmProcAdd(vm,0,"aaNetIcmpCreate",&aaNetIcmpCreate);
 aaVmProcAdd(vm,0,"aaNetIcmpDestroy",&aaNetIcmpDestroy);
 aaVmProcAdd(vm,0,"aaNetIcmpStatus",&aaNetIcmpStatus);
 aaVmProcAdd(vm,0,"aaNetIcmpPktWrite",&aaNetIcmpPktWrite);
 aaVmProcAdd(vm,0,"aaNetIcmpPktRead",&aaNetIcmpPktRead);
 aaVmProcAdd(vm,0,"aaNetIcmpPktPeek",&aaNetIcmpPktPeek);
 aaVmProcAdd(vm,0,"aaNetIcmpPktDiscard",&aaNetIcmpPktDiscard);
 aaVmProcAdd(vm,0,"aaNetUdpOpen",&aaNetUdpOpen);
 aaVmProcAdd(vm,0,"aaNetUdpCreate",&aaNetUdpCreate);
 aaVmProcAdd(vm,0,"aaNetUdpCreateAny",&aaNetUdpCreateAny);
 aaVmProcAdd(vm,0,"aaNetUdpDestroy",&aaNetUdpDestroy);
 aaVmProcAdd(vm,0,"aaNetUdpFlowControlSet",&aaNetUdpFlowControlSet);
 aaVmProcAdd(vm,0,"aaNetUdpChecksumSet",&aaNetUdpChecksumSet);
 aaVmProcAdd(vm,0,"aaNetUdpStatus",&aaNetUdpStatus);
 aaVmProcAdd(vm,0,"aaNetUdpBufferLengthSet",&aaNetUdpBufferLengthSet);
 aaVmProcAdd(vm,0,"aaNetUdpXmitSpeedSet",&aaNetUdpXmitSpeedSet);
 aaVmProcAdd(vm,0,"aaNetUdpExtraDataSet",&aaNetUdpExtraDataSet);
 aaVmProcAdd(vm,0,"aaNetUdpPktDirectSet",&aaNetUdpPktDirectSet);
 aaVmProcAdd(vm,0,"aaNetUdpPktWrite",&aaNetUdpPktWrite);
 aaVmProcAdd(vm,0,"aaNetUdpPktRead",&aaNetUdpPktRead);
 aaVmProcAdd(vm,0,"aaNetUdpPktPeek",&aaNetUdpPktPeek);
 aaVmProcAdd(vm,0,"aaNetUdpPktDiscard",&aaNetUdpPktDiscard);
 aaVmProcAdd(vm,0,"aaNetUdpPktReturn",&aaNetUdpPktReturn);
 aaVmProcAdd(vm,0,"aaNetUdpPktAllocate",&aaNetUdpPktAllocate);
 aaVmProcAdd(vm,0,"aaNetUdpPktRelease",&aaNetUdpPktRelease);
 aaVmProcAdd(vm,0,"aaNetUdpPktSet",&aaNetUdpPktSet);
 aaVmProcAdd(vm,0,"aaNetUdpPktCopy",&aaNetUdpPktCopy);
 aaVmProcAdd(vm,0,"aaNetUdpPktAppend",&aaNetUdpPktAppend);
 aaVmProcAdd(vm,0,"aaNetUdpPktByteAppend",&aaNetUdpPktByteAppend);
 aaVmProcAdd(vm,0,"aaNetUdpPktWordAppend",&aaNetUdpPktWordAppend);
 aaVmProcAdd(vm,0,"aaNetUdpPktDwordAppend",&aaNetUdpPktDwordAppend);
 aaVmProcAdd(vm,0,"aaNetUdpPktQuadAppend",&aaNetUdpPktQuadAppend);
 aaVmProcAdd(vm,0,"aaNetUdpPktTrim",&aaNetUdpPktTrim);
 aaVmProcAdd(vm,0,"aaNetStunClientCreate",&aaNetStunClientCreate);
 aaVmProcAdd(vm,0,"aaNetStunClientDestroy",&aaNetStunClientDestroy);
 aaVmProcAdd(vm,0,"aaNetStunClientStatus",&aaNetStunClientStatus);
 aaVmProcAdd(vm,0,"aaNetTcpPortCreate",&aaNetTcpPortCreate);
 aaVmProcAdd(vm,0,"aaNetTcpPortCreateAny",&aaNetTcpPortCreateAny);
 aaVmProcAdd(vm,0,"aaNetTcpPortDestroy",&aaNetTcpPortDestroy);
 aaVmProcAdd(vm,0,"aaNetTcpPortStatus",&aaNetTcpPortStatus);
 aaVmProcAdd(vm,0,"aaNetTcpPortCallNext",&aaNetTcpPortCallNext);
 aaVmProcAdd(vm,0,"aaNetTcpCallCreate",&aaNetTcpCallCreate);
 aaVmProcAdd(vm,0,"aaNetTcpCallDestroy",&aaNetTcpCallDestroy);
 aaVmProcAdd(vm,0,"aaNetTcpCallDestroyProcSet",&aaNetTcpCallDestroyProcSet);
 aaVmProcAdd(vm,0,"aaNetTcpCallCloseProtect",&aaNetTcpCallCloseProtect);
 aaVmProcAdd(vm,0,"aaNetTcpCallClose",&aaNetTcpCallClose);
 aaVmProcAdd(vm,0,"aaNetTcpCallVitalityGet",&aaNetTcpCallVitalityGet);
 aaVmProcAdd(vm,0,"aaNetTcpCallStatus",&aaNetTcpCallStatus);
 aaVmProcAdd(vm,0,"aaNetTcpCallOfferWrite",&aaNetTcpCallOfferWrite);
 aaVmProcAdd(vm,0,"aaNetTcpCallOfferRead",&aaNetTcpCallOfferRead);
 aaVmProcAdd(vm,0,"aaNetTcpCallOfferAccept",&aaNetTcpCallOfferAccept);
 aaVmProcAdd(vm,0,"aaNetTcpCallNext",&aaNetTcpCallNext);
 aaVmProcAdd(vm,0,"aaNetTcpCallByIndex",&aaNetTcpCallByIndex);
 aaVmProcAdd(vm,0,"aaNetTcpCallAdopt",&aaNetTcpCallAdopt);
 aaVmProcAdd(vm,0,"aaNetTcpCallAnswer",&aaNetTcpCallAnswer);
 aaVmProcAdd(vm,0,"aaNetTcpCallWrite",&aaNetTcpCallWrite);
 aaVmProcAdd(vm,0,"aaNetTcpCallWritef",&aaNetTcpCallWritef);
 aaVmProcAdd(vm,0,"aaNetTcpCallWriteByte",&aaNetTcpCallWriteByte);
 aaVmProcAdd(vm,0,"aaNetTcpCallWriteWord",&aaNetTcpCallWriteWord);
 aaVmProcAdd(vm,0,"aaNetTcpCallWriteDword",&aaNetTcpCallWriteDword);
 aaVmProcAdd(vm,0,"aaNetTcpCallWriteQuad",&aaNetTcpCallWriteQuad);
 aaVmProcAdd(vm,0,"aaNetTcpCallRead",&aaNetTcpCallRead);
 aaVmProcAdd(vm,0,"aaNetTcpCallReadByte",&aaNetTcpCallReadByte);
 aaVmProcAdd(vm,0,"aaNetTcpCallReadWord",&aaNetTcpCallReadWord);
 aaVmProcAdd(vm,0,"aaNetTcpCallReadDword",&aaNetTcpCallReadDword);
 aaVmProcAdd(vm,0,"aaNetTcpCallReadQuad",&aaNetTcpCallReadQuad);
 aaVmProcAdd(vm,0,"aaNetTcpCallPeek",&aaNetTcpCallPeek);
 aaVmProcAdd(vm,0,"aaNetTcpCallDiscard",&aaNetTcpCallDiscard);
 aaVmProcAdd(vm,0,"aaNetTcpCallFindByte",&aaNetTcpCallFindByte);
 aaVmProcAdd(vm,0,"aaNetTcpCallReturn",&aaNetTcpCallReturn);
 aaVmProcAdd(vm,0,"aaNetTcpCallPush",&aaNetTcpCallPush);
 aaVmProcAdd(vm,0,"aaNetTcpCallRelay",&aaNetTcpCallRelay);
 aaVmProcAdd(vm,0,"aaNetTcpCallMirror",&aaNetTcpCallMirror);
 aaVmProcAdd(vm,0,"aaNetTcpCallStringLen",&aaNetTcpCallStringLen);
 aaVmProcAdd(vm,0,"aaNetTcpCallStringRead",&aaNetTcpCallStringRead);
 aaVmProcAdd(vm,0,"aaNetTcpCallStringPeek",&aaNetTcpCallStringPeek);
 aaVmProcAdd(vm,0,"aaNetTcpCallStringLook",&aaNetTcpCallStringLook);
 aaVmProcAdd(vm,0,"aaNetTcpCallStringDiscard",&aaNetTcpCallStringDiscard);
 aaVmProcAdd(vm,0,"aaNetTcpCallPause",&aaNetTcpCallPause);
 aaVmProcAdd(vm,0,"aaNetTcpCallExtraDataSet",&aaNetTcpCallExtraDataSet);
 aaVmProcAdd(vm,0,"aaNetTcpCallExtraDataGet",&aaNetTcpCallExtraDataGet);
 aaVmProcAdd(vm,0,"aaNetTcpCallBufferLengthSet",&aaNetTcpCallBufferLengthSet);
 aaVmProcAdd(vm,0,"aaNetTcpCallSlicerLengthSet",&aaNetTcpCallSlicerLengthSet);
 aaVmProcAdd(vm,0,"aaNetTcpCallNoDelaySet",&aaNetTcpCallNoDelaySet);
 aaVmProcAdd(vm,0,"aaNetTcpCallProtocolSet",&aaNetTcpCallProtocolSet);
 aaVmProcAdd(vm,0,"aaNetTcpCallStageSet",&aaNetTcpCallStageSet);
 aaVmProcAdd(vm,0,"aaNetTcpCallMaxRateSet",&aaNetTcpCallMaxRateSet);
 aaVmProcAdd(vm,0,"aaNetTcpCallInactivityReset",&aaNetTcpCallInactivityReset);
 aaVmProcAdd(vm,0,"aaNetSocksInit",&aaNetSocksInit);
 aaVmProcAdd(vm,0,"aaNetSocksHelloWrite",&aaNetSocksHelloWrite);
 aaVmProcAdd(vm,0,"aaNetSocksConnectIp4Write",&aaNetSocksConnectIp4Write);
 aaVmProcAdd(vm,0,"aaNetHttpHeaderPrepare",&aaNetHttpHeaderPrepare);
 aaVmProcAdd(vm,0,"aaNetHttpHeaderCookiePrepare",&aaNetHttpHeaderCookiePrepare);
 aaVmProcAdd(vm,0,"aaNetHttpHeaderFieldCodeGet",&aaNetHttpHeaderFieldCodeGet);
 aaVmProcAdd(vm,0,"aaNetHttpResultReadFromString",&aaNetHttpResultReadFromString);
 aaVmProcAdd(vm,0,"aaNetHttpHeaderReadFromString",&aaNetHttpHeaderReadFromString);
 aaVmProcAdd(vm,0,"aaNetHttpRequestReadFromString",&aaNetHttpRequestReadFromString);
 aaVmProcAdd(vm,0,"aaNetHttpRequestWrite",&aaNetHttpRequestWrite);
 aaVmProcAdd(vm,0,"aaNetHttpResultWrite",&aaNetHttpResultWrite);
 aaVmProcAdd(vm,0,"aaNetHttpResultRead",&aaNetHttpResultRead);
 aaVmProcAdd(vm,0,"aaNetHttpHeaderRead",&aaNetHttpHeaderRead);
 aaVmProcAdd(vm,0,"aaNetHttpRequestRead",&aaNetHttpRequestRead);
 aaVmProcAdd(vm,0,"aaNetHttpBasicAuthorizationWrite",&aaNetHttpBasicAuthorizationWrite);
 aaVmProcAdd(vm,0,"aaNetHttpCookieSet",&aaNetHttpCookieSet);
 aaVmProcAdd(vm,0,"aaNetHttpChunkSizePeek",&aaNetHttpChunkSizePeek);
 aaVmProcAdd(vm,0,"aaNetHttpChunkSizeRead",&aaNetHttpChunkSizeRead);
 aaVmProcAdd(vm,0,"aaNetHttpChunkSizeWrite",&aaNetHttpChunkSizeWrite);
 aaVmProcAdd(vm,0,"aaNetHttpChunkWritef",&aaNetHttpChunkWritef);
 aaVmProcAdd(vm,0,"aaNetHttpChunkWrite",&aaNetHttpChunkWrite);
 aaVmProcAdd(vm,0,"aaNetSmtpResultRead",&aaNetSmtpResultRead);
 aaVmProcAdd(vm,0,"aaNetFtpResultRead",&aaNetFtpResultRead);
 aaVmProcAdd(vm,0,"aaNetFtpMlsdRead",&aaNetFtpMlsdRead);
 aaVmProcAdd(vm,0,"aaNetRedisPacketRead",&aaNetRedisPacketRead);
 aaVmProcAdd(vm,0,"aaNetRedisPacketWritef",&aaNetRedisPacketWritef);
 aaVmProcAdd(vm,0,"aaNetRedisRespBegin",&aaNetRedisRespBegin);
 aaVmProcAdd(vm,0,"aaNetRedisRespBulkAppend",&aaNetRedisRespBulkAppend);
 aaVmProcAdd(vm,0,"aaNetRedisRespBulkAppendf",&aaNetRedisRespBulkAppendf);
 aaVmProcAdd(vm,0,"aaNetRedisRespIntegerAppend",&aaNetRedisRespIntegerAppend);
 aaVmProcAdd(vm,0,"aaNetSsDbSizeRead",&aaNetSsDbSizeRead);
 aaVmProcAdd(vm,0,"aaNetSsDbPacketWrite",&aaNetSsDbPacketWrite);
 aaVmProcAdd(vm,0,"aaNetIrcAdrToParts",&aaNetIrcAdrToParts);
 aaVmProcAdd(vm,0,"aaNetIrcMsgRead",&aaNetIrcMsgRead);
 aaVmProcAdd(vm,0,"aaNetIrcMsgToString",&aaNetIrcMsgToString);
 aaVmProcAdd(vm,0,"aaNetPortListRead",&aaNetPortListRead);
 aaVmProcAdd(vm,0,"aaNetPortListStop",&aaNetPortListStop);
 aaVmProcAdd(vm,0,"aaNetRttInit",&aaNetRttInit);
 aaVmProcAdd(vm,0,"aaNetRttUpdate",&aaNetRttUpdate);
 aaVmProcAdd(vm,0,"aaNetServerCreate",&aaNetServerCreate);
 aaVmProcAdd(vm,0,"aaNetServerDestroy",&aaNetServerDestroy);
 aaVmProcAdd(vm,0,"aaNetServerStatus",&aaNetServerStatus);
 aaVmProcAdd(vm,0,"aaNetServerCallsAllow",&aaNetServerCallsAllow);
 aaVmProcAdd(vm,0,"aaNetWockCreate",&aaNetWockCreate);
 aaVmProcAdd(vm,0,"aaNetWockDestroy",&aaNetWockDestroy);
 aaVmProcAdd(vm,0,"aaNetWockStatus",&aaNetWockStatus);
 aaVmProcAdd(vm,0,"aaNetWockClose",&aaNetWockClose);
 aaVmProcAdd(vm,0,"aaNetWockPktWrite",&aaNetWockPktWrite);
 aaVmProcAdd(vm,0,"aaNetWockPktWritef",&aaNetWockPktWritef);
 aaVmProcAdd(vm,0,"aaNetWockPktPeek",&aaNetWockPktPeek);
 aaVmProcAdd(vm,0,"aaNetWockPktRead",&aaNetWockPktRead);
 aaVmProcAdd(vm,0,"aaNetWockPktDiscard",&aaNetWockPktDiscard);
 aaVmProcAdd(vm,0,"aaNetChunkReaderNew",&aaNetChunkReaderNew);
 aaVmProcAdd(vm,0,"aaNetChunkReaderDelete",&aaNetChunkReaderDelete);
 aaVmProcAdd(vm,0,"aaNetChunkReaderYield",&aaNetChunkReaderYield);
 aaVmProcAdd(vm,0,"aaNetChunkReaderDiscard",&aaNetChunkReaderDiscard);
 aaVmProcAdd(vm,0,"aaRedcallNew",&aaRedcallNew);
 aaVmProcAdd(vm,0,"aaRedcallDelete",&aaRedcallDelete);
 aaVmProcAdd(vm,0,"aaRedcallYield",&aaRedcallYield);
 aaVmProcAdd(vm,0,"aaRedcallPktWritef",&aaRedcallPktWritef);
 aaVmProcAdd(vm,0,"aaRedcallPktPeek",&aaRedcallPktPeek);
 aaVmProcAdd(vm,0,"aaRedcallPktDiscard",&aaRedcallPktDiscard);
 aaVmProcAdd(vm,0,"aaRedcallPktBug",&aaRedcallPktBug);
 aaVmProcAdd(vm,0,"aaRedcallProc",&aaRedcallProc);
 aaVmProcAdd(vm,0,"aaSsDbClientNew",&aaSsDbClientNew);
 aaVmProcAdd(vm,0,"aaSsDbClientDelete",&aaSsDbClientDelete);
 aaVmProcAdd(vm,0,"aaSsDbClientYield",&aaSsDbClientYield);
 aaVmProcAdd(vm,0,"aaSsDbClientWrite",&aaSsDbClientWrite);
 aaVmProcAdd(vm,0,"aaSsDbClientRead",&aaSsDbClientRead);
 aaVmProcAdd(vm,0,"aaSsDbClientPeek",&aaSsDbClientPeek);
 aaVmProcAdd(vm,0,"aaSsDbClientDiscard",&aaSsDbClientDiscard);
 aaVmProcAdd(vm,0,"aaSsDbClientListReceive",&aaSsDbClientListReceive);
 aaVmProcAdd(vm,0,"aaSsDbClientListEntryGet",&aaSsDbClientListEntryGet);
 aaVmProcAdd(vm,0,"aaTorProcessSnapshot",&aaTorProcessSnapshot);
 aaVmProcAdd(vm,0,"aaTorProcessEntryGet",&aaTorProcessEntryGet);
 aaVmProcAdd(vm,0,"aaTorProcessKill",&aaTorProcessKill);
 aaVmProcAdd(vm,0,"aaTorProcessLaunch",&aaTorProcessLaunch);
 aaVmProcAdd(vm,0,"aaMySqlNew",&aaMySqlNew);
 aaVmProcAdd(vm,0,"aaMySqlNewEx",&aaMySqlNewEx);
 aaVmProcAdd(vm,0,"aaMySqlDelete",&aaMySqlDelete);
 aaVmProcAdd(vm,0,"aaMySqlYield",&aaMySqlYield);
 aaVmProcAdd(vm,0,"aaMySqlQuery",&aaMySqlQuery);
 aaVmProcAdd(vm,0,"aaMySqlPeek",&aaMySqlPeek);
 aaVmProcAdd(vm,0,"aaMySqlDiscard",&aaMySqlDiscard);
 aaVmProcAdd(vm,0,"aaMySqlRead",&aaMySqlRead);
 aaVmProcAdd(vm,0,"aaMySqlQueryExInit",&aaMySqlQueryExInit);
 aaVmProcAdd(vm,0,"aaMySqlQueryExMore",&aaMySqlQueryExMore);
 aaVmProcAdd(vm,0,"aaMySqlQueryExExec",&aaMySqlQueryExExec);
 aaVmProcAdd(vm,0,"aaMySqlBeautifierReset",&aaMySqlBeautifierReset);
 aaVmProcAdd(vm,0,"aaMySqlBeautifierRead",&aaMySqlBeautifierRead);
 aaVmProcAdd(vm,0,"aaShellNew",&aaShellNew);
 aaVmProcAdd(vm,0,"aaShellDelete",&aaShellDelete);
 aaVmProcAdd(vm,0,"aaShellYield",&aaShellYield);
 aaVmProcAdd(vm,0,"aaShellLinePointer",&aaShellLinePointer);
 aaVmProcAdd(vm,0,"aaUpdateAreaReset",&aaUpdateAreaReset);
 aaVmProcAdd(vm,0,"aaUpdateAreaAdd",&aaUpdateAreaAdd);
 aaVmProcAdd(vm,0,"aaUpdateAreaRemove",&aaUpdateAreaRemove);
 aaVmProcAdd(vm,0,"aaColorHalfToneGet",&aaColorHalfToneGet);
 aaVmProcAdd(vm,0,"aaColorHalfToneCalculate",&aaColorHalfToneCalculate);
 aaVmProcAdd(vm,0,"aaFontCreate",&aaFontCreate);
 aaVmProcAdd(vm,0,"aaFontCreateUsingResource",&aaFontCreateUsingResource);
 aaVmProcAdd(vm,0,"aaFontCreateFixedWidth",&aaFontCreateFixedWidth);
 aaVmProcAdd(vm,0,"aaFontDestroy",&aaFontDestroy);
 aaVmProcAdd(vm,0,"aaFontMonoForceSet",&aaFontMonoForceSet);
 aaVmProcAdd(vm,0,"aaFontMonoForceSizeSet",&aaFontMonoForceSizeSet);
 aaVmProcAdd(vm,0,"aaFontStatus",&aaFontStatus);
 aaVmProcAdd(vm,0,"aaFontCharRectGet",&aaFontCharRectGet);
 aaVmProcAdd(vm,0,"aaFontStringCharRectsGet",&aaFontStringCharRectsGet);
 aaVmProcAdd(vm,0,"aaFontStringSizeGet",&aaFontStringSizeGet);
 aaVmProcAdd(vm,0,"aaFontStringSizeFit",&aaFontStringSizeFit);
 aaVmProcAdd(vm,0,"aaFontStringCharRectGet",&aaFontStringCharRectGet);
 aaVmProcAdd(vm,0,"aaFontFamilyList",&aaFontFamilyList);
 aaVmProcAdd(vm,0,"aaPixelStyleInit",&aaPixelStyleInit);
 aaVmProcAdd(vm,0,"aaPixelStyleSet",&aaPixelStyleSet);
 aaVmProcAdd(vm,0,"aaSurfaceCreate",&aaSurfaceCreate);
 aaVmProcAdd(vm,0,"aaSurfaceMinMaxCreate",&aaSurfaceMinMaxCreate);
 aaVmProcAdd(vm,0,"aaSurfaceMake",&aaSurfaceMake);
 aaVmProcAdd(vm,0,"aaSurfaceLoad",&aaSurfaceLoad);
 aaVmProcAdd(vm,0,"aaSurfaceLoadUsingResource",&aaSurfaceLoadUsingResource);
 aaVmProcAdd(vm,0,"aaSurfaceLoadFromMemory",&aaSurfaceLoadFromMemory);
 aaVmProcAdd(vm,0,"aaSurfaceDuplicate",&aaSurfaceDuplicate);
 aaVmProcAdd(vm,0,"aaSurfaceFindByHwnd",&aaSurfaceFindByHwnd);
 aaVmProcAdd(vm,0,"aaSurfaceSave",&aaSurfaceSave);
 aaVmProcAdd(vm,0,"aaSurfaceSaveToMemory",&aaSurfaceSaveToMemory);
 aaVmProcAdd(vm,0,"aaSurfaceReMake",&aaSurfaceReMake);
 aaVmProcAdd(vm,0,"aaSurfaceDestroy",&aaSurfaceDestroy);
 aaVmProcAdd(vm,0,"aaSurfaceIgnoreWMPaint",&aaSurfaceIgnoreWMPaint);
 aaVmProcAdd(vm,0,"aaSurfaceMinMaxSizeSet",&aaSurfaceMinMaxSizeSet);
 aaVmProcAdd(vm,0,"aaSurfaceMaximize",&aaSurfaceMaximize);
 aaVmProcAdd(vm,0,"aaSurfaceRequiresResize",&aaSurfaceRequiresResize);
 aaVmProcAdd(vm,0,"aaSurfaceElseProcSet",&aaSurfaceElseProcSet);
 aaVmProcAdd(vm,0,"aaSurfaceStatus",&aaSurfaceStatus);
 aaVmProcAdd(vm,0,"aaSurfaceCursorCapture",&aaSurfaceCursorCapture);
 aaVmProcAdd(vm,0,"aaSurfaceMoveableSet",&aaSurfaceMoveableSet);
 aaVmProcAdd(vm,0,"aaSurfaceSizeableSet",&aaSurfaceSizeableSet);
 aaVmProcAdd(vm,0,"aaSurfaceResizeCounterGet",&aaSurfaceResizeCounterGet);
 aaVmProcAdd(vm,0,"aaSurfaceResizeCounterReset",&aaSurfaceResizeCounterReset);
 aaVmProcAdd(vm,0,"aaSurfaceDisableRect",&aaSurfaceDisableRect);
 aaVmProcAdd(vm,0,"aaSurfaceClipperGet",&aaSurfaceClipperGet);
 aaVmProcAdd(vm,0,"aaSurfaceClipperSet",&aaSurfaceClipperSet);
 aaVmProcAdd(vm,0,"aaSurfaceFlipSet",&aaSurfaceFlipSet);
 aaVmProcAdd(vm,0,"aaSurfaceBlendSet",&aaSurfaceBlendSet);
 aaVmProcAdd(vm,0,"aaSurfaceAlphaSet",&aaSurfaceAlphaSet);
 aaVmProcAdd(vm,0,"aaSurfaceVisualize",&aaSurfaceVisualize);
 aaVmProcAdd(vm,0,"aaSurfaceRoundedSet",&aaSurfaceRoundedSet);
 aaVmProcAdd(vm,0,"aaSurfaceShow",&aaSurfaceShow);
 aaVmProcAdd(vm,0,"aaSurfaceTraySet",&aaSurfaceTraySet);
 aaVmProcAdd(vm,0,"aaSurfaceTrayClickClear",&aaSurfaceTrayClickClear);
 aaVmProcAdd(vm,0,"aaSurfaceIsTrayClicked",&aaSurfaceIsTrayClicked);
 aaVmProcAdd(vm,0,"aaSurfaceTitleSet",&aaSurfaceTitleSet);
 aaVmProcAdd(vm,0,"aaSurfaceTitleAppendf",&aaSurfaceTitleAppendf);
 aaVmProcAdd(vm,0,"aaSurfaceIconSetUsingResource",&aaSurfaceIconSetUsingResource);
 aaVmProcAdd(vm,0,"aaSurfaceFocus",&aaSurfaceFocus);
 aaVmProcAdd(vm,0,"aaSurfaceMinimize",&aaSurfaceMinimize);
 aaVmProcAdd(vm,0,"aaSurfaceRestore",&aaSurfaceRestore);
 aaVmProcAdd(vm,0,"aaSurfaceRectSet",&aaSurfaceRectSet);
 aaVmProcAdd(vm,0,"aaSurfaceCordSet",&aaSurfaceCordSet);
 aaVmProcAdd(vm,0,"aaSurfaceSizeSet",&aaSurfaceSizeSet);
 aaVmProcAdd(vm,0,"aaSurfaceRectGet",&aaSurfaceRectGet);
 aaVmProcAdd(vm,0,"aaSurfaceCordGet",&aaSurfaceCordGet);
 aaVmProcAdd(vm,0,"aaSurfaceSizeGet",&aaSurfaceSizeGet);
 aaVmProcAdd(vm,0,"aaSurfaceViewportSet",&aaSurfaceViewportSet);
 aaVmProcAdd(vm,0,"aaSurfaceCenter",&aaSurfaceCenter);
 aaVmProcAdd(vm,0,"aaSurfaceRectAlign",&aaSurfaceRectAlign);
 aaVmProcAdd(vm,0,"aaSurfaceMonitorAlign",&aaSurfaceMonitorAlign);
 aaVmProcAdd(vm,0,"aaSurfaceCordAdjust",&aaSurfaceCordAdjust);
 aaVmProcAdd(vm,0,"aaSurfaceOnTop",&aaSurfaceOnTop);
 aaVmProcAdd(vm,0,"aaSurfaceCordToVisualCord",&aaSurfaceCordToVisualCord);
 aaVmProcAdd(vm,0,"aaSurfaceVisualCordToCord",&aaSurfaceVisualCordToCord);
 aaVmProcAdd(vm,0,"aaSurfaceCaretReset",&aaSurfaceCaretReset);
 aaVmProcAdd(vm,0,"aaSurfaceCaretShow",&aaSurfaceCaretShow);
 aaVmProcAdd(vm,0,"aaSurfaceCaretRectSet",&aaSurfaceCaretRectSet);
 aaVmProcAdd(vm,0,"aaSurfaceCaretGet",&aaSurfaceCaretGet);
 aaVmProcAdd(vm,0,"aaSurfaceCaretSpeedSet",&aaSurfaceCaretSpeedSet);
 aaVmProcAdd(vm,0,"aaSurfaceBlit",&aaSurfaceBlit);
 aaVmProcAdd(vm,0,"aaSurfaceImageDrawUsingSurface",&aaSurfaceImageDrawUsingSurface);
 aaVmProcAdd(vm,0,"aaSurfaceImageDraw",&aaSurfaceImageDraw);
 aaVmProcAdd(vm,0,"aaSurfaceImageGrab",&aaSurfaceImageGrab);
 aaVmProcAdd(vm,0,"aaSurfaceImageTile",&aaSurfaceImageTile);
 aaVmProcAdd(vm,0,"aaSurfaceImageWarp",&aaSurfaceImageWarp);
 aaVmProcAdd(vm,0,"aaSurfaceImageRgbaReplace",&aaSurfaceImageRgbaReplace);
 aaVmProcAdd(vm,0,"aaSurfacePixelStyleSet",&aaSurfacePixelStyleSet);
 aaVmProcAdd(vm,0,"aaSurfacePixelStyleGet",&aaSurfacePixelStyleGet);
 aaVmProcAdd(vm,0,"aaSurfacePixelPutProc",&aaSurfacePixelPutProc);
 aaVmProcAdd(vm,0,"aaSurfacePixelSetProc",&aaSurfacePixelSetProc);
 aaVmProcAdd(vm,0,"aaSurfacePixelGetProc",&aaSurfacePixelGetProc);
 aaVmProcAdd(vm,0,"aaSurfacePixelPutProcGet",&aaSurfacePixelPutProcGet);
 aaVmProcAdd(vm,0,"aaSurfacePixelSetProcGet",&aaSurfacePixelSetProcGet);
 aaVmProcAdd(vm,0,"aaSurfacePixelGetProcGet",&aaSurfacePixelGetProcGet);
 aaVmProcAdd(vm,0,"aaSurfacePixelPutProcSet",&aaSurfacePixelPutProcSet);
 aaVmProcAdd(vm,0,"aaSurfacePixelSetProcSet",&aaSurfacePixelSetProcSet);
 aaVmProcAdd(vm,0,"aaSurfacePixelGetProcSet",&aaSurfacePixelGetProcSet);
 aaVmProcAdd(vm,0,"aaSurfacePixelPut",&aaSurfacePixelPut);
 aaVmProcAdd(vm,0,"aaSurfacePixelSet",&aaSurfacePixelSet);
 aaVmProcAdd(vm,0,"aaSurfacePixelGet",&aaSurfacePixelGet);
 aaVmProcAdd(vm,0,"aaSurfaceMaskNotSet",&aaSurfaceMaskNotSet);
 aaVmProcAdd(vm,0,"aaSurfaceMaskNotGet",&aaSurfaceMaskNotGet);
 aaVmProcAdd(vm,0,"aaSurfaceMaskSet",&aaSurfaceMaskSet);
 aaVmProcAdd(vm,0,"aaSurfaceMaskGet",&aaSurfaceMaskGet);
 aaVmProcAdd(vm,0,"aaSurfaceLine",&aaSurfaceLine);
 aaVmProcAdd(vm,0,"aaSurfaceClear",&aaSurfaceClear);
 aaVmProcAdd(vm,0,"aaSurfaceFill",&aaSurfaceFill);
 aaVmProcAdd(vm,0,"aaSurfaceFrame",&aaSurfaceFrame);
 aaVmProcAdd(vm,0,"aaSurfaceFramePart",&aaSurfaceFramePart);
 aaVmProcAdd(vm,0,"aaSurfaceFillFrame",&aaSurfaceFillFrame);
 aaVmProcAdd(vm,0,"aaSurfacePoly",&aaSurfacePoly);
 aaVmProcAdd(vm,0,"aaSurfaceBar",&aaSurfaceBar);
 aaVmProcAdd(vm,0,"aaSurfaceTriangle",&aaSurfaceTriangle);
 aaVmProcAdd(vm,0,"aaSurfaceTriangleFill",&aaSurfaceTriangleFill);
 aaVmProcAdd(vm,0,"aaSurfaceEllipse",&aaSurfaceEllipse);
 aaVmProcAdd(vm,0,"aaSurfaceEllipseFill",&aaSurfaceEllipseFill);
 aaVmProcAdd(vm,0,"aaSurfaceEllipseFillFrame",&aaSurfaceEllipseFillFrame);
 aaVmProcAdd(vm,0,"aaSurfaceFloodFill",&aaSurfaceFloodFill);
 aaVmProcAdd(vm,0,"aaSurfaceArc",&aaSurfaceArc);
 aaVmProcAdd(vm,0,"aaSurfaceRoundedFrame",&aaSurfaceRoundedFrame);
 aaVmProcAdd(vm,0,"aaSurfaceRoundedFill",&aaSurfaceRoundedFill);
 aaVmProcAdd(vm,0,"aaSurfaceChamfer",&aaSurfaceChamfer);
 aaVmProcAdd(vm,0,"aaSurfaceGimpTile",&aaSurfaceGimpTile);
 aaVmProcAdd(vm,0,"aaSurfaceDragBar",&aaSurfaceDragBar);
 aaVmProcAdd(vm,0,"aaSurfaceLabel",&aaSurfaceLabel);
 aaVmProcAdd(vm,0,"aaSurfaceFuzz",&aaSurfaceFuzz);
 aaVmProcAdd(vm,0,"aaSurfacePrintf",&aaSurfacePrintf);
 aaVmProcAdd(vm,0,"aaSurfaceScroll",&aaSurfaceScroll);
 aaVmProcAdd(vm,0,"aaSurfaceBevel",&aaSurfaceBevel);
 aaVmProcAdd(vm,0,"aaSurfaceBlur",&aaSurfaceBlur);
 aaVmProcAdd(vm,0,"aaSurfaceConvolve",&aaSurfaceConvolve);
 aaVmProcAdd(vm,0,"aaSurfaceButtonFrame",&aaSurfaceButtonFrame);
 aaVmProcAdd(vm,0,"aaSurfaceGradientFill",&aaSurfaceGradientFill);
 aaVmProcAdd(vm,0,"aaSurfaceField",&aaSurfaceField);
 aaVmProcAdd(vm,0,"aaSurfaceLog",&aaSurfaceLog);
 aaVmProcAdd(vm,0,"aaSurfaceLogWriteSet",&aaSurfaceLogWriteSet);
 aaVmProcAdd(vm,0,"aaSurfaceUpdateAreaAdd",&aaSurfaceUpdateAreaAdd);
 aaVmProcAdd(vm,0,"aaSurfaceUpdateAreaRemove",&aaSurfaceUpdateAreaRemove);
 aaVmProcAdd(vm,0,"aaSurfaceUpdateAreaReset",&aaSurfaceUpdateAreaReset);
 aaVmProcAdd(vm,0,"aaSurfaceUpdate",&aaSurfaceUpdate);
 aaVmProcAdd(vm,0,"aaSurfaceUpdateAndStatus",&aaSurfaceUpdateAndStatus);
 aaVmProcAdd(vm,0,"aaSurfaceCaptureScreen",&aaSurfaceCaptureScreen);
 aaVmProcAdd(vm,0,"aaSurfaceExtraDataSet",&aaSurfaceExtraDataSet);
 aaVmProcAdd(vm,0,"aaSurfaceExtraDataGet",&aaSurfaceExtraDataGet);
 aaVmProcAdd(vm,0,"aaSurfaceDropAccept",&aaSurfaceDropAccept);
 aaVmProcAdd(vm,0,"aaSurfaceDropClear",&aaSurfaceDropClear);
 aaVmProcAdd(vm,0,"aaSurfaceSpotIdRangeReserve",&aaSurfaceSpotIdRangeReserve);
 aaVmProcAdd(vm,0,"aaSurfaceSpotFindByNumber",&aaSurfaceSpotFindByNumber);
 aaVmProcAdd(vm,0,"aaSurfaceSpotFindById",&aaSurfaceSpotFindById);
 aaVmProcAdd(vm,0,"aaSurfaceSpotAdd",&aaSurfaceSpotAdd);
 aaVmProcAdd(vm,0,"aaSurfaceSpotRemove",&aaSurfaceSpotRemove);
 aaVmProcAdd(vm,0,"aaSurfaceSpotPurge",&aaSurfaceSpotPurge);
 aaVmProcAdd(vm,0,"aaSurfaceSpotSet",&aaSurfaceSpotSet);
 aaVmProcAdd(vm,0,"aaSurfaceSpotStateSet",&aaSurfaceSpotStateSet);
 aaVmProcAdd(vm,0,"aaSurfaceArrow",&aaSurfaceArrow);
 aaVmProcAdd(vm,0,"aaSurfaceCheckMark",&aaSurfaceCheckMark);
 aaVmProcAdd(vm,0,"aaSurfaceCrossMark",&aaSurfaceCrossMark);
 aaVmProcAdd(vm,0,"aaSurfaceRadioButton",&aaSurfaceRadioButton);
 aaVmProcAdd(vm,0,"aaSurfaceCloseIcon",&aaSurfaceCloseIcon);
 aaVmProcAdd(vm,0,"aaSurfaceMaximizeIcon",&aaSurfaceMaximizeIcon);
 aaVmProcAdd(vm,0,"aaSurfaceRestoreIcon",&aaSurfaceRestoreIcon);
 aaVmProcAdd(vm,0,"aaSurfaceMinimizeIcon",&aaSurfaceMinimizeIcon);
 aaVmProcAdd(vm,0,"aaSurfaceCaption",&aaSurfaceCaption);
 aaVmProcAdd(vm,0,"aaSurfaceCaptionButtons",&aaSurfaceCaptionButtons);
 aaVmProcAdd(vm,0,"aaImageYuv420ToBgra",&aaImageYuv420ToBgra);
 aaVmProcAdd(vm,0,"aaFancyTextInit",&aaFancyTextInit);
 aaVmProcAdd(vm,0,"aaFancyTextRectSet",&aaFancyTextRectSet);
 aaVmProcAdd(vm,0,"aaFancyTextSelSet",&aaFancyTextSelSet);
 aaVmProcAdd(vm,0,"aaFancyTextCaretSet",&aaFancyTextCaretSet);
 aaVmProcAdd(vm,0,"aaFancyTextPositionSet",&aaFancyTextPositionSet);
 aaVmProcAdd(vm,0,"aaFancyTextWrite",&aaFancyTextWrite);
 aaVmProcAdd(vm,0,"aaFancyTextWritef",&aaFancyTextWritef);
 aaVmProcAdd(vm,0,"aaFancyTextPaint",&aaFancyTextPaint);
 aaVmProcAdd(vm,0,"aaCursorSet",&aaCursorSet);
 aaVmProcAdd(vm,0,"aaCursorGet",&aaCursorGet);
 aaVmProcAdd(vm,0,"aaCursorSimulate",&aaCursorSimulate);
 aaVmProcAdd(vm,0,"aaAppBarSet",&aaAppBarSet);
 aaVmProcAdd(vm,0,"aaAppBarGet",&aaAppBarGet);
 aaVmProcAdd(vm,0,"aaGifCreate",&aaGifCreate);
 aaVmProcAdd(vm,0,"aaGifCreateUsingResource",&aaGifCreateUsingResource);
 aaVmProcAdd(vm,0,"aaGifDestroy",&aaGifDestroy);
 aaVmProcAdd(vm,0,"aaGifStatus",&aaGifStatus);
 aaVmProcAdd(vm,0,"aaGifRewind",&aaGifRewind);
 aaVmProcAdd(vm,0,"aaGifFrameNext",&aaGifFrameNext);
 aaVmProcAdd(vm,0,"aaInputKeySimulate",&aaInputKeySimulate);
 aaVmProcAdd(vm,0,"aaInputKeyPairSimulate",&aaInputKeyPairSimulate);
 aaVmProcAdd(vm,0,"aaInputKeyPattern",&aaInputKeyPattern);
 aaVmProcAdd(vm,0,"aaInputKeyStringSimulate",&aaInputKeyStringSimulate);
 aaVmProcAdd(vm,0,"aaInputKeyCharSimulate",&aaInputKeyCharSimulate);
 aaVmProcAdd(vm,0,"aaInputStateGet",&aaInputStateGet);
 aaVmProcAdd(vm,0,"aaInputEngine",&aaInputEngine);
 aaVmProcAdd(vm,0,"aaInputEventToString",&aaInputEventToString);
 aaVmProcAdd(vm,0,"aaDisplaySet",&aaDisplaySet);
 aaVmProcAdd(vm,0,"aaDisplayInfoGet",&aaDisplayInfoGet);
 aaVmProcAdd(vm,0,"aaDisplayMonitorFromCord",&aaDisplayMonitorFromCord);
 aaVmProcAdd(vm,0,"aaDisplayGammaGet",&aaDisplayGammaGet);
 aaVmProcAdd(vm,0,"aaDisplayGammaSet",&aaDisplayGammaSet);
 aaVmProcAdd(vm,0,"aaDisplayGammaBrightnessSet",&aaDisplayGammaBrightnessSet);
 aaVmProcAdd(vm,0,"aaDisplayBrightnessSet",&aaDisplayBrightnessSet);
 aaVmProcAdd(vm,0,"aaDisplayBrightnessFlash",&aaDisplayBrightnessFlash);
 aaVmProcAdd(vm,0,"aaDisplayPixelGet",&aaDisplayPixelGet);
 aaVmProcAdd(vm,0,"aaDisplayPixelSet",&aaDisplayPixelSet);
 aaVmProcAdd(vm,0,"aaDisplayInfoToString",&aaDisplayInfoToString);
 aaVmProcAdd(vm,0,"aaDisplayMonitorPowerSet",&aaDisplayMonitorPowerSet);
 aaVmProcAdd(vm,0,"aaDisplayPowerBrightnessGet",&aaDisplayPowerBrightnessGet);
 aaVmProcAdd(vm,0,"aaDisplayPowerBrightnessSet",&aaDisplayPowerBrightnessSet);
 aaVmProcAdd(vm,0,"aaDisplayToMm",&aaDisplayToMm);
 aaVmProcAdd(vm,0,"aaDisplayFromMm",&aaDisplayFromMm);
 aaVmProcAdd(vm,0,"aaAudioCountGet",&aaAudioCountGet);
 aaVmProcAdd(vm,0,"aaAudioNameGet",&aaAudioNameGet);
 aaVmProcAdd(vm,0,"aaAudioModeSet",&aaAudioModeSet);
 aaVmProcAdd(vm,0,"aaAudioModeCopy",&aaAudioModeCopy);
 aaVmProcAdd(vm,0,"aaAudioModeIsValid",&aaAudioModeIsValid);
 aaVmProcAdd(vm,0,"aaAudioBpmToSamples",&aaAudioBpmToSamples);
 aaVmProcAdd(vm,0,"aaAudioBpmFromSamples",&aaAudioBpmFromSamples);
 aaVmProcAdd(vm,0,"aaAudioSamplesToTime",&aaAudioSamplesToTime);
 aaVmProcAdd(vm,0,"aaAudioSamplesFromTime",&aaAudioSamplesFromTime);
 aaVmProcAdd(vm,0,"aaAudioToFloats",&aaAudioToFloats);
 aaVmProcAdd(vm,0,"aaAudioFromFloats",&aaAudioFromFloats);
 aaVmProcAdd(vm,0,"aaAudioConverterInit",&aaAudioConverterInit);
 aaVmProcAdd(vm,0,"aaAudioConverterProcess",&aaAudioConverterProcess);
 aaVmProcAdd(vm,0,"aaAudioPitchTempoGet",&aaAudioPitchTempoGet);
 aaVmProcAdd(vm,0,"aaAudioPitchShiftInit",&aaAudioPitchShiftInit);
 aaVmProcAdd(vm,0,"aaAudioPitchShift",&aaAudioPitchShift);
 aaVmProcAdd(vm,0,"aaAudioCreate",&aaAudioCreate);
 aaVmProcAdd(vm,0,"aaAudioDestroy",&aaAudioDestroy);
 aaVmProcAdd(vm,0,"aaAudioStatus",&aaAudioStatus);
 aaVmProcAdd(vm,0,"aaAudioReset",&aaAudioReset);
 aaVmProcAdd(vm,0,"aaAudioPause",&aaAudioPause);
 aaVmProcAdd(vm,0,"aaAudioWrite",&aaAudioWrite);
 aaVmProcAdd(vm,0,"aaAudioRead",&aaAudioRead);
 aaVmProcAdd(vm,0,"aaAudioPeek",&aaAudioPeek);
 aaVmProcAdd(vm,0,"aaAudioDiscard",&aaAudioDiscard);
 aaVmProcAdd(vm,0,"aaAudioMuteSet",&aaAudioMuteSet);
 aaVmProcAdd(vm,0,"aaAudioVolumeSet",&aaAudioVolumeSet);
 aaVmProcAdd(vm,0,"aaBiquadInit",&aaBiquadInit);
 aaVmProcAdd(vm,0,"aaBiquadProcess",&aaBiquadProcess);
 aaVmProcAdd(vm,0,"aaMathDct",&aaMathDct);
 aaVmProcAdd(vm,0,"aaMathSinTableCreate",&aaMathSinTableCreate);
 aaVmProcAdd(vm,0,"aaMathCosTableCreate",&aaMathCosTableCreate);
 aaVmProcAdd(vm,0,"aaMathDtmfSet",&aaMathDtmfSet);
 aaVmProcAdd(vm,0,"aaMathLatLongDistanceGet",&aaMathLatLongDistanceGet);
 aaVmProcAdd(vm,0,"aaMathLatLongCordGet",&aaMathLatLongCordGet);
 aaVmProcAdd(vm,0,"aaMathDoubleRound",&aaMathDoubleRound);
 aaVmProcAdd(vm,0,"aaMathRand32",&aaMathRand32);
 aaVmProcAdd(vm,0,"aaMathRand64",&aaMathRand64);
 aaVmProcAdd(vm,0,"aaMathRandDouble",&aaMathRandDouble);
 aaVmProcAdd(vm,0,"aaMathRandomGet",&aaMathRandomGet);
 aaVmProcAdd(vm,0,"aaMathTwisterInit",&aaMathTwisterInit);
 aaVmProcAdd(vm,0,"aaMathTwisterInt32",&aaMathTwisterInt32);
 aaVmProcAdd(vm,0,"aaMathTwisterInt31",&aaMathTwisterInt31);
 aaVmProcAdd(vm,0,"aaMathTwisterReal1",&aaMathTwisterReal1);
 aaVmProcAdd(vm,0,"aaMathTwisterReal2",&aaMathTwisterReal2);
 aaVmProcAdd(vm,0,"aaMathTwisterReal3",&aaMathTwisterReal3);
 aaVmProcAdd(vm,0,"aaMathTwisterRes53",&aaMathTwisterRes53);
 aaVmProcAdd(vm,0,"aaMathAngleToCord",&aaMathAngleToCord);
 aaVmProcAdd(vm,0,"aaMathLog2",&aaMathLog2);
 aaVmProcAdd(vm,0,"aaMathLog2D",&aaMathLog2D);
 aaVmProcAdd(vm,0,"aaMathIsPowerOfTwo",&aaMathIsPowerOfTwo);
 aaVmProcAdd(vm,0,"aaBigInit",&aaBigInit);
 aaVmProcAdd(vm,0,"aaBigCopy",&aaBigCopy);
 aaVmProcAdd(vm,0,"aaBigDump",&aaBigDump);
 aaVmProcAdd(vm,0,"aaBigBaseSet",&aaBigBaseSet);
 aaVmProcAdd(vm,0,"aaBigToInt",&aaBigToInt);
 aaVmProcAdd(vm,0,"aaBigFromInt",&aaBigFromInt);
 aaVmProcAdd(vm,0,"aaBigToString",&aaBigToString);
 aaVmProcAdd(vm,0,"aaBigFromString",&aaBigFromString);
 aaVmProcAdd(vm,0,"aaBigFromStringf",&aaBigFromStringf);
 aaVmProcAdd(vm,0,"aaBigIsOdd",&aaBigIsOdd);
 aaVmProcAdd(vm,0,"aaBigIsEven",&aaBigIsEven);
 aaVmProcAdd(vm,0,"aaBigIsZero",&aaBigIsZero);
 aaVmProcAdd(vm,0,"aaBigIsOne",&aaBigIsOne);
 aaVmProcAdd(vm,0,"aaBigCompare",&aaBigCompare);
 aaVmProcAdd(vm,0,"aaBigAdd",&aaBigAdd);
 aaVmProcAdd(vm,0,"aaBigSub",&aaBigSub);
 aaVmProcAdd(vm,0,"aaBigMul",&aaBigMul);
 aaVmProcAdd(vm,0,"aaBigDiv",&aaBigDiv);
 aaVmProcAdd(vm,0,"aaBigMod",&aaBigMod);
 aaVmProcAdd(vm,0,"aaBigPow",&aaBigPow);
 aaVmProcAdd(vm,0,"aaBigCompareInt",&aaBigCompareInt);
 aaVmProcAdd(vm,0,"aaBigAddInt",&aaBigAddInt);
 aaVmProcAdd(vm,0,"aaBigSubInt",&aaBigSubInt);
 aaVmProcAdd(vm,0,"aaBigMulInt",&aaBigMulInt);
 aaVmProcAdd(vm,0,"aaBigDivInt",&aaBigDivInt);
 aaVmProcAdd(vm,0,"aaBigModInt",&aaBigModInt);
 aaVmProcAdd(vm,0,"aaBigPowInt",&aaBigPowInt);
 aaVmProcAdd(vm,0,"aaBigInc",&aaBigInc);
 aaVmProcAdd(vm,0,"aaBigDec",&aaBigDec);
 aaVmProcAdd(vm,0,"aaBigSquareRoot",&aaBigSquareRoot);
 aaVmProcAdd(vm,0,"aaBigIsPrime",&aaBigIsPrime);
 aaVmProcAdd(vm,0,"aaBigShiftLeft",&aaBigShiftLeft);
 aaVmProcAdd(vm,0,"aaBigShiftRight",&aaBigShiftRight);
 aaVmProcAdd(vm,0,"aaBigShiftLeftInt",&aaBigShiftLeftInt);
 aaVmProcAdd(vm,0,"aaBigShiftRightInt",&aaBigShiftRightInt);
 aaVmProcAdd(vm,0,"aaBigBitSet",&aaBigBitSet);
 aaVmProcAdd(vm,0,"aaBigBitIsSet",&aaBigBitIsSet);
 aaVmProcAdd(vm,0,"aaBigBitClear",&aaBigBitClear);
 aaVmProcAdd(vm,0,"aaBigBitSetInt",&aaBigBitSetInt);
 aaVmProcAdd(vm,0,"aaBigBitIsSetInt",&aaBigBitIsSetInt);
 aaVmProcAdd(vm,0,"aaBigBitClearInt",&aaBigBitClearInt);
 aaVmProcAdd(vm,0,"aaVidCapCountGet",&aaVidCapCountGet);
 aaVmProcAdd(vm,0,"aaVidCapNameGet",&aaVidCapNameGet);
 aaVmProcAdd(vm,0,"aaVidCapCreate",&aaVidCapCreate);
 aaVmProcAdd(vm,0,"aaVidCapCreateAutoDetect",&aaVidCapCreateAutoDetect);
 aaVmProcAdd(vm,0,"aaVidCapDestroy",&aaVidCapDestroy);
 aaVmProcAdd(vm,0,"aaVidCapStatus",&aaVidCapStatus);
 aaVmProcAdd(vm,0,"aaVidCapFormatSet",&aaVidCapFormatSet);
 aaVmProcAdd(vm,0,"aaVidCapPreviewSet",&aaVidCapPreviewSet);
 aaVmProcAdd(vm,0,"aaVidCapFrameIsReady",&aaVidCapFrameIsReady);
 aaVmProcAdd(vm,0,"aaVidCapFrameNext",&aaVidCapFrameNext);
 aaVmProcAdd(vm,0,"aaVidCapSourceBoxShow",&aaVidCapSourceBoxShow);
 aaVmProcAdd(vm,0,"aaWavLoad",&aaWavLoad);
 aaVmProcAdd(vm,0,"aaWavLoadUsingResource",&aaWavLoadUsingResource);
 aaVmProcAdd(vm,0,"aaWavRelease",&aaWavRelease);
 aaVmProcAdd(vm,0,"aaIniOpen",&aaIniOpen);
 aaVmProcAdd(vm,0,"aaIniClose",&aaIniClose);
 aaVmProcAdd(vm,0,"aaIniEntryGet",&aaIniEntryGet);
 aaVmProcAdd(vm,0,"aaFilePartsGet",&aaFilePartsGet);
 aaVmProcAdd(vm,0,"aaFileEqualsFile",&aaFileEqualsFile);
 aaVmProcAdd(vm,0,"aaFileInfoGet",&aaFileInfoGet);
 aaVmProcAdd(vm,0,"aaFileInformationGet",&aaFileInformationGet);
 aaVmProcAdd(vm,0,"aaFileExists",&aaFileExists);
 aaVmProcAdd(vm,0,"aaFileDelete",&aaFileDelete);
 aaVmProcAdd(vm,0,"aaFileCopy",&aaFileCopy);
 aaVmProcAdd(vm,0,"aaFileRename",&aaFileRename);
 aaVmProcAdd(vm,0,"aaFileSaveFromMemory",&aaFileSaveFromMemory);
 aaVmProcAdd(vm,0,"aaFileAppendFromMemory",&aaFileAppendFromMemory);
 aaVmProcAdd(vm,0,"aaFileAppendf",&aaFileAppendf);
 aaVmProcAdd(vm,0,"aaFileLoadToMemory",&aaFileLoadToMemory);
 aaVmProcAdd(vm,0,"aaFileLoadToBuffer",&aaFileLoadToBuffer);
 aaVmProcAdd(vm,0,"aaFileUniqueCreate",&aaFileUniqueCreate);
 aaVmProcAdd(vm,0,"aaFileTimeSet",&aaFileTimeSet);
 aaVmProcAdd(vm,0,"aaFileSizeSet",&aaFileSizeSet);
 aaVmProcAdd(vm,0,"aaFileIsUpxCompressed",&aaFileIsUpxCompressed);
 aaVmProcAdd(vm,0,"aaFileAttributesGet",&aaFileAttributesGet);
 aaVmProcAdd(vm,0,"aaFileAttributesSet",&aaFileAttributesSet);
 aaVmProcAdd(vm,0,"aaFileDetailsGet",&aaFileDetailsGet);
 aaVmProcAdd(vm,0,"aaFileFolderCreate",&aaFileFolderCreate);
 aaVmProcAdd(vm,0,"aaFileFolderDelete",&aaFileFolderDelete);
 aaVmProcAdd(vm,0,"aaFileFolderExists",&aaFileFolderExists);
 aaVmProcAdd(vm,0,"aaFileFolderWorkingSet",&aaFileFolderWorkingSet);
 aaVmProcAdd(vm,0,"aaFileFolderWorkingGet",&aaFileFolderWorkingGet);
 aaVmProcAdd(vm,0,"aaFileFolderRename",&aaFileFolderRename);
 aaVmProcAdd(vm,0,"aaFileFolderTreeCreate",&aaFileFolderTreeCreate);
 aaVmProcAdd(vm,0,"aaFileFolderTreeDelete",&aaFileFolderTreeDelete);
 aaVmProcAdd(vm,0,"aaFileUnitLoad",&aaFileUnitLoad);
 aaVmProcAdd(vm,0,"aaFileUnitRelease",&aaFileUnitRelease);
 aaVmProcAdd(vm,0,"aaFileBoxOpen",&aaFileBoxOpen);
 aaVmProcAdd(vm,0,"aaFileBoxClose",&aaFileBoxClose);
 aaVmProcAdd(vm,0,"aaFileBoxStatus",&aaFileBoxStatus);
 aaVmProcAdd(vm,0,"aaFolderBoxOpen",&aaFolderBoxOpen);
 aaVmProcAdd(vm,0,"aaFolderBoxClose",&aaFolderBoxClose);
 aaVmProcAdd(vm,0,"aaFolderBoxStatus",&aaFolderBoxStatus);
 aaVmProcAdd(vm,0,"aaDirOpen",&aaDirOpen);
 aaVmProcAdd(vm,0,"aaDirClose",&aaDirClose);
 aaVmProcAdd(vm,0,"aaDirStatus",&aaDirStatus);
 aaVmProcAdd(vm,0,"aaDirWalkerCreate",&aaDirWalkerCreate);
 aaVmProcAdd(vm,0,"aaDirWalkerDestroy",&aaDirWalkerDestroy);
 aaVmProcAdd(vm,0,"aaDirWalkerStatus",&aaDirWalkerStatus);
 aaVmProcAdd(vm,0,"aaDriveInfoGet",&aaDriveInfoGet);
 aaVmProcAdd(vm,0,"aaDriveEject",&aaDriveEject);
 aaVmProcAdd(vm,0,"aaDriveListGet",&aaDriveListGet);
 aaVmProcAdd(vm,0,"aaFileStreamCreate",&aaFileStreamCreate);
 aaVmProcAdd(vm,0,"aaFileStreamDestroy",&aaFileStreamDestroy);
 aaVmProcAdd(vm,0,"aaFileStreamStatus",&aaFileStreamStatus);
 aaVmProcAdd(vm,0,"aaFileStreamInfoGet",&aaFileStreamInfoGet);
 aaVmProcAdd(vm,0,"aaFileStreamRead",&aaFileStreamRead);
 aaVmProcAdd(vm,0,"aaFileStreamPeek",&aaFileStreamPeek);
 aaVmProcAdd(vm,0,"aaFileStreamWrite",&aaFileStreamWrite);
 aaVmProcAdd(vm,0,"aaFileStreamWritef",&aaFileStreamWritef);
 aaVmProcAdd(vm,0,"aaFileStreamWriteByte",&aaFileStreamWriteByte);
 aaVmProcAdd(vm,0,"aaFileStreamWriteWord",&aaFileStreamWriteWord);
 aaVmProcAdd(vm,0,"aaFileStreamWriteDword",&aaFileStreamWriteDword);
 aaVmProcAdd(vm,0,"aaFileStreamWriteQuad",&aaFileStreamWriteQuad);
 aaVmProcAdd(vm,0,"aaFileStreamWriteFloat",&aaFileStreamWriteFloat);
 aaVmProcAdd(vm,0,"aaFileStreamWriteDouble",&aaFileStreamWriteDouble);
 aaVmProcAdd(vm,0,"aaFileStreamReadByte",&aaFileStreamReadByte);
 aaVmProcAdd(vm,0,"aaFileStreamReadWord",&aaFileStreamReadWord);
 aaVmProcAdd(vm,0,"aaFileStreamReadDword",&aaFileStreamReadDword);
 aaVmProcAdd(vm,0,"aaFileStreamReadQuad",&aaFileStreamReadQuad);
 aaVmProcAdd(vm,0,"aaFileStreamReadFloat",&aaFileStreamReadFloat);
 aaVmProcAdd(vm,0,"aaFileStreamReadDouble",&aaFileStreamReadDouble);
 aaVmProcAdd(vm,0,"aaFileStreamPeekByte",&aaFileStreamPeekByte);
 aaVmProcAdd(vm,0,"aaFileStreamPeekWord",&aaFileStreamPeekWord);
 aaVmProcAdd(vm,0,"aaFileStreamPeekDword",&aaFileStreamPeekDword);
 aaVmProcAdd(vm,0,"aaFileStreamPeekQuad",&aaFileStreamPeekQuad);
 aaVmProcAdd(vm,0,"aaFileStreamPeekFloat",&aaFileStreamPeekFloat);
 aaVmProcAdd(vm,0,"aaFileStreamPeekDouble",&aaFileStreamPeekDouble);
 aaVmProcAdd(vm,0,"aaFileStreamOffsetSet",&aaFileStreamOffsetSet);
 aaVmProcAdd(vm,0,"aaFileStreamOffsetAdjust",&aaFileStreamOffsetAdjust);
 aaVmProcAdd(vm,0,"aaFileStreamOffsetPush",&aaFileStreamOffsetPush);
 aaVmProcAdd(vm,0,"aaFileStreamOffsetPop",&aaFileStreamOffsetPop);
 aaVmProcAdd(vm,0,"aaFileStreamSizeSet",&aaFileStreamSizeSet);
 aaVmProcAdd(vm,0,"aaFileStreamSizeAdjust",&aaFileStreamSizeAdjust);
 aaVmProcAdd(vm,0,"aaFileStreamFlush",&aaFileStreamFlush);
 aaVmProcAdd(vm,0,"aaFileStreamStringLen",&aaFileStreamStringLen);
 aaVmProcAdd(vm,0,"aaFileStreamStringRead",&aaFileStreamStringRead);
 aaVmProcAdd(vm,0,"aaFileStreamStringLook",&aaFileStreamStringLook);
 aaVmProcAdd(vm,0,"aaFileStreamWriteEof",&aaFileStreamWriteEof);
 aaVmProcAdd(vm,0,"aaFileStreamSearch",&aaFileStreamSearch);
 aaVmProcAdd(vm,0,"aaFileStreamSearchf",&aaFileStreamSearchf);
 aaVmProcAdd(vm,0,"aaTextReaderNew",&aaTextReaderNew);
 aaVmProcAdd(vm,0,"aaTextReaderOpen",&aaTextReaderOpen);
 aaVmProcAdd(vm,0,"aaTextReaderDelete",&aaTextReaderDelete);
 aaVmProcAdd(vm,0,"aaTextReaderLineGet",&aaTextReaderLineGet);
 aaVmProcAdd(vm,0,"aaTextLoaderNew",&aaTextLoaderNew);
 aaVmProcAdd(vm,0,"aaTextLoaderDelete",&aaTextLoaderDelete);
 aaVmProcAdd(vm,0,"aaTextLoaderYield",&aaTextLoaderYield);
 aaVmProcAdd(vm,0,"aaSysRgbaGet",&aaSysRgbaGet);
 aaVmProcAdd(vm,0,"aaSysMetricsGet",&aaSysMetricsGet);
 aaVmProcAdd(vm,0,"aaSysPathGet",&aaSysPathGet);
 aaVmProcAdd(vm,0,"aaSysPathToString",&aaSysPathToString);
 aaVmProcAdd(vm,0,"aaSysVarsGet",&aaSysVarsGet);
 aaVmProcAdd(vm,0,"aaSysVarsSet",&aaSysVarsSet);
 aaVmProcAdd(vm,0,"aaSysvarsExplode",&aaSysvarsExplode);
 aaVmProcAdd(vm,0,"aaSysVarsToString",&aaSysVarsToString);
 aaVmProcAdd(vm,0,"aaSysInfoGet",&aaSysInfoGet);
 aaVmProcAdd(vm,0,"aaSysInfoToString",&aaSysInfoToString);
 aaVmProcAdd(vm,0,"aaSysPowerGet",&aaSysPowerGet);
 aaVmProcAdd(vm,0,"aaSysBenchmark",&aaSysBenchmark);
 aaVmProcAdd(vm,0,"aaSysRemoteSessionGet",&aaSysRemoteSessionGet);
 aaVmProcAdd(vm,0,"aaSysTrayGet",&aaSysTrayGet);
 aaVmProcAdd(vm,0,"aaSysFileIconGet",&aaSysFileIconGet);
 aaVmProcAdd(vm,0,"aaSysRestartOnCrashSet",&aaSysRestartOnCrashSet);
 aaVmProcAdd(vm,0,"aaSysCpuLoadRefresh",&aaSysCpuLoadRefresh);
 aaVmProcAdd(vm,0,"aaSysShortCutCreate",&aaSysShortCutCreate);
 aaVmProcAdd(vm,0,"aaSysUnInstallSet",&aaSysUnInstallSet);
 aaVmProcAdd(vm,0,"aaSysUnInstallRemove",&aaSysUnInstallRemove);
 aaVmProcAdd(vm,0,"aaSysStartupAppSet",&aaSysStartupAppSet);
 aaVmProcAdd(vm,0,"aaSysStartupAppGet",&aaSysStartupAppGet);
 aaVmProcAdd(vm,0,"aaSysStartupAppRemove",&aaSysStartupAppRemove);
 aaVmProcAdd(vm,0,"aaSysFileAssociationSet",&aaSysFileAssociationSet);
 aaVmProcAdd(vm,0,"aaSysFileAssociationRemove",&aaSysFileAssociationRemove);
 aaVmProcAdd(vm,0,"aaSysContextMenuSet",&aaSysContextMenuSet);
 aaVmProcAdd(vm,0,"aaSysContextMenuRemove",&aaSysContextMenuRemove);
 aaVmProcAdd(vm,0,"aaSysSchemeHandlerSet",&aaSysSchemeHandlerSet);
 aaVmProcAdd(vm,0,"aaSysTweak",&aaSysTweak);
 aaVmProcAdd(vm,0,"aaResourceInfoGet",&aaResourceInfoGet);
 aaVmProcAdd(vm,0,"aaResourceToMemory",&aaResourceToMemory);
 aaVmProcAdd(vm,0,"aaResourceToFile",&aaResourceToFile);
 aaVmProcAdd(vm,0,"aaDigestCreate",&aaDigestCreate);
 aaVmProcAdd(vm,0,"aaDigestDestroy",&aaDigestDestroy);
 aaVmProcAdd(vm,0,"aaDigestStatus",&aaDigestStatus);
 aaVmProcAdd(vm,0,"aaDigestWrite",&aaDigestWrite);
 aaVmProcAdd(vm,0,"aaDigestReset",&aaDigestReset);
 aaVmProcAdd(vm,0,"aaDigestToString",&aaDigestToString);
 aaVmProcAdd(vm,0,"aaDigestMac",&aaDigestMac);
 aaVmProcAdd(vm,0,"aaDigestQuick",&aaDigestQuick);
 aaVmProcAdd(vm,0,"aaDigestQuickf",&aaDigestQuickf);
 aaVmProcAdd(vm,0,"aaCryptoCreate",&aaCryptoCreate);
 aaVmProcAdd(vm,0,"aaCryptoDestroy",&aaCryptoDestroy);
 aaVmProcAdd(vm,0,"aaCryptoTranscode",&aaCryptoTranscode);
 aaVmProcAdd(vm,0,"aaJsonCreate",&aaJsonCreate);
 aaVmProcAdd(vm,0,"aaJsonDestroy",&aaJsonDestroy);
 aaVmProcAdd(vm,0,"aaJsonStatus",&aaJsonStatus);
 aaVmProcAdd(vm,0,"aaJsonReset",&aaJsonReset);
 aaVmProcAdd(vm,0,"aaJsonAppendf",&aaJsonAppendf);
 aaVmProcAdd(vm,0,"aaJsonAppendBytes",&aaJsonAppendBytes);
 aaVmProcAdd(vm,0,"aaJsonDecode",&aaJsonDecode);
 aaVmProcAdd(vm,0,"aaJsonEncodeObjectOpen",&aaJsonEncodeObjectOpen);
 aaVmProcAdd(vm,0,"aaJsonEncodeObjectClose",&aaJsonEncodeObjectClose);
 aaVmProcAdd(vm,0,"aaJsonEncodeArrayOpen",&aaJsonEncodeArrayOpen);
 aaVmProcAdd(vm,0,"aaJsonEncodeArrayClose",&aaJsonEncodeArrayClose);
 aaVmProcAdd(vm,0,"aaJsonEncodeKey",&aaJsonEncodeKey);
 aaVmProcAdd(vm,0,"aaJsonEncodeString",&aaJsonEncodeString);
 aaVmProcAdd(vm,0,"aaJsonEncodeFloat",&aaJsonEncodeFloat);
 aaVmProcAdd(vm,0,"aaJsonEncodeInt",&aaJsonEncodeInt);
 aaVmProcAdd(vm,0,"aaJsonEncodeBool",&aaJsonEncodeBool);
 aaVmProcAdd(vm,0,"aaJsonEncodeNull",&aaJsonEncodeNull);
 aaVmProcAdd(vm,0,"aaJsonEncodeKeyString",&aaJsonEncodeKeyString);
 aaVmProcAdd(vm,0,"aaJsonEncodeKeyFloat",&aaJsonEncodeKeyFloat);
 aaVmProcAdd(vm,0,"aaJsonEncodeKeyInt",&aaJsonEncodeKeyInt);
 aaVmProcAdd(vm,0,"aaJsonEncodeKeyBool",&aaJsonEncodeKeyBool);
 aaVmProcAdd(vm,0,"aaJsonEncodeKeyNull",&aaJsonEncodeKeyNull);
 aaVmProcAdd(vm,0,"aaJsonParserLineGet",&aaJsonParserLineGet);
 aaVmProcAdd(vm,0,"aaJsonParserKeyFind",&aaJsonParserKeyFind);
 aaVmProcAdd(vm,0,"aaJsonDumpLineGet",&aaJsonDumpLineGet);
 aaVmProcAdd(vm,0,"aaClassEmptyIdGet",&aaClassEmptyIdGet);
 aaVmProcAdd(vm,0,"aaClassCreate",&aaClassCreate);
 aaVmProcAdd(vm,0,"aaClassDestroy",&aaClassDestroy);
 aaVmProcAdd(vm,0,"aaClassStatus",&aaClassStatus);
 aaVmProcAdd(vm,0,"aaClassNew",&aaClassNew);
 aaVmProcAdd(vm,0,"aaClassDelete",&aaClassDelete);
 aaVmProcAdd(vm,0,"aaClassCheck",&aaClassCheck);
 aaVmProcAdd(vm,0,"aaClassIndexGet",&aaClassIndexGet);
 aaVmProcAdd(vm,0,"aaClassProtect",&aaClassProtect);
 aaVmProcAdd(vm,0,"aaClassNext",&aaClassNext);
 aaVmProcAdd(vm,0,"aaClassGet",&aaClassGet);
 aaVmProcAdd(vm,0,"aaClassIdGet",&aaClassIdGet);
 aaVmProcAdd(vm,0,"aaTaskNew",&aaTaskNew);
 aaVmProcAdd(vm,0,"aaTaskDelete",&aaTaskDelete);
 aaVmProcAdd(vm,0,"aaTaskStageSet",&aaTaskStageSet);
 aaVmProcAdd(vm,0,"aaTaskExit",&aaTaskExit);
 aaVmProcAdd(vm,0,"aaTaskYield",&aaTaskYield);
 aaVmProcAdd(vm,0,"aaTaskGroupNew",&aaTaskGroupNew);
 aaVmProcAdd(vm,0,"aaTaskGroupDelete",&aaTaskGroupDelete);
 aaVmProcAdd(vm,0,"aaTaskGroupAdd",&aaTaskGroupAdd);
 aaVmProcAdd(vm,0,"aaTaskGroupYield",&aaTaskGroupYield);
 aaVmProcAdd(vm,0,"aaSettingsCreate",&aaSettingsCreate);
 aaVmProcAdd(vm,0,"aaSettingsDestroy",&aaSettingsDestroy);
 aaVmProcAdd(vm,0,"aaSettingsRead",&aaSettingsRead);
 aaVmProcAdd(vm,0,"aaSettingsWrite",&aaSettingsWrite);
 aaVmProcAdd(vm,0,"aaSettingsDelete",&aaSettingsDelete);
 aaVmProcAdd(vm,0,"aaSettingsLengthGet",&aaSettingsLengthGet);
 aaVmProcAdd(vm,0,"aaSettingsEnumStart",&aaSettingsEnumStart);
 aaVmProcAdd(vm,0,"aaSettingsEnumStep",&aaSettingsEnumStep);
 aaVmProcAdd(vm,0,"aaSettingsEnumStop",&aaSettingsEnumStop);
 aaVmProcAdd(vm,0,"aaSettingsDrop",&aaSettingsDrop);
 aaVmProcAdd(vm,0,"aaSettingsSave",&aaSettingsSave);
 aaVmProcAdd(vm,0,"aaSettingsLoad",&aaSettingsLoad);
 aaVmProcAdd(vm,0,"aaClipBoardTextWritef",&aaClipBoardTextWritef);
 aaVmProcAdd(vm,0,"aaClipBoardTextWrite",&aaClipBoardTextWrite);
 aaVmProcAdd(vm,0,"aaClipBoardTextRead",&aaClipBoardTextRead);
 aaVmProcAdd(vm,0,"aaClipBoardDiscard",&aaClipBoardDiscard);
 aaVmProcAdd(vm,0,"aaClipBoardTextPaste",&aaClipBoardTextPaste);
 aaVmProcAdd(vm,0,"aaClipBoardFileSet",&aaClipBoardFileSet);
 aaVmProcAdd(vm,0,"aaClipBoardFileRead",&aaClipBoardFileRead);
 aaVmProcAdd(vm,0,"aaIpcCreate",&aaIpcCreate);
 aaVmProcAdd(vm,0,"aaIpcDestroy",&aaIpcDestroy);
 aaVmProcAdd(vm,0,"aaIpcStatus",&aaIpcStatus);
 aaVmProcAdd(vm,0,"aaDesktopCreate",&aaDesktopCreate);
 aaVmProcAdd(vm,0,"aaDesktopDestroy",&aaDesktopDestroy);
 aaVmProcAdd(vm,0,"aaDesktopStatus",&aaDesktopStatus);
 aaVmProcAdd(vm,0,"aaDesktopSwitch",&aaDesktopSwitch);
 aaVmProcAdd(vm,0,"aaVmNew",&aaVmNew);
 aaVmProcAdd(vm,0,"aaVmDelete",&aaVmDelete);
 aaVmProcAdd(vm,0,"aaVmRamSwap",&aaVmRamSwap);
 aaVmProcAdd(vm,0,"aaVmProcGet",&aaVmProcGet);
 aaVmProcAdd(vm,0,"aaVmProcFind",&aaVmProcFind);
 aaVmProcAdd(vm,0,"aaVmProcAdd",&aaVmProcAdd);
 aaVmProcAdd(vm,0,"aaVmProcLoad",&aaVmProcLoad);
 aaVmProcAdd(vm,0,"aaVmParmPush",&aaVmParmPush);
 aaVmProcAdd(vm,0,"aaVmParmPtr",&aaVmParmPtr);
 aaVmProcAdd(vm,0,"aaVmParmPtrPtr",&aaVmParmPtrPtr);
 aaVmProcAdd(vm,0,"aaVmParmByte",&aaVmParmByte);
 aaVmProcAdd(vm,0,"aaVmParmWord",&aaVmParmWord);
 aaVmProcAdd(vm,0,"aaVmParmDword",&aaVmParmDword);
 aaVmProcAdd(vm,0,"aaVmParmQuad",&aaVmParmQuad);
 aaVmProcAdd(vm,0,"aaVmParmDouble",&aaVmParmDouble);
 aaVmProcAdd(vm,0,"aaVmParmMulti",&aaVmParmMulti);
 aaVmProcAdd(vm,0,"aaVmCall",&aaVmCall);
 aaVmProcAdd(vm,0,"aaVmCallEx",&aaVmCallEx);
 aaVmProcAdd(vm,0,"aaVmAaHeaderFunctions",&aaVmAaHeaderFunctions);


 vm->is_sys_func=NO;
 return RET_YES;
 }


 B aaVmDelete                          (_vm*vm)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(vm->proc_data.magic!=0) { aaVectorDelete(&vm->proc_data); }
 aaMemoryFill(vm,sizeof(_vm),0);
 return RET_YES;
 }



 B aaVmRamSwap                         (_vm*vm,BP parmram,BP userram)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(parmram==NULL) { vm->parm_ram_ptr=vm->parm_ram; }
 else              { vm->parm_ram_ptr=parmram; }
 if(userram==NULL) { vm->user_ram_ptr=vm->user_ram; }
 else              { vm->user_ram_ptr=userram; }
 return RET_YES;
 }



 B aaVmProcGet                         (_vm*vm,H index,VP name,PP proc,HP proclen)
 {
 B ret;
 _aavectorslot avs;
 _vmprocentry*vmpe;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(name) { aaStringNull(name); }
 if(proc) { *proc=NULL; }
 if(proclen) { *proclen=0; }
 if(index>=vm->proc_count) { return RET_BOUNDS; }
 if((ret=aaVectorSlotGet(&vm->proc_data,index,&avs))!=RET_YES) { oops; }
 vmpe=(_vmprocentry*)avs.ptr;
 if(name) { aaStringCopy(name,vmpe->name); }
 if(proc) { *proc=vmpe->proc; }
 if(proclen) { *proclen=vmpe->proc_len; }
 return RET_YES;
 }



 B aaVmProcFind                        (_vm*vm,VP name,HP index,PP proc,HP proclen,B addifok)
 {
 B ret;
 H i,sl;
 _aavectorslot avs;
 _vmprocentry*vmpe;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(name==NULL) { return RET_BADPARM; }
 aaStringLen(name,&sl);
 if(sl==0||sl>=48) { return RET_BADPARM; }
 if(proc) { *proc=NULL; }
 if(proclen) { *proclen=0; }
 //aaCast(bp,BP,name);
 for(i=0;i<vm->proc_count;i++)
  {
  if((ret=aaVectorSlotGet(&vm->proc_data,i,&avs))!=RET_YES) { oops; }
  vmpe=(_vmprocentry*)avs.ptr;
  if(vmpe->name_len!=sl) { continue; }
  if(aaStringNICompare(name,vmpe->name,sl,0)!=YES) { continue; }
  if(index) { *index=i; }
  if(proc) { *proc=vmpe->proc; }
  if(proclen) { *proclen=vmpe->proc_len; }
  if(addifok)
   {
   if((ret=aaVmProcLoad(vm,i))!=RET_YES) { return ret; }
   }
  return RET_YES;
  }
 return RET_NOTFOUND;
 }




 B aaVmProcAdd                         (_vm*vm,HP index,VP name,VP proc)
 {
 B ret;
 _aavectorslot avs;
 _vmprocentry*vmpe;
 BP bp;
 BP procmem;
 H i=0,sl,left;
 H proc_len,j,k;
 B check_before_release=NO;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(proc==NULL) { return RET_BADPARM; }
 if(name==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,name);
 aaStringLen(bp,&sl);
 if(sl==0||sl>=48) { return RET_BADPARM; }
 left=vm->proc_data.count-vm->proc_count;
 // comment out following line: if(vm->is_sys_func==NO)  , before releasing
 if(vm->is_sys_func==NO||check_before_release==YES)
  {
  for(i=0;i<vm->proc_count;i++)
   {
   if((ret=aaVectorSlotGet(&vm->proc_data,i,&avs))!=RET_YES) { oops; }
   vmpe=(_vmprocentry*)avs.ptr;
   if(vmpe->name_len!=sl) { continue; }
   if(aaStringNICompare(bp,vmpe->name,sl,0)!=YES) { continue; }
   aaLog(-666,"i=%i exists",i);
   if(index) { *index=i; }
   if(check_before_release) { aaNote(0,"RET_EXISTS. there is a duplicate in aaVmNew system table");   }
   return RET_EXISTS;
   }
  }
 if(left<50)
  {
  if((ret=aaVectorExtendSlots(&vm->proc_data,vm->proc_data.count/3))!=RET_YES) { oops; }
  }
 if((ret=aaVectorSlotGet(&vm->proc_data,vm->proc_count,&avs))!=RET_YES) { oops; }
 vmpe=(_vmprocentry*)avs.ptr;
 if(index) { *index=i; }
 if(vm->is_sys_func)
  {
  vmpe->name[0]='a';
  vmpe->name[1]='a';
  aaStringCopy(&vmpe->name[2],bp);
  sl+=2;
  }
 else
  {
  aaStringCopy(vmpe->name,bp);
  }
 vmpe->name_len=sl;
 vmpe->proc=proc;
 vm->proc_count++;
 while(1)
  {
  proc_len=j=0;
  procmem=(BP)proc;
  if(procmem[j+0]!=0x55||procmem[j+1]!=0x89||procmem[j+2]!=0xe5) { oof; break; }
  k=j;
  j+=3;
  while(1)
   {
   if(procmem[j+0]!=0xc3) { j+=1; continue; }
   if(procmem[j+1]!=0x55) { j+=2; continue; }
   if(procmem[j+2]!=0x89) { j+=3; continue; }
   if(procmem[j+3]!=0xe5) { j+=4; continue; }
   j+=1;
   proc_len=j-k;
   break;
   }
  vmpe->proc_len=proc_len;
  break;
  }
 return RET_YES;
 }









 B aaVmProcLoad                        (_vm*vm,H index)
 {
 B ret;
 _aavectorslot avs;
 _vmprocentry*vmpe;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(index>=vm->proc_count) { return RET_BOUNDS; }
 if((ret=aaVectorSlotGet(&vm->proc_data,index,&avs))!=RET_YES) { oops; }
 vmpe=(_vmprocentry*)avs.ptr;
 vm->proc_func=vmpe->proc;
 vm->proc_index=index;
 vm->parm_bytes=0;
 vm->parm_count=0;
 *(QP)&vm->ret_ram[0]=0;
 vm->ret=0;
 return RET_YES;
 }




 B aaVmParmPush                        (_vm*vm,H psize,VP parm)
 {
 H di;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(vm->proc_func==NULL) { return RET_NOTREADY; }
 if(psize==0||psize>8) { return RET_BOUNDS; }
 aaMemoryCopy(&vm->parm_ram[vm->parm_bytes],psize,parm);
 vm->parm_bytes+=psize;
 if((psize%4)!=0)
  {
  if((di=4-(psize%4))!=0)
   {
   aaMemoryFill(&vm->parm_ram[vm->parm_bytes],di,0);
   vm->parm_bytes+=di;
   }
  }
 vm->parm_count++;
 return RET_YES;
 }



 B aaVmParmPtr                         (_vm*vm,VP ptr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaVmParmPush(vm,4,&ptr));
 }


 B aaVmParmPtrPtr                      (_vm*vm,PP ptr)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaVmParmPush(vm,4,&ptr));
 }



 B aaVmParmByte                        (_vm*vm,B parm)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaVmParmPush(vm,1,&parm));
 }



 B aaVmParmWord                        (_vm*vm,W parm)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaVmParmPush(vm,2,&parm));
 }


 B aaVmParmDword                       (_vm*vm,H parm)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaVmParmPush(vm,4,&parm));
 }

 B aaVmParmQuad                        (_vm*vm,Q parm)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaVmParmPush(vm,8,&parm));
 }


 B aaVmParmDouble                      (_vm*vm,D parm)
 {
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 return(aaVmParmPush(vm,8,&parm));
 }






 B aaVmParmMulti                       (_vm*vm,VP fmt,...)
 {
 va_list ap;
 BP bp;
 H off;
 B ch;
 B var_b; W var_w; H var_h;
 Q var_q; D var_d; VP var_ptr;
 PP var_ptrptr;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(fmt==NULL) { return RET_BADPARM; }
 aaCast(bp,BP,fmt);
 va_start(ap,fmt);
 off=0;
 while(1)
  {
  ch=bp[off];
  if(ch==NULL_CHAR) { break; }
  switch(ch)
   {
   case 'b': case 'B': var_b=(B)va_arg(ap,u32); aaVmParmByte(vm,var_b);   break;
   case 'w': case 'W': var_w=(W)va_arg(ap,u32); aaVmParmWord(vm,var_w);   break;
   case 'h': case 'H': var_h=(H)va_arg(ap,u32); aaVmParmDword(vm,var_h);  break;
   case 'q': case 'Q': var_q=(Q)va_arg(ap,u64); aaVmParmQuad(vm,var_q);   break;
   case 'd': case 'D': var_d=(D)va_arg(ap,D);   aaVmParmDouble(vm,var_d); break;
   case 'p': case 'P': var_ptr=va_arg(ap,VP);   aaVmParmPtr(vm,var_ptr);  break;
   case 'x': case 'X': var_ptrptr=va_arg(ap,PP);   aaVmParmPtrPtr(vm,var_ptrptr);  break;
   default:   oof;   break;
   }
  off++;
  }
 va_end(ap);
 return RET_YES;
 }






 B aaVmCall                            (_vm*vm)
 {
 T Q (*zunc)(VP,H,H);
 Q qv;
 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif

 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(vm->proc_func==NULL) { return RET_NOTREADY; }
 *(QP)&vm->ret_ram[0]=0;
 qv=(Q)((zunc)aa_cdecl)(vm->parm_ram,vm->parm_bytes,(H)vm->proc_func);
 *(QP)&vm->ret_ram[0]=qv;
 vm->ret=vm->ret_ram[0];
 if(vm->ret!=RET_YES) { return RET_OTHER; }
 return RET_YES;
 }



 B aaVmCallEx                          (_vm*vm,VP name,VP fmt,...)
 {
 va_list ap;
 B ret;
 //T Q (*zunc)(VP,H,H);
 BP bp;
 H off,index;
 B ch;
 B var_b; W var_w; H var_h;
 Q var_q; D var_d; VP var_ptr;
 PP var_ptrptr;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 if(vm==NULL) { return RET_BADPARM; }
 if(vm->magic!=(H)(PP)aaVmNew) { return RET_NOTINITIALIZED; }
 if(name==NULL) { return RET_BADPARM; }
 if(fmt==NULL) { return RET_BADPARM; }
 if((ret=aaVmProcFind(vm,name,&index,NULL,NULL,YES))!=RET_YES) { return ret; }
 //if((ret=aaVmProcLoad(vm,index))!=RET_YES) { return ret; }
 aaCast(bp,BP,fmt);
 va_start(ap,fmt);
 off=0;
 while(1)
  {
  ch=bp[off];
  if(ch==NULL_CHAR) { break; }
  switch(ch)
   {
   case 'b': case 'B': var_b=(B)va_arg(ap,u32); aaVmParmByte(vm,var_b);   break;
   case 'w': case 'W': var_w=(W)va_arg(ap,u32); aaVmParmWord(vm,var_w);   break;
   case 'h': case 'H': var_h=(H)va_arg(ap,u32); aaVmParmDword(vm,var_h);  break;
   case 'q': case 'Q': var_q=(Q)va_arg(ap,u64); aaVmParmQuad(vm,var_q);   break;
   case 'd': case 'D': var_d=(D)va_arg(ap,D);   aaVmParmDouble(vm,var_d); break;
   case 'p': case 'P': var_ptr=va_arg(ap,VP);   aaVmParmPtr(vm,var_ptr);  break;
   case 'x': case 'X': var_ptrptr=va_arg(ap,PP);   aaVmParmPtrPtr(vm,var_ptrptr);  break;
   default:   oof;   break;
   }
  off++;
  }
 va_end(ap);
 return(aaVmCall(vm));
 }




 B aaVmAaHeaderFunctions               (V)
 {
 _textloader tl;

 #ifdef aa_VERSION
 aa_ZIAG(__FUNCTION__);
 #endif
 B aaTextLoaderProcx                   (_textloader*textloader,Q linenum,H chars,VP txt)
 {
 B ascii;
 _parser pa;

 if(textloader) {}
 if(linenum)    {}
 aaStringFirstCharNonVisibleRemove(txt,chars);
 aaStringLastCharNonVisibleRemove(txt,chars);
 aaStringLen(txt,&chars);
 if(chars==0) { return RET_NO; }
 aaStringLastCharGet(txt,chars,&ascii);
 if(ascii!=';') { return RET_NO; }
 aaParserInit(&pa,txt,chars);
 if(aaCharIsAlpha(pa.bp[0])!=YES) { return RET_NO; }
 aaParserSeek(&pa,1);
 while(1)
  {
  if(pa.is_end) { break; }
  if(aaCharIsAlpha(pa.ch)) { aaParserSeek(&pa,1); continue; }
  if(aaCharIsVisible(pa.ch)==YES) { return RET_NO; } //aaParserSeek(&pa,1); continue; }
  aaParserSeek(&pa,1);
  while(1)
   {
   if(pa.is_end) { break; }
   if(aaCharIsAlphaNum(pa.ch)) { aaParserSeek(&pa,1); continue; }
   if(aaCharIsVisible(pa.ch)==YES) { return RET_NO; } //aaParserSeek(&pa,1); continue; }
   aaParserSeekToVisibleChar(&pa,YES);
   if(pa.ch!='(') { return RET_NO; }
   aaParserOffsetSet(&pa,0);
   aaParserSeekToVisibleChar(&pa,NO);
   aaParserSeekToVisibleChar(&pa,YES);
   aaParserStackPush(&pa);
   aaParserSeekToVisibleChar(&pa,NO);
   aaParserStackString(&pa,&chars,F32,txt,YES);
   while(1)
    {
    if(aaStringICompare(txt,"aaSorterProc",0)==YES) { break; }
    if(aaStringICompare(txt,"aaMySqlProc",0)==YES) { break; }
    if(aaStringICompare(txt,"aaTextLoaderProc",0)==YES) { break; }
    //aaDebugf(" aaVmProcAdd(vm,0,\"%s\",&%s);",txt,txt);
    aaLog(-555," aaVmProcAdd(vm,0,\"%s\",&%s);",txt,txt);
    break;
    }
   break;
   }
  break;
  }
 return RET_NO;
 }
 aaTextLoaderNew(&tl,0,"aa.h",aaTextLoaderProcx);
 while(1) { if(aaTextLoaderYield(&tl,F32)==YES) { break; }   }
 aaTextLoaderDelete(&tl);
 return RET_YES;
 }



/*-----------------------------------------------------------------------*/

 V aaDummyFunction2                    (){} // this function is the first function offset, useful for aaFuncInfoGet

/*-----------------------------------------------------------------------*/

 #if aa_DIAGNOSE == YES
 #if __LINE__>aa_SHOW_DIAG_LINES
 #error "ALLOCATE MORE LINES TO DIAGNOSTICS"
 #endif
 #endif



